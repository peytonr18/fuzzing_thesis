{"project": "FFmpeg", "commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "target": 1, "function": "static void check_lowpass_line(int depth){    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);    int w = WIDTH;    int mref = WIDTH_PADDED * -1;    int pref = WIDTH_PADDED;    int i, depth_byte;    InterlaceContext s;    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);    s.lowpass = 1;    s.lowpass = VLPF_LIN;    depth_byte = depth >> 3;    w /= depth_byte;    memset(src,     0, SRC_SIZE);    memset(dst_ref, 0, WIDTH_PADDED);    memset(dst_new, 0, WIDTH_PADDED);    randomize_buffers(src, SRC_SIZE);    ff_interlace_init(&s, depth);    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {        for (i = 0; i < 32; i++) { /* simulate crop */            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);            if (memcmp(dst_ref, dst_new, WIDTH - i))                fail();        }        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);    }}", "idx": 7}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "function": "static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size){    AVIOContext *in, *out;    int ret = 0;    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)        return ret;    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {        avio_close(in);        return ret;    }    while (size > 0) {        uint8_t buf[8192];        int n = FFMIN(size, sizeof(buf));        n = avio_read(in, buf, n);        if (n <= 0) {            ret = AVERROR(EIO);            break;        }        avio_write(out, buf, n);        size -= n;    }    avio_flush(out);    avio_close(out);    avio_close(in);    return ret;}", "idx": 49}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "function": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align){    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    /* virtio-1 compliant devices cannot change the alignment */    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {        error_report(\"tried to modify queue alignment for virtio-1 device\");        return;    }    /* Check that the transport told us it was going to do this     * (so a buggy transport will immediately assert rather than     * silently failing to migrate this state)     */    assert(k->has_variable_vring_alignment);    vdev->vq[n].vring.align = align;    virtio_queue_update_rings(vdev, n);}", "idx": 97}
{"project": "FFmpeg", "commit_id": "4ea7744859dc3d214ef13e920f5d07b070920e3f", "target": 1, "function": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride){    int i;    pixel *dst = (pixel*)_dst;    dctcoef *block = (dctcoef*)_block;    stride >>= sizeof(pixel)-1;    block[0] += 1 << 5;    for(i=0; i<4; i++){        const int z0=  block[i + 4*0]     +  block[i + 4*2];        const int z1=  block[i + 4*0]     -  block[i + 4*2];        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);        block[i + 4*0]= z0 + z3;        block[i + 4*1]= z1 + z2;        block[i + 4*2]= z1 - z2;        block[i + 4*3]= z0 - z3;    }    for(i=0; i<4; i++){        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));    }    memset(block, 0, 16 * sizeof(dctcoef));}", "idx": 119}
{"project": "qemu", "commit_id": "eb69b50ad9806c4a3b5900392a5acc9837cffd18", "target": 1, "function": "static void wm8750_audio_out_cb(void *opaque, int free_b){    struct wm8750_s *s = (struct wm8750_s *) opaque;    wm8750_out_flush(s);    s->req_out = free_b;    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);}", "idx": 160}
{"project": "FFmpeg", "commit_id": "3d79d0c93e5b37a35b1b22d6c18699c233aad1ba", "target": 1, "function": "static int adpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                              const AVFrame *frame, int *got_packet_ptr){    int n, i, ch, st, pkt_size, ret;    const int16_t *samples;    int16_t **samples_p;    uint8_t *dst;    ADPCMEncodeContext *c = avctx->priv_data;    uint8_t *buf;    samples = (const int16_t *)frame->data[0];    samples_p = (int16_t **)frame->extended_data;    st = avctx->channels == 2;    if (avctx->codec_id == AV_CODEC_ID_ADPCM_SWF)        pkt_size = (2 + avctx->channels * (22 + 4 * (frame->nb_samples - 1)) + 7) / 8;    else        pkt_size = avctx->block_align;    if ((ret = ff_alloc_packet(avpkt, pkt_size))) {        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");        return ret;    }    dst = avpkt->data;    switch(avctx->codec->id) {    case AV_CODEC_ID_ADPCM_IMA_WAV:    {        int blocks, j;        blocks = (frame->nb_samples - 1) / 8;        for (ch = 0; ch < avctx->channels; ch++) {            ADPCMChannelStatus *status = &c->status[ch];            status->prev_sample = samples_p[ch][0];            /* status->step_index = 0;               XXX: not sure how to init the state machine */            bytestream_put_le16(&dst, status->prev_sample);            *dst++ = status->step_index;            *dst++ = 0; /* unknown */        }        /* stereo: 4 bytes (8 samples) for left, 4 bytes for right */        if (avctx->trellis > 0) {            FF_ALLOC_OR_GOTO(avctx, buf, avctx->channels * blocks * 8, error);            for (ch = 0; ch < avctx->channels; ch++) {                adpcm_compress_trellis(avctx, &samples_p[ch][1],                                       buf + ch * blocks * 8, &c->status[ch],                                       blocks * 8, 1);            }            for (i = 0; i < blocks; i++) {                for (ch = 0; ch < avctx->channels; ch++) {                    uint8_t *buf1 = buf + ch * blocks * 8 + i * 8;                    for (j = 0; j < 8; j += 2)                        *dst++ = buf1[j] | (buf1[j + 1] << 4);                }            }            av_free(buf);        } else {            for (i = 0; i < blocks; i++) {                for (ch = 0; ch < avctx->channels; ch++) {                    ADPCMChannelStatus *status = &c->status[ch];                    const int16_t *smp = &samples_p[ch][1 + i * 8];                    for (j = 0; j < 8; j += 2) {                        uint8_t v = adpcm_ima_compress_sample(status, smp[j    ]);                        v        |= adpcm_ima_compress_sample(status, smp[j + 1]) << 4;                        *dst++ = v;                    }                }            }        }        break;    }    case AV_CODEC_ID_ADPCM_IMA_QT:    {        PutBitContext pb;        init_put_bits(&pb, dst, pkt_size * 8);        for (ch = 0; ch < avctx->channels; ch++) {            ADPCMChannelStatus *status = &c->status[ch];            put_bits(&pb, 9, (status->prev_sample & 0xFFFF) >> 7);            put_bits(&pb, 7,  status->step_index);            if (avctx->trellis > 0) {                uint8_t buf[64];                adpcm_compress_trellis(avctx, &samples_p[ch][1], buf, status,                                       64, 1);                for (i = 0; i < 64; i++)                    put_bits(&pb, 4, buf[i ^ 1]);            } else {                for (i = 0; i < 64; i += 2) {                    int t1, t2;                    t1 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i    ]);                    t2 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i + 1]);                    put_bits(&pb, 4, t2);                    put_bits(&pb, 4, t1);                }            }        }        flush_put_bits(&pb);        break;    }    case AV_CODEC_ID_ADPCM_SWF:    {        PutBitContext pb;        init_put_bits(&pb, dst, pkt_size * 8);        n = frame->nb_samples - 1;        // store AdpcmCodeSize        put_bits(&pb, 2, 2);    // set 4-bit flash adpcm format        // init the encoder state        for (i = 0; i < avctx->channels; i++) {            // clip step so it fits 6 bits            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 63);            put_sbits(&pb, 16, samples[i]);            put_bits(&pb, 6, c->status[i].step_index);            c->status[i].prev_sample = samples[i];        }        if (avctx->trellis > 0) {            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);            adpcm_compress_trellis(avctx, samples + avctx->channels, buf,                                   &c->status[0], n, avctx->channels);            if (avctx->channels == 2)                adpcm_compress_trellis(avctx, samples + avctx->channels + 1,                                       buf + n, &c->status[1], n,                                       avctx->channels);            for (i = 0; i < n; i++) {                put_bits(&pb, 4, buf[i]);                if (avctx->channels == 2)                    put_bits(&pb, 4, buf[n + i]);            }            av_free(buf);        } else {            for (i = 1; i < frame->nb_samples; i++) {                put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[0],                         samples[avctx->channels * i]));                if (avctx->channels == 2)                    put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[1],                             samples[2 * i + 1]));            }        }        flush_put_bits(&pb);        break;    }    case AV_CODEC_ID_ADPCM_MS:        for (i = 0; i < avctx->channels; i++) {            int predictor = 0;            *dst++ = predictor;            c->status[i].coeff1 = ff_adpcm_AdaptCoeff1[predictor];            c->status[i].coeff2 = ff_adpcm_AdaptCoeff2[predictor];        }        for (i = 0; i < avctx->channels; i++) {            if (c->status[i].idelta < 16)                c->status[i].idelta = 16;            bytestream_put_le16(&dst, c->status[i].idelta);        }        for (i = 0; i < avctx->channels; i++)            c->status[i].sample2= *samples++;        for (i = 0; i < avctx->channels; i++) {            c->status[i].sample1 = *samples++;            bytestream_put_le16(&dst, c->status[i].sample1);        }        for (i = 0; i < avctx->channels; i++)            bytestream_put_le16(&dst, c->status[i].sample2);        if (avctx->trellis > 0) {            n = avctx->block_align - 7 * avctx->channels;            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);            if (avctx->channels == 1) {                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,                                       avctx->channels);                for (i = 0; i < n; i += 2)                    *dst++ = (buf[i] << 4) | buf[i + 1];            } else {                adpcm_compress_trellis(avctx, samples,     buf,                                       &c->status[0], n, avctx->channels);                adpcm_compress_trellis(avctx, samples + 1, buf + n,                                       &c->status[1], n, avctx->channels);                for (i = 0; i < n; i++)                    *dst++ = (buf[i] << 4) | buf[n + i];            }            av_free(buf);        } else {            for (i = 7 * avctx->channels; i < avctx->block_align; i++) {                int nibble;                nibble  = adpcm_ms_compress_sample(&c->status[ 0], *samples++) << 4;                nibble |= adpcm_ms_compress_sample(&c->status[st], *samples++);                *dst++  = nibble;            }        }        break;    case AV_CODEC_ID_ADPCM_YAMAHA:        n = frame->nb_samples / 2;        if (avctx->trellis > 0) {            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n * 2, error);            n *= 2;            if (avctx->channels == 1) {                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,                                       avctx->channels);                for (i = 0; i < n; i += 2)                    *dst++ = buf[i] | (buf[i + 1] << 4);            } else {                adpcm_compress_trellis(avctx, samples,     buf,                                       &c->status[0], n, avctx->channels);                adpcm_compress_trellis(avctx, samples + 1, buf + n,                                       &c->status[1], n, avctx->channels);                for (i = 0; i < n; i++)                    *dst++ = buf[i] | (buf[n + i] << 4);            }            av_free(buf);        } else            for (n *= avctx->channels; n > 0; n--) {                int nibble;                nibble  = adpcm_yamaha_compress_sample(&c->status[ 0], *samples++);                nibble |= adpcm_yamaha_compress_sample(&c->status[st], *samples++) << 4;                *dst++  = nibble;            }        break;    default:        return AVERROR(EINVAL);    }    avpkt->size = pkt_size;    *got_packet_ptr = 1;    return 0;error:    return AVERROR(ENOMEM);}", "idx": 242}
{"project": "FFmpeg", "commit_id": "38229362529ed1619d8ebcc81ecde85b23b45895", "target": 1, "function": "static int decode_subframe(WMAProDecodeCtx *s){    int offset = s->samples_per_frame;    int subframe_len = s->samples_per_frame;    int i;    int total_samples   = s->samples_per_frame * s->avctx->channels;    int transmit_coeffs = 0;    int cur_subwoofer_cutoff;    s->subframe_offset = get_bits_count(&s->gb);    /** reset channel context and find the next block offset and size        == the next block of the channel with the smallest number of        decoded samples    */    for (i = 0; i < s->avctx->channels; i++) {        s->channel[i].grouped = 0;        if (offset > s->channel[i].decoded_samples) {            offset = s->channel[i].decoded_samples;            subframe_len =                s->channel[i].subframe_len[s->channel[i].cur_subframe];        }    }    av_dlog(s->avctx,            \"processing subframe with offset %i len %i\\n\", offset, subframe_len);    /** get a list of all channels that contain the estimated block */    s->channels_for_cur_subframe = 0;    for (i = 0; i < s->avctx->channels; i++) {        const int cur_subframe = s->channel[i].cur_subframe;        /** subtract already processed samples */        total_samples -= s->channel[i].decoded_samples;        /** and count if there are multiple subframes that match our profile */        if (offset == s->channel[i].decoded_samples &&            subframe_len == s->channel[i].subframe_len[cur_subframe]) {            total_samples -= s->channel[i].subframe_len[cur_subframe];            s->channel[i].decoded_samples +=                s->channel[i].subframe_len[cur_subframe];            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;            ++s->channels_for_cur_subframe;        }    }    /** check if the frame will be complete after processing the        estimated block */    if (!total_samples)        s->parsed_all_subframes = 1;    av_dlog(s->avctx, \"subframe is part of %i channels\\n\",            s->channels_for_cur_subframe);    /** calculate number of scale factor bands and their offsets */    s->table_idx         = av_log2(s->samples_per_frame/subframe_len);    s->num_bands         = s->num_sfb[s->table_idx];    s->cur_sfb_offsets   = s->sfb_offsets[s->table_idx];    cur_subwoofer_cutoff = s->subwoofer_cutoffs[s->table_idx];    /** configure the decoder for the current subframe */    for (i = 0; i < s->channels_for_cur_subframe; i++) {        int c = s->channel_indexes_for_cur_subframe[i];        s->channel[c].coeffs = &s->channel[c].out[(s->samples_per_frame >> 1)                                                  + offset];    }    s->subframe_len = subframe_len;    s->esc_len = av_log2(s->subframe_len - 1) + 1;    /** skip extended header if any */    if (get_bits1(&s->gb)) {        int num_fill_bits;        if (!(num_fill_bits = get_bits(&s->gb, 2))) {            int len = get_bits(&s->gb, 4);            num_fill_bits = get_bits(&s->gb, len) + 1;        }        if (num_fill_bits >= 0) {            if (get_bits_count(&s->gb) + num_fill_bits > s->num_saved_bits) {                av_log(s->avctx, AV_LOG_ERROR, \"invalid number of fill bits\\n\");                return AVERROR_INVALIDDATA;            }            skip_bits_long(&s->gb, num_fill_bits);        }    }    /** no idea for what the following bit is used */    if (get_bits1(&s->gb)) {        avpriv_request_sample(s->avctx, \"Reserved bit\");        return AVERROR_PATCHWELCOME;    }    if (decode_channel_transform(s) < 0)        return AVERROR_INVALIDDATA;    for (i = 0; i < s->channels_for_cur_subframe; i++) {        int c = s->channel_indexes_for_cur_subframe[i];        if ((s->channel[c].transmit_coefs = get_bits1(&s->gb)))            transmit_coeffs = 1;    }    if (transmit_coeffs) {        int step;        int quant_step = 90 * s->bits_per_sample >> 4;        /** decode number of vector coded coefficients */        if ((s->transmit_num_vec_coeffs = get_bits1(&s->gb))) {            int num_bits = av_log2((s->subframe_len + 3)/4) + 1;            for (i = 0; i < s->channels_for_cur_subframe; i++) {                int c = s->channel_indexes_for_cur_subframe[i];                int num_vec_coeffs = get_bits(&s->gb, num_bits) << 2;                if (num_vec_coeffs > WMAPRO_BLOCK_MAX_SIZE) {                    av_log(s->avctx, AV_LOG_ERROR, \"num_vec_coeffs %d is too large\\n\", num_vec_coeffs);                    return AVERROR_INVALIDDATA;                }                s->channel[c].num_vec_coeffs = num_vec_coeffs;            }        } else {            for (i = 0; i < s->channels_for_cur_subframe; i++) {                int c = s->channel_indexes_for_cur_subframe[i];                s->channel[c].num_vec_coeffs = s->subframe_len;            }        }        /** decode quantization step */        step = get_sbits(&s->gb, 6);        quant_step += step;        if (step == -32 || step == 31) {            const int sign = (step == 31) - 1;            int quant = 0;            while (get_bits_count(&s->gb) + 5 < s->num_saved_bits &&                   (step = get_bits(&s->gb, 5)) == 31) {                quant += 31;            }            quant_step += ((quant + step) ^ sign) - sign;        }        if (quant_step < 0) {            av_log(s->avctx, AV_LOG_DEBUG, \"negative quant step\\n\");        }        /** decode quantization step modifiers for every channel */        if (s->channels_for_cur_subframe == 1) {            s->channel[s->channel_indexes_for_cur_subframe[0]].quant_step = quant_step;        } else {            int modifier_len = get_bits(&s->gb, 3);            for (i = 0; i < s->channels_for_cur_subframe; i++) {                int c = s->channel_indexes_for_cur_subframe[i];                s->channel[c].quant_step = quant_step;                if (get_bits1(&s->gb)) {                    if (modifier_len) {                        s->channel[c].quant_step += get_bits(&s->gb, modifier_len) + 1;                    } else                        ++s->channel[c].quant_step;                }            }        }        /** decode scale factors */        if (decode_scale_factors(s) < 0)            return AVERROR_INVALIDDATA;    }    av_dlog(s->avctx, \"BITSTREAM: subframe header length was %i\\n\",            get_bits_count(&s->gb) - s->subframe_offset);    /** parse coefficients */    for (i = 0; i < s->channels_for_cur_subframe; i++) {        int c = s->channel_indexes_for_cur_subframe[i];        if (s->channel[c].transmit_coefs &&            get_bits_count(&s->gb) < s->num_saved_bits) {            decode_coeffs(s, c);        } else            memset(s->channel[c].coeffs, 0,                   sizeof(*s->channel[c].coeffs) * subframe_len);    }    av_dlog(s->avctx, \"BITSTREAM: subframe length was %i\\n\",            get_bits_count(&s->gb) - s->subframe_offset);    if (transmit_coeffs) {        FFTContext *mdct = &s->mdct_ctx[av_log2(subframe_len) - WMAPRO_BLOCK_MIN_BITS];        /** reconstruct the per channel data */        inverse_channel_transform(s);        for (i = 0; i < s->channels_for_cur_subframe; i++) {            int c = s->channel_indexes_for_cur_subframe[i];            const int* sf = s->channel[c].scale_factors;            int b;            if (c == s->lfe_channel)                memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *                       (subframe_len - cur_subwoofer_cutoff));            /** inverse quantization and rescaling */            for (b = 0; b < s->num_bands; b++) {                const int end = FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);                const int exp = s->channel[c].quant_step -                            (s->channel[c].max_scale_factor - *sf++) *                            s->channel[c].scale_factor_step;                const float quant = pow(10.0, exp / 20.0);                int start = s->cur_sfb_offsets[b];                s->fdsp.vector_fmul_scalar(s->tmp + start,                                           s->channel[c].coeffs + start,                                           quant, end - start);            }            /** apply imdct (imdct_half == DCTIV with reverse) */            mdct->imdct_half(mdct, s->channel[c].coeffs, s->tmp);        }    }    /** window and overlapp-add */    wmapro_window(s);    /** handled one subframe */    for (i = 0; i < s->channels_for_cur_subframe; i++) {        int c = s->channel_indexes_for_cur_subframe[i];        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");            return AVERROR_INVALIDDATA;        }        ++s->channel[c].cur_subframe;    }    return 0;}", "idx": 333}
{"project": "qemu", "commit_id": "c963530a5b3e3e0f7304841adfe84416d82f59f6", "target": 0, "function": "static char *assign_name(NetClientState *nc1, const char *model){    NetClientState *nc;    char buf[256];    int id = 0;    QTAILQ_FOREACH(nc, &net_clients, next) {        if (nc == nc1) {            continue;        }        /* For compatibility only bump id for net clients on a vlan */        if (strcmp(nc->model, model) == 0 &&            net_hub_id_for_client(nc, NULL) == 0) {            id++;        }    }    snprintf(buf, sizeof(buf), \"%s.%d\", model, id);    return g_strdup(buf);}", "idx": 458}
{"project": "FFmpeg", "commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "target": 1, "function": "static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,        int *need_next_header, int *new_frame_start){    int err;    union {        uint64_t u64;        uint8_t  u8[8];    } tmp = { av_be2ne64(state) };    AC3HeaderInfo hdr, *phdr = &hdr;    GetBitContext gbc;    init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54);    err = avpriv_ac3_parse_header2(&gbc, &phdr);    if(err < 0)        return 0;    hdr_info->sample_rate = hdr.sample_rate;    hdr_info->bit_rate = hdr.bit_rate;    hdr_info->channels = hdr.channels;    hdr_info->channel_layout = hdr.channel_layout;    hdr_info->samples = hdr.num_blocks * 256;    hdr_info->service_type = hdr.bitstream_mode;    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;    if(hdr.bitstream_id>10)        hdr_info->codec_id = AV_CODEC_ID_EAC3;    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)        hdr_info->codec_id = AV_CODEC_ID_AC3;    *need_next_header = (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);    *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);    return hdr.frame_size;}", "idx": 519}
{"project": "qemu", "commit_id": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486", "target": 0, "function": "void vnc_disconnect_finish(VncState *vs){    int i;    vnc_jobs_join(vs); /* Wait encoding jobs */    vnc_lock_output(vs);    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);    buffer_free(&vs->input);    buffer_free(&vs->output);#ifdef CONFIG_VNC_WS    buffer_free(&vs->ws_input);    buffer_free(&vs->ws_output);#endif /* CONFIG_VNC_WS */    qapi_free_VncClientInfo(vs->info);    vnc_zlib_clear(vs);    vnc_tight_clear(vs);    vnc_zrle_clear(vs);#ifdef CONFIG_VNC_TLS    vnc_tls_client_cleanup(vs);#endif /* CONFIG_VNC_TLS */#ifdef CONFIG_VNC_SASL    vnc_sasl_client_cleanup(vs);#endif /* CONFIG_VNC_SASL */    audio_del(vs);    vnc_release_modifiers(vs);    if (vs->initialized) {        QTAILQ_REMOVE(&vs->vd->clients, vs, next);        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);    }    if (vs->vd->lock_key_sync)        qemu_remove_led_event_handler(vs->led);    vnc_unlock_output(vs);    qemu_mutex_destroy(&vs->output_mutex);    if (vs->bh != NULL) {        qemu_bh_delete(vs->bh);    }    buffer_free(&vs->jobs_buffer);    for (i = 0; i < VNC_STAT_ROWS; ++i) {        g_free(vs->lossy_rect[i]);    }    g_free(vs->lossy_rect);    g_free(vs);}", "idx": 553}
{"project": "qemu", "commit_id": "4207117c93357347500235952ce7891688089cb1", "target": 0, "function": "static void akita_init(int ram_size, int vga_ram_size, int boot_device,                DisplayState *ds, const char **fd_filename, int snapshot,                const char *kernel_filename, const char *kernel_cmdline,                const char *initrd_filename, const char *cpu_model){    spitz_common_init(ram_size, vga_ram_size, ds, kernel_filename,                kernel_cmdline, initrd_filename, akita, 0x2e8);}", "idx": 557}
{"project": "FFmpeg", "commit_id": "20e8be0c20c7b51964fa4d317073bd36b983eb55", "target": 1, "function": "static int mkv_write_header(AVFormatContext *s){    MatroskaMuxContext *mkv = s->priv_data;    AVIOContext *pb = s->pb;    ebml_master ebml_header;    AVDictionaryEntry *tag;    int ret, i, version = 2;    int64_t creation_time;    if (!strcmp(s->oformat->name, \"webm\"))        mkv->mode = MODE_WEBM;    else        mkv->mode = MODE_MATROSKAv2;    if (mkv->mode != MODE_WEBM ||        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))        version = 4;    for (i = 0; i < s->nb_streams; i++) {        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {            av_log(s, AV_LOG_ERROR,                   \"The Matroska muxer does not yet support muxing %s\\n\",                   avcodec_get_name(s->streams[i]->codecpar->codec_id));            return AVERROR_PATCHWELCOME;        }        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))            version = 4;    }    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));    if (!mkv->tracks) {        ret = AVERROR(ENOMEM);        goto fail;    }    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);    end_ebml_master(pb, ebml_header);    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);    mkv->segment_offset = avio_tell(pb);    // we write 2 seek heads - one at the end of the file to point to each    // cluster, and one at the beginning to point to all other level one    // elements (including the seek head at the end of the file), which    // isn't more than 10 elements if we only write one of each other    // currently defined level 1 element    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);    if (!mkv->main_seekhead) {        ret = AVERROR(ENOMEM);        goto fail;    }    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));    if (ret < 0) goto fail;    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);    if (ret < 0)        return ret;    pb = mkv->info_bc;    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);        else            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);        if (mkv->mode != MODE_WEBM) {            uint32_t segment_uid[4];            AVLFG lfg;            av_lfg_init(&lfg, av_get_random_seed());            for (i = 0; i < 4; i++)                segment_uid[i] = av_lfg_get(&lfg);            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);        }    } else {        const char *ident = \"Lavf\";        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);    }    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;        uint8_t date_utc_buf[8];        AV_WB64(date_utc_buf, date_utc);        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);    }    // reserve space for the duration    mkv->duration = 0;    mkv->duration_offset = avio_tell(pb);    if (!mkv->is_live) {        int64_t metadata_duration = get_metadata_duration(s);        if (s->duration > 0) {            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);        } else if (metadata_duration > 0) {            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);        } else {            put_ebml_void(pb, 11);              // assumes double-precision float to be written        }    }    if (s->pb->seekable && !mkv->is_live)        put_ebml_void(s->pb, avio_tell(pb));    else        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);    pb = s->pb;    // initialize stream_duration fields    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));    ret = mkv_write_tracks(s);    if (ret < 0)        goto fail;    for (i = 0; i < s->nb_chapters; i++)        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);    if (mkv->mode != MODE_WEBM) {        ret = mkv_write_chapters(s);        if (ret < 0)            goto fail;        ret = mkv_write_attachments(s);        if (ret < 0)            goto fail;        ret = mkv_write_tags(s);        if (ret < 0)            goto fail;    }    if (!s->pb->seekable && !mkv->is_live)        mkv_write_seekhead(pb, mkv);    mkv->cues = mkv_start_cues(mkv->segment_offset);    if (!mkv->cues) {        ret = AVERROR(ENOMEM);        goto fail;    }    if (pb->seekable && mkv->reserve_cues_space) {        mkv->cues_pos = avio_tell(pb);        put_ebml_void(pb, mkv->reserve_cues_space);    }    av_init_packet(&mkv->cur_audio_pkt);    mkv->cur_audio_pkt.size = 0;    mkv->cluster_pos = -1;    avio_flush(pb);    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or    // after 4k and on a keyframe    if (pb->seekable) {        if (mkv->cluster_time_limit < 0)            mkv->cluster_time_limit = 5000;        if (mkv->cluster_size_limit < 0)            mkv->cluster_size_limit = 5 * 1024 * 1024;    } else {        if (mkv->cluster_time_limit < 0)            mkv->cluster_time_limit = 1000;        if (mkv->cluster_size_limit < 0)            mkv->cluster_size_limit = 32 * 1024;    }    return 0;fail:    mkv_free(mkv);    return ret;}", "idx": 568}
{"project": "qemu", "commit_id": "1ad9f0a464fe78d30ee60b3629f7a825cf2fab13", "target": 0, "function": "void kvmppc_hash64_write_pte(CPUPPCState *env, target_ulong pte_index,                             target_ulong pte0, target_ulong pte1){    int htab_fd;    struct kvm_get_htab_fd ghf;    struct kvm_get_htab_buf hpte_buf;    ghf.flags = 0;    ghf.start_index = 0;     /* Ignored */    htab_fd = kvm_vm_ioctl(kvm_state, KVM_PPC_GET_HTAB_FD, &ghf);    if (htab_fd < 0) {        goto error_out;    }    hpte_buf.header.n_valid = 1;    hpte_buf.header.n_invalid = 0;    hpte_buf.header.index = pte_index;    hpte_buf.hpte[0] = pte0;    hpte_buf.hpte[1] = pte1;    /*     * Write the hpte entry.     * CAUTION: write() has the warn_unused_result attribute. Hence we     * need to check the return value, even though we do nothing.     */    if (write(htab_fd, &hpte_buf, sizeof(hpte_buf)) < 0) {        goto out_close;    }out_close:    close(htab_fd);    return;error_out:    return;}", "idx": 594}
{"project": "qemu", "commit_id": "a4a1c70dc759e5b81627e96564f344ab43ea86eb", "target": 0, "function": "static GenericList *qobject_input_next_list(Visitor *v, GenericList *tail,                                            size_t size){    QObjectInputVisitor *qiv = to_qiv(v);    StackObject *so = QSLIST_FIRST(&qiv->stack);    if (!so->entry) {        return NULL;    }    tail->next = g_malloc0(size);    return tail->next;}", "idx": 612}
{"project": "qemu", "commit_id": "cec56a733dd2c3fa81dbedbecf03922258747f7d", "target": 1, "function": "void cpu_state_reset(CPUMIPSState *env){    MIPSCPU *cpu = mips_env_get_cpu(env);    CPUState *cs = CPU(cpu);    /* Reset registers to their default values */    env->CP0_PRid = env->cpu_model->CP0_PRid;    env->CP0_Config0 = env->cpu_model->CP0_Config0;#ifdef TARGET_WORDS_BIGENDIAN    env->CP0_Config0 |= (1 << CP0C0_BE);#endif    env->CP0_Config1 = env->cpu_model->CP0_Config1;    env->CP0_Config2 = env->cpu_model->CP0_Config2;    env->CP0_Config3 = env->cpu_model->CP0_Config3;    env->CP0_Config4 = env->cpu_model->CP0_Config4;    env->CP0_Config4_rw_bitmask = env->cpu_model->CP0_Config4_rw_bitmask;    env->CP0_Config5 = env->cpu_model->CP0_Config5;    env->CP0_Config5_rw_bitmask = env->cpu_model->CP0_Config5_rw_bitmask;    env->CP0_Config6 = env->cpu_model->CP0_Config6;    env->CP0_Config7 = env->cpu_model->CP0_Config7;    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask                                 << env->cpu_model->CP0_LLAddr_shift;    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;    env->SYNCI_Step = env->cpu_model->SYNCI_Step;    env->CCRes = env->cpu_model->CCRes;    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;    env->current_tc = 0;    env->SEGBITS = env->cpu_model->SEGBITS;    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);#if defined(TARGET_MIPS64)    if (env->cpu_model->insn_flags & ISA_MIPS3) {        env->SEGMask |= 3ULL << 62;    }#endif    env->PABITS = env->cpu_model->PABITS;    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;    env->CP0_PageGrain_rw_bitmask = env->cpu_model->CP0_PageGrain_rw_bitmask;    env->CP0_PageGrain = env->cpu_model->CP0_PageGrain;    env->CP0_EBaseWG_rw_bitmask = env->cpu_model->CP0_EBaseWG_rw_bitmask;    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;    env->active_fpu.fcr31_rw_bitmask = env->cpu_model->CP1_fcr31_rw_bitmask;    env->active_fpu.fcr31 = env->cpu_model->CP1_fcr31;    env->msair = env->cpu_model->MSAIR;    env->insn_flags = env->cpu_model->insn_flags;#if defined(CONFIG_USER_ONLY)    env->CP0_Status = (MIPS_HFLAG_UM << CP0St_KSU);# ifdef TARGET_MIPS64    /* Enable 64-bit register mode.  */    env->CP0_Status |= (1 << CP0St_PX);# endif# ifdef TARGET_ABI_MIPSN64    /* Enable 64-bit address mode.  */    env->CP0_Status |= (1 << CP0St_UX);# endif    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR       hardware registers.  */    env->CP0_HWREna |= 0x0000000F;    if (env->CP0_Config1 & (1 << CP0C1_FP)) {        env->CP0_Status |= (1 << CP0St_CU1);    }    if (env->CP0_Config3 & (1 << CP0C3_DSPP)) {        env->CP0_Status |= (1 << CP0St_MX);    }# if defined(TARGET_MIPS64)    /* For MIPS64, init FR bit to 1 if FPU unit is there and bit is writable. */    if ((env->CP0_Config1 & (1 << CP0C1_FP)) &&        (env->CP0_Status_rw_bitmask & (1 << CP0St_FR))) {        env->CP0_Status |= (1 << CP0St_FR);    }# endif#else    if (env->hflags & MIPS_HFLAG_BMASK) {        /* If the exception was raised from a delay slot,           come back to the jump.  */        env->CP0_ErrorEPC = (env->active_tc.PC                             - (env->hflags & MIPS_HFLAG_B16 ? 2 : 4));    } else {        env->CP0_ErrorEPC = env->active_tc.PC;    }    env->active_tc.PC = env->exception_base;    env->CP0_Random = env->tlb->nb_tlb - 1;    env->tlb->tlb_in_use = env->tlb->nb_tlb;    env->CP0_Wired = 0;    env->CP0_GlobalNumber = (cs->cpu_index & 0xFF) << CP0GN_VPId;    env->CP0_EBase = (cs->cpu_index & 0x3FF);    if (kvm_enabled()) {        env->CP0_EBase |= 0x40000000;    } else {        env->CP0_EBase |= (int32_t)0x80000000;    }    if (env->CP0_Config3 & (1 << CP0C3_CMGCR)) {        env->CP0_CMGCRBase = 0x1fbf8000 >> 4;    }    env->CP0_EntryHi_ASID_mask = (env->CP0_Config4 & (1 << CP0C4_AE)) ?                                 0x3ff : 0xff;    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);    /* vectored interrupts not implemented, timer on int 7,       no performance counters. */    env->CP0_IntCtl = 0xe0000000;    {        int i;        for (i = 0; i < 7; i++) {            env->CP0_WatchLo[i] = 0;            env->CP0_WatchHi[i] = 0x80000000;        }        env->CP0_WatchLo[7] = 0;        env->CP0_WatchHi[7] = 0;    }    /* Count register increments in debug mode, EJTAG version 1 */    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);    cpu_mips_store_count(env, 1);    if (env->CP0_Config3 & (1 << CP0C3_MT)) {        int i;        /* Only TC0 on VPE 0 starts as active.  */        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {            env->tcs[i].CP0_TCBind = cs->cpu_index << CP0TCBd_CurVPE;            env->tcs[i].CP0_TCHalt = 1;        }        env->active_tc.CP0_TCHalt = 1;        cs->halted = 1;        if (cs->cpu_index == 0) {            /* VPE0 starts up enabled.  */            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);            /* TC0 starts up unhalted.  */            cs->halted = 0;            env->active_tc.CP0_TCHalt = 0;            env->tcs[0].CP0_TCHalt = 0;            /* With thread 0 active.  */            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);        }    }#endif    if ((env->insn_flags & ISA_MIPS32R6) &&        (env->active_fpu.fcr0 & (1 << FCR0_F64))) {        /* Status.FR = 0 mode in 64-bit FPU not allowed in R6 */        env->CP0_Status |= (1 << CP0St_FR);    }    /* MSA */    if (env->CP0_Config3 & (1 << CP0C3_MSAP)) {        msa_reset(env);    }    compute_hflags(env);    restore_fp_status(env);    restore_pamask(env);    cs->exception_index = EXCP_NONE;    if (semihosting_get_argc()) {        /* UHI interface can be used to obtain argc and argv */        env->active_tc.gpr[4] = -1;    }}", "idx": 616}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "function": "int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp){    uint8_t t[sizeof(diag_501)];    if (cpu_memory_rw_debug(cs, bp->pc, t, sizeof(diag_501), 0)) {        return -EINVAL;    } else if (memcmp(t, diag_501, sizeof(diag_501))) {        return -EINVAL;    } else if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,                                   sizeof(diag_501), 1)) {        return -EINVAL;    }    return 0;}", "idx": 711}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "function": "static int rd_frame(CinepakEncContext *s, AVFrame *frame, unsigned char *buf, int buf_size){    int num_strips, strip, h, i, y, size, temp_size, best_size;    AVPicture last_pict, pict, scratch_pict;    int64_t best_score = 0, score, score_temp;    //TODO: support encoding zero strips (meaning skip the whole frame)    for(num_strips = MIN_STRIPS; num_strips <= MAX_STRIPS && num_strips <= s->h / MB_SIZE; num_strips++) {        score = 0;        size = 0;        h = s->h / num_strips;        //make h into next multiple of 4        h += 4 - (h & 3);        for(strip = 0; strip < num_strips; strip++) {            y = strip*h;            get_sub_picture(s, 0, y, (AVPicture*)frame,            &pict);            get_sub_picture(s, 0, y, (AVPicture*)&s->last_frame,    &last_pict);            get_sub_picture(s, 0, y, (AVPicture*)&s->scratch_frame, &scratch_pict);            if((temp_size = rd_strip(s, y, FFMIN(h, s->h - y), frame->key_frame, &last_pict, &pict, &scratch_pict, s->frame_buf + CVID_HEADER_SIZE, &score_temp)) < 0)                return temp_size;            score += score_temp;            size += temp_size;        }        if(best_score == 0 || score < best_score) {            best_score = score;            best_size = size + write_cvid_header(s, s->frame_buf, num_strips, size);            av_log(s->avctx, AV_LOG_INFO, \"best number of strips so far: %2i, %12li, %i B\\n\", num_strips, score, best_size);            FFSWAP(AVFrame, s->best_frame, s->scratch_frame);        }    }    memcpy(buf, s->frame_buf, best_size);    return best_size;}", "idx": 716}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "function": "static int proxy_opendir(FsContext *ctx,                         V9fsPath *fs_path, V9fsFidOpenState *fs){    int serrno, fd;    fs->dir = NULL;    fd = v9fs_request(ctx->private, T_OPEN, NULL, \"sd\", fs_path, O_DIRECTORY);    if (fd < 0) {        errno = -fd;        return -1;    }    fs->dir = fdopendir(fd);    if (!fs->dir) {        serrno = errno;        close(fd);        errno = serrno;        return -1;    }    return 0;}", "idx": 801}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "function": "ThreadPool *thread_pool_new(AioContext *ctx){    ThreadPool *pool = g_new(ThreadPool, 1);    thread_pool_init_one(pool, ctx);    return pool;}", "idx": 807}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void assigned_dev_ioport_write(void *opaque, target_phys_addr_t addr,                                      uint64_t data, unsigned size){    assigned_dev_ioport_rw(opaque, addr, size, &data);}", "idx": 818}
{"project": "qemu", "commit_id": "ac3107340fbb9422ea63ee5d6729775965e121fd", "target": 1, "function": "void qemu_chr_be_write(CharDriverState *s, uint8_t *buf, int len){    s->chr_read(s->handler_opaque, buf, len);}", "idx": 841}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "function": "static int64_t load_kernel(void){    int64_t entry, kernel_high;    long kernel_size, initrd_size, params_size;    ram_addr_t initrd_offset;    uint32_t *params_buf;    int big_endian;#ifdef TARGET_WORDS_BIGENDIAN    big_endian = 1;#else    big_endian = 0;#endif    kernel_size = load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys,                           NULL, (uint64_t *)&entry, NULL,                           (uint64_t *)&kernel_high, big_endian,                           ELF_MACHINE, 1);    if (kernel_size >= 0) {        if ((entry & ~0x7fffffffULL) == 0x80000000)            entry = (int32_t)entry;    } else {        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",                loaderparams.kernel_filename);        exit(1);    }    /* load initrd */    initrd_size = 0;    initrd_offset = 0;    if (loaderparams.initrd_filename) {        initrd_size = get_image_size (loaderparams.initrd_filename);        if (initrd_size > 0) {            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;            if (initrd_offset + initrd_size > ram_size) {                fprintf(stderr,                        \"qemu: memory too small for initial ram disk '%s'\\n\",                        loaderparams.initrd_filename);                exit(1);            }            initrd_size = load_image_targphys(loaderparams.initrd_filename,                                              initrd_offset,                                              ram_size - initrd_offset);        }        if (initrd_size == (target_ulong) -1) {            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",                    loaderparams.initrd_filename);            exit(1);        }    }    /* Store command line.  */    params_size = 264;    params_buf = g_malloc(params_size);    params_buf[0] = tswap32(ram_size);    params_buf[1] = tswap32(0x12345678);    if (initrd_size > 0) {        snprintf((char *)params_buf + 8, 256, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",                 cpu_mips_phys_to_kseg0(NULL, initrd_offset),                 initrd_size, loaderparams.kernel_cmdline);    } else {        snprintf((char *)params_buf + 8, 256, \"%s\", loaderparams.kernel_cmdline);    }    rom_add_blob_fixed(\"params\", params_buf, params_size,                       (16 << 20) - 264);    return entry;}", "idx": 846}
{"project": "FFmpeg", "commit_id": "55fa898969d10e2d47bba0613175bf57a86c5a41", "target": 1, "function": "static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,                   uint8_t *properties){    Jpeg2000QuantStyle tmp;    int compno, ret;    if ((ret = get_qcx(s, n, &tmp)) < 0)        return ret;    for (compno = 0; compno < s->ncomponents; compno++)        if (!(properties[compno] & HAD_QCC))            memcpy(q + compno, &tmp, sizeof(tmp));    return 0;}", "idx": 932}
{"project": "FFmpeg", "commit_id": "b54ac8403bfea4e7fab0799ccfe728ba76959a38", "target": 0, "function": "static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,                             uint32_t length){    uint32_t sequence_number;    if (length != 26)        return AVERROR_INVALIDDATA;    if (!(s->state & PNG_IHDR)) {        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");        return AVERROR_INVALIDDATA;    }    s->last_w = s->cur_w;    s->last_h = s->cur_h;    s->last_x_offset = s->x_offset;    s->last_y_offset = s->y_offset;    s->last_dispose_op = s->dispose_op;    sequence_number = bytestream2_get_be32(&s->gb);    s->cur_w        = bytestream2_get_be32(&s->gb);    s->cur_h        = bytestream2_get_be32(&s->gb);    s->x_offset     = bytestream2_get_be32(&s->gb);    s->y_offset     = bytestream2_get_be32(&s->gb);    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */    s->dispose_op   = bytestream2_get_byte(&s->gb);    s->blend_op     = bytestream2_get_byte(&s->gb);    bytestream2_skip(&s->gb, 4); /* crc */    if (sequence_number == 0 &&        (s->cur_w != s->width ||         s->cur_h != s->height ||         s->x_offset != 0 ||         s->y_offset != 0) ||        s->cur_w <= 0 || s->cur_h <= 0 ||        s->x_offset < 0 || s->y_offset < 0 ||        s->cur_w > s->width - s->x_offset|| s->cur_h > s->height - s->y_offset)            return AVERROR_INVALIDDATA;    if (sequence_number == 0 && s->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {        // No previous frame to revert to for the first frame        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND        s->dispose_op = APNG_DISPOSE_OP_BACKGROUND;    }    if (s->dispose_op == APNG_BLEND_OP_OVER && !s->has_trns && (            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK        )) {        // APNG_DISPOSE_OP_OVER is the same as APNG_DISPOSE_OP_SOURCE when there is no alpha channel        s->dispose_op = APNG_BLEND_OP_SOURCE;    }    return 0;}", "idx": 936}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "function": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,                              target_ulong opcode, target_ulong *args){    target_ulong liobn = args[0];    target_ulong ioba = args[1];    target_ulong tce = args[2];    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);    VIOsPAPR_RTCE *rtce;    if (!dev) {        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);        return H_PARAMETER;    }    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);#ifdef DEBUG_TCE    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);#endif    if (ioba >= dev->rtce_window_size) {        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);        return H_PARAMETER;    }    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);    rtce->tce = tce;    return H_SUCCESS;}", "idx": 937}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "function": "Object *object_resolve_path_component(Object *parent, const gchar *part){    ObjectProperty *prop = object_property_find(parent, part, NULL);    if (prop == NULL) {        return NULL;    }    if (object_property_is_link(prop)) {        return *(Object **)prop->opaque;    } else if (object_property_is_child(prop)) {        return prop->opaque;    } else {        return NULL;    }}", "idx": 946}
{"project": "FFmpeg", "commit_id": "2e67a99fbc6b99315925de40fc6fa7161576be10", "target": 0, "function": "static int draw_text(AVFilterContext *ctx, AVFrame *frame,                     int width, int height){    DrawTextContext *s = ctx->priv;    AVFilterLink *inlink = ctx->inputs[0];    uint32_t code = 0, prev_code = 0;    int x = 0, y = 0, i = 0, ret;    int max_text_line_w = 0, len;    int box_w, box_h;    char *text;    uint8_t *p;    int y_min = 32000, y_max = -32000;    int x_min = 32000, x_max = -32000;    FT_Vector delta;    Glyph *glyph = NULL, *prev_glyph = NULL;    Glyph dummy = { 0 };    time_t now = time(0);    struct tm ltime;    AVBPrint *bp = &s->expanded_text;    FFDrawColor fontcolor;    FFDrawColor shadowcolor;    FFDrawColor bordercolor;    FFDrawColor boxcolor;    av_bprint_clear(bp);    if(s->basetime != AV_NOPTS_VALUE)        now= frame->pts*av_q2d(ctx->inputs[0]->time_base) + s->basetime/1000000;    switch (s->exp_mode) {    case EXP_NONE:        av_bprintf(bp, \"%s\", s->text);        break;    case EXP_NORMAL:        if ((ret = expand_text(ctx, s->text, &s->expanded_text)) < 0)            return ret;        break;    case EXP_STRFTIME:        localtime_r(&now, &ltime);        av_bprint_strftime(bp, s->text, &ltime);        break;    }    if (s->tc_opt_string) {        char tcbuf[AV_TIMECODE_STR_SIZE];        av_timecode_make_string(&s->tc, tcbuf, inlink->frame_count);        av_bprint_clear(bp);        av_bprintf(bp, \"%s%s\", s->text, tcbuf);    }    if (!av_bprint_is_complete(bp))        return AVERROR(ENOMEM);    text = s->expanded_text.str;    if ((len = s->expanded_text.len) > s->nb_positions) {        if (!(s->positions =              av_realloc(s->positions, len*sizeof(*s->positions))))            return AVERROR(ENOMEM);        s->nb_positions = len;    }    if (s->fontcolor_expr[0]) {        /* If expression is set, evaluate and replace the static value */        av_bprint_clear(&s->expanded_fontcolor);        if ((ret = expand_text(ctx, s->fontcolor_expr, &s->expanded_fontcolor)) < 0)            return ret;        if (!av_bprint_is_complete(&s->expanded_fontcolor))            return AVERROR(ENOMEM);        av_log(s, AV_LOG_DEBUG, \"Evaluated fontcolor is '%s'\\n\", s->expanded_fontcolor.str);        ret = av_parse_color(s->fontcolor.rgba, s->expanded_fontcolor.str, -1, s);        if (ret)            return ret;        ff_draw_color(&s->dc, &s->fontcolor, s->fontcolor.rgba);    }    x = 0;    y = 0;    /* load and cache glyphs */    for (i = 0, p = text; *p; i++) {        GET_UTF8(code, *p++, continue;);        /* get glyph */        dummy.code = code;        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);        if (!glyph) {            load_glyph(ctx, &glyph, code);        }        y_min = FFMIN(glyph->bbox.yMin, y_min);        y_max = FFMAX(glyph->bbox.yMax, y_max);        x_min = FFMIN(glyph->bbox.xMin, x_min);        x_max = FFMAX(glyph->bbox.xMax, x_max);    }    s->max_glyph_h = y_max - y_min;    s->max_glyph_w = x_max - x_min;    /* compute and save position for each glyph */    glyph = NULL;    for (i = 0, p = text; *p; i++) {        GET_UTF8(code, *p++, continue;);        /* skip the \\n in the sequence \\r\\n */        if (prev_code == '\\r' && code == '\\n')            continue;        prev_code = code;        if (is_newline(code)) {            max_text_line_w = FFMAX(max_text_line_w, x);            y += s->max_glyph_h;            x = 0;            continue;        }        /* get glyph */        prev_glyph = glyph;        dummy.code = code;        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);        /* kerning */        if (s->use_kerning && prev_glyph && glyph->code) {            FT_Get_Kerning(s->face, prev_glyph->code, glyph->code,                           ft_kerning_default, &delta);            x += delta.x >> 6;        }        /* save position */        s->positions[i].x = x + glyph->bitmap_left;        s->positions[i].y = y - glyph->bitmap_top + y_max;        if (code == '\\t') x  = (x / s->tabsize + 1)*s->tabsize;        else              x += glyph->advance;    }    max_text_line_w = FFMAX(x, max_text_line_w);    s->var_values[VAR_TW] = s->var_values[VAR_TEXT_W] = max_text_line_w;    s->var_values[VAR_TH] = s->var_values[VAR_TEXT_H] = y + s->max_glyph_h;    s->var_values[VAR_MAX_GLYPH_W] = s->max_glyph_w;    s->var_values[VAR_MAX_GLYPH_H] = s->max_glyph_h;    s->var_values[VAR_MAX_GLYPH_A] = s->var_values[VAR_ASCENT ] = y_max;    s->var_values[VAR_MAX_GLYPH_D] = s->var_values[VAR_DESCENT] = y_min;    s->var_values[VAR_LINE_H] = s->var_values[VAR_LH] = s->max_glyph_h;    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);    s->y = s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, &s->prng);    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);    update_alpha(s);    update_color_with_alpha(s, &fontcolor  , s->fontcolor  );    update_color_with_alpha(s, &shadowcolor, s->shadowcolor);    update_color_with_alpha(s, &bordercolor, s->bordercolor);    update_color_with_alpha(s, &boxcolor   , s->boxcolor   );    box_w = FFMIN(width - 1 , max_text_line_w);    box_h = FFMIN(height - 1, y + s->max_glyph_h);    /* draw box */    if (s->draw_box)        ff_blend_rectangle(&s->dc, &boxcolor,                           frame->data, frame->linesize, width, height,                           s->x - s->boxborderw, s->y - s->boxborderw,                           box_w + s->boxborderw * 2, box_h + s->boxborderw * 2);    if (s->shadowx || s->shadowy) {        if ((ret = draw_glyphs(s, frame, width, height,                               &shadowcolor, s->shadowx, s->shadowy, 0)) < 0)            return ret;    }    if (s->borderw) {        if ((ret = draw_glyphs(s, frame, width, height,                               &bordercolor, 0, 0, s->borderw)) < 0)            return ret;    }    if ((ret = draw_glyphs(s, frame, width, height,                           &fontcolor, 0, 0, 0)) < 0)        return ret;    return 0;}", "idx": 949}
{"project": "qemu", "commit_id": "bbc01ca7f265f2c5be8aee7c9ce1d10aa26063f5", "target": 0, "function": "static int check_pow_970 (CPUPPCState *env){    if (env->spr[SPR_HID0] & 0x00600000)        return 1;    return 0;}", "idx": 993}
{"project": "FFmpeg", "commit_id": "d917f25658c47b617420aa7a389cc354d6580ee4", "target": 1, "function": "static int cache_read(URLContext *h, unsigned char *buf, int size){    Context *c= h->priv_data;    CacheEntry *entry, *next[2] = {NULL, NULL};    int r;    entry = av_tree_find(c->root, &c->logical_pos, cmp, (void**)next);    if (!entry)        entry = next[0];    if (entry) {        int64_t in_block_pos = c->logical_pos - entry->logical_pos;        av_assert0(entry->logical_pos <= c->logical_pos);        if (in_block_pos < entry->size) {            int64_t physical_target = entry->physical_pos + in_block_pos;            if (c->cache_pos != physical_target) {                r = lseek(c->fd, physical_target, SEEK_SET);            } else                r = c->cache_pos;            if (r >= 0) {                c->cache_pos = r;                r = read(c->fd, buf, FFMIN(size, entry->size - in_block_pos));            }            if (r > 0) {                c->cache_pos += r;                c->logical_pos += r;                c->cache_hit ++;                return r;            }        }    }    // Cache miss or some kind of fault with the cache    if (c->logical_pos != c->inner_pos) {        r = ffurl_seek(c->inner, c->logical_pos, SEEK_SET);        if (r<0) {            av_log(h, AV_LOG_ERROR, \"Failed to perform internal seek\\n\");            return r;        }        c->inner_pos = r;    }    r = ffurl_read(c->inner, buf, size);    if (r == 0 && size>0) {        c->is_true_eof = 1;        av_assert0(c->end >= c->logical_pos);    }    if (r<=0)        return r;    c->inner_pos += r;    c->cache_miss ++;    add_entry(h, buf, r);    c->logical_pos += r;    c->end = FFMAX(c->end, c->logical_pos);    return r;}", "idx": 1012}
{"project": "qemu", "commit_id": "21e00fa55f3fdfcbb20da7c6876c91ef3609b387", "target": 0, "function": "static void guest_phys_blocks_region_add(MemoryListener *listener,                                         MemoryRegionSection *section){    GuestPhysListener *g;    uint64_t section_size;    hwaddr target_start, target_end;    uint8_t *host_addr;    GuestPhysBlock *predecessor;    /* we only care about RAM */    if (!memory_region_is_ram(section->mr) ||        memory_region_is_skip_dump(section->mr)) {        return;    }    g            = container_of(listener, GuestPhysListener, listener);    section_size = int128_get64(section->size);    target_start = section->offset_within_address_space;    target_end   = target_start + section_size;    host_addr    = memory_region_get_ram_ptr(section->mr) +                   section->offset_within_region;    predecessor  = NULL;    /* find continuity in guest physical address space */    if (!QTAILQ_EMPTY(&g->list->head)) {        hwaddr predecessor_size;        predecessor = QTAILQ_LAST(&g->list->head, GuestPhysBlockHead);        predecessor_size = predecessor->target_end - predecessor->target_start;        /* the memory API guarantees monotonically increasing traversal */        g_assert(predecessor->target_end <= target_start);        /* we want continuity in both guest-physical and host-virtual memory */        if (predecessor->target_end < target_start ||            predecessor->host_addr + predecessor_size != host_addr) {            predecessor = NULL;        }    }    if (predecessor == NULL) {        /* isolated mapping, allocate it and add it to the list */        GuestPhysBlock *block = g_malloc0(sizeof *block);        block->target_start = target_start;        block->target_end   = target_end;        block->host_addr    = host_addr;        block->mr           = section->mr;        memory_region_ref(section->mr);        QTAILQ_INSERT_TAIL(&g->list->head, block, next);        ++g->list->num;    } else {        /* expand predecessor until @target_end; predecessor's start doesn't         * change         */        predecessor->target_end = target_end;    }#ifdef DEBUG_GUEST_PHYS_REGION_ADD    fprintf(stderr, \"%s: target_start=\" TARGET_FMT_plx \" target_end=\"            TARGET_FMT_plx \": %s (count: %u)\\n\", __FUNCTION__, target_start,            target_end, predecessor ? \"joined\" : \"added\", g->list->num);#endif}", "idx": 1106}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "function": "build_fadt(GArray *table_data, GArray *linker, AcpiPmInfo *pm,           unsigned facs, unsigned dsdt){    AcpiFadtDescriptorRev1 *fadt = acpi_data_push(table_data, sizeof(*fadt));    fadt->firmware_ctrl = cpu_to_le32(facs);    /* FACS address to be filled by Guest linker */    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,                                   ACPI_BUILD_TABLE_FILE,                                   table_data, &fadt->firmware_ctrl,                                   sizeof fadt->firmware_ctrl);    fadt->dsdt = cpu_to_le32(dsdt);    /* DSDT address to be filled by Guest linker */    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,                                   ACPI_BUILD_TABLE_FILE,                                   table_data, &fadt->dsdt,                                   sizeof fadt->dsdt);    fadt_setup(fadt, pm);    build_header(linker, table_data,                 (void *)fadt, \"FACP\", sizeof(*fadt), 1, NULL);}", "idx": 1110}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "function": "static void register_multipage(MemoryRegionSection *section){    target_phys_addr_t start_addr = section->offset_within_address_space;    ram_addr_t size = section->size;    target_phys_addr_t addr;    uint16_t section_index = phys_section_add(section);    assert(size);    addr = start_addr;    phys_page_set(addr >> TARGET_PAGE_BITS, size >> TARGET_PAGE_BITS,                  section_index);}", "idx": 1114}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "function": "void qpci_iounmap(QPCIDevice *dev, void *data){    /* FIXME */}", "idx": 1141}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "function": "static int pix_norm1_altivec(uint8_t *pix, int line_size){    int i, s = 0;    const vector unsigned int zero =        (const vector unsigned int) vec_splat_u32(0);    vector unsigned int sv = (vector unsigned int) vec_splat_u32(0);    vector signed int sum;    for (i = 0; i < 16; i++) {        /* Read the potentially unaligned pixels. */        //vector unsigned char pixl = vec_ld(0,  pix);        //vector unsigned char pixr = vec_ld(15, pix);        //vector unsigned char pixv = vec_perm(pixl, pixr, perm);        vector unsigned char pixv = vec_vsx_ld(0,  pix);        /* Square the values, and add them to our sum. */        sv = vec_msum(pixv, pixv, sv);        pix += line_size;    }    /* Sum up the four partial sums, and put the result into s. */    sum = vec_sums((vector signed int) sv, (vector signed int) zero);    sum = vec_splat(sum, 3);    vec_vsx_st(sum, 0, &s);    return s;}", "idx": 1151}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "function": "uint64_t timer_expire_time_ns(QEMUTimer *ts){    return timer_pending(ts) ? ts->expire_time : -1;}", "idx": 1187}
{"project": "qemu", "commit_id": "1f001dc7bc9e435bf231a5b0edcad1c7c2bd6214", "target": 0, "function": "static int default_fdset_dup_fd_add(int64_t fdset_id, int dup_fd){    return -1;}", "idx": 1188}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "function": "void qmp_block_stream(const char *device, bool has_base,                      const char *base, Error **errp){    BlockDriverState *bs;    BlockDriverState *base_bs = NULL;    Error *local_err = NULL;    bs = bdrv_find(device);    if (!bs) {        error_set(errp, QERR_DEVICE_NOT_FOUND, device);        return;    }    if (base) {        base_bs = bdrv_find_backing_image(bs, base);        if (base_bs == NULL) {            error_set(errp, QERR_BASE_NOT_FOUND, base);            return;        }    }    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);    if (error_is_set(&local_err)) {        error_propagate(errp, local_err);        return;    }    /* Grab a reference so hotplug does not delete the BlockDriverState from     * underneath us.     */    drive_get_ref(drive_get_by_blockdev(bs));    trace_qmp_block_stream(bs, bs->job);}", "idx": 1227}
{"project": "qemu", "commit_id": "7a7aae21ccab06606cee9aba846d2e30cb616763", "target": 0, "function": "void qdev_prop_set_ptr(DeviceState *dev, const char *name, void *value){    qdev_prop_set(dev, name, &value, PROP_TYPE_PTR);}", "idx": 1256}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "function": "static inline void float_to_int (float * _f, int16_t * s16, int samples){    int32_t * f = (int32_t *) _f;       // XXX assumes IEEE float format    int i;    for (i = 0; i < samples; i++) {        s16[i] = blah (f[i]);    }}", "idx": 1296}
{"project": "qemu", "commit_id": "ce0bd027df9c62766a5417521d0f08f27359d43f", "target": 0, "function": "static void slirp_init_once(void){    static int initialized;    struct hostent *he;    char our_name[256];#ifdef _WIN32    WSADATA Data;#endif    if (initialized) {        return;    }    initialized = 1;#ifdef _WIN32    WSAStartup(MAKEWORD(2,0), &Data);    atexit(winsock_cleanup);#endif    loopback_addr.s_addr = htonl(INADDR_LOOPBACK);    /* FIXME: This address may change during runtime */    if (gethostname(our_name, sizeof(our_name)) == 0) {        he = gethostbyname(our_name);        if (he) {            our_addr = *(struct in_addr *)he->h_addr;        }    }    if (our_addr.s_addr == 0) {        our_addr = loopback_addr;    }    /* FIXME: This address may change during runtime */    if (get_dns_addr(&dns_addr) < 0) {        dns_addr = loopback_addr;    }}", "idx": 1304}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "function": "FFTContext *av_fft_init(int nbits, int inverse){    FFTContext *s = av_malloc(sizeof(*s));    if (s && ff_fft_init(s, nbits, inverse))        av_freep(&s);    return s;}", "idx": 1307}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "function": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width){\tint i;\tfor(i=0; i<width; i++)\t{\t\tint r=  ((uint32_t*)src)[i]&0xFF;\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\t}}", "idx": 1341}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "function": "static uint64_t pxa2xx_pic_mem_read(void *opaque, hwaddr offset,                                    unsigned size){    PXA2xxPICState *s = (PXA2xxPICState *) opaque;    switch (offset) {    case ICIP:\t/* IRQ Pending register */        return s->int_pending[0] & ~s->is_fiq[0] & s->int_enabled[0];    case ICIP2:\t/* IRQ Pending register 2 */        return s->int_pending[1] & ~s->is_fiq[1] & s->int_enabled[1];    case ICMR:\t/* Mask register */        return s->int_enabled[0];    case ICMR2:\t/* Mask register 2 */        return s->int_enabled[1];    case ICLR:\t/* Level register */        return s->is_fiq[0];    case ICLR2:\t/* Level register 2 */        return s->is_fiq[1];    case ICCR:\t/* Idle mask */        return (s->int_idle == 0);    case ICFP:\t/* FIQ Pending register */        return s->int_pending[0] & s->is_fiq[0] & s->int_enabled[0];    case ICFP2:\t/* FIQ Pending register 2 */        return s->int_pending[1] & s->is_fiq[1] & s->int_enabled[1];    case ICPR:\t/* Pending register */        return s->int_pending[0];    case ICPR2:\t/* Pending register 2 */        return s->int_pending[1];    case IPR0  ... IPR31:        return s->priority[0  + ((offset - IPR0 ) >> 2)];    case IPR32 ... IPR39:        return s->priority[32 + ((offset - IPR32) >> 2)];    case ICHP:\t/* Highest Priority register */        return pxa2xx_pic_highest(s);    default:        printf(\"%s: Bad register offset \" REG_FMT \"\\n\", __FUNCTION__, offset);        return 0;    }}", "idx": 1348}
{"project": "FFmpeg", "commit_id": "b7dc6f662868fbdad779c61c233b1d19d8b89d3c", "target": 1, "function": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc,\t\t\t\t   int flags, int canMMX2BeUsed, int16_t *hLumFilter,\t\t\t\t   int16_t *hLumFilterPos, int hLumFilterSize, void *funnyYCode, \t\t\t\t   int srcFormat, uint8_t *formatConvBuffer){    if(srcFormat==IMGFMT_YUY2)    {\tRENAME(yuy2ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_BGR32)    {\tRENAME(bgr32ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_BGR24)    {\tRENAME(bgr24ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_BGR16)    {\tRENAME(bgr16ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_BGR15)    {\tRENAME(bgr15ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_RGB32)    {\tRENAME(rgb32ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }    else if(srcFormat==IMGFMT_RGB24)    {\tRENAME(rgb24ToY)(formatConvBuffer, src, srcW);\tsrc= formatConvBuffer;    }#ifdef HAVE_MMX\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)    if(!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))#else    if(!(flags&SWS_FAST_BILINEAR))#endif    {    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);    }    else // Fast Bilinear upscale / crap downscale    {#ifdef ARCH_X86#ifdef HAVE_MMX2\tint i;\tif(canMMX2BeUsed)\t{\t\tasm volatile(\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\"\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF#define FUNNY_Y_CODE \\\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\t\t\t\"call *%6\t\t\t\\n\\t\"\\\t\t\t\"movq %%mm4, %%mm2\t\t\\n\\t\"\\\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"FUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODEFUNNY_Y_CODE\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF), \"m\" (funnyYCode)\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\t\t);\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\t}\telse\t{#endif\t//NO MMX just normal asm ...\tasm volatile(\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\t\t\".balign 16\t\t\t\\n\\t\"\t\t\"1:\t\t\t\t\\n\\t\"\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\t\t\"shll $16, %%edi\t\t\\n\\t\"\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\t\t\"shll $16, %%edi\t\t\\n\\t\"\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\t\t\" jb 1b\t\t\t\t\\n\\t\"\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\t\t);#ifdef HAVE_MMX2\t} //if MMX2 cant be used#endif#else\tint i;\tunsigned int xpos=0;\tfor(i=0;i<dstWidth;i++)\t{\t\tregister unsigned int xx=xpos>>16;\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\t\txpos+=xInc;\t}#endif    }}", "idx": 1380}
{"project": "FFmpeg", "commit_id": "0f87b42b44f8da7234e8e43b27d1dc5e4dce7582", "target": 0, "function": "int avformat_queue_attached_pictures(AVFormatContext *s){    int i;    for (i = 0; i < s->nb_streams; i++)        if (s->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC &&            s->streams[i]->discard < AVDISCARD_ALL) {            AVPacket copy = s->streams[i]->attached_pic;            if (copy.size <= 0)                return AVERROR(EINVAL);            copy.buf = av_buffer_ref(copy.buf);            if (!copy.buf)                return AVERROR(ENOMEM);            add_to_pktbuf(&s->raw_packet_buffer, &copy,                          &s->raw_packet_buffer_end);        }    return 0;}", "idx": 1541}
{"project": "qemu", "commit_id": "9445673ea67c272616b9f718396e267caa6446b7", "target": 0, "function": "static void nbd_refresh_filename(BlockDriverState *bs, QDict *options){    BDRVNBDState *s = bs->opaque;    QDict *opts = qdict_new();    QObject *saddr_qdict;    Visitor *ov;    const char *host = NULL, *port = NULL, *path = NULL;    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {        const InetSocketAddress *inet = s->saddr->u.inet.data;        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {            host = inet->host;            port = inet->port;        }    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {        path = s->saddr->u.q_unix.data->path;    }    qdict_put(opts, \"driver\", qstring_from_str(\"nbd\"));    if (path && s->export) {        snprintf(bs->exact_filename, sizeof(bs->exact_filename),                 \"nbd+unix:///%s?socket=%s\", s->export, path);    } else if (path && !s->export) {        snprintf(bs->exact_filename, sizeof(bs->exact_filename),                 \"nbd+unix://?socket=%s\", path);    } else if (host && s->export) {        snprintf(bs->exact_filename, sizeof(bs->exact_filename),                 \"nbd://%s:%s/%s\", host, port, s->export);    } else if (host && !s->export) {        snprintf(bs->exact_filename, sizeof(bs->exact_filename),                 \"nbd://%s:%s\", host, port);    }    ov = qobject_output_visitor_new(&saddr_qdict);    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);    visit_complete(ov, &saddr_qdict);    visit_free(ov);    qdict_put_obj(opts, \"server\", saddr_qdict);    if (s->export) {        qdict_put(opts, \"export\", qstring_from_str(s->export));    }    if (s->tlscredsid) {        qdict_put(opts, \"tls-creds\", qstring_from_str(s->tlscredsid));    }    qdict_flatten(opts);    bs->full_open_options = opts;}", "idx": 1569}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "function": "static int rm_write_video(AVFormatContext *s, const uint8_t *buf, int size){    RMContext *rm = s->priv_data;    ByteIOContext *pb = &s->pb;    StreamInfo *stream = rm->video_stream;    int key_frame = stream->enc->coded_frame->key_frame;    /* XXX: this is incorrect: should be a parameter */    /* Well, I spent some time finding the meaning of these bits. I am       not sure I understood everything, but it works !! */#if 1    write_packet_header(s, stream, size + 7, key_frame);    /* bit 7: '1' if final packet of a frame converted in several packets */    put_byte(pb, 0x81);     /* bit 7: '1' if I frame. bits 6..0 : sequence number in current       frame starting from 1 */    if (key_frame) {        put_byte(pb, 0x81);     } else {        put_byte(pb, 0x01);     }    put_be16(pb, 0x4000 | (size)); /* total frame size */    put_be16(pb, 0x4000 | (size));              /* offset from the start or the end */#else    /* full frame */    write_packet_header(s, size + 6);    put_byte(pb, 0xc0);     put_be16(pb, 0x4000 | size); /* total frame size */    put_be16(pb, 0x4000 + packet_number * 126); /* position in stream */#endif    put_byte(pb, stream->nb_frames & 0xff);         put_buffer(pb, buf, size);    put_flush_packet(pb);    stream->nb_frames++;    return 0;}", "idx": 1716}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "function": "void qemu_co_queue_run_restart(Coroutine *co){    Coroutine *next;    trace_qemu_co_queue_run_restart(co);    while ((next = QSIMPLEQ_FIRST(&co->co_queue_wakeup))) {        QSIMPLEQ_REMOVE_HEAD(&co->co_queue_wakeup, co_queue_next);        qemu_coroutine_enter(next, NULL);    }}", "idx": 1718}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "function": "static int decode_block(ALSDecContext *ctx, ALSBlockData *bd){    unsigned int smp;    // read block type flag and read the samples accordingly    if (*bd->const_block)        decode_const_block_data(ctx, bd);    else if (decode_var_block_data(ctx, bd))        return -1;    // TODO: read RLSLMS extension data    if (*bd->shift_lsbs)        for (smp = 0; smp < bd->block_length; smp++)            bd->raw_samples[smp] <<= *bd->shift_lsbs;    return 0;}", "idx": 1722}
{"project": "FFmpeg", "commit_id": "f74ce3a60d6ef49080df85c44b54280357109f56", "target": 1, "function": "static int vorbis_parse_audio_packet(vorbis_context *vc){    GetBitContext *gb = &vc->gb;    FFTContext *mdct;    unsigned previous_window = vc->previous_window;    unsigned mode_number, blockflag, blocksize;    int i, j;    uint8_t no_residue[255];    uint8_t do_not_decode[255];    vorbis_mapping *mapping;    float *ch_res_ptr   = vc->channel_residues;    float *ch_floor_ptr = vc->channel_floors;    uint8_t res_chan[255];    unsigned res_num = 0;    int retlen  = 0;    int ch_left = vc->audio_channels;    if (get_bits1(gb)) {        av_log(vc->avccontext, AV_LOG_ERROR, \"Not a Vorbis I audio packet.\\n\");        return AVERROR_INVALIDDATA; // packet type not audio    }    if (vc->mode_count == 1) {        mode_number = 0;    } else {        GET_VALIDATED_INDEX(mode_number, ilog(vc->mode_count-1), vc->mode_count)    }    vc->mode_number = mode_number;    mapping = &vc->mappings[vc->modes[mode_number].mapping];    av_dlog(NULL, \" Mode number: %u , mapping: %d , blocktype %d\\n\", mode_number,            vc->modes[mode_number].mapping, vc->modes[mode_number].blockflag);    blockflag = vc->modes[mode_number].blockflag;    blocksize = vc->blocksize[blockflag];    if (blockflag)        skip_bits(gb, 2); // previous_window, next_window    memset(ch_res_ptr,   0, sizeof(float) * vc->audio_channels * blocksize / 2); //FIXME can this be removed ?    memset(ch_floor_ptr, 0, sizeof(float) * vc->audio_channels * blocksize / 2); //FIXME can this be removed ?// Decode floor    for (i = 0; i < vc->audio_channels; ++i) {        vorbis_floor *floor;        int ret;        if (mapping->submaps > 1) {            floor = &vc->floors[mapping->submap_floor[mapping->mux[i]]];        } else {            floor = &vc->floors[mapping->submap_floor[0]];        }        ret = floor->decode(vc, &floor->data, ch_floor_ptr);        if (ret < 0) {            av_log(vc->avccontext, AV_LOG_ERROR, \"Invalid codebook in vorbis_floor_decode.\\n\");            return AVERROR_INVALIDDATA;        }        no_residue[i] = ret;        ch_floor_ptr += blocksize / 2;    }// Nonzero vector propagate    for (i = mapping->coupling_steps - 1; i >= 0; --i) {        if (!(no_residue[mapping->magnitude[i]] & no_residue[mapping->angle[i]])) {            no_residue[mapping->magnitude[i]] = 0;            no_residue[mapping->angle[i]]     = 0;        }    }// Decode residue    for (i = 0; i < mapping->submaps; ++i) {        vorbis_residue *residue;        unsigned ch = 0;        for (j = 0; j < vc->audio_channels; ++j) {            if ((mapping->submaps == 1) || (i == mapping->mux[j])) {                res_chan[j] = res_num;                if (no_residue[j]) {                    do_not_decode[ch] = 1;                } else {                    do_not_decode[ch] = 0;                }                ++ch;                ++res_num;            }        }        residue = &vc->residues[mapping->submap_residue[i]];        if (ch_left < ch) {            av_log(vc->avccontext, AV_LOG_ERROR, \"Too many channels in vorbis_floor_decode.\\n\");            return -1;        }        vorbis_residue_decode(vc, residue, ch, do_not_decode, ch_res_ptr, blocksize/2);        ch_res_ptr += ch * blocksize / 2;        ch_left -= ch;    }// Inverse coupling    for (i = mapping->coupling_steps - 1; i >= 0; --i) { //warning: i has to be signed        float *mag, *ang;        mag = vc->channel_residues+res_chan[mapping->magnitude[i]] * blocksize / 2;        ang = vc->channel_residues+res_chan[mapping->angle[i]]     * blocksize / 2;        vc->dsp.vorbis_inverse_coupling(mag, ang, blocksize / 2);    }// Dotproduct, MDCT    mdct = &vc->mdct[blockflag];    for (j = vc->audio_channels-1;j >= 0; j--) {        ch_floor_ptr = vc->channel_floors   + j           * blocksize / 2;        ch_res_ptr   = vc->channel_residues + res_chan[j] * blocksize / 2;        vc->dsp.vector_fmul(ch_floor_ptr, ch_floor_ptr, ch_res_ptr, blocksize / 2);        mdct->imdct_half(mdct, ch_res_ptr, ch_floor_ptr);    }// Overlap/add, save data for next overlapping  FPMATH    retlen = (blocksize + vc->blocksize[previous_window]) / 4;    for (j = 0; j < vc->audio_channels; j++) {        unsigned bs0 = vc->blocksize[0];        unsigned bs1 = vc->blocksize[1];        float *residue    = vc->channel_residues + res_chan[j] * blocksize / 2;        float *saved      = vc->saved + j * bs1 / 4;        float *ret        = vc->channel_floors + j * retlen;        float *buf        = residue;        const float *win  = vc->win[blockflag & previous_window];        if (blockflag == previous_window) {            vc->dsp.vector_fmul_window(ret, saved, buf, win, blocksize / 4);        } else if (blockflag > previous_window) {            vc->dsp.vector_fmul_window(ret, saved, buf, win, bs0 / 4);            memcpy(ret+bs0/2, buf+bs0/4, ((bs1-bs0)/4) * sizeof(float));        } else {            memcpy(ret, saved, ((bs1 - bs0) / 4) * sizeof(float));            vc->dsp.vector_fmul_window(ret + (bs1 - bs0) / 4, saved + (bs1 - bs0) / 4, buf, win, bs0 / 4);        }        memcpy(saved, buf + blocksize / 4, blocksize / 4 * sizeof(float));    }    vc->previous_window = blockflag;    return retlen;}", "idx": 1729}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "function": "int vnc_tls_set_x509_creds_dir(VncDisplay *vd,                               const char *certdir){    if (vnc_set_x509_credential(vd, certdir, X509_CA_CERT_FILE, &vd->tls.x509cacert, 0) < 0)        goto cleanup;    if (vnc_set_x509_credential(vd, certdir, X509_CA_CRL_FILE, &vd->tls.x509cacrl, 1) < 0)        goto cleanup;    if (vnc_set_x509_credential(vd, certdir, X509_SERVER_CERT_FILE, &vd->tls.x509cert, 0) < 0)        goto cleanup;    if (vnc_set_x509_credential(vd, certdir, X509_SERVER_KEY_FILE, &vd->tls.x509key, 0) < 0)        goto cleanup;    return 0; cleanup:    g_free(vd->tls.x509cacert);    g_free(vd->tls.x509cacrl);    g_free(vd->tls.x509cert);    g_free(vd->tls.x509key);    vd->tls.x509cacert = vd->tls.x509cacrl = vd->tls.x509cert = vd->tls.x509key = NULL;    return -1;}", "idx": 1742}
{"project": "FFmpeg", "commit_id": "4e8d01f20ce82b49f47c704a461c5d30866affaf", "target": 0, "function": "static void m4sl_cb(MpegTSFilter *filter, const uint8_t *section,                    int section_len){    MpegTSContext *ts = filter->u.section_filter.opaque;    MpegTSSectionFilter *tssf = &filter->u.section_filter;    SectionHeader h;    const uint8_t *p, *p_end;    AVIOContext pb;    int mp4_descr_count = 0;    Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = { { 0 } };    int i, pid;    AVFormatContext *s = ts->stream;    p_end = section + section_len - 4;    p = section;    if (parse_section_header(&h, &p, p_end) < 0)        return;    if (h.tid != M4OD_TID)        return;    if (h.version == tssf->last_ver)        return;    tssf->last_ver = h.version;    mp4_read_od(s, p, (unsigned) (p_end - p), mp4_descr, &mp4_descr_count,                MAX_MP4_DESCR_COUNT);    for (pid = 0; pid < NB_PID_MAX; pid++) {        if (!ts->pids[pid])            continue;        for (i = 0; i < mp4_descr_count; i++) {            PESContext *pes;            AVStream *st;            if (ts->pids[pid]->es_id != mp4_descr[i].es_id)                continue;            if (ts->pids[pid]->type != MPEGTS_PES) {                av_log(s, AV_LOG_ERROR, \"pid %x is not PES\\n\", pid);                continue;            }            pes = ts->pids[pid]->u.pes_filter.opaque;            st  = pes->st;            if (!st)                continue;            pes->sl = mp4_descr[i].sl;            ffio_init_context(&pb, mp4_descr[i].dec_config_descr,                              mp4_descr[i].dec_config_descr_len, 0,                              NULL, NULL, NULL, NULL);            ff_mp4_read_dec_config_descr(s, st, &pb);            if (st->codec->codec_id == AV_CODEC_ID_AAC &&                st->codec->extradata_size > 0)                st->need_parsing = 0;            if (st->codec->codec_id == AV_CODEC_ID_H264 &&                st->codec->extradata_size > 0)                st->need_parsing = 0;            if (st->codec->codec_id <= AV_CODEC_ID_NONE) {                // do nothing            } else if (st->codec->codec_id < AV_CODEC_ID_FIRST_AUDIO)                st->codec->codec_type = AVMEDIA_TYPE_VIDEO;            else if (st->codec->codec_id < AV_CODEC_ID_FIRST_SUBTITLE)                st->codec->codec_type = AVMEDIA_TYPE_AUDIO;            else if (st->codec->codec_id < AV_CODEC_ID_FIRST_UNKNOWN)                st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;        }    }    for (i = 0; i < mp4_descr_count; i++)        av_free(mp4_descr[i].dec_config_descr);}", "idx": 1833}
{"project": "FFmpeg", "commit_id": "75084e47ffc24bede7acaf00c5e092ca46f52bbc", "target": 0, "function": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,                           int srcSliceH, uint8_t* dst[], int dstStride[]){    /* load a few things into local vars to make the code more readable? and faster */    const int srcW= c->srcW;    const int dstW= c->dstW;    const int dstH= c->dstH;    const int chrDstW= c->chrDstW;    const int chrSrcW= c->chrSrcW;    const int lumXInc= c->lumXInc;    const int chrXInc= c->chrXInc;    const enum PixelFormat dstFormat= c->dstFormat;    const enum PixelFormat srcFormat= c->srcFormat;    const int flags= c->flags;    int16_t *vLumFilterPos= c->vLumFilterPos;    int16_t *vChrFilterPos= c->vChrFilterPos;    int16_t *hLumFilterPos= c->hLumFilterPos;    int16_t *hChrFilterPos= c->hChrFilterPos;    int16_t *vLumFilter= c->vLumFilter;    int16_t *vChrFilter= c->vChrFilter;    int16_t *hLumFilter= c->hLumFilter;    int16_t *hChrFilter= c->hChrFilter;    int32_t *lumMmxFilter= c->lumMmxFilter;    int32_t *chrMmxFilter= c->chrMmxFilter;    int32_t *alpMmxFilter= c->alpMmxFilter;    const int vLumFilterSize= c->vLumFilterSize;    const int vChrFilterSize= c->vChrFilterSize;    const int hLumFilterSize= c->hLumFilterSize;    const int hChrFilterSize= c->hChrFilterSize;    int16_t **lumPixBuf= c->lumPixBuf;    int16_t **chrPixBuf= c->chrPixBuf;    int16_t **alpPixBuf= c->alpPixBuf;    const int vLumBufSize= c->vLumBufSize;    const int vChrBufSize= c->vChrBufSize;    uint8_t *formatConvBuffer= c->formatConvBuffer;    const int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;    const int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);    int lastDstY;    uint32_t *pal=c->pal_yuv;    /* vars which will change and which we need to store back in the context */    int dstY= c->dstY;    int lumBufIndex= c->lumBufIndex;    int chrBufIndex= c->chrBufIndex;    int lastInLumBuf= c->lastInLumBuf;    int lastInChrBuf= c->lastInChrBuf;    if (isPacked(c->srcFormat)) {        src[0]=        src[1]=        src[2]=        src[3]= src[0];        srcStride[0]=        srcStride[1]=        srcStride[2]=        srcStride[3]= srcStride[0];    }    srcStride[1]<<= c->vChrDrop;    srcStride[2]<<= c->vChrDrop;    DEBUG_BUFFERS(\"swScale() %p[%d] %p[%d] %p[%d] %p[%d] -> %p[%d] %p[%d] %p[%d] %p[%d]\\n\",                  src[0], srcStride[0], src[1], srcStride[1], src[2], srcStride[2], src[3], srcStride[3],                  dst[0], dstStride[0], dst[1], dstStride[1], dst[2], dstStride[2], dst[3], dstStride[3]);    DEBUG_BUFFERS(\"srcSliceY: %d srcSliceH: %d dstY: %d dstH: %d\\n\",                   srcSliceY,    srcSliceH,    dstY,    dstH);    DEBUG_BUFFERS(\"vLumFilterSize: %d vLumBufSize: %d vChrFilterSize: %d vChrBufSize: %d\\n\",                   vLumFilterSize,    vLumBufSize,    vChrFilterSize,    vChrBufSize);    if (dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0 || dstStride[3]%8 != 0) {        static int warnedAlready=0; //FIXME move this into the context perhaps        if (flags & SWS_PRINT_INFO && !warnedAlready) {            av_log(c, AV_LOG_WARNING, \"Warning: dstStride is not aligned!\\n\"                   \"         ->cannot do aligned memory accesses anymore\\n\");            warnedAlready=1;        }    }    /* Note the user might start scaling the picture in the middle so this       will not get executed. This is not really intended but works       currently, so people might do it. */    if (srcSliceY ==0) {        lumBufIndex=0;        chrBufIndex=0;        dstY=0;        lastInLumBuf= -1;        lastInChrBuf= -1;    }    lastDstY= dstY;    for (;dstY < dstH; dstY++) {        unsigned char *dest =dst[0]+dstStride[0]*dstY;        const int chrDstY= dstY>>c->chrDstVSubSample;        unsigned char *uDest=dst[1]+dstStride[1]*chrDstY;        unsigned char *vDest=dst[2]+dstStride[2]*chrDstY;        unsigned char *aDest=(CONFIG_SWSCALE_ALPHA && alpPixBuf) ? dst[3]+dstStride[3]*dstY : NULL;        const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input        const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input        int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input        int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input        int enough_lines;        //handle holes (FAST_BILINEAR & weird filters)        if (firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;        if (firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;        assert(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1);        assert(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1);        // Do we have enough lines in this slice to output the dstY line        enough_lines = lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample);        if (!enough_lines) {            lastLumSrcY = srcSliceY + srcSliceH - 1;            lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1;        }        DEBUG_BUFFERS(\"dstY: %d\\n\", dstY);        DEBUG_BUFFERS(\"\\tfirstLumSrcY: %d lastLumSrcY: %d lastInLumBuf: %d\\n\",                         firstLumSrcY,    lastLumSrcY,    lastInLumBuf);        DEBUG_BUFFERS(\"\\tfirstChrSrcY: %d lastChrSrcY: %d lastInChrBuf: %d\\n\",                         firstChrSrcY,    lastChrSrcY,    lastInChrBuf);        //Do horizontal scaling        while(lastInLumBuf < lastLumSrcY) {            uint8_t *src1= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];            uint8_t *src2= src[3]+(lastInLumBuf + 1 - srcSliceY)*srcStride[3];            lumBufIndex++;            DEBUG_BUFFERS(\"\\t\\tlumBufIndex %d: lastInLumBuf: %d\\n\",                               lumBufIndex,    lastInLumBuf);            assert(lumBufIndex < 2*vLumBufSize);            assert(lastInLumBuf + 1 - srcSliceY < srcSliceH);            assert(lastInLumBuf + 1 - srcSliceY >= 0);            RENAME(hyscale)(c, lumPixBuf[ lumBufIndex ], dstW, src1, srcW, lumXInc,                            flags, hLumFilter, hLumFilterPos, hLumFilterSize,                            c->srcFormat, formatConvBuffer,                            pal, 0);            if (CONFIG_SWSCALE_ALPHA && alpPixBuf)                RENAME(hyscale)(c, alpPixBuf[ lumBufIndex ], dstW, src2, srcW, lumXInc,                                flags, hLumFilter, hLumFilterPos, hLumFilterSize,                                c->srcFormat, formatConvBuffer,                                pal, 1);            lastInLumBuf++;        }        while(lastInChrBuf < lastChrSrcY) {            uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];            uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];            chrBufIndex++;            DEBUG_BUFFERS(\"\\t\\tchrBufIndex %d: lastInChrBuf: %d\\n\",                               chrBufIndex,    lastInChrBuf);            assert(chrBufIndex < 2*vChrBufSize);            assert(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH));            assert(lastInChrBuf + 1 - chrSrcSliceY >= 0);            //FIXME replace parameters through context struct (some at least)            if (!(isGray(srcFormat) || isGray(dstFormat)))                RENAME(hcscale)(c, chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,                                flags, hChrFilter, hChrFilterPos, hChrFilterSize,                                c->srcFormat, formatConvBuffer,                                pal);            lastInChrBuf++;        }        //wrap buf index around to stay inside the ring buffer        if (lumBufIndex >= vLumBufSize) lumBufIndex-= vLumBufSize;        if (chrBufIndex >= vChrBufSize) chrBufIndex-= vChrBufSize;        if (!enough_lines)            break; //we can't output a dstY line so let's try with the next slice#if COMPILE_TEMPLATE_MMX        c->blueDither= ff_dither8[dstY&1];        if (c->dstFormat == PIX_FMT_RGB555 || c->dstFormat == PIX_FMT_BGR555)            c->greenDither= ff_dither8[dstY&1];        else            c->greenDither= ff_dither4[dstY&1];        c->redDither= ff_dither8[(dstY+1)&1];#endif        if (dstY < dstH-2) {            const int16_t **lumSrcPtr= (const int16_t **) lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;            const int16_t **chrSrcPtr= (const int16_t **) chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;            const int16_t **alpSrcPtr= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? (const int16_t **) alpPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize : NULL;#if COMPILE_TEMPLATE_MMX            int i;            if (flags & SWS_ACCURATE_RND) {                int s= APCK_SIZE / 8;                for (i=0; i<vLumFilterSize; i+=2) {                    *(void**)&lumMmxFilter[s*i              ]= lumSrcPtr[i  ];                    *(void**)&lumMmxFilter[s*i+APCK_PTR2/4  ]= lumSrcPtr[i+(vLumFilterSize>1)];                              lumMmxFilter[s*i+APCK_COEF/4  ]=                              lumMmxFilter[s*i+APCK_COEF/4+1]= vLumFilter[dstY*vLumFilterSize + i    ]                        + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);                    if (CONFIG_SWSCALE_ALPHA && alpPixBuf) {                        *(void**)&alpMmxFilter[s*i              ]= alpSrcPtr[i  ];                        *(void**)&alpMmxFilter[s*i+APCK_PTR2/4  ]= alpSrcPtr[i+(vLumFilterSize>1)];                                  alpMmxFilter[s*i+APCK_COEF/4  ]=                                  alpMmxFilter[s*i+APCK_COEF/4+1]= lumMmxFilter[s*i+APCK_COEF/4  ];                    }                }                for (i=0; i<vChrFilterSize; i+=2) {                    *(void**)&chrMmxFilter[s*i              ]= chrSrcPtr[i  ];                    *(void**)&chrMmxFilter[s*i+APCK_PTR2/4  ]= chrSrcPtr[i+(vChrFilterSize>1)];                              chrMmxFilter[s*i+APCK_COEF/4  ]=                              chrMmxFilter[s*i+APCK_COEF/4+1]= vChrFilter[chrDstY*vChrFilterSize + i    ]                        + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);                }            } else {                for (i=0; i<vLumFilterSize; i++) {                    lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];                    lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;                    lumMmxFilter[4*i+2]=                    lumMmxFilter[4*i+3]=                        ((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;                    if (CONFIG_SWSCALE_ALPHA && alpPixBuf) {                        alpMmxFilter[4*i+0]= (int32_t)alpSrcPtr[i];                        alpMmxFilter[4*i+1]= (uint64_t)alpSrcPtr[i] >> 32;                        alpMmxFilter[4*i+2]=                        alpMmxFilter[4*i+3]= lumMmxFilter[4*i+2];                    }                }                for (i=0; i<vChrFilterSize; i++) {                    chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];                    chrMmxFilter[4*i+1]= (uint64_t)chrSrcPtr[i] >> 32;                    chrMmxFilter[4*i+2]=                    chrMmxFilter[4*i+3]=                        ((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;                }            }#endif            if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) {                const int chrSkipMask= (1<<c->chrDstVSubSample)-1;                if (dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi                c->yuv2nv12X(c,                             vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                             vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                             dest, uDest, dstW, chrDstW, dstFormat);            } else if (isPlanarYUV(dstFormat) || dstFormat==PIX_FMT_GRAY8) { //YV12 like                const int chrSkipMask= (1<<c->chrDstVSubSample)-1;                if ((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi                if (is16BPS(dstFormat)) {                    yuv2yuvX16inC(                                  vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                                  vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                  alpSrcPtr, (uint16_t *) dest, (uint16_t *) uDest, (uint16_t *) vDest, (uint16_t *) aDest, dstW, chrDstW,                                  dstFormat);                } else if (vLumFilterSize == 1 && vChrFilterSize == 1) { // unscaled YV12                    int16_t *lumBuf = lumSrcPtr[0];                    int16_t *chrBuf= chrSrcPtr[0];                    int16_t *alpBuf= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? alpSrcPtr[0] : NULL;                    c->yuv2yuv1(c, lumBuf, chrBuf, alpBuf, dest, uDest, vDest, aDest, dstW, chrDstW);                } else { //General YV12                    c->yuv2yuvX(c,                                vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                                vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                alpSrcPtr, dest, uDest, vDest, aDest, dstW, chrDstW);                }            } else {                assert(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);                assert(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);                if (vLumFilterSize == 1 && vChrFilterSize == 2) { //unscaled RGB                    int chrAlpha= vChrFilter[2*dstY+1];                    if(flags & SWS_FULL_CHR_H_INT) {                        yuv2rgbXinC_full(c, //FIXME write a packed1_full function                                         vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                         vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                         alpSrcPtr, dest, dstW, dstY);                    } else {                        c->yuv2packed1(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),                                       alpPixBuf ? *alpSrcPtr : NULL,                                       dest, dstW, chrAlpha, dstFormat, flags, dstY);                    }                } else if (vLumFilterSize == 2 && vChrFilterSize == 2) { //bilinear upscale RGB                    int lumAlpha= vLumFilter[2*dstY+1];                    int chrAlpha= vChrFilter[2*dstY+1];                    lumMmxFilter[2]=                    lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;                    chrMmxFilter[2]=                    chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;                    if(flags & SWS_FULL_CHR_H_INT) {                        yuv2rgbXinC_full(c, //FIXME write a packed2_full function                                         vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                         vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                         alpSrcPtr, dest, dstW, dstY);                    } else {                        c->yuv2packed2(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),                                       alpPixBuf ? *alpSrcPtr : NULL, alpPixBuf ? *(alpSrcPtr+1) : NULL,                                       dest, dstW, lumAlpha, chrAlpha, dstY);                    }                } else { //general RGB                    if(flags & SWS_FULL_CHR_H_INT) {                        yuv2rgbXinC_full(c,                                         vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                         vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                         alpSrcPtr, dest, dstW, dstY);                    } else {                        c->yuv2packedX(c,                                       vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                       vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                       alpSrcPtr, dest, dstW, dstY);                    }                }            }        } else { // hmm looks like we can't use MMX here without overwriting this array's tail            const int16_t **lumSrcPtr= (const int16_t **)lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;            const int16_t **chrSrcPtr= (const int16_t **)chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;            const int16_t **alpSrcPtr= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? (const int16_t **)alpPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize : NULL;            if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) {                const int chrSkipMask= (1<<c->chrDstVSubSample)-1;                if (dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi                yuv2nv12XinC(                             vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                             vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                             dest, uDest, dstW, chrDstW, dstFormat);            } else if (isPlanarYUV(dstFormat) || dstFormat==PIX_FMT_GRAY8) { //YV12                const int chrSkipMask= (1<<c->chrDstVSubSample)-1;                if ((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi                if (is16BPS(dstFormat)) {                    yuv2yuvX16inC(                                  vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                                  vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                  alpSrcPtr, (uint16_t *) dest, (uint16_t *) uDest, (uint16_t *) vDest, (uint16_t *) aDest, dstW, chrDstW,                                  dstFormat);                } else {                    yuv2yuvXinC(                                vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,                                vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                alpSrcPtr, dest, uDest, vDest, aDest, dstW, chrDstW);                }            } else {                assert(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);                assert(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);                if(flags & SWS_FULL_CHR_H_INT) {                    yuv2rgbXinC_full(c,                                     vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                     vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                     alpSrcPtr, dest, dstW, dstY);                } else {                    yuv2packedXinC(c,                                   vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,                                   vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,                                   alpSrcPtr, dest, dstW, dstY);                }            }        }    }    if ((dstFormat == PIX_FMT_YUVA420P) && !alpPixBuf)        fillPlane(dst[3], dstStride[3], dstW, dstY-lastDstY, lastDstY, 255);#if COMPILE_TEMPLATE_MMX    if (flags & SWS_CPU_CAPS_MMX2 )  __asm__ volatile(\"sfence\":::\"memory\");    /* On K6 femms is faster than emms. On K7 femms is directly mapped to emms. */    if (flags & SWS_CPU_CAPS_3DNOW)  __asm__ volatile(\"femms\" :::\"memory\");    else                             __asm__ volatile(\"emms\"  :::\"memory\");#endif    /* store changed local vars back in the context */    c->dstY= dstY;    c->lumBufIndex= lumBufIndex;    c->chrBufIndex= chrBufIndex;    c->lastInLumBuf= lastInLumBuf;    c->lastInChrBuf= lastInChrBuf;    return dstY - lastDstY;}", "idx": 1836}
{"project": "qemu", "commit_id": "9ed2690354e65a87b830f197cac0138e842f989e", "target": 0, "function": "void *pci_assign_dev_load_option_rom(PCIDevice *dev, struct Object *owner,                                     int *size, unsigned int domain,                                     unsigned int bus, unsigned int slot,                                     unsigned int function){    char name[32], rom_file[64];    FILE *fp;    uint8_t val;    struct stat st;    void *ptr = NULL;    /* If loading ROM from file, pci handles it */    if (dev->romfile || !dev->rom_bar) {        return NULL;    }    snprintf(rom_file, sizeof(rom_file),             \"/sys/bus/pci/devices/%04x:%02x:%02x.%01x/rom\",             domain, bus, slot, function);    if (stat(rom_file, &st)) {        if (errno != ENOENT) {            error_report(\"pci-assign: Invalid ROM.\");        }        return NULL;    }    /* Write \"1\" to the ROM file to enable it */    fp = fopen(rom_file, \"r+\");    if (fp == NULL) {        error_report(\"pci-assign: Cannot open %s: %s\", rom_file, strerror(errno));        return NULL;    }    val = 1;    if (fwrite(&val, 1, 1, fp) != 1) {        goto close_rom;    }    fseek(fp, 0, SEEK_SET);    snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(owner));    memory_region_init_ram(&dev->rom, owner, name, st.st_size, &error_abort);    vmstate_register_ram(&dev->rom, &dev->qdev);    ptr = memory_region_get_ram_ptr(&dev->rom);    memset(ptr, 0xff, st.st_size);    if (!fread(ptr, 1, st.st_size, fp)) {        error_report(\"pci-assign: Cannot read from host %s\", rom_file);        error_printf(\"Device option ROM contents are probably invalid \"                     \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"                     \"or load from file with romfile=\\n\");        goto close_rom;    }    pci_register_bar(dev, PCI_ROM_SLOT, 0, &dev->rom);    dev->has_rom = true;    *size = st.st_size;close_rom:    /* Write \"0\" to disable ROM */    fseek(fp, 0, SEEK_SET);    val = 0;    if (!fwrite(&val, 1, 1, fp)) {        DEBUG(\"%s\\n\", \"Failed to disable pci-sysfs rom file\");    }    fclose(fp);    return ptr;}", "idx": 1855}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "function": "static void dvbsub_parse_region_segment(AVCodecContext *avctx,                                        const uint8_t *buf, int buf_size){    DVBSubContext *ctx = avctx->priv_data;    const uint8_t *buf_end = buf + buf_size;    int region_id, object_id;    DVBSubRegion *region;    DVBSubObject *object;    DVBSubObjectDisplay *display;    int fill;    if (buf_size < 10)        return;    region_id = *buf++;    region = get_region(ctx, region_id);    if (!region) {        region = av_mallocz(sizeof(DVBSubRegion));        region->id = region_id;        region->next = ctx->region_list;        ctx->region_list = region;    }    fill = ((*buf++) >> 3) & 1;    region->width = AV_RB16(buf);    buf += 2;    region->height = AV_RB16(buf);    buf += 2;    if (region->width * region->height != region->buf_size) {        av_free(region->pbuf);        region->buf_size = region->width * region->height;        region->pbuf = av_malloc(region->buf_size);        fill = 1;    }    region->depth = 1 << (((*buf++) >> 2) & 7);    if(region->depth<2 || region->depth>8){        av_log(avctx, AV_LOG_ERROR, \"region depth %d is invalid\\n\", region->depth);        region->depth= 4;    }    region->clut = *buf++;    if (region->depth == 8)        region->bgcolor = *buf++;    else {        buf += 1;        if (region->depth == 4)            region->bgcolor = (((*buf++) >> 4) & 15);        else            region->bgcolor = (((*buf++) >> 2) & 3);    }    av_dlog(avctx, \"Region %d, (%dx%d)\\n\", region_id, region->width, region->height);    if (fill) {        memset(region->pbuf, region->bgcolor, region->buf_size);        av_dlog(avctx, \"Fill region (%d)\\n\", region->bgcolor);    }    delete_region_display_list(ctx, region);    while (buf + 5 < buf_end) {        object_id = AV_RB16(buf);        buf += 2;        object = get_object(ctx, object_id);        if (!object) {            object = av_mallocz(sizeof(DVBSubObject));            object->id = object_id;            object->next = ctx->object_list;            ctx->object_list = object;        }        object->type = (*buf) >> 6;        display = av_mallocz(sizeof(DVBSubObjectDisplay));        display->object_id = object_id;        display->region_id = region_id;        display->x_pos = AV_RB16(buf) & 0xfff;        buf += 2;        display->y_pos = AV_RB16(buf) & 0xfff;        buf += 2;        if ((object->type == 1 || object->type == 2) && buf+1 < buf_end) {            display->fgcolor = *buf++;            display->bgcolor = *buf++;        }        display->region_list_next = region->display_list;        region->display_list = display;        display->object_list_next = object->display_list;        object->display_list = display;    }}", "idx": 1889}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "function": "static int coroutine_fn iscsi_co_flush(BlockDriverState *bs){    IscsiLun *iscsilun = bs->opaque;    struct IscsiTask iTask;    if (bs->sg) {        return 0;    }    if (!iscsilun->force_next_flush) {        return 0;    }    iscsilun->force_next_flush = false;    iscsi_co_init_iscsitask(iscsilun, &iTask);retry:    if (iscsi_synchronizecache10_task(iscsilun->iscsi, iscsilun->lun, 0, 0, 0,                                      0, iscsi_co_generic_cb, &iTask) == NULL) {        return -ENOMEM;    }    while (!iTask.complete) {        iscsi_set_events(iscsilun);        qemu_coroutine_yield();    }    if (iTask.task != NULL) {        scsi_free_scsi_task(iTask.task);        iTask.task = NULL;    }    if (iTask.do_retry) {        iTask.complete = 0;        goto retry;    }    if (iTask.status != SCSI_STATUS_GOOD) {        return -EIO;    }    return 0;}", "idx": 1893}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "function": "static void v9fs_getlock(void *opaque){    size_t offset = 7;    struct stat stbuf;    V9fsFidState *fidp;    V9fsGetlock *glock;    int32_t fid, err = 0;    V9fsPDU *pdu = opaque;    V9fsState *s = pdu->s;    glock = g_malloc(sizeof(*glock));    pdu_unmarshal(pdu, offset, \"dbqqds\", &fid, &glock->type,                  &glock->start, &glock->length, &glock->proc_id,                  &glock->client_id);    trace_v9fs_getlock(pdu->tag, pdu->id, fid,                       glock->type, glock->start, glock->length);    fidp = get_fid(pdu, fid);    if (fidp == NULL) {        err = -ENOENT;        goto out_nofid;    }    err = v9fs_co_fstat(pdu, fidp->fs.fd, &stbuf);    if (err < 0) {        goto out;    }    glock->type = P9_LOCK_TYPE_UNLCK;    offset += pdu_marshal(pdu, offset, \"bqqds\", glock->type,                          glock->start, glock->length, glock->proc_id,                          &glock->client_id);    err = offset;out:    put_fid(pdu, fidp);out_nofid:    complete_pdu(s, pdu, err);    v9fs_string_free(&glock->client_id);    g_free(glock);}", "idx": 2011}
{"project": "qemu", "commit_id": "1fd5d4fea4ba686705fd377c7cffc0f0c9f83f93", "target": 0, "function": "void hmp_info_memory_devices(Monitor *mon, const QDict *qdict){    Error *err = NULL;    MemoryDeviceInfoList *info_list = qmp_query_memory_devices(&err);    MemoryDeviceInfoList *info;    MemoryDeviceInfo *value;    PCDIMMDeviceInfo *di;    for (info = info_list; info; info = info->next) {        value = info->value;        if (value) {            switch (value->kind) {            case MEMORY_DEVICE_INFO_KIND_DIMM:                di = value->dimm;                monitor_printf(mon, \"Memory device [%s]: \\\"%s\\\"\\n\",                               MemoryDeviceInfoKind_lookup[value->kind],                               di->id ? di->id : \"\");                monitor_printf(mon, \"  addr: 0x%\" PRIx64 \"\\n\", di->addr);                monitor_printf(mon, \"  slot: %\" PRId64 \"\\n\", di->slot);                monitor_printf(mon, \"  node: %\" PRId64 \"\\n\", di->node);                monitor_printf(mon, \"  size: %\" PRIu64 \"\\n\", di->size);                monitor_printf(mon, \"  memdev: %s\\n\", di->memdev);                monitor_printf(mon, \"  hotplugged: %s\\n\",                               di->hotplugged ? \"true\" : \"false\");                monitor_printf(mon, \"  hotpluggable: %s\\n\",                               di->hotpluggable ? \"true\" : \"false\");                break;            default:                break;            }        }    }    qapi_free_MemoryDeviceInfoList(info_list);}", "idx": 2057}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "function": "static ssize_t nbd_receive_request(int csock, struct nbd_request *request){    uint8_t buf[4 + 4 + 8 + 8 + 4];    uint32_t magic;    if (read_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {        LOG(\"read failed\");        errno = EINVAL;        return -1;    }    /* Request       [ 0 ..  3]   magic   (NBD_REQUEST_MAGIC)       [ 4 ..  7]   type    (0 == READ, 1 == WRITE)       [ 8 .. 15]   handle       [16 .. 23]   from       [24 .. 27]   len     */    magic = be32_to_cpup((uint32_t*)buf);    request->type  = be32_to_cpup((uint32_t*)(buf + 4));    request->handle = be64_to_cpup((uint64_t*)(buf + 8));    request->from  = be64_to_cpup((uint64_t*)(buf + 16));    request->len   = be32_to_cpup((uint32_t*)(buf + 24));    TRACE(\"Got request: \"          \"{ magic = 0x%x, .type = %d, from = %\" PRIu64\" , len = %u }\",          magic, request->type, request->from, request->len);    if (magic != NBD_REQUEST_MAGIC) {        LOG(\"invalid magic (got 0x%x)\", magic);        errno = EINVAL;        return -1;    }    return 0;}", "idx": 2079}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,                           uint64_t value, unsigned size){    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;    int offset = addr & OMAP_MPUI_REG_MASK;    if (size != 1) {        return omap_badwidth_write8(opaque, addr, value);    }    switch (offset) {    case 0x00:\t/* FRC */        s->frc = value & 0x3f;        break;    case 0x04:\t/* VRC */        if ((value ^ s->vrc) & 1) {            if (value & 1)                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */                                ((omap_clk_getrate(s->clk) >> 3) /                                 /* Pre-multiplexer divider */                                 ((s->gcr & 2) ? 1 : 154) /                                 /* Octave multiplexer */                                 (2 << (value & 3)) *                                 /* 101/107 divider */                                 ((value & (1 << 2)) ? 101 : 107) *                                 /*  49/55 divider */                                 ((value & (1 << 3)) ?  49 : 55) *                                 /*  50/63 divider */                                 ((value & (1 << 4)) ?  50 : 63) *                                 /*  80/127 divider */                                 ((value & (1 << 5)) ?  80 : 127) /                                 (107 * 55 * 63 * 127)));            else                printf(\"%s: silence!\\n\", __FUNCTION__);        }        s->vrc = value & 0x7f;        break;    case 0x08:\t/* GCR */        s->gcr = value & 3;        break;    default:        OMAP_BAD_REG(addr);        return;    }}", "idx": 2084}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "function": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict){    BlockJobInfoList *list;    Error *err = NULL;    list = qmp_query_block_jobs(&err);    assert(!err);    if (!list) {        monitor_printf(mon, \"No active jobs\\n\");        return;    }    while (list) {        if (strcmp(list->value->type, \"stream\") == 0) {            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64                           \" bytes/s\\n\",                           list->value->device,                           list->value->offset,                           list->value->len,                           list->value->speed);        } else {            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64                           \" bytes/s\\n\",                           list->value->type,                           list->value->device,                           list->value->offset,                           list->value->len,                           list->value->speed);        }        list = list->next;    }}", "idx": 2148}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "function": "static inline void qemu_assert(int cond, const char *msg){    if (!cond) {        fprintf (stderr, \"badness: %s\\n\", msg);        abort();    }}", "idx": 2239}
{"project": "qemu", "commit_id": "5df5416e639cd75bd85d243af41387c2418fa580", "target": 0, "function": "static void *source_return_path_thread(void *opaque){    MigrationState *ms = opaque;    QEMUFile *rp = ms->rp_state.from_dst_file;    uint16_t header_len, header_type;    const int max_len = 512;    uint8_t buf[max_len];    uint32_t tmp32, sibling_error;    ram_addr_t start = 0; /* =0 to silence warning */    size_t  len = 0, expected_len;    int res;    trace_source_return_path_thread_entry();    while (!ms->rp_state.error && !qemu_file_get_error(rp) &&           migration_is_setup_or_active(ms->state)) {        trace_source_return_path_thread_loop_top();        header_type = qemu_get_be16(rp);        header_len = qemu_get_be16(rp);        if (header_type >= MIG_RP_MSG_MAX ||            header_type == MIG_RP_MSG_INVALID) {            error_report(\"RP: Received invalid message 0x%04x length 0x%04x\",                    header_type, header_len);            mark_source_rp_bad(ms);            goto out;        }        if ((rp_cmd_args[header_type].len != -1 &&            header_len != rp_cmd_args[header_type].len) ||            header_len > max_len) {            error_report(\"RP: Received '%s' message (0x%04x) with\"                    \"incorrect length %d expecting %zu\",                    rp_cmd_args[header_type].name, header_type, header_len,                    (size_t)rp_cmd_args[header_type].len);            mark_source_rp_bad(ms);            goto out;        }        /* We know we've got a valid header by this point */        res = qemu_get_buffer(rp, buf, header_len);        if (res != header_len) {            error_report(\"RP: Failed reading data for message 0x%04x\"                         \" read %d expected %d\",                         header_type, res, header_len);            mark_source_rp_bad(ms);            goto out;        }        /* OK, we have the message and the data */        switch (header_type) {        case MIG_RP_MSG_SHUT:            sibling_error = be32_to_cpup((uint32_t *)buf);            trace_source_return_path_thread_shut(sibling_error);            if (sibling_error) {                error_report(\"RP: Sibling indicated error %d\", sibling_error);                mark_source_rp_bad(ms);            }            /*             * We'll let the main thread deal with closing the RP             * we could do a shutdown(2) on it, but we're the only user             * anyway, so there's nothing gained.             */            goto out;        case MIG_RP_MSG_PONG:            tmp32 = be32_to_cpup((uint32_t *)buf);            trace_source_return_path_thread_pong(tmp32);            break;        case MIG_RP_MSG_REQ_PAGES:            start = be64_to_cpup((uint64_t *)buf);            len = be32_to_cpup((uint32_t *)(buf + 8));            migrate_handle_rp_req_pages(ms, NULL, start, len);            break;        case MIG_RP_MSG_REQ_PAGES_ID:            expected_len = 12 + 1; /* header + termination */            if (header_len >= expected_len) {                start = be64_to_cpup((uint64_t *)buf);                len = be32_to_cpup((uint32_t *)(buf + 8));                /* Now we expect an idstr */                tmp32 = buf[12]; /* Length of the following idstr */                buf[13 + tmp32] = '\\0';                expected_len += tmp32;            }            if (header_len != expected_len) {                error_report(\"RP: Req_Page_id with length %d expecting %zd\",                        header_len, expected_len);                mark_source_rp_bad(ms);                goto out;            }            migrate_handle_rp_req_pages(ms, (char *)&buf[13], start, len);            break;        default:            break;        }    }    if (rp && qemu_file_get_error(rp)) {        trace_source_return_path_thread_bad_end();        mark_source_rp_bad(ms);    }    trace_source_return_path_thread_end();out:    ms->rp_state.from_dst_file = NULL;    qemu_fclose(rp);    return NULL;}", "idx": 2269}
{"project": "qemu", "commit_id": "2ff64038a59e8de2baa485806be0838f49f70b79", "target": 0, "function": "static void migration_end(void){    if (migration_bitmap) {        memory_global_dirty_log_stop();        g_free(migration_bitmap);        migration_bitmap = NULL;    }    XBZRLE_cache_lock();    if (XBZRLE.cache) {        cache_fini(XBZRLE.cache);        g_free(XBZRLE.encoded_buf);        g_free(XBZRLE.current_buf);        XBZRLE.cache = NULL;        XBZRLE.encoded_buf = NULL;        XBZRLE.current_buf = NULL;    }    XBZRLE_cache_unlock();}", "idx": 2284}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "function": "static void rv34_idct_dc_add_c(uint8_t *dst, int stride, int dc){    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    int i, j;    cm += (13*13*dc + 0x200) >> 10;    for (i = 0; i < 4; i++)    {        for (j = 0; j < 4; j++)            dst[j] = cm[ dst[j] ];        dst += stride;    }}", "idx": 2357}
{"project": "FFmpeg", "commit_id": "7e2b15c094bb41ede9ce2a208982a20e4dfa26a6", "target": 0, "function": "int avfilter_link(AVFilterContext *src, unsigned srcpad,                  AVFilterContext *dst, unsigned dstpad){    AVFilterLink *link;    if (src->nb_outputs <= srcpad || dst->nb_inputs <= dstpad ||        src->outputs[srcpad]      || dst->inputs[dstpad])        return -1;    if (src->output_pads[srcpad].type != dst->input_pads[dstpad].type) {        av_log(src, AV_LOG_ERROR,               \"Media type mismatch between the '%s' filter output pad %d and the '%s' filter input pad %d\\n\",               src->name, srcpad, dst->name, dstpad);        return AVERROR(EINVAL);    }    src->outputs[srcpad] =    dst-> inputs[dstpad] = link = av_mallocz(sizeof(AVFilterLink));    link->src     = src;    link->dst     = dst;    link->srcpad  = &src->output_pads[srcpad];    link->dstpad  = &dst->input_pads[dstpad];    link->type    = src->output_pads[srcpad].type;    assert(AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1);    link->format  = -1;    return 0;}", "idx": 2390}
{"project": "FFmpeg", "commit_id": "24ae353dfbe61019a86093a9c5cd15476aabef49", "target": 1, "function": "static av_cold int xan_decode_init(AVCodecContext *avctx){    XanContext *s = avctx->priv_data;    s->avctx = avctx;    s->frame_size = 0;    if ((avctx->codec->id == CODEC_ID_XAN_WC3) &&        (s->avctx->palctrl == NULL)) {        av_log(avctx, AV_LOG_ERROR, \"palette expected\\n\");        return AVERROR(EINVAL);    }    avctx->pix_fmt = PIX_FMT_PAL8;    s->buffer1_size = avctx->width * avctx->height;    s->buffer1 = av_malloc(s->buffer1_size);    if (!s->buffer1)        return AVERROR(ENOMEM);    s->buffer2_size = avctx->width * avctx->height;    s->buffer2 = av_malloc(s->buffer2_size + 130);    if (!s->buffer2) {        av_freep(&s->buffer1);        return AVERROR(ENOMEM);    }    return 0;}", "idx": 2405}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "function": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,                                ptrdiff_t stride){    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,                                         src - (stride * 2) +                                         sizeof(uint8_t), stride, dst, stride);}", "idx": 2429}
{"project": "qemu", "commit_id": "692d88b4085559f1254d0e04d64a849ce8ab5932", "target": 1, "function": "static void mux_chr_update_read_handler(CharDriverState *chr,                                        GMainContext *context){    MuxDriver *d = chr->opaque;    int idx;    if (d->mux_cnt >= MAX_MUX) {        fprintf(stderr, \"Cannot add I/O handlers, MUX array is full\\n\");        return;    }    if (chr->mux_idx == -1) {        chr->mux_idx = d->mux_cnt++;    }    idx = chr->mux_idx;    d->ext_opaque[idx] = chr->handler_opaque;    d->chr_can_read[idx] = chr->chr_can_read;    d->chr_read[idx] = chr->chr_read;    d->chr_event[idx] = chr->chr_event;    /* Fix up the real driver with mux routines */    if (d->mux_cnt == 1) {        qemu_chr_add_handlers_full(d->drv, mux_chr_can_read,                                   mux_chr_read,                                   mux_chr_event,                                   chr, context);    }    if (d->focus != -1) {        mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_OUT);    }    d->focus = idx;    mux_chr_send_event(d, d->focus, CHR_EVENT_MUX_IN);}", "idx": 2682}
{"project": "qemu", "commit_id": "cb69166bb8defaaa4b3e0a4e31de693737634a54", "target": 1, "function": "static void test_keyval_visit_any(void){    Visitor *v;    QDict *qdict;    QObject *any;    QList *qlist;    QString *qstr;    qdict = keyval_parse(\"a.0=null,a.1=1\", NULL, &error_abort);    v = qobject_input_visitor_new_keyval(QOBJECT(qdict));    QDECREF(qdict);    visit_start_struct(v, NULL, NULL, 0, &error_abort);    visit_type_any(v, \"a\", &any, &error_abort);    qlist = qobject_to_qlist(any);    g_assert(qlist);    qstr = qobject_to_qstring(qlist_pop(qlist));    g_assert_cmpstr(qstring_get_str(qstr), ==, \"null\");    qstr = qobject_to_qstring(qlist_pop(qlist));    g_assert_cmpstr(qstring_get_str(qstr), ==, \"1\");    g_assert(qlist_empty(qlist));    visit_check_struct(v, &error_abort);    visit_end_struct(v, NULL);    visit_free(v);}", "idx": 2706}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "function": "void pc_cmos_init(ram_addr_t ram_size, ram_addr_t above_4g_mem_size,                  const char *boot_device,                  BusState *idebus0, BusState *idebus1,                  FDCtrl *floppy_controller, ISADevice *s){    int val, nb;    FDriveType fd0, fd1;    static pc_cmos_init_late_arg arg;    /* various important CMOS locations needed by PC/Bochs bios */    /* memory size */    val = 640; /* base memory in K */    rtc_set_memory(s, 0x15, val);    rtc_set_memory(s, 0x16, val >> 8);    val = (ram_size / 1024) - 1024;    if (val > 65535)        val = 65535;    rtc_set_memory(s, 0x17, val);    rtc_set_memory(s, 0x18, val >> 8);    rtc_set_memory(s, 0x30, val);    rtc_set_memory(s, 0x31, val >> 8);    if (above_4g_mem_size) {        rtc_set_memory(s, 0x5b, (unsigned int)above_4g_mem_size >> 16);        rtc_set_memory(s, 0x5c, (unsigned int)above_4g_mem_size >> 24);        rtc_set_memory(s, 0x5d, (uint64_t)above_4g_mem_size >> 32);    }    if (ram_size > (16 * 1024 * 1024))        val = (ram_size / 65536) - ((16 * 1024 * 1024) / 65536);    else        val = 0;    if (val > 65535)        val = 65535;    rtc_set_memory(s, 0x34, val);    rtc_set_memory(s, 0x35, val >> 8);    /* set the number of CPU */    rtc_set_memory(s, 0x5f, smp_cpus - 1);    /* set boot devices, and disable floppy signature check if requested */    if (set_boot_dev(s, boot_device, fd_bootchk)) {        exit(1);    }    /* floppy type */    fd0 = fdctrl_get_drive_type(floppy_controller, 0);    fd1 = fdctrl_get_drive_type(floppy_controller, 1);    val = (cmos_get_fd_drive_type(fd0) << 4) | cmos_get_fd_drive_type(fd1);    rtc_set_memory(s, 0x10, val);    val = 0;    nb = 0;    if (fd0 < FDRIVE_DRV_NONE) {        nb++;    }    if (fd1 < FDRIVE_DRV_NONE) {        nb++;    }    switch (nb) {    case 0:        break;    case 1:        val |= 0x01; /* 1 drive, ready for boot */        break;    case 2:        val |= 0x41; /* 2 drives, ready for boot */        break;    }    val |= 0x02; /* FPU is there */    val |= 0x04; /* PS/2 mouse installed */    rtc_set_memory(s, REG_EQUIPMENT_BYTE, val);    /* hard drives */    arg.rtc_state = s;    arg.idebus0 = idebus0;    arg.idebus1 = idebus1;    qemu_register_reset(pc_cmos_init_late, &arg);}", "idx": 2720}
{"project": "qemu", "commit_id": "d41f3e750d2c06c613cb1b8db7724f0fbc0a2b14", "target": 0, "function": "void numa_cpu_pre_plug(const CPUArchId *slot, DeviceState *dev, Error **errp){    int mapped_node_id; /* set by -numa option */    int node_id = object_property_get_int(OBJECT(dev), \"node-id\", &error_abort);    /* by default CPUState::numa_node was 0 if it wasn't set explicitly     * TODO: make it error when incomplete numa mapping support is removed     */    mapped_node_id = slot->props.node_id;    if (!slot->props.has_node_id) {        mapped_node_id = 0;    }    if (node_id == CPU_UNSET_NUMA_NODE_ID) {        /* due to bug in libvirt, it doesn't pass node-id from props on         * device_add as expected, so we have to fix it up here */        object_property_set_int(OBJECT(dev), mapped_node_id, \"node-id\", errp);    } else if (node_id != mapped_node_id) {        error_setg(errp, \"node-id=%d must match numa node specified \"                   \"with -numa option\", node_id);    }}", "idx": 2733}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "function": "PPC_OP(mulhw){    T0 = ((int64_t)Ts0 * (int64_t)Ts1) >> 32;    RETURN();}", "idx": 2771}
{"project": "FFmpeg", "commit_id": "77742c75c5503c848447814a96f16abc6b9aa5f4", "target": 0, "function": "static int dxva2_vp9_start_frame(AVCodecContext *avctx,                                 av_unused const uint8_t *buffer,                                 av_unused uint32_t size){    const VP9SharedContext *h = avctx->priv_data;    AVDXVAContext *ctx = avctx->hwaccel_context;    struct vp9_dxva2_picture_context *ctx_pic = h->frames[CUR_FRAME].hwaccel_picture_private;    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)        return -1;    av_assert0(ctx_pic);    /* Fill up DXVA_PicParams_VP9 */    if (fill_picture_parameters(avctx, ctx, h, &ctx_pic->pp) < 0)        return -1;    ctx_pic->bitstream_size = 0;    ctx_pic->bitstream      = NULL;    return 0;}", "idx": 2860}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "function": "char *object_property_print(Object *obj, const char *name, bool human,                            Error **errp){    StringOutputVisitor *sov;    char *string = NULL;    Error *local_err = NULL;    sov = string_output_visitor_new(human);    object_property_get(obj, string_output_get_visitor(sov), name, &local_err);    if (local_err) {        error_propagate(errp, local_err);        goto out;    }    string = string_output_get_string(sov);out:    visit_free(string_output_get_visitor(sov));    return string;}", "idx": 2870}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "function": "static void do_commit(int argc, const char **argv){    int i;    for (i = 0; i < MAX_DISKS; i++) {        if (bs_table[i])            bdrv_commit(bs_table[i]);    }}", "idx": 2879}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "function": "void qemu_free(void *ptr){    free(ptr);}", "idx": 2897}
{"project": "qemu", "commit_id": "f9148c8ae7b1515776699387b4d59864f302c77d", "target": 0, "function": "void vnc_display_open(const char *id, Error **errp){    VncDisplay *vs = vnc_display_find(id);    QemuOpts *opts = qemu_opts_find(&qemu_vnc_opts, id);    QemuOpts *sopts, *wsopts;    const char *share, *device_id;    QemuConsole *con;    bool password = false;    bool reverse = false;    const char *vnc;    const char *has_to;    char *h;    bool has_ipv4 = false;    bool has_ipv6 = false;    const char *websocket;    bool tls = false, x509 = false;#ifdef CONFIG_VNC_TLS    const char *path;#endif    bool sasl = false;#ifdef CONFIG_VNC_SASL    int saslErr;#endif#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)    int acl = 0;#endif    int lock_key_sync = 1;    if (!vs) {        error_setg(errp, \"VNC display not active\");        return;    }    vnc_display_close(vs);    if (!opts) {        return;    }    vnc = qemu_opt_get(opts, \"vnc\");    if (!vnc || strcmp(vnc, \"none\") == 0) {        return;    }    sopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);    wsopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);    h = strrchr(vnc, ':');    if (h) {        char *host = g_strndup(vnc, h - vnc);        qemu_opt_set(sopts, \"host\", host, &error_abort);        qemu_opt_set(wsopts, \"host\", host, &error_abort);        qemu_opt_set(sopts, \"port\", h+1, &error_abort);        g_free(host);    } else {        error_setg(errp, \"no vnc port specified\");        goto fail;    }    has_to = qemu_opt_get(opts, \"to\");    has_ipv4 = qemu_opt_get_bool(opts, \"ipv4\", false);    has_ipv6 = qemu_opt_get_bool(opts, \"ipv6\", false);    if (has_to) {        qemu_opt_set(sopts, \"to\", has_to, &error_abort);        qemu_opt_set(wsopts, \"to\", has_to, &error_abort);    }    if (has_ipv4) {        qemu_opt_set(sopts, \"ipv4\", \"on\", &error_abort);        qemu_opt_set(wsopts, \"ipv4\", \"on\", &error_abort);    }    if (has_ipv6) {        qemu_opt_set(sopts, \"ipv6\", \"on\", &error_abort);        qemu_opt_set(wsopts, \"ipv6\", \"on\", &error_abort);    }    password = qemu_opt_get_bool(opts, \"password\", false);    if (password && fips_get_state()) {        error_setg(errp,                   \"VNC password auth disabled due to FIPS mode, \"                   \"consider using the VeNCrypt or SASL authentication \"                   \"methods as an alternative\");        goto fail;    }    reverse = qemu_opt_get_bool(opts, \"reverse\", false);    lock_key_sync = qemu_opt_get_bool(opts, \"lock-key-sync\", true);    sasl = qemu_opt_get_bool(opts, \"sasl\", false);#ifndef CONFIG_VNC_SASL    if (sasl) {        error_setg(errp, \"VNC SASL auth requires cyrus-sasl support\");        goto fail;    }#endif /* CONFIG_VNC_SASL */    tls  = qemu_opt_get_bool(opts, \"tls\", false);#ifdef CONFIG_VNC_TLS    path = qemu_opt_get(opts, \"x509\");    if (!path) {        path = qemu_opt_get(opts, \"x509verify\");        if (path) {            vs->tls.x509verify = true;        }    }    if (path) {        x509 = true;        if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {            error_setg(errp, \"Failed to find x509 certificates/keys in %s\",                       path);            goto fail;        }    }#else /* ! CONFIG_VNC_TLS */    if (tls) {        error_setg(errp, \"VNC TLS auth requires gnutls support\");        goto fail;    }#endif /* ! CONFIG_VNC_TLS */#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)    acl = qemu_opt_get_bool(opts, \"acl\", false);#endif    share = qemu_opt_get(opts, \"share\");    if (share) {        if (strcmp(share, \"ignore\") == 0) {            vs->share_policy = VNC_SHARE_POLICY_IGNORE;        } else if (strcmp(share, \"allow-exclusive\") == 0) {            vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;        } else if (strcmp(share, \"force-shared\") == 0) {            vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;        } else {            error_setg(errp, \"unknown vnc share= option\");            goto fail;        }    } else {        vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;    }    vs->connections_limit = qemu_opt_get_number(opts, \"connections\", 32);    websocket = qemu_opt_get(opts, \"websocket\");    if (websocket) {#ifdef CONFIG_VNC_WS        vs->ws_enabled = true;        qemu_opt_set(wsopts, \"port\", websocket, &error_abort);#else /* ! CONFIG_VNC_WS */        error_setg(errp, \"Websockets protocol requires gnutls support\");        goto fail;#endif /* ! CONFIG_VNC_WS */    }#ifdef CONFIG_VNC_JPEG    vs->lossy = qemu_opt_get_bool(opts, \"lossy\", false);#endif    vs->non_adaptive = qemu_opt_get_bool(opts, \"non-adaptive\", false);    /* adaptive updates are only used with tight encoding and     * if lossy updates are enabled so we can disable all the     * calculations otherwise */    if (!vs->lossy) {        vs->non_adaptive = true;    }#ifdef CONFIG_VNC_TLS    if (acl && x509 && vs->tls.x509verify) {        char *aclname;        if (strcmp(vs->id, \"default\") == 0) {            aclname = g_strdup(\"vnc.x509dname\");        } else {            aclname = g_strdup_printf(\"vnc.%s.x509dname\", vs->id);        }        vs->tls.acl = qemu_acl_init(aclname);        if (!vs->tls.acl) {            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");            exit(1);        }        g_free(aclname);    }#endif#ifdef CONFIG_VNC_SASL    if (acl && sasl) {        char *aclname;        if (strcmp(vs->id, \"default\") == 0) {            aclname = g_strdup(\"vnc.username\");        } else {            aclname = g_strdup_printf(\"vnc.%s.username\", vs->id);        }        vs->sasl.acl = qemu_acl_init(aclname);        if (!vs->sasl.acl) {            fprintf(stderr, \"Failed to create username ACL\\n\");            exit(1);        }        g_free(aclname);    }#endif    vnc_display_setup_auth(vs, password, sasl, tls, x509);#ifdef CONFIG_VNC_SASL    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {        error_setg(errp, \"Failed to initialize SASL auth: %s\",                   sasl_errstring(saslErr, NULL, NULL));        goto fail;    }#endif    vs->lock_key_sync = lock_key_sync;    device_id = qemu_opt_get(opts, \"display\");    if (device_id) {        DeviceState *dev;        int head = qemu_opt_get_number(opts, \"head\", 0);        dev = qdev_find_recursive(sysbus_get_default(), device_id);        if (dev == NULL) {            error_setg(errp, \"Device '%s' not found\", device_id);            goto fail;        }        con = qemu_console_lookup_by_device(dev, head);        if (con == NULL) {            error_setg(errp, \"Device %s is not bound to a QemuConsole\",                       device_id);            goto fail;        }    } else {        con = NULL;    }    if (con != vs->dcl.con) {        unregister_displaychangelistener(&vs->dcl);        vs->dcl.con = con;        register_displaychangelistener(&vs->dcl);    }    if (reverse) {        /* connect to viewer */        int csock;        vs->lsock = -1;#ifdef CONFIG_VNC_WS        vs->lwebsock = -1;#endif        if (strncmp(vnc, \"unix:\", 5) == 0) {            csock = unix_connect(vnc+5, errp);        } else {            csock = inet_connect(vnc, errp);        }        if (csock < 0) {            goto fail;        }        vnc_connect(vs, csock, false, false);    } else {        /* listen for connects */        if (strncmp(vnc, \"unix:\", 5) == 0) {            vs->lsock = unix_listen(vnc+5, NULL, 0, errp);            vs->is_unix = true;        } else {            vs->lsock = inet_listen_opts(sopts, 5900, errp);            if (vs->lsock < 0) {                goto fail;            }#ifdef CONFIG_VNC_WS            if (vs->ws_enabled) {                vs->lwebsock = inet_listen_opts(wsopts, 0, errp);                if (vs->lwebsock < 0) {                    if (vs->lsock != -1) {                        close(vs->lsock);                        vs->lsock = -1;                    }                    goto fail;                }            }#endif /* CONFIG_VNC_WS */        }        vs->enabled = true;        qemu_set_fd_handler2(vs->lsock, NULL,                vnc_listen_regular_read, NULL, vs);#ifdef CONFIG_VNC_WS        if (vs->ws_enabled) {            qemu_set_fd_handler2(vs->lwebsock, NULL,                    vnc_listen_websocket_read, NULL, vs);        }#endif /* CONFIG_VNC_WS */    }    qemu_opts_del(sopts);    qemu_opts_del(wsopts);    return;fail:    qemu_opts_del(sopts);    qemu_opts_del(wsopts);    vs->enabled = false;#ifdef CONFIG_VNC_WS    vs->ws_enabled = false;#endif /* CONFIG_VNC_WS */}", "idx": 3050}
{"project": "qemu", "commit_id": "4bc7b4d56657ebf75b986ad46e959cf7232ff26a", "target": 1, "function": "static void i6300esb_restart_timer(I6300State *d, int stage){    int64_t timeout;    if (!d->enabled)        return;    d->stage = stage;    if (d->stage <= 1)        timeout = d->timer1_preload;    else        timeout = d->timer2_preload;    if (d->clock_scale == CLOCK_SCALE_1KHZ)        timeout <<= 15;    else        timeout <<= 5;    /* Get the timeout in units of ticks_per_sec. */    timeout = get_ticks_per_sec() * timeout / 33000000;    i6300esb_debug(\"stage %d, timeout %\" PRIi64 \"\\n\", d->stage, timeout);    timer_mod(d->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + timeout);}", "idx": 3088}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "function": "static uint64_t openpic_msi_read(void *opaque, hwaddr addr, unsigned size){    OpenPICState *opp = opaque;    uint64_t r = 0;    int i, srs;    DPRINTF(\"%s: addr \" TARGET_FMT_plx \"\\n\", __func__, addr);    if (addr & 0xF) {        return -1;    }    srs = addr >> 4;    switch (addr) {    case 0x00:    case 0x10:    case 0x20:    case 0x30:    case 0x40:    case 0x50:    case 0x60:    case 0x70: /* MSIRs */        r = opp->msi[srs].msir;        /* Clear on read */        opp->msi[srs].msir = 0;        break;    case 0x120: /* MSISR */        for (i = 0; i < MAX_MSI; i++) {            r |= (opp->msi[i].msir ? 1 : 0) << i;        }        break;    }    return r;}", "idx": 3121}
{"project": "FFmpeg", "commit_id": "171c407621b7ff52a0cf128b31651ca927c2dd49", "target": 1, "function": "static int decode_frame(AVCodecContext *avctx,                             void *data, int *data_size,                             uint8_t *buf, int buf_size){    H264Context *h = avctx->priv_data;    MpegEncContext *s = &h->s;    AVFrame *pict = data;    int buf_index;    s->flags= avctx->flags;    s->flags2= avctx->flags2;   /* no supplementary picture */    if (buf_size == 0) {        return 0;    }    if(s->flags&CODEC_FLAG_TRUNCATED){        int next= find_frame_end(h, buf, buf_size);        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )            return buf_size;//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);    }    if(h->is_avc && !h->got_avcC) {        int i, cnt, nalsize;        unsigned char *p = avctx->extradata;        if(avctx->extradata_size < 7) {            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");            return -1;        }        if(*p != 1) {            av_log(avctx, AV_LOG_ERROR, \"Unknown avcC version %d\\n\", *p);            return -1;        }        /* sps and pps in the avcC always have length coded with 2 bytes,           so put a fake nal_length_size = 2 while parsing them */        h->nal_length_size = 2;        // Decode sps from avcC        cnt = *(p+5) & 0x1f; // Number of sps        p += 6;        for (i = 0; i < cnt; i++) {            nalsize = BE_16(p) + 2;            if(decode_nal_units(h, p, nalsize) < 0) {                av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);                return -1;            }            p += nalsize;        }        // Decode pps from avcC        cnt = *(p++); // Number of pps        for (i = 0; i < cnt; i++) {            nalsize = BE_16(p) + 2;            if(decode_nal_units(h, p, nalsize)  != nalsize) {                av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);                return -1;            }            p += nalsize;        }        // Now store right nal length size, that will be use to parse all other nals        h->nal_length_size = ((*(((char*)(avctx->extradata))+4))&0x03)+1;        // Do not reparse avcC        h->got_avcC = 1;    }    if(!h->is_avc && s->avctx->extradata_size && s->picture_number==0){        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0)            return -1;    }    buf_index=decode_nal_units(h, buf, buf_size);    if(buf_index < 0)        return -1;    //FIXME do something with unavailable reference frames//    if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_index, buf_size);    if(!s->current_picture_ptr){        av_log(h->s.avctx, AV_LOG_DEBUG, \"error, NO frame\\n\");        return -1;    }    {        Picture *out = s->current_picture_ptr;#if 0 //decode order        *data_size = sizeof(AVFrame);#else        /* Sort B-frames into display order */        Picture *cur = s->current_picture_ptr;        Picture *prev = h->delayed_output_pic;        int out_idx = 0;        int pics = 0;        int out_of_order;        int cross_idr = 0;        int dropped_frame = 0;        int i;        if(h->sps.bitstream_restriction_flag           && s->avctx->has_b_frames < h->sps.num_reorder_frames){            s->avctx->has_b_frames = h->sps.num_reorder_frames;            s->low_delay = 0;        }        while(h->delayed_pic[pics]) pics++;        h->delayed_pic[pics++] = cur;        if(cur->reference == 0)            cur->reference = 1;        for(i=0; h->delayed_pic[i]; i++)            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)                cross_idr = 1;        out = h->delayed_pic[0];        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)            if(h->delayed_pic[i]->poc < out->poc){                out = h->delayed_pic[i];                out_idx = i;            }        out_of_order = !cross_idr && prev && out->poc < prev->poc;        if(prev && pics <= s->avctx->has_b_frames)            out = prev;        else if((out_of_order && pics-1 == s->avctx->has_b_frames && pics < 15)           || (s->low_delay &&            ((!cross_idr && prev && out->poc > prev->poc + 2)             || cur->pict_type == B_TYPE)))        {            s->low_delay = 0;            s->avctx->has_b_frames++;            out = prev;        }        else if(out_of_order)            out = prev;        if(out_of_order || pics > s->avctx->has_b_frames){            dropped_frame = (out != h->delayed_pic[out_idx]);            for(i=out_idx; h->delayed_pic[i]; i++)                h->delayed_pic[i] = h->delayed_pic[i+1];        }        if(prev == out && !dropped_frame)            *data_size = 0;        else            *data_size = sizeof(AVFrame);        if(prev && prev != out && prev->reference == 1)            prev->reference = 0;        h->delayed_output_pic = out;#endif        if(out)            *pict= *(AVFrame*)out;        else            av_log(avctx, AV_LOG_DEBUG, \"no picture\\n\");    }    assert(pict->data[0] || !*data_size);    ff_print_debug_info(s, pict);//printf(\"out %d\\n\", (int)pict->data[0]);#if 0 //?    /* Return the Picture timestamp as the frame number */    /* we substract 1 because it is added on utils.c    */    avctx->frame_number = s->picture_number - 1;#endif    return get_consumed_bytes(s, buf_index, buf_size);}", "idx": 3146}
{"project": "qemu", "commit_id": "6e05a12f8f7f32a3fecbeb0c572d549a5f6e9177", "target": 1, "function": "static void digic_load_rom(DigicBoardState *s, hwaddr addr,                           hwaddr max_size, const char *def_filename){    target_long rom_size;    const char *filename;    if (qtest_enabled()) {        /* qtest runs no code so don't attempt a ROM load which         * could fail and result in a spurious test failure.         */        return;    }    if (bios_name) {        filename = bios_name;    } else {        filename = def_filename;    }    if (filename) {        char *fn = qemu_find_file(QEMU_FILE_TYPE_BIOS, filename);        if (!fn) {            error_report(\"Couldn't find rom image '%s'.\", filename);            exit(1);        }        rom_size = load_image_targphys(fn, addr, max_size);        if (rom_size < 0 || rom_size > max_size) {            error_report(\"Couldn't load rom image '%s'.\", filename);            exit(1);        }    }}", "idx": 3148}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "function": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den){    *q_ptr = num / den;    return num % den;}", "idx": 3162}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "function": "uint64_t helper_mulqv (uint64_t op1, uint64_t op2){    uint64_t tl, th;    muls64(&tl, &th, op1, op2);    /* If th != 0 && th != -1, then we had an overflow */    if (unlikely((th + 1) > 1)) {        arith_excp(env, GETPC(), EXC_M_IOV, 0);    }    return tl;}", "idx": 3168}
{"project": "qemu", "commit_id": "661e32fb3cb71c7e019daee375be4bb487b9917c", "target": 1, "function": "void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,                            uint32_t event, uint32_t reason){    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);    VirtIOSCSIReq *req;    VirtIOSCSIEvent *evt;    VirtIODevice *vdev = VIRTIO_DEVICE(s);    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {        return;    }    if (s->dataplane_started) {        assert(s->ctx);        aio_context_acquire(s->ctx);    }    req = virtio_scsi_pop_req(s, vs->event_vq);    if (!req) {        s->events_dropped = true;        goto out;    }    if (s->events_dropped) {        event |= VIRTIO_SCSI_T_EVENTS_MISSED;        s->events_dropped = false;    }    if (virtio_scsi_parse_req(req, 0, sizeof(VirtIOSCSIEvent))) {        virtio_scsi_bad_req();    }    evt = &req->resp.event;    memset(evt, 0, sizeof(VirtIOSCSIEvent));    evt->event = virtio_tswap32(vdev, event);    evt->reason = virtio_tswap32(vdev, reason);    if (!dev) {        assert(event == VIRTIO_SCSI_T_EVENTS_MISSED);    } else {        evt->lun[0] = 1;        evt->lun[1] = dev->id;        /* Linux wants us to keep the same encoding we use for REPORT LUNS.  */        if (dev->lun >= 256) {            evt->lun[2] = (dev->lun >> 8) | 0x40;        }        evt->lun[3] = dev->lun & 0xFF;    }    virtio_scsi_complete_req(req);out:    if (s->dataplane_started) {        aio_context_release(s->ctx);    }}", "idx": 3226}
{"project": "qemu", "commit_id": "4ed069ab5334a495b49d0704795524fa34e8dbfc", "target": 1, "function": "static uint64_t do_cvttq(CPUAlphaState *env, uint64_t a, int roundmode){    uint64_t frac, ret = 0;    uint32_t exp, sign, exc = 0;    int shift;    sign = (a >> 63);    exp = (uint32_t)(a >> 52) & 0x7ff;    frac = a & 0xfffffffffffffull;    if (exp == 0) {        if (unlikely(frac != 0)) {            goto do_underflow;        }    } else if (exp == 0x7ff) {        exc = FPCR_INV;    } else {        /* Restore implicit bit.  */        frac |= 0x10000000000000ull;        shift = exp - 1023 - 52;        if (shift >= 0) {            /* In this case the number is so large that we must shift               the fraction left.  There is no rounding to do.  */            if (shift < 64) {                ret = frac << shift;            }            /* Check for overflow.  Note the special case of -0x1p63.  */            if (shift >= 11 && a != 0xC3E0000000000000ull) {                exc = FPCR_IOV | FPCR_INE;            }        } else {            uint64_t round;            /* In this case the number is smaller than the fraction as               represented by the 52 bit number.  Here we must think               about rounding the result.  Handle this by shifting the               fractional part of the number into the high bits of ROUND.               This will let us efficiently handle round-to-nearest.  */            shift = -shift;            if (shift < 63) {                ret = frac >> shift;                round = frac << (64 - shift);            } else {                /* The exponent is so small we shift out everything.                   Leave a sticky bit for proper rounding below.  */            do_underflow:                round = 1;            }            if (round) {                exc = FPCR_INE;                switch (roundmode) {                case float_round_nearest_even:                    if (round == (1ull << 63)) {                        /* Fraction is exactly 0.5; round to even.  */                        ret += (ret & 1);                    } else if (round > (1ull << 63)) {                        ret += 1;                    }                    break;                case float_round_to_zero:                    break;                case float_round_up:                    ret += 1 - sign;                    break;                case float_round_down:                    ret += sign;                    break;                }            }        }        if (sign) {            ret = -ret;        }    }    env->error_code = exc;    return ret;}", "idx": 3243}
{"project": "FFmpeg", "commit_id": "c5fd57f483d2ad8e34551b78509f1e14136f73c0", "target": 1, "function": "static int vp8_packet(AVFormatContext *s, int idx){    struct ogg *ogg = s->priv_data;    struct ogg_stream *os = ogg->streams + idx;    uint8_t *p = os->buf + os->pstart;    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) &&        !(os->flags & OGG_FLAG_EOS)) {        int seg;        int duration;        uint8_t *last_pkt = p;        uint8_t *next_pkt;        seg = os->segp;        duration = (last_pkt[0] >> 4) & 1;        next_pkt = last_pkt += os->psize;        for (; seg < os->nsegs; seg++) {            if (os->segments[seg] < 255) {                duration += (last_pkt[0] >> 4) & 1;                last_pkt  = next_pkt + os->segments[seg];            }            next_pkt += os->segments[seg];        }        os->lastpts =        os->lastdts = vp8_gptopts(s, idx, os->granule, NULL) - duration;        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {            s->streams[idx]->start_time = os->lastpts;            if (s->streams[idx]->duration)                s->streams[idx]->duration -= s->streams[idx]->start_time;        }    }    if (os->psize > 0)        os->pduration = (p[0] >> 4) & 1;    return 0;}", "idx": 3247}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "function": "static void dec_barrel(DisasContext *dc){    TCGv t0;    unsigned int s, t;    if ((dc->tb_flags & MSR_EE_FLAG)          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)          && !(dc->env->pvr.regs[0] & PVR0_USE_BARREL_MASK)) {        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);        t_gen_raise_exception(dc, EXCP_HW_EXCP);        return;    }    s = dc->imm & (1 << 10);    t = dc->imm & (1 << 9);    LOG_DIS(\"bs%s%s r%d r%d r%d\\n\",            s ? \"l\" : \"r\", t ? \"a\" : \"l\", dc->rd, dc->ra, dc->rb);    t0 = tcg_temp_new();    tcg_gen_mov_tl(t0, *(dec_alu_op_b(dc)));    tcg_gen_andi_tl(t0, t0, 31);    if (s)        tcg_gen_shl_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);    else {        if (t)            tcg_gen_sar_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);        else            tcg_gen_shr_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);    }}", "idx": 3272}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "function": "void rgb16tobgr24(const uint8_t *src, uint8_t *dst, unsigned int src_size){\tconst uint16_t *end;\tuint8_t *d = (uint8_t *)dst;\tconst uint16_t *s = (const uint16_t *)src;\tend = s + src_size/2;\twhile(s < end)\t{\t\tregister uint16_t bgr;\t\tbgr = *s++;\t\t*d++ = (bgr&0xF800)>>8;\t\t*d++ = (bgr&0x7E0)>>3;\t\t*d++ = (bgr&0x1F)<<3;\t}}", "idx": 3282}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "function": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,                             int s_bits, int tlb_offset){    TCGReg base = TCG_AREG0;    /* Should generate something like the following:     * pre-v7:     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)     *   add    r2, env, #off & 0xff00     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)     *   ldr    r0, [r2, #off & 0xff]!                            (4)     *   tst    addr_reg, #s_mask     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)     *     * v7 (not implemented yet):     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask     *   movw   r0, #off     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)     *   bic    tmp, addr_reg, tmp     *   ldr    r0, [r2, r0]!                                     (3)     *   cmp    r0, tmp                                           (4)     */#  if CPU_TLB_BITS > 8#   error#  endif    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));    /* We assume that the offset is contained within 16 bits.  */    assert((tlb_offset & ~0xffff) == 0);    if (tlb_offset > 0xff) {        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,                        (24 << 7) | (tlb_offset >> 8));        tlb_offset &= 0xff;        base = TCG_REG_R2;    }    tcg_out_dat_imm(s, COND_AL, ARITH_AND,                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));    /* Load the tlb comparator.  Use ldrd if needed and available,       but due to how the pointer needs setting up, ldm isn't useful.       Base arm5 doesn't have ldrd, but armv5te does.  */    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,                        TCG_REG_R2, tlb_offset, 1, 1);    } else {        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,                         TCG_REG_R2, tlb_offset, 1, 1);        if (TARGET_LONG_BITS == 64) {            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,                             TCG_REG_R2, 4, 1, 0);        }    }    /* Check alignment.  */    if (s_bits) {        tcg_out_dat_imm(s, COND_AL, ARITH_TST,                        0, addrlo, (1 << s_bits) - 1);    }    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));    if (TARGET_LONG_BITS == 64) {        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));    }}", "idx": 3288}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "function": "static void set_sensor_type(IPMIBmcSim *ibs,                               uint8_t *cmd, unsigned int cmd_len,                               uint8_t *rsp, unsigned int *rsp_len,                               unsigned int max_rsp_len){    IPMISensor *sens;    IPMI_CHECK_CMD_LEN(5);    if ((cmd[2] > MAX_SENSORS) ||            !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;        return;    }    sens = ibs->sensors + cmd[2];    sens->sensor_type = cmd[3];    sens->evt_reading_type_code = cmd[4] & 0x7f;}", "idx": 3296}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "function": "static int mux_chr_can_read(void *opaque){    CharDriverState *chr = opaque;    MuxDriver *d = chr->opaque;    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)        return 1;    if (d->chr_can_read[chr->focus])        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);    return 0;}", "idx": 3392}
{"project": "FFmpeg", "commit_id": "6f20921deec135a68f78cb327472ea6cf28644a5", "target": 1, "function": "static int applehttp_read_seek(AVFormatContext *s, int stream_index,                               int64_t timestamp, int flags){    AppleHTTPContext *c = s->priv_data;    int i, j, ret;    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->finished)        return AVERROR(ENOSYS);    timestamp = av_rescale_rnd(timestamp, 1, stream_index >= 0 ?                               s->streams[stream_index]->time_base.den :                               AV_TIME_BASE, flags & AVSEEK_FLAG_BACKWARD ?                               AV_ROUND_DOWN : AV_ROUND_UP);    ret = AVERROR(EIO);    for (i = 0; i < c->n_variants; i++) {        /* Reset reading */        struct variant *var = c->variants[i];        int64_t pos = 0;        if (var->input) {            ffurl_close(var->input);            var->input = NULL;        }        av_free_packet(&var->pkt);        reset_packet(&var->pkt);        var->pb.eof_reached = 0;        /* Locate the segment that contains the target timestamp */        for (j = 0; j < var->n_segments; j++) {            if (timestamp >= pos &&                timestamp < pos + var->segments[j]->duration) {                var->cur_seq_no = var->start_seq_no + j;                ret = 0;                break;            }            pos += var->segments[j]->duration;        }    }    return ret;}", "idx": 3412}
{"project": "qemu", "commit_id": "36e60ef6ac5d8a262d0fbeedfdb2b588514cb1ea", "target": 0, "function": "static void tcg_constant_folding(TCGContext *s){    int oi, oi_next, nb_temps, nb_globals;    /* Array VALS has an element for each temp.       If this temp holds a constant then its value is kept in VALS' element.       If this temp is a copy of other ones then the other copies are       available through the doubly linked circular list. */    nb_temps = s->nb_temps;    nb_globals = s->nb_globals;    reset_all_temps(nb_temps);    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {        tcg_target_ulong mask, partmask, affected;        int nb_oargs, nb_iargs, i;        TCGArg tmp;        TCGOp * const op = &s->gen_op_buf[oi];        TCGArg * const args = &s->gen_opparam_buf[op->args];        TCGOpcode opc = op->opc;        const TCGOpDef *def = &tcg_op_defs[opc];        oi_next = op->next;        if (opc == INDEX_op_call) {            nb_oargs = op->callo;            nb_iargs = op->calli;        } else {            nb_oargs = def->nb_oargs;            nb_iargs = def->nb_iargs;        }        /* Do copy propagation */        for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {            if (temps[args[i]].state == TCG_TEMP_COPY) {                args[i] = find_better_copy(s, args[i]);            }        }        /* For commutative operations make constant second argument */        switch (opc) {        CASE_OP_32_64(add):        CASE_OP_32_64(mul):        CASE_OP_32_64(and):        CASE_OP_32_64(or):        CASE_OP_32_64(xor):        CASE_OP_32_64(eqv):        CASE_OP_32_64(nand):        CASE_OP_32_64(nor):        CASE_OP_32_64(muluh):        CASE_OP_32_64(mulsh):            swap_commutative(args[0], &args[1], &args[2]);            break;        CASE_OP_32_64(brcond):            if (swap_commutative(-1, &args[0], &args[1])) {                args[2] = tcg_swap_cond(args[2]);            }            break;        CASE_OP_32_64(setcond):            if (swap_commutative(args[0], &args[1], &args[2])) {                args[3] = tcg_swap_cond(args[3]);            }            break;        CASE_OP_32_64(movcond):            if (swap_commutative(-1, &args[1], &args[2])) {                args[5] = tcg_swap_cond(args[5]);            }            /* For movcond, we canonicalize the \"false\" input reg to match               the destination reg so that the tcg backend can implement               a \"move if true\" operation.  */            if (swap_commutative(args[0], &args[4], &args[3])) {                args[5] = tcg_invert_cond(args[5]);            }            break;        CASE_OP_32_64(add2):            swap_commutative(args[0], &args[2], &args[4]);            swap_commutative(args[1], &args[3], &args[5]);            break;        CASE_OP_32_64(mulu2):        CASE_OP_32_64(muls2):            swap_commutative(args[0], &args[2], &args[3]);            break;        case INDEX_op_brcond2_i32:            if (swap_commutative2(&args[0], &args[2])) {                args[4] = tcg_swap_cond(args[4]);            }            break;        case INDEX_op_setcond2_i32:            if (swap_commutative2(&args[1], &args[3])) {                args[5] = tcg_swap_cond(args[5]);            }            break;        default:            break;        }        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\",           and \"sub r, 0, a => neg r, a\" case.  */        switch (opc) {        CASE_OP_32_64(shl):        CASE_OP_32_64(shr):        CASE_OP_32_64(sar):        CASE_OP_32_64(rotl):        CASE_OP_32_64(rotr):            if (temps[args[1]].state == TCG_TEMP_CONST                && temps[args[1]].val == 0) {                tcg_opt_gen_movi(s, op, args, args[0], 0);                continue;            }            break;        CASE_OP_32_64(sub):            {                TCGOpcode neg_op;                bool have_neg;                if (temps[args[2]].state == TCG_TEMP_CONST) {                    /* Proceed with possible constant folding. */                    break;                }                if (opc == INDEX_op_sub_i32) {                    neg_op = INDEX_op_neg_i32;                    have_neg = TCG_TARGET_HAS_neg_i32;                } else {                    neg_op = INDEX_op_neg_i64;                    have_neg = TCG_TARGET_HAS_neg_i64;                }                if (!have_neg) {                    break;                }                if (temps[args[1]].state == TCG_TEMP_CONST                    && temps[args[1]].val == 0) {                    op->opc = neg_op;                    reset_temp(args[0]);                    args[1] = args[2];                    continue;                }            }            break;        CASE_OP_32_64(xor):        CASE_OP_32_64(nand):            if (temps[args[1]].state != TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST                && temps[args[2]].val == -1) {                i = 1;                goto try_not;            }            break;        CASE_OP_32_64(nor):            if (temps[args[1]].state != TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST                && temps[args[2]].val == 0) {                i = 1;                goto try_not;            }            break;        CASE_OP_32_64(andc):            if (temps[args[2]].state != TCG_TEMP_CONST                && temps[args[1]].state == TCG_TEMP_CONST                && temps[args[1]].val == -1) {                i = 2;                goto try_not;            }            break;        CASE_OP_32_64(orc):        CASE_OP_32_64(eqv):            if (temps[args[2]].state != TCG_TEMP_CONST                && temps[args[1]].state == TCG_TEMP_CONST                && temps[args[1]].val == 0) {                i = 2;                goto try_not;            }            break;        try_not:            {                TCGOpcode not_op;                bool have_not;                if (def->flags & TCG_OPF_64BIT) {                    not_op = INDEX_op_not_i64;                    have_not = TCG_TARGET_HAS_not_i64;                } else {                    not_op = INDEX_op_not_i32;                    have_not = TCG_TARGET_HAS_not_i32;                }                if (!have_not) {                    break;                }                op->opc = not_op;                reset_temp(args[0]);                args[1] = args[i];                continue;            }        default:            break;        }        /* Simplify expression for \"op r, a, const => mov r, a\" cases */        switch (opc) {        CASE_OP_32_64(add):        CASE_OP_32_64(sub):        CASE_OP_32_64(shl):        CASE_OP_32_64(shr):        CASE_OP_32_64(sar):        CASE_OP_32_64(rotl):        CASE_OP_32_64(rotr):        CASE_OP_32_64(or):        CASE_OP_32_64(xor):        CASE_OP_32_64(andc):            if (temps[args[1]].state != TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST                && temps[args[2]].val == 0) {                tcg_opt_gen_mov(s, op, args, args[0], args[1]);                continue;            }            break;        CASE_OP_32_64(and):        CASE_OP_32_64(orc):        CASE_OP_32_64(eqv):            if (temps[args[1]].state != TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST                && temps[args[2]].val == -1) {                tcg_opt_gen_mov(s, op, args, args[0], args[1]);                continue;            }            break;        default:            break;        }        /* Simplify using known-zero bits. Currently only ops with a single           output argument is supported. */        mask = -1;        affected = -1;        switch (opc) {        CASE_OP_32_64(ext8s):            if ((temps[args[1]].mask & 0x80) != 0) {                break;            }        CASE_OP_32_64(ext8u):            mask = 0xff;            goto and_const;        CASE_OP_32_64(ext16s):            if ((temps[args[1]].mask & 0x8000) != 0) {                break;            }        CASE_OP_32_64(ext16u):            mask = 0xffff;            goto and_const;        case INDEX_op_ext32s_i64:            if ((temps[args[1]].mask & 0x80000000) != 0) {                break;            }        case INDEX_op_ext32u_i64:            mask = 0xffffffffU;            goto and_const;        CASE_OP_32_64(and):            mask = temps[args[2]].mask;            if (temps[args[2]].state == TCG_TEMP_CONST) {        and_const:                affected = temps[args[1]].mask & ~mask;            }            mask = temps[args[1]].mask & mask;            break;        CASE_OP_32_64(andc):            /* Known-zeros does not imply known-ones.  Therefore unless               args[2] is constant, we can't infer anything from it.  */            if (temps[args[2]].state == TCG_TEMP_CONST) {                mask = ~temps[args[2]].mask;                goto and_const;            }            /* But we certainly know nothing outside args[1] may be set. */            mask = temps[args[1]].mask;            break;        case INDEX_op_sar_i32:            if (temps[args[2]].state == TCG_TEMP_CONST) {                tmp = temps[args[2]].val & 31;                mask = (int32_t)temps[args[1]].mask >> tmp;            }            break;        case INDEX_op_sar_i64:            if (temps[args[2]].state == TCG_TEMP_CONST) {                tmp = temps[args[2]].val & 63;                mask = (int64_t)temps[args[1]].mask >> tmp;            }            break;        case INDEX_op_shr_i32:            if (temps[args[2]].state == TCG_TEMP_CONST) {                tmp = temps[args[2]].val & 31;                mask = (uint32_t)temps[args[1]].mask >> tmp;            }            break;        case INDEX_op_shr_i64:            if (temps[args[2]].state == TCG_TEMP_CONST) {                tmp = temps[args[2]].val & 63;                mask = (uint64_t)temps[args[1]].mask >> tmp;            }            break;        case INDEX_op_trunc_shr_i32:            mask = (uint64_t)temps[args[1]].mask >> args[2];            break;        CASE_OP_32_64(shl):            if (temps[args[2]].state == TCG_TEMP_CONST) {                tmp = temps[args[2]].val & (TCG_TARGET_REG_BITS - 1);                mask = temps[args[1]].mask << tmp;            }            break;        CASE_OP_32_64(neg):            /* Set to 1 all bits to the left of the rightmost.  */            mask = -(temps[args[1]].mask & -temps[args[1]].mask);            break;        CASE_OP_32_64(deposit):            mask = deposit64(temps[args[1]].mask, args[3], args[4],                             temps[args[2]].mask);            break;        CASE_OP_32_64(or):        CASE_OP_32_64(xor):            mask = temps[args[1]].mask | temps[args[2]].mask;            break;        CASE_OP_32_64(setcond):        case INDEX_op_setcond2_i32:            mask = 1;            break;        CASE_OP_32_64(movcond):            mask = temps[args[3]].mask | temps[args[4]].mask;            break;        CASE_OP_32_64(ld8u):            mask = 0xff;            break;        CASE_OP_32_64(ld16u):            mask = 0xffff;            break;        case INDEX_op_ld32u_i64:            mask = 0xffffffffu;            break;        CASE_OP_32_64(qemu_ld):            {                TCGMemOpIdx oi = args[nb_oargs + nb_iargs];                TCGMemOp mop = get_memop(oi);                if (!(mop & MO_SIGN)) {                    mask = (2ULL << ((8 << (mop & MO_SIZE)) - 1)) - 1;                }            }            break;        default:            break;        }        /* 32-bit ops generate 32-bit results.  For the result is zero test           below, we can ignore high bits, but for further optimizations we           need to record that the high bits contain garbage.  */        partmask = mask;        if (!(def->flags & TCG_OPF_64BIT)) {            mask |= ~(tcg_target_ulong)0xffffffffu;            partmask &= 0xffffffffu;            affected &= 0xffffffffu;        }        if (partmask == 0) {            assert(nb_oargs == 1);            tcg_opt_gen_movi(s, op, args, args[0], 0);            continue;        }        if (affected == 0) {            assert(nb_oargs == 1);            tcg_opt_gen_mov(s, op, args, args[0], args[1]);            continue;        }        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */        switch (opc) {        CASE_OP_32_64(and):        CASE_OP_32_64(mul):        CASE_OP_32_64(muluh):        CASE_OP_32_64(mulsh):            if ((temps[args[2]].state == TCG_TEMP_CONST                && temps[args[2]].val == 0)) {                tcg_opt_gen_movi(s, op, args, args[0], 0);                continue;            }            break;        default:            break;        }        /* Simplify expression for \"op r, a, a => mov r, a\" cases */        switch (opc) {        CASE_OP_32_64(or):        CASE_OP_32_64(and):            if (temps_are_copies(args[1], args[2])) {                tcg_opt_gen_mov(s, op, args, args[0], args[1]);                continue;            }            break;        default:            break;        }        /* Simplify expression for \"op r, a, a => movi r, 0\" cases */        switch (opc) {        CASE_OP_32_64(andc):        CASE_OP_32_64(sub):        CASE_OP_32_64(xor):            if (temps_are_copies(args[1], args[2])) {                tcg_opt_gen_movi(s, op, args, args[0], 0);                continue;            }            break;        default:            break;        }        /* Propagate constants through copy operations and do constant           folding.  Constants will be substituted to arguments by register           allocator where needed and possible.  Also detect copies. */        switch (opc) {        CASE_OP_32_64(mov):            tcg_opt_gen_mov(s, op, args, args[0], args[1]);            break;        CASE_OP_32_64(movi):            tcg_opt_gen_movi(s, op, args, args[0], args[1]);            break;        CASE_OP_32_64(not):        CASE_OP_32_64(neg):        CASE_OP_32_64(ext8s):        CASE_OP_32_64(ext8u):        CASE_OP_32_64(ext16s):        CASE_OP_32_64(ext16u):        case INDEX_op_ext32s_i64:        case INDEX_op_ext32u_i64:            if (temps[args[1]].state == TCG_TEMP_CONST) {                tmp = do_constant_folding(opc, temps[args[1]].val, 0);                tcg_opt_gen_movi(s, op, args, args[0], tmp);                break;            }            goto do_default;        case INDEX_op_trunc_shr_i32:            if (temps[args[1]].state == TCG_TEMP_CONST) {                tmp = do_constant_folding(opc, temps[args[1]].val, args[2]);                tcg_opt_gen_movi(s, op, args, args[0], tmp);                break;            }            goto do_default;        CASE_OP_32_64(add):        CASE_OP_32_64(sub):        CASE_OP_32_64(mul):        CASE_OP_32_64(or):        CASE_OP_32_64(and):        CASE_OP_32_64(xor):        CASE_OP_32_64(shl):        CASE_OP_32_64(shr):        CASE_OP_32_64(sar):        CASE_OP_32_64(rotl):        CASE_OP_32_64(rotr):        CASE_OP_32_64(andc):        CASE_OP_32_64(orc):        CASE_OP_32_64(eqv):        CASE_OP_32_64(nand):        CASE_OP_32_64(nor):        CASE_OP_32_64(muluh):        CASE_OP_32_64(mulsh):        CASE_OP_32_64(div):        CASE_OP_32_64(divu):        CASE_OP_32_64(rem):        CASE_OP_32_64(remu):            if (temps[args[1]].state == TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST) {                tmp = do_constant_folding(opc, temps[args[1]].val,                                          temps[args[2]].val);                tcg_opt_gen_movi(s, op, args, args[0], tmp);                break;            }            goto do_default;        CASE_OP_32_64(deposit):            if (temps[args[1]].state == TCG_TEMP_CONST                && temps[args[2]].state == TCG_TEMP_CONST) {                tmp = deposit64(temps[args[1]].val, args[3], args[4],                                temps[args[2]].val);                tcg_opt_gen_movi(s, op, args, args[0], tmp);                break;            }            goto do_default;        CASE_OP_32_64(setcond):            tmp = do_constant_folding_cond(opc, args[1], args[2], args[3]);            if (tmp != 2) {                tcg_opt_gen_movi(s, op, args, args[0], tmp);                break;            }            goto do_default;        CASE_OP_32_64(brcond):            tmp = do_constant_folding_cond(opc, args[0], args[1], args[2]);            if (tmp != 2) {                if (tmp) {                    reset_all_temps(nb_temps);                    op->opc = INDEX_op_br;                    args[0] = args[3];                } else {                    tcg_op_remove(s, op);                }                break;            }            goto do_default;        CASE_OP_32_64(movcond):            tmp = do_constant_folding_cond(opc, args[1], args[2], args[5]);            if (tmp != 2) {                tcg_opt_gen_mov(s, op, args, args[0], args[4-tmp]);                break;            }            goto do_default;        case INDEX_op_add2_i32:        case INDEX_op_sub2_i32:            if (temps[args[2]].state == TCG_TEMP_CONST                && temps[args[3]].state == TCG_TEMP_CONST                && temps[args[4]].state == TCG_TEMP_CONST                && temps[args[5]].state == TCG_TEMP_CONST) {                uint32_t al = temps[args[2]].val;                uint32_t ah = temps[args[3]].val;                uint32_t bl = temps[args[4]].val;                uint32_t bh = temps[args[5]].val;                uint64_t a = ((uint64_t)ah << 32) | al;                uint64_t b = ((uint64_t)bh << 32) | bl;                TCGArg rl, rh;                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);                TCGArg *args2 = &s->gen_opparam_buf[op2->args];                if (opc == INDEX_op_add2_i32) {                    a += b;                } else {                    a -= b;                }                rl = args[0];                rh = args[1];                tcg_opt_gen_movi(s, op, args, rl, (uint32_t)a);                tcg_opt_gen_movi(s, op2, args2, rh, (uint32_t)(a >> 32));                /* We've done all we need to do with the movi.  Skip it.  */                oi_next = op2->next;                break;            }            goto do_default;        case INDEX_op_mulu2_i32:            if (temps[args[2]].state == TCG_TEMP_CONST                && temps[args[3]].state == TCG_TEMP_CONST) {                uint32_t a = temps[args[2]].val;                uint32_t b = temps[args[3]].val;                uint64_t r = (uint64_t)a * b;                TCGArg rl, rh;                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);                TCGArg *args2 = &s->gen_opparam_buf[op2->args];                rl = args[0];                rh = args[1];                tcg_opt_gen_movi(s, op, args, rl, (uint32_t)r);                tcg_opt_gen_movi(s, op2, args2, rh, (uint32_t)(r >> 32));                /* We've done all we need to do with the movi.  Skip it.  */                oi_next = op2->next;                break;            }            goto do_default;        case INDEX_op_brcond2_i32:            tmp = do_constant_folding_cond2(&args[0], &args[2], args[4]);            if (tmp != 2) {                if (tmp) {            do_brcond_true:                    reset_all_temps(nb_temps);                    op->opc = INDEX_op_br;                    args[0] = args[5];                } else {            do_brcond_false:                    tcg_op_remove(s, op);                }            } else if ((args[4] == TCG_COND_LT || args[4] == TCG_COND_GE)                       && temps[args[2]].state == TCG_TEMP_CONST                       && temps[args[3]].state == TCG_TEMP_CONST                       && temps[args[2]].val == 0                       && temps[args[3]].val == 0) {                /* Simplify LT/GE comparisons vs zero to a single compare                   vs the high word of the input.  */            do_brcond_high:                reset_all_temps(nb_temps);                op->opc = INDEX_op_brcond_i32;                args[0] = args[1];                args[1] = args[3];                args[2] = args[4];                args[3] = args[5];            } else if (args[4] == TCG_COND_EQ) {                /* Simplify EQ comparisons where one of the pairs                   can be simplified.  */                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,                                               args[0], args[2], TCG_COND_EQ);                if (tmp == 0) {                    goto do_brcond_false;                } else if (tmp == 1) {                    goto do_brcond_high;                }                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,                                               args[1], args[3], TCG_COND_EQ);                if (tmp == 0) {                    goto do_brcond_false;                } else if (tmp != 1) {                    goto do_default;                }            do_brcond_low:                reset_all_temps(nb_temps);                op->opc = INDEX_op_brcond_i32;                args[1] = args[2];                args[2] = args[4];                args[3] = args[5];            } else if (args[4] == TCG_COND_NE) {                /* Simplify NE comparisons where one of the pairs                   can be simplified.  */                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,                                               args[0], args[2], TCG_COND_NE);                if (tmp == 0) {                    goto do_brcond_high;                } else if (tmp == 1) {                    goto do_brcond_true;                }                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,                                               args[1], args[3], TCG_COND_NE);                if (tmp == 0) {                    goto do_brcond_low;                } else if (tmp == 1) {                    goto do_brcond_true;                }                goto do_default;            } else {                goto do_default;            }            break;        case INDEX_op_setcond2_i32:            tmp = do_constant_folding_cond2(&args[1], &args[3], args[5]);            if (tmp != 2) {            do_setcond_const:                tcg_opt_gen_movi(s, op, args, args[0], tmp);            } else if ((args[5] == TCG_COND_LT || args[5] == TCG_COND_GE)                       && temps[args[3]].state == TCG_TEMP_CONST                       && temps[args[4]].state == TCG_TEMP_CONST                       && temps[args[3]].val == 0                       && temps[args[4]].val == 0) {                /* Simplify LT/GE comparisons vs zero to a single compare                   vs the high word of the input.  */            do_setcond_high:                reset_temp(args[0]);                temps[args[0]].mask = 1;                op->opc = INDEX_op_setcond_i32;                args[1] = args[2];                args[2] = args[4];                args[3] = args[5];            } else if (args[5] == TCG_COND_EQ) {                /* Simplify EQ comparisons where one of the pairs                   can be simplified.  */                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,                                               args[1], args[3], TCG_COND_EQ);                if (tmp == 0) {                    goto do_setcond_const;                } else if (tmp == 1) {                    goto do_setcond_high;                }                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,                                               args[2], args[4], TCG_COND_EQ);                if (tmp == 0) {                    goto do_setcond_high;                } else if (tmp != 1) {                    goto do_default;                }            do_setcond_low:                reset_temp(args[0]);                temps[args[0]].mask = 1;                op->opc = INDEX_op_setcond_i32;                args[2] = args[3];                args[3] = args[5];            } else if (args[5] == TCG_COND_NE) {                /* Simplify NE comparisons where one of the pairs                   can be simplified.  */                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,                                               args[1], args[3], TCG_COND_NE);                if (tmp == 0) {                    goto do_setcond_high;                } else if (tmp == 1) {                    goto do_setcond_const;                }                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,                                               args[2], args[4], TCG_COND_NE);                if (tmp == 0) {                    goto do_setcond_low;                } else if (tmp == 1) {                    goto do_setcond_const;                }                goto do_default;            } else {                goto do_default;            }            break;        case INDEX_op_call:            if (!(args[nb_oargs + nb_iargs + 1]                  & (TCG_CALL_NO_READ_GLOBALS | TCG_CALL_NO_WRITE_GLOBALS))) {                for (i = 0; i < nb_globals; i++) {                    reset_temp(i);                }            }            goto do_reset_output;        default:        do_default:            /* Default case: we know nothing about operation (or were unable               to compute the operation result) so no propagation is done.               We trash everything if the operation is the end of a basic               block, otherwise we only trash the output args.  \"mask\" is               the non-zero bits mask for the first output arg.  */            if (def->flags & TCG_OPF_BB_END) {                reset_all_temps(nb_temps);            } else {        do_reset_output:                for (i = 0; i < nb_oargs; i++) {                    reset_temp(args[i]);                    /* Save the corresponding known-zero bits mask for the                       first output argument (only one supported so far). */                    if (i == 0) {                        temps[args[i]].mask = mask;                    }                }            }            break;        }    }}", "idx": 3439}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "function": "static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,                                                       uint8_t alpha_in,                                                       uint8_t beta_in,                                                       uint32_t img_width){    uint16_t out0, out1, out2, out3;    v8i16 tmp1;    v16u8 alpha, beta, is_less_than;    v8i16 p0_or_q0, q0_or_p0;    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;    v16i8 zero = { 0 };    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;    v16u8 is_less_than_alpha, is_less_than_beta;    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;    {        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,                      row0, row1, row2, row3, row4, row5, row6, row7);        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,                          p1_or_q1_org, p0_or_q0_org,                          q0_or_p0_org, q1_or_p1_org);    }    alpha = (v16u8) __msa_fill_b(alpha_in);    beta = (v16u8) __msa_fill_b(beta_in);    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);    is_less_than_alpha = (p0_asub_q0 < alpha);    is_less_than_beta = (p1_asub_p0 < beta);    is_less_than = is_less_than_beta & is_less_than_alpha;    is_less_than_beta = (q1_asub_q0 < beta);    is_less_than = is_less_than_beta & is_less_than;    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);    if (!__msa_test_bz_v(is_less_than)) {        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);        /* convert 16 bit output into 8 bit output */        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);        p0_or_q0_org =            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);        q0_or_p0_org =            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);        data_cb_or_cr -= 1;        out0 = __msa_copy_u_h(tmp1, 0);        out1 = __msa_copy_u_h(tmp1, 1);        out2 = __msa_copy_u_h(tmp1, 2);        out3 = __msa_copy_u_h(tmp1, 3);        STORE_HWORD(data_cb_or_cr, out0);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out1);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out2);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out3);        data_cb_or_cr += img_width;        out0 = __msa_copy_u_h(tmp1, 4);        out1 = __msa_copy_u_h(tmp1, 5);        out2 = __msa_copy_u_h(tmp1, 6);        out3 = __msa_copy_u_h(tmp1, 7);        STORE_HWORD(data_cb_or_cr, out0);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out1);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out2);        data_cb_or_cr += img_width;        STORE_HWORD(data_cb_or_cr, out3);    }}", "idx": 3452}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "function": "void block_job_cancel_sync(BlockJob *job){    BlockDriverState *bs = job->bs;    assert(bs->job == job);    block_job_cancel(job);    while (bs->job != NULL && bs->job->busy) {        qemu_aio_wait();    }}", "idx": 3464}
{"project": "FFmpeg", "commit_id": "973c3dba27d0b1a88c70f6661b6a90d2f2e50665", "target": 1, "function": "static int mpeg_decode_slice(MpegEncContext *s, int mb_y,                             const uint8_t **buf, int buf_size){    AVCodecContext *avctx = s->avctx;    const int lowres      = s->avctx->lowres;    const int field_pic   = s->picture_structure != PICT_FRAME;    int ret;    s->resync_mb_x =    s->resync_mb_y = -1;    av_assert0(mb_y < s->mb_height);    init_get_bits(&s->gb, *buf, buf_size * 8);    if (s->codec_id != AV_CODEC_ID_MPEG1VIDEO && s->mb_height > 2800/16)        skip_bits(&s->gb, 3);    ff_mpeg1_clean_buffers(s);    s->interlaced_dct = 0;    s->qscale = get_qscale(s);    if (s->qscale == 0) {        av_log(s->avctx, AV_LOG_ERROR, \"qscale == 0\\n\");        return AVERROR_INVALIDDATA;    }    /* extra slice info */    if (skip_1stop_8data_bits(&s->gb) < 0)        return AVERROR_INVALIDDATA;    s->mb_x = 0;    if (mb_y == 0 && s->codec_tag == AV_RL32(\"SLIF\")) {        skip_bits1(&s->gb);    } else {        while (get_bits_left(&s->gb) > 0) {            int code = get_vlc2(&s->gb, ff_mbincr_vlc.table,                                MBINCR_VLC_BITS, 2);            if (code < 0) {                av_log(s->avctx, AV_LOG_ERROR, \"first mb_incr damaged\\n\");                return AVERROR_INVALIDDATA;            }            if (code >= 33) {                if (code == 33)                    s->mb_x += 33;                /* otherwise, stuffing, nothing to do */            } else {                s->mb_x += code;                break;            }        }    }    if (s->mb_x >= (unsigned) s->mb_width) {        av_log(s->avctx, AV_LOG_ERROR, \"initial skip overflow\\n\");        return AVERROR_INVALIDDATA;    }    if (avctx->hwaccel && avctx->hwaccel->decode_slice) {        const uint8_t *buf_end, *buf_start = *buf - 4; /* include start_code */        int start_code = -1;        buf_end = avpriv_find_start_code(buf_start + 2, *buf + buf_size, &start_code);        if (buf_end < *buf + buf_size)            buf_end -= 4;        s->mb_y = mb_y;        if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_end - buf_start) < 0)            return DECODE_SLICE_ERROR;        *buf = buf_end;        return DECODE_SLICE_OK;    }    s->resync_mb_x = s->mb_x;    s->resync_mb_y = s->mb_y = mb_y;    s->mb_skip_run = 0;    ff_init_block_index(s);    if (s->mb_y == 0 && s->mb_x == 0 && (s->first_field || s->picture_structure == PICT_FRAME)) {        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {            av_log(s->avctx, AV_LOG_DEBUG,                   \"qp:%d fc:%2d%2d%2d%2d %s %s %s %s %s dc:%d pstruct:%d fdct:%d cmv:%d qtype:%d ivlc:%d rff:%d %s\\n\",                   s->qscale,                   s->mpeg_f_code[0][0], s->mpeg_f_code[0][1],                   s->mpeg_f_code[1][0], s->mpeg_f_code[1][1],                   s->pict_type  == AV_PICTURE_TYPE_I ? \"I\" :                   (s->pict_type == AV_PICTURE_TYPE_P ? \"P\" :                   (s->pict_type == AV_PICTURE_TYPE_B ? \"B\" : \"S\")),                   s->progressive_sequence ? \"ps\"  : \"\",                   s->progressive_frame    ? \"pf\"  : \"\",                   s->alternate_scan       ? \"alt\" : \"\",                   s->top_field_first      ? \"top\" : \"\",                   s->intra_dc_precision, s->picture_structure,                   s->frame_pred_frame_dct, s->concealment_motion_vectors,                   s->q_scale_type, s->intra_vlc_format,                   s->repeat_first_field, s->chroma_420_type ? \"420\" : \"\");        }    }    for (;;) {        // If 1, we memcpy blocks in xvmcvideo.        if ((CONFIG_MPEG1_XVMC_HWACCEL || CONFIG_MPEG2_XVMC_HWACCEL) && s->pack_pblocks)            ff_xvmc_init_block(s); // set s->block        if ((ret = mpeg_decode_mb(s, s->block)) < 0)            return ret;        // Note motion_val is normally NULL unless we want to extract the MVs.        if (s->current_picture.motion_val[0] && !s->encoding) {            const int wrap = s->b8_stride;            int xy         = s->mb_x * 2 + s->mb_y * 2 * wrap;            int b8_xy      = 4 * (s->mb_x + s->mb_y * s->mb_stride);            int motion_x, motion_y, dir, i;            for (i = 0; i < 2; i++) {                for (dir = 0; dir < 2; dir++) {                    if (s->mb_intra ||                        (dir == 1 && s->pict_type != AV_PICTURE_TYPE_B)) {                        motion_x = motion_y = 0;                    } else if (s->mv_type == MV_TYPE_16X16 ||                               (s->mv_type == MV_TYPE_FIELD && field_pic)) {                        motion_x = s->mv[dir][0][0];                        motion_y = s->mv[dir][0][1];                    } else { /* if ((s->mv_type == MV_TYPE_FIELD) || (s->mv_type == MV_TYPE_16X8)) */                        motion_x = s->mv[dir][i][0];                        motion_y = s->mv[dir][i][1];                    }                    s->current_picture.motion_val[dir][xy][0]     = motion_x;                    s->current_picture.motion_val[dir][xy][1]     = motion_y;                    s->current_picture.motion_val[dir][xy + 1][0] = motion_x;                    s->current_picture.motion_val[dir][xy + 1][1] = motion_y;                    s->current_picture.ref_index [dir][b8_xy]     =                    s->current_picture.ref_index [dir][b8_xy + 1] = s->field_select[dir][i];                    av_assert2(s->field_select[dir][i] == 0 ||                               s->field_select[dir][i] == 1);                }                xy    += wrap;                b8_xy += 2;            }        }        s->dest[0] += 16 >> lowres;        s->dest[1] +=(16 >> lowres) >> s->chroma_x_shift;        s->dest[2] +=(16 >> lowres) >> s->chroma_x_shift;        ff_mpv_decode_mb(s, s->block);        if (++s->mb_x >= s->mb_width) {            const int mb_size = 16 >> s->avctx->lowres;            ff_mpeg_draw_horiz_band(s, mb_size * (s->mb_y >> field_pic), mb_size);            ff_mpv_report_decode_progress(s);            s->mb_x  = 0;            s->mb_y += 1 << field_pic;            if (s->mb_y >= s->mb_height) {                int left   = get_bits_left(&s->gb);                int is_d10 = s->chroma_format == 2 &&                             s->pict_type == AV_PICTURE_TYPE_I &&                             avctx->profile == 0 && avctx->level == 5 &&                             s->intra_dc_precision == 2 &&                             s->q_scale_type == 1 && s->alternate_scan == 0 &&                             s->progressive_frame == 0                             /* vbv_delay == 0xBBB || 0xE10 */;                if (left >= 32 && !is_d10) {                    GetBitContext gb = s->gb;                    align_get_bits(&gb);                    if (show_bits(&gb, 24) == 0x060E2B) {                        av_log(avctx, AV_LOG_DEBUG, \"Invalid MXF data found in video stream\\n\");                        is_d10 = 1;                    }                }                if (left < 0 ||                    (left && show_bits(&s->gb, FFMIN(left, 23)) && !is_d10) ||                    ((avctx->err_recognition & (AV_EF_BITSTREAM | AV_EF_AGGRESSIVE)) && left > 8)) {                    av_log(avctx, AV_LOG_ERROR, \"end mismatch left=%d %0X\\n\",                           left, show_bits(&s->gb, FFMIN(left, 23)));                    return AVERROR_INVALIDDATA;                } else                    goto eos;            }            // There are some files out there which are missing the last slice            // in cases where the slice is completely outside the visible            // area, we detect this here instead of running into the end expecting            // more data            if (s->mb_y >= ((s->height + 15) >> 4) &&                !s->progressive_sequence &&                get_bits_left(&s->gb) <= 8 &&                get_bits_left(&s->gb) >= 0 &&                s->mb_skip_run == -1 &&                show_bits(&s->gb, 8) == 0)                goto eos;            ff_init_block_index(s);        }        /* skip mb handling */        if (s->mb_skip_run == -1) {            /* read increment again */            s->mb_skip_run = 0;            for (;;) {                int code = get_vlc2(&s->gb, ff_mbincr_vlc.table,                                    MBINCR_VLC_BITS, 2);                if (code < 0) {                    av_log(s->avctx, AV_LOG_ERROR, \"mb incr damaged\\n\");                    return AVERROR_INVALIDDATA;                }                if (code >= 33) {                    if (code == 33) {                        s->mb_skip_run += 33;                    } else if (code == 35) {                        if (s->mb_skip_run != 0 || show_bits(&s->gb, 15) != 0) {                            av_log(s->avctx, AV_LOG_ERROR, \"slice mismatch\\n\");                            return AVERROR_INVALIDDATA;                        }                        goto eos; /* end of slice */                    }                    /* otherwise, stuffing, nothing to do */                } else {                    s->mb_skip_run += code;                    break;                }            }            if (s->mb_skip_run) {                int i;                if (s->pict_type == AV_PICTURE_TYPE_I) {                    av_log(s->avctx, AV_LOG_ERROR,                           \"skipped MB in I frame at %d %d\\n\", s->mb_x, s->mb_y);                    return AVERROR_INVALIDDATA;                }                /* skip mb */                s->mb_intra = 0;                for (i = 0; i < 12; i++)                    s->block_last_index[i] = -1;                if (s->picture_structure == PICT_FRAME)                    s->mv_type = MV_TYPE_16X16;                else                    s->mv_type = MV_TYPE_FIELD;                if (s->pict_type == AV_PICTURE_TYPE_P) {                    /* if P type, zero motion vector is implied */                    s->mv_dir             = MV_DIR_FORWARD;                    s->mv[0][0][0]        = s->mv[0][0][1]      = 0;                    s->last_mv[0][0][0]   = s->last_mv[0][0][1] = 0;                    s->last_mv[0][1][0]   = s->last_mv[0][1][1] = 0;                    s->field_select[0][0] = (s->picture_structure - 1) & 1;                } else {                    /* if B type, reuse previous vectors and directions */                    s->mv[0][0][0] = s->last_mv[0][0][0];                    s->mv[0][0][1] = s->last_mv[0][0][1];                    s->mv[1][0][0] = s->last_mv[1][0][0];                    s->mv[1][0][1] = s->last_mv[1][0][1];                }            }        }    }eos: // end of slice    if (get_bits_left(&s->gb) < 0) {        av_log(s, AV_LOG_ERROR, \"overread %d\\n\", -get_bits_left(&s->gb));        return AVERROR_INVALIDDATA;    }    *buf += (get_bits_count(&s->gb) - 1) / 8;    ff_dlog(s, \"Slice start:%d %d  end:%d %d\\n\", s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y);    return 0;}", "idx": 3480}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "void stw_le_phys(target_phys_addr_t addr, uint32_t val){    stw_phys_internal(addr, val, DEVICE_LITTLE_ENDIAN);}", "idx": 3510}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "function": "int ff_rv34_decode_frame(AVCodecContext *avctx,                            void *data, int *got_picture_ptr,                            AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    RV34DecContext *r = avctx->priv_data;    MpegEncContext *s = &r->s;    AVFrame *pict = data;    SliceInfo si;    int i, ret;    int slice_count;    const uint8_t *slices_hdr = NULL;    int last = 0;    /* no supplementary picture */    if (buf_size == 0) {        /* special case for last picture */        if (s->low_delay==0 && s->next_picture_ptr) {            if ((ret = av_frame_ref(pict, &s->next_picture_ptr->f)) < 0)                return ret;            s->next_picture_ptr = NULL;            *got_picture_ptr = 1;        }        return 0;    }    if(!avctx->slice_count){        slice_count = (*buf++) + 1;        slices_hdr = buf + 4;        buf += 8 * slice_count;        buf_size -= 1 + 8 * slice_count;    }else        slice_count = avctx->slice_count;    //parse first slice header to check whether this frame can be decoded    if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||       get_slice_offset(avctx, slices_hdr, 0) > buf_size){        av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");        return AVERROR_INVALIDDATA;    }    init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);    if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){        av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");        return AVERROR_INVALIDDATA;    }    if ((!s->last_picture_ptr || !s->last_picture_ptr->f.data[0]) &&        si.type == AV_PICTURE_TYPE_B) {        av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"               \"reference data.\\n\");        return AVERROR_INVALIDDATA;    }    if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)       || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)       ||  avctx->skip_frame >= AVDISCARD_ALL)        return avpkt->size;    /* first slice */    if (si.start == 0) {        if (s->mb_num_left > 0) {            av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",                   s->mb_num_left);            ff_er_frame_end(&s->er);            ff_MPV_frame_end(s);        }        if (s->width != si.width || s->height != si.height) {            int err;            av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",                   si.width, si.height);            s->width  = si.width;            s->height = si.height;            err = ff_set_dimensions(s->avctx, s->width, s->height);            if (err < 0)                return err;            if ((err = ff_MPV_common_frame_size_change(s)) < 0)                return err;            if ((err = rv34_decoder_realloc(r)) < 0)                return err;        }        s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;        if (ff_MPV_frame_start(s, s->avctx) < 0)            return -1;        ff_mpeg_er_frame_start(s);        if (!r->tmp_b_block_base) {            int i;            r->tmp_b_block_base = av_malloc(s->linesize * 48);            for (i = 0; i < 2; i++)                r->tmp_b_block_y[i] = r->tmp_b_block_base                                      + i * 16 * s->linesize;            for (i = 0; i < 4; i++)                r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize                                       + (i >> 1) * 8 * s->uvlinesize                                       + (i &  1) * 16;        }        r->cur_pts = si.pts;        if (s->pict_type != AV_PICTURE_TYPE_B) {            r->last_pts = r->next_pts;            r->next_pts = r->cur_pts;        } else {            int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);            int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);            int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);            if(!refdist){                r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;                r->scaled_weight = 0;            }else{                r->mv_weight1 = (dist0 << 14) / refdist;                r->mv_weight2 = (dist1 << 14) / refdist;                if((r->mv_weight1|r->mv_weight2) & 511){                    r->weight1 = r->mv_weight1;                    r->weight2 = r->mv_weight2;                    r->scaled_weight = 0;                }else{                    r->weight1 = r->mv_weight1 >> 9;                    r->weight2 = r->mv_weight2 >> 9;                    r->scaled_weight = 1;                }            }        }        s->mb_x = s->mb_y = 0;        ff_thread_finish_setup(s->avctx);    } else if (HAVE_THREADS &&               (s->avctx->active_thread_type & FF_THREAD_FRAME)) {        av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"               \"multithreading mode (start MB is %d).\\n\", si.start);        return AVERROR_INVALIDDATA;    }    for(i = 0; i < slice_count; i++){        int offset = get_slice_offset(avctx, slices_hdr, i);        int size;        if(i+1 == slice_count)            size = buf_size - offset;        else            size = get_slice_offset(avctx, slices_hdr, i+1) - offset;        if(offset < 0 || offset > buf_size){            av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");            break;        }        r->si.end = s->mb_width * s->mb_height;        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;        if(i+1 < slice_count){            if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||                get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {                av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");                break;            }            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){                if(i+2 < slice_count)                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;                else                    size = buf_size - offset;            }else                r->si.end = si.start;        }        if (size < 0 || size > buf_size - offset) {            av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");            break;        }        last = rv34_decode_slice(r, r->si.end, buf + offset, size);        if(last)            break;    }    if (s->current_picture_ptr) {        if (last) {            if(r->loop_filter)                r->loop_filter(r, s->mb_height - 1);            ret = finish_frame(avctx, pict);            if (ret < 0)                return ret;            *got_picture_ptr = ret;        } else if (HAVE_THREADS &&                   (s->avctx->active_thread_type & FF_THREAD_FRAME)) {            av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");            /* always mark the current frame as finished, frame-mt supports             * only complete frames */            ff_er_frame_end(&s->er);            ff_MPV_frame_end(s);            s->mb_num_left = 0;            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);            return AVERROR_INVALIDDATA;        }    }    return avpkt->size;}", "idx": 3560}
{"project": "qemu", "commit_id": "1760048a5d21bacf0e4838da2f61b2d8db7d2866", "target": 1, "function": "static void test_ivshmem_memdev(void){    IVState state;    /* just for the sake of checking memory-backend property */    setup_vm_cmd(&state, \"-object memory-backend-ram,size=1M,id=mb1\"                 \" -device ivshmem,x-memdev=mb1\", false);    qtest_quit(state.qtest);}", "idx": 3572}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "function": "static void curses_refresh(DisplayChangeListener *dcl){    int chr, nextchr, keysym, keycode, keycode_alt;    curses_winch_check();    if (invalidate) {        clear();        refresh();        curses_calc_pad();        graphic_hw_invalidate(NULL);        invalidate = 0;    }    graphic_hw_text_update(NULL, screen);    nextchr = ERR;    while (1) {        /* while there are any pending key strokes to process */        if (nextchr == ERR)            chr = getch();        else {            chr = nextchr;            nextchr = ERR;        }        if (chr == ERR)            break;#ifdef KEY_RESIZE        /* this shouldn't occur when we use a custom SIGWINCH handler */        if (chr == KEY_RESIZE) {            clear();            refresh();            curses_calc_pad();            curses_update(dcl, 0, 0, width, height);            continue;        }#endif        keycode = curses2keycode[chr];        keycode_alt = 0;        /* alt key */        if (keycode == 1) {            nextchr = getch();            if (nextchr != ERR) {                chr = nextchr;                keycode_alt = ALT;                keycode = curses2keycode[nextchr];                nextchr = ERR;                if (keycode != -1) {                    keycode |= ALT;                    /* process keys reserved for qemu */                    if (keycode >= QEMU_KEY_CONSOLE0 &&                            keycode < QEMU_KEY_CONSOLE0 + 9) {                        erase();                        wnoutrefresh(stdscr);                        console_select(keycode - QEMU_KEY_CONSOLE0);                        invalidate = 1;                        continue;                    }                }            }        }        if (kbd_layout) {            keysym = -1;            if (chr < CURSES_KEYS)                keysym = curses2keysym[chr];            if (keysym == -1) {                if (chr < ' ') {                    keysym = chr + '@';                    if (keysym >= 'A' && keysym <= 'Z')                        keysym += 'a' - 'A';                    keysym |= KEYSYM_CNTRL;                } else                    keysym = chr;            }            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);            if (keycode == 0)                continue;            keycode |= (keysym & ~KEYSYM_MASK) >> 16;            keycode |= keycode_alt;        }        if (keycode == -1)            continue;        if (qemu_console_is_graphic(NULL)) {            /* since terminals don't know about key press and release             * events, we need to emit both for each key received */            if (keycode & SHIFT) {                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);                qemu_input_event_send_key_delay(0);            }            if (keycode & CNTRL) {                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);                qemu_input_event_send_key_delay(0);            }            if (keycode & ALT) {                qemu_input_event_send_key_number(NULL, ALT_CODE, true);                qemu_input_event_send_key_delay(0);            }            if (keycode & ALTGR) {                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);                qemu_input_event_send_key_delay(0);            }            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);            qemu_input_event_send_key_delay(0);            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);            qemu_input_event_send_key_delay(0);            if (keycode & ALTGR) {                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);                qemu_input_event_send_key_delay(0);            }            if (keycode & ALT) {                qemu_input_event_send_key_number(NULL, ALT_CODE, false);                qemu_input_event_send_key_delay(0);            }            if (keycode & CNTRL) {                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);                qemu_input_event_send_key_delay(0);            }            if (keycode & SHIFT) {                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);                qemu_input_event_send_key_delay(0);            }        } else {            keysym = curses2qemu[chr];            if (keysym == -1)                keysym = chr;            kbd_put_keysym(keysym);        }    }}", "idx": 3582}
{"project": "FFmpeg", "commit_id": "7fcb98a7ec51123ecfd810a167d96f128eed9b79", "target": 0, "function": "static int decode_band(IVI5DecContext *ctx, int plane_num,                       IVIBandDesc *band, AVCodecContext *avctx){    int         result, i, t, idx1, idx2;    IVITile     *tile;    band->buf     = band->bufs[ctx->dst_buf];    band->ref_buf = band->bufs[ctx->ref_buf];    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);    result = decode_band_hdr(ctx, band, avctx);    if (result) {        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",               result);        return -1;    }    if (band->is_empty) {        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");        return -1;    }    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];    /* apply corrections to the selected rvmap table if present */    for (i = 0; i < band->num_corr; i++) {        idx1 = band->corr[i*2];        idx2 = band->corr[i*2+1];        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);    }    for (t = 0; t < band->num_tiles; t++) {        tile = &band->tiles[t];        tile->is_empty = get_bits1(&ctx->gb);        if (tile->is_empty) {            ff_ivi_process_empty_tile(avctx, band, tile,                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));            align_get_bits(&ctx->gb);        } else {            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);            result = decode_mb_info(ctx, band, tile, avctx);            if (result < 0)                break;            if (band->blk_size == 8) {                band->intra_base  = &ivi5_base_quant_8x8_intra[band->quant_mat][0];                band->inter_base  = &ivi5_base_quant_8x8_inter[band->quant_mat][0];                band->intra_scale = &ivi5_scale_quant_8x8_intra[band->quant_mat][0];                band->inter_scale = &ivi5_scale_quant_8x8_inter[band->quant_mat][0];            } else {                band->intra_base  = ivi5_base_quant_4x4_intra;                band->inter_base  = ivi5_base_quant_4x4_inter;                band->intra_scale = ivi5_scale_quant_4x4_intra;                band->inter_scale = ivi5_scale_quant_4x4_inter;            }            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);            if (result < 0) {                av_log(avctx, AV_LOG_ERROR, \"Corrupted blocks data encountered!\\n\");                break;            }        }    }    /* restore the selected rvmap table by applying its corrections in reverse order */    for (i = band->num_corr-1; i >= 0; i--) {        idx1 = band->corr[i*2];        idx2 = band->corr[i*2+1];        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);    }#if IVI_DEBUG    if (band->checksum_present) {        uint16_t chksum = ivi_calc_band_checksum(band);        if (chksum != band->checksum) {            av_log(avctx, AV_LOG_ERROR,                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",                   band->plane, band->band_num, band->checksum, chksum);        }    }#endif    return result;}", "idx": 3615}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "function": "static void property_get_tm(Object *obj, Visitor *v, const char *name,                            void *opaque, Error **errp){    TMProperty *prop = opaque;    Error *err = NULL;    struct tm value;    prop->get(obj, &value, &err);    if (err) {        goto out;    }    visit_start_struct(v, name, NULL, 0, &err);    if (err) {        goto out;    }    visit_type_int32(v, \"tm_year\", &value.tm_year, &err);    if (err) {        goto out_end;    }    visit_type_int32(v, \"tm_mon\", &value.tm_mon, &err);    if (err) {        goto out_end;    }    visit_type_int32(v, \"tm_mday\", &value.tm_mday, &err);    if (err) {        goto out_end;    }    visit_type_int32(v, \"tm_hour\", &value.tm_hour, &err);    if (err) {        goto out_end;    }    visit_type_int32(v, \"tm_min\", &value.tm_min, &err);    if (err) {        goto out_end;    }    visit_type_int32(v, \"tm_sec\", &value.tm_sec, &err);    if (err) {        goto out_end;    }out_end:    error_propagate(errp, err);    err = NULL;    visit_end_struct(v, errp);out:    error_propagate(errp, err);}", "idx": 3618}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "function": "static int sse_mb(MpegEncContext *s){    int w= 16;    int h= 16;    if(s->mb_x*16 + 16 > s->width ) w= s->width - s->mb_x*16;    if(s->mb_y*16 + 16 > s->height) h= s->height- s->mb_y*16;    if(w==16 && h==16)      if(s->avctx->mb_cmp == FF_CMP_NSSE){        return  s->dsp.nsse[0](s, s->new_picture.f.data[0] + s->mb_x*16 + s->mb_y*s->linesize*16, s->dest[0], s->linesize, 16)               +s->dsp.nsse[1](s, s->new_picture.f.data[1] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[1], s->uvlinesize, 8)               +s->dsp.nsse[1](s, s->new_picture.f.data[2] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[2], s->uvlinesize, 8);      }else{        return  s->dsp.sse[0](NULL, s->new_picture.f.data[0] + s->mb_x*16 + s->mb_y*s->linesize*16, s->dest[0], s->linesize, 16)               +s->dsp.sse[1](NULL, s->new_picture.f.data[1] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[1], s->uvlinesize, 8)               +s->dsp.sse[1](NULL, s->new_picture.f.data[2] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[2], s->uvlinesize, 8);      }    else        return  sse(s, s->new_picture.f.data[0] + s->mb_x*16 + s->mb_y*s->linesize*16, s->dest[0], w, h, s->linesize)               +sse(s, s->new_picture.f.data[1] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[1], w>>1, h>>1, s->uvlinesize)               +sse(s, s->new_picture.f.data[2] + s->mb_x*8  + s->mb_y*s->uvlinesize*8,s->dest[2], w>>1, h>>1, s->uvlinesize);}", "idx": 3626}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "function": "bool postcopy_ram_supported_by_host(void){    error_report(\"%s: No OS support\", __func__);    return false;}", "idx": 3665}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "function": "static inline int qemu_rdma_buffer_mergable(RDMAContext *rdma,                    uint64_t offset, uint64_t len){    RDMALocalBlock *block;    uint8_t *host_addr;    uint8_t *chunk_end;    if (rdma->current_index < 0) {        return 0;    }    if (rdma->current_chunk < 0) {        return 0;    }    block = &(rdma->local_ram_blocks.block[rdma->current_index]);    host_addr = block->local_host_addr + (offset - block->offset);    chunk_end = ram_chunk_end(block, rdma->current_chunk);    if (rdma->current_length == 0) {        return 0;    }    /*     * Only merge into chunk sequentially.     */    if (offset != (rdma->current_addr + rdma->current_length)) {        return 0;    }    if (offset < block->offset) {        return 0;    }    if ((offset + len) > (block->offset + block->length)) {        return 0;    }    if ((host_addr + len) > chunk_end) {        return 0;    }    return 1;}", "idx": 3668}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "function": "void ff_vp3_idct_add_c(uint8_t *dest/*align 8*/, int line_size, DCTELEM *block/*align 16*/){    idct(dest, line_size, block, 2);}", "idx": 3760}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "function": "void replay_save_input_event(InputEvent *evt){    InputKeyEvent *key;    InputBtnEvent *btn;    InputMoveEvent *move;    replay_put_dword(evt->type);    switch (evt->type) {    case INPUT_EVENT_KIND_KEY:        key = evt->u.key;        replay_put_dword(key->key->type);        switch (key->key->type) {        case KEY_VALUE_KIND_NUMBER:            replay_put_qword(key->key->u.number);            replay_put_byte(key->down);            break;        case KEY_VALUE_KIND_QCODE:            replay_put_dword(key->key->u.qcode);            replay_put_byte(key->down);            break;        case KEY_VALUE_KIND__MAX:            /* keep gcc happy */            break;        }        break;    case INPUT_EVENT_KIND_BTN:        btn = evt->u.btn;        replay_put_dword(btn->button);        replay_put_byte(btn->down);        break;    case INPUT_EVENT_KIND_REL:        move = evt->u.rel;        replay_put_dword(move->axis);        replay_put_qword(move->value);        break;    case INPUT_EVENT_KIND_ABS:        move = evt->u.abs;        replay_put_dword(move->axis);        replay_put_qword(move->value);        break;    case INPUT_EVENT_KIND__MAX:        /* keep gcc happy */        break;    }}", "idx": 3761}
{"project": "qemu", "commit_id": "6d152ebaf4db6567cefbbd3b2b102c4a50172109", "target": 0, "function": "void virt_acpi_build(VirtGuestInfo *guest_info, AcpiBuildTables *tables){    GArray *table_offsets;    unsigned dsdt, rsdt;    VirtAcpiCpuInfo cpuinfo;    GArray *tables_blob = tables->table_data;    virt_acpi_get_cpu_info(&cpuinfo);    table_offsets = g_array_new(false, true /* clear */,                                        sizeof(uint32_t));    bios_linker_loader_alloc(tables->linker, ACPI_BUILD_TABLE_FILE,                             64, false /* high memory */);    /*     * The ACPI v5.1 tables for Hardware-reduced ACPI platform are:     * RSDP     * RSDT     * FADT     * GTDT     * MADT     * MCFG     * DSDT     */    /* DSDT is pointed to by FADT */    dsdt = tables_blob->len;    build_dsdt(tables_blob, tables->linker, guest_info);    /* FADT MADT GTDT MCFG SPCR pointed to by RSDT */    acpi_add_table(table_offsets, tables_blob);    build_fadt(tables_blob, tables->linker, dsdt);    acpi_add_table(table_offsets, tables_blob);    build_madt(tables_blob, tables->linker, guest_info, &cpuinfo);    acpi_add_table(table_offsets, tables_blob);    build_gtdt(tables_blob, tables->linker);    acpi_add_table(table_offsets, tables_blob);    build_mcfg(tables_blob, tables->linker, guest_info);    acpi_add_table(table_offsets, tables_blob);    build_spcr(tables_blob, tables->linker, guest_info);    /* RSDT is pointed to by RSDP */    rsdt = tables_blob->len;    build_rsdt(tables_blob, tables->linker, table_offsets);    /* RSDP is in FSEG memory, so allocate it separately */    build_rsdp(tables->rsdp, tables->linker, rsdt);    /* Cleanup memory that's no longer used. */    g_array_free(table_offsets, true);}", "idx": 3781}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "function": "static void spapr_msi_setmsg(PCIDevice *pdev, hwaddr addr,                             bool msix, unsigned req_num){    unsigned i;    MSIMessage msg = { .address = addr, .data = 0 };    if (!msix) {        msi_set_message(pdev, msg);        trace_spapr_pci_msi_setup(pdev->name, 0, msg.address);        return;    }    for (i = 0; i < req_num; ++i) {        msg.address = addr | (i << 2);        msix_set_message(pdev, i, msg);        trace_spapr_pci_msi_setup(pdev->name, i, msg.address);    }}", "idx": 3792}
{"project": "qemu", "commit_id": "a30cf8760f4a59797fc060c3c5a13b7749551d0c", "target": 0, "function": "SerialState *serial_mm_init(MemoryRegion *address_space,                            hwaddr base, int it_shift,                            qemu_irq irq, int baudbase,                            CharDriverState *chr, enum device_endian end){    SerialState *s;    Error *err = NULL;    s = g_malloc0(sizeof(SerialState));    s->it_shift = it_shift;    s->irq = irq;    s->baudbase = baudbase;    s->chr = chr;    serial_realize_core(s, &err);    if (err != NULL) {        error_report(\"%s\", error_get_pretty(err));        error_free(err);        exit(1);    }    vmstate_register(NULL, base, &vmstate_serial, s);    memory_region_init_io(&s->io, NULL, &serial_mm_ops[end], s,                          \"serial\", 8 << it_shift);    memory_region_add_subregion(address_space, base, &s->io);    serial_update_msl(s);    return s;}", "idx": 3808}
{"project": "qemu", "commit_id": "242acf3af4605adce933906bdc053b2414181ec7", "target": 0, "function": "udp_listen(port, laddr, lport, flags)\tu_int port;\tu_int32_t laddr;\tu_int lport;\tint flags;{\tstruct sockaddr_in addr;\tstruct socket *so;\tint addrlen = sizeof(struct sockaddr_in), opt = 1;\tif ((so = socreate()) == NULL) {\t\tfree(so);\t\treturn NULL;\t}\tso->s = socket(AF_INET,SOCK_DGRAM,0);\tso->so_expire = curtime + SO_EXPIRE;\tinsque(so,&udb);\taddr.sin_family = AF_INET;\taddr.sin_addr.s_addr = INADDR_ANY;\taddr.sin_port = port;\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\t\tudp_detach(so);\t\treturn NULL;\t}\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));/*\tsetsockopt(so->s,SOL_SOCKET,SO_OOBINLINE,(char *)&opt,sizeof(int)); */\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\tso->so_fport = addr.sin_port;\tif (addr.sin_addr.s_addr == 0 || addr.sin_addr.s_addr == loopback_addr.s_addr)\t   so->so_faddr = alias_addr;\telse\t   so->so_faddr = addr.sin_addr;\tso->so_lport = lport;\tso->so_laddr.s_addr = laddr;\tif (flags != SS_FACCEPTONCE)\t   so->so_expire = 0;\tso->so_state = SS_ISFCONNECTED;\treturn so;}", "idx": 3810}
{"project": "FFmpeg", "commit_id": "8f6f2322285fc14f8f16377db50355864019a757", "target": 1, "function": "static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eof){    int ret = 0, i;    int got_output = 0;    AVPacket avpkt;    if (!ist->saw_first_ts) {        ist->dts = ist->st->avg_frame_rate.num ? - ist->dec_ctx->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;        ist->pts = 0;        if (pkt && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong        }        ist->saw_first_ts = 1;    }    if (ist->next_dts == AV_NOPTS_VALUE)        ist->next_dts = ist->dts;    if (ist->next_pts == AV_NOPTS_VALUE)        ist->next_pts = ist->pts;    if (!pkt) {        /* EOF handling */        av_init_packet(&avpkt);        avpkt.data = NULL;        avpkt.size = 0;        goto handle_eof;    } else {        avpkt = *pkt;    }    if (pkt->dts != AV_NOPTS_VALUE) {        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);        if (ist->dec_ctx->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)            ist->next_pts = ist->pts = ist->dts;    }    // while we have more to decode or while the decoder did output something on EOF    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {        int duration;    handle_eof:        ist->pts = ist->next_pts;        ist->dts = ist->next_dts;        switch (ist->dec_ctx->codec_type) {        case AVMEDIA_TYPE_AUDIO:            ret = decode_audio    (ist, &avpkt, &got_output);            break;        case AVMEDIA_TYPE_VIDEO:            ret = decode_video    (ist, &avpkt, &got_output);            if (avpkt.duration) {                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);            } else if(ist->dec_ctx->framerate.num != 0 && ist->dec_ctx->framerate.den != 0) {                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict+1 : ist->dec_ctx->ticks_per_frame;                duration = ((int64_t)AV_TIME_BASE *                                ist->dec_ctx->framerate.den * ticks) /                                ist->dec_ctx->framerate.num / ist->dec_ctx->ticks_per_frame;            } else                duration = 0;            if(ist->dts != AV_NOPTS_VALUE && duration) {                ist->next_dts += duration;            }else                ist->next_dts = AV_NOPTS_VALUE;            if (got_output)                ist->next_pts += duration; //FIXME the duration is not correct in some cases            break;        case AVMEDIA_TYPE_SUBTITLE:            ret = transcode_subtitles(ist, &avpkt, &got_output);            break;        default:            return -1;        }        if (ret < 0) {            av_log(NULL, AV_LOG_ERROR, \"Error while decoding stream #%d:%d: %s\\n\",                   ist->file_index, ist->st->index, av_err2str(ret));            if (exit_on_error)                exit_program(1);            break;        }        avpkt.dts=        avpkt.pts= AV_NOPTS_VALUE;        // touch data and size only if not EOF        if (pkt) {            if(ist->dec_ctx->codec_type != AVMEDIA_TYPE_AUDIO)                ret = avpkt.size;            avpkt.data += ret;            avpkt.size -= ret;        }        if (!got_output) {            continue;        }        if (got_output && !pkt)            break;    }    /* after flushing, send an EOF on all the filter inputs attached to the stream */    /* except when looping we need to flush but not to send an EOF */    if (!pkt && ist->decoding_needed && !got_output && !no_eof) {        int ret = send_filter_eof(ist);        if (ret < 0) {            av_log(NULL, AV_LOG_FATAL, \"Error marking filters as finished\\n\");            exit_program(1);        }    }    /* handle stream copy */    if (!ist->decoding_needed) {        ist->dts = ist->next_dts;        switch (ist->dec_ctx->codec_type) {        case AVMEDIA_TYPE_AUDIO:            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /                             ist->dec_ctx->sample_rate;            break;        case AVMEDIA_TYPE_VIDEO:            if (ist->framerate.num) {                // TODO: Remove work-around for c99-to-c89 issue 7                AVRational time_base_q = AV_TIME_BASE_Q;                int64_t next_dts = av_rescale_q(ist->next_dts, time_base_q, av_inv_q(ist->framerate));                ist->next_dts = av_rescale_q(next_dts + 1, av_inv_q(ist->framerate), time_base_q);            } else if (pkt->duration) {                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);            } else if(ist->dec_ctx->framerate.num != 0) {                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;                ist->next_dts += ((int64_t)AV_TIME_BASE *                                  ist->dec_ctx->framerate.den * ticks) /                                  ist->dec_ctx->framerate.num / ist->dec_ctx->ticks_per_frame;            }            break;        }        ist->pts = ist->dts;        ist->next_pts = ist->next_dts;    }    for (i = 0; pkt && i < nb_output_streams; i++) {        OutputStream *ost = output_streams[i];        if (!check_output_constraints(ist, ost) || ost->encoding_needed)            continue;        do_streamcopy(ist, ost, pkt);    }    return got_output;}", "idx": 3830}
{"project": "qemu", "commit_id": "cf864569cd9134ee503ad9eb6be2881001c0ed80", "target": 0, "function": "int vnc_display_password(DisplayState *ds, const char *password){    VncDisplay *vs = vnc_display;    if (!vs) {        return -EINVAL;    }    if (!password) {        /* This is not the intention of this interface but err on the side           of being safe */        return vnc_display_disable_login(ds);    }    if (vs->password) {        g_free(vs->password);        vs->password = NULL;    }    vs->password = g_strdup(password);    if (vs->auth == VNC_AUTH_NONE) {        vs->auth = VNC_AUTH_VNC;    }    return 0;}", "idx": 3841}
{"project": "FFmpeg", "commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "target": 1, "function": "static int sad8_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h){    int i;    int s;    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);    const vector unsigned char permclear = (vector unsigned char){255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0};    vector unsigned char perm1 = vec_lvsl(0, pix1);    vector unsigned char perm2 = vec_lvsl(0, pix2);    vector unsigned char t1, t2, t3,t4, t5;    vector unsigned int sad;    vector signed int sumdiffs;    sad = (vector unsigned int)vec_splat_u32(0);    for (i = 0; i < h; i++) {        /* Read potentially unaligned pixels into t1 and t2           Since we're reading 16 pixels, and actually only want 8,           mask out the last 8 pixels. The 0s don't change the sum. */        vector unsigned char pix1l = vec_ld( 0, pix1);        vector unsigned char pix1r = vec_ld(15, pix1);        vector unsigned char pix2l = vec_ld( 0, pix2);        vector unsigned char pix2r = vec_ld(15, pix2);        t1 = vec_and(vec_perm(pix1l, pix1r, perm1), permclear);        t2 = vec_and(vec_perm(pix2l, pix2r, perm2), permclear);        /* Calculate a sum of abs differences vector */        t3 = vec_max(t1, t2);        t4 = vec_min(t1, t2);        t5 = vec_sub(t3, t4);        /* Add each 4 pixel group together and put 4 results into sad */        sad = vec_sum4s(t5, sad);        pix1 += line_size;        pix2 += line_size;    }    /* Sum up the four partial sums, and put the result into s */    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);    sumdiffs = vec_splat(sumdiffs, 3);    vec_ste(sumdiffs, 0, &s);    return s;}", "idx": 4089}
{"project": "qemu", "commit_id": "134d42d614768b2803e551621f6654dab1fdc2d2", "target": 0, "function": "static unsigned acpi_data_len(GArray *table){#if GLIB_CHECK_VERSION(2, 14, 0)    assert(g_array_get_element_size(table) == 1);#endif    return table->len;}", "idx": 4103}
{"project": "FFmpeg", "commit_id": "06599638dd678c9939df0fd83ff693c43b25971d", "target": 0, "function": "static int decode_frame(NUTContext *nut, AVPacket *pkt, int frame_code){    AVFormatContext *s= nut->avf;    ByteIOContext *bc = &s->pb;    int size, stream_id, flags, discard;    int64_t pts, last_IP_pts;    size= decode_frame_header(nut, &flags, &pts, &stream_id, frame_code);    if(size < 0)        return -1;    if (flags & FLAG_KEY)        nut->stream[stream_id].skip_until_key_frame=0;    discard= s->streams[ stream_id ]->discard;    last_IP_pts= s->streams[ stream_id ]->last_IP_pts;    if(  (discard >= AVDISCARD_NONKEY && !(flags & FLAG_KEY))       ||(discard >= AVDISCARD_BIDIR && last_IP_pts != AV_NOPTS_VALUE && last_IP_pts > pts)       || discard >= AVDISCARD_ALL       || nut->stream[stream_id].skip_until_key_frame){        url_fskip(bc, size);        return 1;    }    av_get_packet(bc, pkt, size);    pkt->stream_index = stream_id;    if (flags & FLAG_KEY)        pkt->flags |= PKT_FLAG_KEY;    pkt->pts = pts;    return 0;}", "idx": 4110}
{"project": "qemu", "commit_id": "07b70bfbb3f3aea9ce7a3a1da78cbfa8ae6bbce6", "target": 0, "function": "int bdrv_can_snapshot(BlockDriverState *bs){    BlockDriver *drv = bs->drv;    if (!drv || bdrv_is_removable(bs) || bdrv_is_read_only(bs)) {        return 0;    }    if (!drv->bdrv_snapshot_create) {        if (bs->file != NULL) {            return bdrv_can_snapshot(bs->file);        }        return 0;    }    return 1;}", "idx": 4114}
{"project": "FFmpeg", "commit_id": "16a75304fe42d3a007c78126b6370c94ccf891f6", "target": 0, "function": "static av_cold int find_component(OMXContext *omx_context, void *logctx,                                  const char *role, char *str, int str_size){    OMX_U32 i, num = 0;    char **components;    int ret = 0;#if CONFIG_OMX_RPI    if (av_strstart(role, \"video_encoder.\", NULL)) {        av_strlcpy(str, \"OMX.broadcom.video_encode\", str_size);        return 0;    }#endif    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);    if (!num) {        av_log(logctx, AV_LOG_WARNING, \"No component for role %s found\\n\", role);        return AVERROR_ENCODER_NOT_FOUND;    }    components = av_mallocz(sizeof(char*) * num);    if (!components)        return AVERROR(ENOMEM);    for (i = 0; i < num; i++) {        components[i] = av_mallocz(OMX_MAX_STRINGNAME_SIZE);        if (!components) {            ret = AVERROR(ENOMEM);            goto end;        }    }    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8**) components);    av_strlcpy(str, components[0], str_size);end:    for (i = 0; i < num; i++)        av_free(components[i]);    av_free(components);    return ret;}", "idx": 4122}
{"project": "FFmpeg", "commit_id": "09b23786b3986502ee88d4907356979127169bdd", "target": 1, "function": "static const uint8_t *pcx_rle_decode(const uint8_t *src,                                     const uint8_t *end,                                     uint8_t *dst,                                     unsigned int bytes_per_scanline,                                     int compressed){    unsigned int i = 0;    unsigned char run, value;    if (compressed) {        while (i < bytes_per_scanline && src < end) {            run   = 1;            value = *src++;            if (value >= 0xc0 && src < end) {                run   = value & 0x3f;                value = *src++;            }            while (i < bytes_per_scanline && run--)                dst[i++] = value;        }    } else {        memcpy(dst, src, bytes_per_scanline);        src += bytes_per_scanline;    }    return src;}", "idx": 4140}
{"project": "qemu", "commit_id": "333cb18ff4aaf249b2e81a376bee2b15370f4784", "target": 1, "function": "DisplayState *init_displaystate(void){    gchar *name;    int i;    if (!display_state) {        display_state = g_new0(DisplayState, 1);    }    for (i = 0; i < nb_consoles; i++) {        if (consoles[i]->console_type != GRAPHIC_CONSOLE &&            consoles[i]->ds == NULL) {            text_console_do_init(consoles[i]->chr, display_state);        }        /* Hook up into the qom tree here (not in new_console()), once         * all QemuConsoles are created and the order / numbering         * doesn't change any more */        name = g_strdup_printf(\"console[%d]\", i);        object_property_add_child(container_get(object_get_root(), \"/backend\"),                                  name, OBJECT(consoles[i]), &error_abort);        g_free(name);    }    return display_state;}", "idx": 4155}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "function": "static void test_bh_schedule10(void){    BHTestData data = { .n = 0, .max = 10 };    data.bh = aio_bh_new(ctx, bh_test_cb, &data);    qemu_bh_schedule(data.bh);    g_assert_cmpint(data.n, ==, 0);    g_assert(aio_poll(ctx, false));    g_assert_cmpint(data.n, ==, 1);    g_assert(aio_poll(ctx, true));    g_assert_cmpint(data.n, ==, 2);    wait_for_aio();    g_assert_cmpint(data.n, ==, 10);    g_assert(!aio_poll(ctx, false));    g_assert_cmpint(data.n, ==, 10);    qemu_bh_delete(data.bh);}", "idx": 4172}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "function": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque){    BlockDriverState *bs = opaque;    int ret = 0;    if (bdrv_set_key(bs, password) != 0) {        monitor_printf(mon, \"invalid password\\n\");        ret = -EPERM;    }    if (mon->password_completion_cb)        mon->password_completion_cb(mon->password_opaque, ret);    monitor_read_command(mon, 1);}", "idx": 4178}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "function": "static void rtas_set_tce_bypass(PowerPCCPU *cpu, sPAPREnvironment *spapr,                                uint32_t token,                                uint32_t nargs, target_ulong args,                                uint32_t nret, target_ulong rets){    VIOsPAPRBus *bus = spapr->vio_bus;    VIOsPAPRDevice *dev;    uint32_t unit, enable;    if (nargs != 2) {        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);        return;    }    unit = rtas_ld(args, 0);    enable = rtas_ld(args, 1);    dev = spapr_vio_find_by_reg(bus, unit);    if (!dev) {        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);        return;    }    if (!dev->tcet) {        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);        return;    }    spapr_tce_set_bypass(dev->tcet, !!enable);    rtas_st(rets, 0, RTAS_OUT_SUCCESS);}", "idx": 4180}
{"project": "qemu", "commit_id": "734a77584ae13d36113a7a7cd8b54beb49a8a48e", "target": 0, "function": "static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,                              int64_t pos){    BDRVQcow2State *s = bs->opaque;    int64_t total_sectors = bs->total_sectors;    bool zero_beyond_eof = bs->zero_beyond_eof;    int ret;    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);    bs->zero_beyond_eof = false;    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);    bs->zero_beyond_eof = zero_beyond_eof;    /* bdrv_co_do_writev will have increased the total_sectors value to include     * the VM state - the VM state is however not an actual part of the block     * device, therefore, we need to restore the old value. */    bs->total_sectors = total_sectors;    return ret;}", "idx": 4192}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "function": "void main_loop_wait(int nonblocking){    fd_set rfds, wfds, xfds;    int ret, nfds;    struct timeval tv;    int timeout;    if (nonblocking)        timeout = 0;    else {        timeout = qemu_calculate_timeout();        qemu_bh_update_timeout(&timeout);    }    os_host_main_loop_wait(&timeout);    tv.tv_sec = timeout / 1000;    tv.tv_usec = (timeout % 1000) * 1000;    /* poll any events */    /* XXX: separate device handlers from system ones */    nfds = -1;    FD_ZERO(&rfds);    FD_ZERO(&wfds);    FD_ZERO(&xfds);    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);    qemu_mutex_unlock_iothread();    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);    qemu_mutex_lock_iothread();    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));    qemu_run_all_timers();    /* Check bottom-halves last in case any of the earlier events triggered       them.  */    qemu_bh_poll();}", "idx": 4221}
{"project": "qemu", "commit_id": "f1a6cf3ef734aab142d5f7ce52e219474ababf6b", "target": 1, "function": "static target_ulong h_random(PowerPCCPU *cpu, sPAPRMachineState *spapr,                             target_ulong opcode, target_ulong *args){    sPAPRRngState *rngstate;    HRandomData hrdata;    rngstate = SPAPR_RNG(object_resolve_path_type(\"\", TYPE_SPAPR_RNG, NULL));    if (!rngstate || !rngstate->backend) {        return H_HARDWARE;    }    qemu_sem_init(&hrdata.sem, 0);    hrdata.val.v64 = 0;    hrdata.received = 0;    qemu_mutex_unlock_iothread();    while (hrdata.received < 8) {        rng_backend_request_entropy(rngstate->backend, 8 - hrdata.received,                                    random_recv, &hrdata);        qemu_sem_wait(&hrdata.sem);    }    qemu_mutex_lock_iothread();    qemu_sem_destroy(&hrdata.sem);    args[0] = hrdata.val.v64;    return H_SUCCESS;}", "idx": 4232}
{"project": "qemu", "commit_id": "b8afb520e479e693c227aa39c2fb7670743e104f", "target": 1, "function": "BdrvDirtyBitmap *bdrv_create_dirty_bitmap(BlockDriverState *bs, int granularity){    int64_t bitmap_size;    BdrvDirtyBitmap *bitmap;    assert((granularity & (granularity - 1)) == 0);    granularity >>= BDRV_SECTOR_BITS;    assert(granularity);    bitmap_size = (bdrv_getlength(bs) >> BDRV_SECTOR_BITS);    bitmap = g_malloc0(sizeof(BdrvDirtyBitmap));    bitmap->bitmap = hbitmap_alloc(bitmap_size, ffs(granularity) - 1);    QLIST_INSERT_HEAD(&bs->dirty_bitmaps, bitmap, list);    return bitmap;}", "idx": 4247}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "function": "void visit_end_list(Visitor *v, Error **errp){    assert(!error_is_set(errp));    v->end_list(v, errp);}", "idx": 4265}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "function": "static void spr_write_601_ubatl (void *opaque, int sprn){    DisasContext *ctx = opaque;    gen_op_store_601_batl((sprn - SPR_IBAT0L) / 2);    RET_STOP(ctx);}", "idx": 4276}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "function": "int kvm_vm_ioctl(KVMState *s, int type, ...){    int ret;    void *arg;    va_list ap;    va_start(ap, type);    arg = va_arg(ap, void *);    va_end(ap);    ret = ioctl(s->vmfd, type, arg);    if (ret == -1)        ret = -errno;    return ret;}", "idx": 4326}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "function": "target_ulong helper_cfc1(CPUMIPSState *env, uint32_t reg){    target_ulong arg1;    switch (reg) {    case 0:        arg1 = (int32_t)env->active_fpu.fcr0;        break;    case 25:        arg1 = ((env->active_fpu.fcr31 >> 24) & 0xfe) | ((env->active_fpu.fcr31 >> 23) & 0x1);        break;    case 26:        arg1 = env->active_fpu.fcr31 & 0x0003f07c;        break;    case 28:        arg1 = (env->active_fpu.fcr31 & 0x00000f83) | ((env->active_fpu.fcr31 >> 22) & 0x4);        break;    default:        arg1 = (int32_t)env->active_fpu.fcr31;        break;    }    return arg1;}", "idx": 4328}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "function": "static int encode_slice_plane(AVCodecContext *avctx, int mb_count,        uint8_t *src, int src_stride, uint8_t *buf, unsigned buf_size,        int *qmat, int chroma){    ProresContext* ctx = avctx->priv_data;    FDCTDSPContext *fdsp = &ctx->fdsp;    DECLARE_ALIGNED(16, int16_t, blocks)[DEFAULT_SLICE_MB_WIDTH << 8], *block;    int i, blocks_per_slice;    PutBitContext pb;    block = blocks;    for (i = 0; i < mb_count; i++) {        fdct_get(fdsp, src,                  src_stride, block + (0 << 6));        fdct_get(fdsp, src + 8 * src_stride, src_stride, block + ((2 - chroma) << 6));        if (!chroma) {            fdct_get(fdsp, src + 16,                  src_stride, block + (1 << 6));            fdct_get(fdsp, src + 16 + 8 * src_stride, src_stride, block + (3 << 6));        }        block += (256 >> chroma);        src   += (32  >> chroma);    }    blocks_per_slice = mb_count << (2 - chroma);    init_put_bits(&pb, buf, buf_size << 3);    encode_dc_coeffs(&pb, blocks, blocks_per_slice, qmat);    encode_ac_coeffs(avctx, &pb, blocks, blocks_per_slice, qmat);    flush_put_bits(&pb);    return put_bits_ptr(&pb) - pb.buf;}", "idx": 4421}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "function": "void test_misc(void){    char table[256];    long res, i;    for(i=0;i<256;i++) table[i] = 256 - i;    res = 0x12345678;    asm (\"xlat\" : \"=a\" (res) : \"b\" (table), \"0\" (res));    printf(\"xlat: EAX=\" FMTLX \"\\n\", res);#if defined(__x86_64__)#if 0    {        /* XXX: see if Intel Core2 and AMD64 behavior really           differ. Here we implemented the Intel way which is not           compatible yet with QEMU. */        static struct __attribute__((packed)) {            uint64_t offset;            uint16_t seg;        } desc;        long cs_sel;        asm volatile (\"mov %%cs, %0\" : \"=r\" (cs_sel));        asm volatile (\"push %1\\n\"                      \"call func_lret\\n\"                      : \"=a\" (res)                      : \"r\" (cs_sel) : \"memory\", \"cc\");        printf(\"func_lret=\" FMTLX \"\\n\", res);        desc.offset = (long)&func_lret;        desc.seg = cs_sel;        asm volatile (\"xor %%rax, %%rax\\n\"                      \"rex64 lcall *(%%rcx)\\n\"                      : \"=a\" (res)                      : \"c\" (&desc)                      : \"memory\", \"cc\");        printf(\"func_lret2=\" FMTLX \"\\n\", res);        asm volatile (\"push %2\\n\"                      \"mov $ 1f, %%rax\\n\"                      \"push %%rax\\n\"                      \"rex64 ljmp *(%%rcx)\\n\"                      \"1:\\n\"                      : \"=a\" (res)                      : \"c\" (&desc), \"b\" (cs_sel)                      : \"memory\", \"cc\");        printf(\"func_lret3=\" FMTLX \"\\n\", res);    }#endif#else    asm volatile (\"push %%cs ; call %1\"                  : \"=a\" (res)                  : \"m\" (func_lret): \"memory\", \"cc\");    printf(\"func_lret=\" FMTLX \"\\n\", res);    asm volatile (\"pushf ; push %%cs ; call %1\"                  : \"=a\" (res)                  : \"m\" (func_iret): \"memory\", \"cc\");    printf(\"func_iret=\" FMTLX \"\\n\", res);#endif#if defined(__x86_64__)    /* specific popl test */    asm volatile (\"push $12345432 ; push $0x9abcdef ; pop (%%rsp) ; pop %0\"                  : \"=g\" (res));    printf(\"popl esp=\" FMTLX \"\\n\", res);#else    /* specific popl test */    asm volatile (\"pushl $12345432 ; pushl $0x9abcdef ; popl (%%esp) ; popl %0\"                  : \"=g\" (res));    printf(\"popl esp=\" FMTLX \"\\n\", res);    /* specific popw test */    asm volatile (\"pushl $12345432 ; pushl $0x9abcdef ; popw (%%esp) ; addl $2, %%esp ; popl %0\"                  : \"=g\" (res));    printf(\"popw esp=\" FMTLX \"\\n\", res);#endif}", "idx": 4442}
{"project": "FFmpeg", "commit_id": "0105ed551cb9610c62b6920a301125781e1161a0", "target": 0, "function": "void ff_put_h264_qpel8_mc00_msa(uint8_t *dst, const uint8_t *src,                                ptrdiff_t stride){    copy_width8_msa(src, stride, dst, stride, 8);}", "idx": 4476}
{"project": "qemu", "commit_id": "6e24ee0c1e4b6c0c9c748acab77ecd113c942a4d", "target": 1, "function": "static void ps2_reset_keyboard(PS2KbdState *s){    trace_ps2_reset_keyboard(s);    s->scan_enabled = 1;    s->scancode_set = 2;    ps2_set_ledstate(s, 0);}", "idx": 4482}
{"project": "qemu", "commit_id": "ba3186c4e473963ba83b5792f3d02d4ac0a76ba5", "target": 0, "function": "static void curl_multi_timeout_do(void *arg){#ifdef NEED_CURL_TIMER_CALLBACK    BDRVCURLState *s = (BDRVCURLState *)arg;    int running;    if (!s->multi) {        return;    }    aio_context_acquire(s->aio_context);    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);    curl_multi_check_completion(s);    aio_context_release(s->aio_context);#else    abort();#endif}", "idx": 4485}
{"project": "FFmpeg", "commit_id": "c3da9f506038aea306dd1b9ce48db94ca251a08d", "target": 1, "function": "static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE], int total_gain){    int v, bsize, ch, coef_nb_bits, parse_exponents;    float mdct_norm;    int nb_coefs[MAX_CHANNELS];    static const int fixed_exp[25]={20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20};    //FIXME remove duplication relative to decoder    if (s->use_variable_block_len) {        assert(0); //FIXME not implemented    }else{        /* fixed block len */        s->next_block_len_bits = s->frame_len_bits;        s->prev_block_len_bits = s->frame_len_bits;        s->block_len_bits = s->frame_len_bits;    }    s->block_len = 1 << s->block_len_bits;//     assert((s->block_pos + s->block_len) <= s->frame_len);    bsize = s->frame_len_bits - s->block_len_bits;    //FIXME factor    v = s->coefs_end[bsize] - s->coefs_start;    for(ch = 0; ch < s->nb_channels; ch++)        nb_coefs[ch] = v;    {        int n4 = s->block_len / 2;        mdct_norm = 1.0 / (float)n4;        if (s->version == 1) {            mdct_norm *= sqrt(n4);        }    }    if (s->nb_channels == 2) {        put_bits(&s->pb, 1, !!s->ms_stereo);    }    for(ch = 0; ch < s->nb_channels; ch++) {        s->channel_coded[ch] = 1; //FIXME only set channel_coded when needed, instead of always        if (s->channel_coded[ch]) {            init_exp(s, ch, fixed_exp);        }    }    for(ch = 0; ch < s->nb_channels; ch++) {        if (s->channel_coded[ch]) {            WMACoef *coefs1;            float *coefs, *exponents, mult;            int i, n;            coefs1 = s->coefs1[ch];            exponents = s->exponents[ch];            mult = pow(10, total_gain * 0.05) / s->max_exponent[ch];            mult *= mdct_norm;            coefs = src_coefs[ch];            if (s->use_noise_coding && 0) {                assert(0); //FIXME not implemented            } else {                coefs += s->coefs_start;                n = nb_coefs[ch];                for(i = 0;i < n; i++){                    double t= *coefs++ / (exponents[i] * mult);                    if(t<-32768 || t>32767)                        return -1;                    coefs1[i] = lrint(t);                }            }        }    }    v = 0;    for(ch = 0; ch < s->nb_channels; ch++) {        int a = s->channel_coded[ch];        put_bits(&s->pb, 1, a);        v |= a;    }    if (!v)        return 1;    for(v= total_gain-1; v>=127; v-= 127)        put_bits(&s->pb, 7, 127);    put_bits(&s->pb, 7, v);    coef_nb_bits= ff_wma_total_gain_to_bits(total_gain);    if (s->use_noise_coding) {        for(ch = 0; ch < s->nb_channels; ch++) {            if (s->channel_coded[ch]) {                int i, n;                n = s->exponent_high_sizes[bsize];                for(i=0;i<n;i++) {                    put_bits(&s->pb, 1, s->high_band_coded[ch][i]= 0);                    if (0)                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];                }            }        }    }    parse_exponents = 1;    if (s->block_len_bits != s->frame_len_bits) {        put_bits(&s->pb, 1, parse_exponents);    }    if (parse_exponents) {        for(ch = 0; ch < s->nb_channels; ch++) {            if (s->channel_coded[ch]) {                if (s->use_exp_vlc) {                    encode_exp_vlc(s, ch, fixed_exp);                } else {                    assert(0); //FIXME not implemented//                    encode_exp_lsp(s, ch);                }            }        }    } else {        assert(0); //FIXME not implemented    }    for(ch = 0; ch < s->nb_channels; ch++) {        if (s->channel_coded[ch]) {            int run, tindex;            WMACoef *ptr, *eptr;            tindex = (ch == 1 && s->ms_stereo);            ptr = &s->coefs1[ch][0];            eptr = ptr + nb_coefs[ch];            run=0;            for(;ptr < eptr; ptr++){                if(*ptr){                    int level= *ptr;                    int abs_level= FFABS(level);                    int code= 0;                    if(abs_level <= s->coef_vlcs[tindex]->max_level){                        if(run < s->coef_vlcs[tindex]->levels[abs_level-1])                            code= run + s->int_table[tindex][abs_level-1];                    }                    assert(code < s->coef_vlcs[tindex]->n);                    put_bits(&s->pb, s->coef_vlcs[tindex]->huffbits[code], s->coef_vlcs[tindex]->huffcodes[code]);                    if(code == 0){                        if(1<<coef_nb_bits <= abs_level)                            return -1;                        //Workaround minor rounding differences for the regression tests, FIXME we should find and replace the problematic float by fixpoint for reg tests                        if(abs_level == 0x71B && (s->avctx->flags & CODEC_FLAG_BITEXACT)) abs_level=0x71A;                        put_bits(&s->pb, coef_nb_bits, abs_level);                        put_bits(&s->pb, s->frame_len_bits, run);                    }                    put_bits(&s->pb, 1, level < 0); //FIXME the sign is fliped somewhere                    run=0;                }else{                    run++;                }            }            if(run)                put_bits(&s->pb, s->coef_vlcs[tindex]->huffbits[1], s->coef_vlcs[tindex]->huffcodes[1]);        }        if (s->version == 1 && s->nb_channels >= 2) {            avpriv_align_put_bits(&s->pb);        }    }    return 0;}", "idx": 4537}
{"project": "qemu", "commit_id": "d451008e0fdf7fb817c791397e7999d5f3687e58", "target": 1, "function": "static uint64_t vfio_rtl8168_window_quirk_read(void *opaque,                                               hwaddr addr, unsigned size){    VFIOQuirk *quirk = opaque;    VFIOPCIDevice *vdev = quirk->vdev;    switch (addr) {    case 4: /* address */        if (quirk->data.flags) {            trace_vfio_rtl8168_window_quirk_read_fake(                    memory_region_name(&quirk->mem),                    vdev->vbasedev.name);            return quirk->data.address_match ^ 0x80000000U;        }        break;    case 0: /* data */        if (quirk->data.flags) {            uint64_t val;            trace_vfio_rtl8168_window_quirk_read_table(                    memory_region_name(&quirk->mem),                    vdev->vbasedev.name);            if (!(vdev->pdev.cap_present & QEMU_PCI_CAP_MSIX)) {                return 0;            }            memory_region_dispatch_read(&vdev->pdev.msix_table_mmio,                                        (hwaddr)(quirk->data.address_match                                                 & 0xfff),                                        &val,                                        size,                                        MEMTXATTRS_UNSPECIFIED);            return val;        }    }    trace_vfio_rtl8168_window_quirk_read_direct(memory_region_name(&quirk->mem),                                                vdev->vbasedev.name);    return vfio_region_read(&vdev->bars[quirk->data.bar].region,                            addr + 0x70, size);}", "idx": 4595}
{"project": "FFmpeg", "commit_id": "b2a4316287ea814168b0b794bd7ab0063fd1dd0f", "target": 0, "function": "static void audio_encode_example(const char *filename){    AVCodec *codec;    AVCodecContext *c= NULL;    AVFrame *frame;    AVPacket pkt;    int i, j, k, ret, got_output;    int buffer_size;    FILE *f;    uint16_t *samples;    float t, tincr;    printf(\"Encode audio file %s\\n\", filename);    /* find the MP2 encoder */    codec = avcodec_find_encoder(AV_CODEC_ID_MP2);    if (!codec) {        fprintf(stderr, \"Codec not found\\n\");        exit(1);    }    c = avcodec_alloc_context3(codec);    if (!c) {        fprintf(stderr, \"Could not allocate audio codec context\\n\");        exit(1);    }    /* put sample parameters */    c->bit_rate = 64000;    /* check that the encoder supports s16 pcm input */    c->sample_fmt = AV_SAMPLE_FMT_S16;    if (!check_sample_fmt(codec, c->sample_fmt)) {        fprintf(stderr, \"Encoder does not support sample format %s\",                av_get_sample_fmt_name(c->sample_fmt));        exit(1);    }    /* select other audio parameters supported by the encoder */    c->sample_rate    = select_sample_rate(codec);    c->channel_layout = select_channel_layout(codec);    c->channels       = av_get_channel_layout_nb_channels(c->channel_layout);    /* open it */    if (avcodec_open2(c, codec, NULL) < 0) {        fprintf(stderr, \"Could not open codec\\n\");        exit(1);    }    f = fopen(filename, \"wb\");    if (!f) {        fprintf(stderr, \"Could not open %s\\n\", filename);        exit(1);    }    /* frame containing input raw audio */    frame = av_frame_alloc();    if (!frame) {        fprintf(stderr, \"Could not allocate audio frame\\n\");        exit(1);    }    frame->nb_samples     = c->frame_size;    frame->format         = c->sample_fmt;    frame->channel_layout = c->channel_layout;    /* the codec gives us the frame size, in samples,     * we calculate the size of the samples buffer in bytes */    buffer_size = av_samples_get_buffer_size(NULL, c->channels, c->frame_size,                                             c->sample_fmt, 0);    if (!buffer_size) {        fprintf(stderr, \"Could not get sample buffer size\\n\");        exit(1);    }    samples = av_malloc(buffer_size);    if (!samples) {        fprintf(stderr, \"Could not allocate %d bytes for samples buffer\\n\",                buffer_size);        exit(1);    }    /* setup the data pointers in the AVFrame */    ret = avcodec_fill_audio_frame(frame, c->channels, c->sample_fmt,                                   (const uint8_t*)samples, buffer_size, 0);    if (ret < 0) {        fprintf(stderr, \"Could not setup audio frame\\n\");        exit(1);    }    /* encode a single tone sound */    t = 0;    tincr = 2 * M_PI * 440.0 / c->sample_rate;    for(i=0;i<200;i++) {        av_init_packet(&pkt);        pkt.data = NULL; // packet data will be allocated by the encoder        pkt.size = 0;        for (j = 0; j < c->frame_size; j++) {            samples[2*j] = (int)(sin(t) * 10000);            for (k = 1; k < c->channels; k++)                samples[2*j + k] = samples[2*j];            t += tincr;        }        /* encode the samples */        ret = avcodec_encode_audio2(c, &pkt, frame, &got_output);        if (ret < 0) {            fprintf(stderr, \"Error encoding audio frame\\n\");            exit(1);        }        if (got_output) {            fwrite(pkt.data, 1, pkt.size, f);            av_free_packet(&pkt);        }    }    /* get the delayed frames */    for (got_output = 1; got_output; i++) {        ret = avcodec_encode_audio2(c, &pkt, NULL, &got_output);        if (ret < 0) {            fprintf(stderr, \"Error encoding frame\\n\");            exit(1);        }        if (got_output) {            fwrite(pkt.data, 1, pkt.size, f);            av_free_packet(&pkt);        }    }    fclose(f);    av_freep(&samples);    av_frame_free(&frame);    avcodec_close(c);    av_free(c);}", "idx": 4682}
{"project": "FFmpeg", "commit_id": "e46a6fb7732a7caef97a916a4f765ec0f779d195", "target": 0, "function": "static void avconv_cleanup(int ret){    int i, j;    for (i = 0; i < nb_filtergraphs; i++) {        FilterGraph *fg = filtergraphs[i];        avfilter_graph_free(&fg->graph);        for (j = 0; j < fg->nb_inputs; j++) {            while (av_fifo_size(fg->inputs[j]->frame_queue)) {                AVFrame *frame;                av_fifo_generic_read(fg->inputs[j]->frame_queue, &frame,                                     sizeof(frame), NULL);                av_frame_free(&frame);            }            av_fifo_free(fg->inputs[j]->frame_queue);            av_buffer_unref(&fg->inputs[j]->hw_frames_ctx);            av_freep(&fg->inputs[j]->name);            av_freep(&fg->inputs[j]);        }        av_freep(&fg->inputs);        for (j = 0; j < fg->nb_outputs; j++) {            av_freep(&fg->outputs[j]->name);            av_freep(&fg->outputs[j]->formats);            av_freep(&fg->outputs[j]->channel_layouts);            av_freep(&fg->outputs[j]->sample_rates);            av_freep(&fg->outputs[j]);        }        av_freep(&fg->outputs);        av_freep(&fg->graph_desc);        av_freep(&filtergraphs[i]);    }    av_freep(&filtergraphs);    /* close files */    for (i = 0; i < nb_output_files; i++) {        OutputFile *of = output_files[i];        AVFormatContext *s = of->ctx;        if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE) && s->pb)            avio_close(s->pb);        avformat_free_context(s);        av_dict_free(&of->opts);        av_freep(&output_files[i]);    }    for (i = 0; i < nb_output_streams; i++) {        OutputStream *ost = output_streams[i];        for (j = 0; j < ost->nb_bitstream_filters; j++)            av_bsf_free(&ost->bsf_ctx[j]);        av_freep(&ost->bsf_ctx);        av_freep(&ost->bitstream_filters);        av_frame_free(&ost->filtered_frame);        av_parser_close(ost->parser);        avcodec_free_context(&ost->parser_avctx);        av_freep(&ost->forced_keyframes);        av_freep(&ost->avfilter);        av_freep(&ost->logfile_prefix);        avcodec_free_context(&ost->enc_ctx);        while (av_fifo_size(ost->muxing_queue)) {            AVPacket pkt;            av_fifo_generic_read(ost->muxing_queue, &pkt, sizeof(pkt), NULL);            av_packet_unref(&pkt);        }        av_fifo_free(ost->muxing_queue);        av_freep(&output_streams[i]);    }    for (i = 0; i < nb_input_files; i++) {        avformat_close_input(&input_files[i]->ctx);        av_freep(&input_files[i]);    }    for (i = 0; i < nb_input_streams; i++) {        InputStream *ist = input_streams[i];        av_frame_free(&ist->decoded_frame);        av_frame_free(&ist->filter_frame);        av_dict_free(&ist->decoder_opts);        av_freep(&ist->filters);        av_freep(&ist->hwaccel_device);        avcodec_free_context(&ist->dec_ctx);        av_freep(&input_streams[i]);    }    if (vstats_file)        fclose(vstats_file);    av_free(vstats_filename);    av_freep(&input_streams);    av_freep(&input_files);    av_freep(&output_streams);    av_freep(&output_files);    uninit_opts();    avformat_network_deinit();    if (received_sigterm) {        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",               (int) received_sigterm);        exit (255);    }}", "idx": 4683}
{"project": "FFmpeg", "commit_id": "5804201cbac2de8824013a8294e381e93bbe45f2", "target": 1, "function": "AVFrameSideData *av_frame_new_side_data(AVFrame *frame,                                        enum AVFrameSideDataType type,                                        int size){    AVFrameSideData *ret, **tmp;    if (frame->nb_side_data > INT_MAX / sizeof(*frame->side_data) - 1)        return NULL;    tmp = av_realloc(frame->side_data,                     (frame->nb_side_data + 1) * sizeof(*frame->side_data));    if (!tmp)        return NULL;    frame->side_data = tmp;    ret = av_mallocz(sizeof(*ret));    if (!ret)        return NULL;    if (size > 0) {        ret->buf = av_buffer_alloc(size);        if (!ret->buf) {            av_freep(&ret);            return NULL;        }        ret->data = ret->buf->data;        ret->size = size;    }    ret->type = type;    frame->side_data[frame->nb_side_data++] = ret;    return ret;}", "idx": 4689}
{"project": "FFmpeg", "commit_id": "cde9e7800128f5466d97279918e1d20fc250a33b", "target": 0, "function": "static av_always_inline void MPV_decode_mb_internal(MpegEncContext *s, DCTELEM block[12][64], int lowres_flag){    int mb_x, mb_y;    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;#ifdef HAVE_XVMC    if(s->avctx->xvmc_acceleration){        XVMC_decode_mb(s);//xvmc uses pblocks        return;    }#endif    mb_x = s->mb_x;    mb_y = s->mb_y;    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {       /* save DCT coefficients */       int i,j;       DCTELEM *dct = &s->current_picture.dct_coeff[mb_xy*64*6];       for(i=0; i<6; i++)           for(j=0; j<64; j++)               *dct++ = block[i][s->dsp.idct_permutation[j]];    }    s->current_picture.qscale_table[mb_xy]= s->qscale;    /* update DC predictors for P macroblocks */    if (!s->mb_intra) {        if (s->h263_pred || s->h263_aic) {            if(s->mbintra_table[mb_xy])                ff_clean_intra_table_entries(s);        } else {            s->last_dc[0] =            s->last_dc[1] =            s->last_dc[2] = 128 << s->intra_dc_precision;        }    }    else if (s->h263_pred || s->h263_aic)        s->mbintra_table[mb_xy]=1;    if ((s->flags&CODEC_FLAG_PSNR) || !(s->encoding && (s->intra_only || s->pict_type==B_TYPE) && s->avctx->mb_decision != FF_MB_DECISION_RD)) { //FIXME precalc        uint8_t *dest_y, *dest_cb, *dest_cr;        int dct_linesize, dct_offset;        op_pixels_func (*op_pix)[4];        qpel_mc_func (*op_qpix)[16];        const int linesize= s->current_picture.linesize[0]; //not s->linesize as this would be wrong for field pics        const int uvlinesize= s->current_picture.linesize[1];        const int readable= s->pict_type != B_TYPE || s->encoding || s->avctx->draw_horiz_band || lowres_flag;        const int block_size= lowres_flag ? 8>>s->avctx->lowres : 8;        /* avoid copy if macroblock skipped in last frame too */        /* skip only during decoding as we might trash the buffers during encoding a bit */        if(!s->encoding){            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];            const int age= s->current_picture.age;            assert(age);            if (s->mb_skipped) {                s->mb_skipped= 0;                assert(s->pict_type!=I_TYPE);                (*mbskip_ptr) ++; /* indicate that this time we skipped it */                if(*mbskip_ptr >99) *mbskip_ptr= 99;                /* if previous was skipped too, then nothing to do !  */                if (*mbskip_ptr >= age && s->current_picture.reference){                    return;                }            } else if(!s->current_picture.reference){                (*mbskip_ptr) ++; /* increase counter so the age can be compared cleanly */                if(*mbskip_ptr >99) *mbskip_ptr= 99;            } else{                *mbskip_ptr = 0; /* not skipped */            }        }        dct_linesize = linesize << s->interlaced_dct;        dct_offset =(s->interlaced_dct)? linesize : linesize*block_size;        if(readable){            dest_y=  s->dest[0];            dest_cb= s->dest[1];            dest_cr= s->dest[2];        }else{            dest_y = s->b_scratchpad;            dest_cb= s->b_scratchpad+16*linesize;            dest_cr= s->b_scratchpad+32*linesize;        }        if (!s->mb_intra) {            /* motion handling */            /* decoding or more than one mb_type (MC was already done otherwise) */            if(!s->encoding){                if(lowres_flag){                    h264_chroma_mc_func *op_pix = s->dsp.put_h264_chroma_pixels_tab;                    if (s->mv_dir & MV_DIR_FORWARD) {                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.data, op_pix);                        op_pix = s->dsp.avg_h264_chroma_pixels_tab;                    }                    if (s->mv_dir & MV_DIR_BACKWARD) {                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.data, op_pix);                    }                }else{                    op_qpix= s->me.qpel_put;                    if ((!s->no_rounding) || s->pict_type==B_TYPE){                        op_pix = s->dsp.put_pixels_tab;                    }else{                        op_pix = s->dsp.put_no_rnd_pixels_tab;                    }                    if (s->mv_dir & MV_DIR_FORWARD) {                        MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.data, op_pix, op_qpix);                        op_pix = s->dsp.avg_pixels_tab;                        op_qpix= s->me.qpel_avg;                    }                    if (s->mv_dir & MV_DIR_BACKWARD) {                        MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.data, op_pix, op_qpix);                    }                }            }            /* skip dequant / idct if we are really late ;) */            if(s->hurry_up>1) goto skip_idct;            if(s->avctx->skip_idct){                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == B_TYPE)                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != I_TYPE)                   || s->avctx->skip_idct >= AVDISCARD_ALL)                    goto skip_idct;            }            /* add dct residue */            if(s->encoding || !(   s->h263_msmpeg4 || s->codec_id==CODEC_ID_MPEG1VIDEO || s->codec_id==CODEC_ID_MPEG2VIDEO                                || (s->codec_id==CODEC_ID_MPEG4 && !s->mpeg_quant))){                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);                if(!(s->flags&CODEC_FLAG_GRAY)){                    if (s->chroma_y_shift){                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);                    }else{                        dct_linesize >>= 1;                        dct_offset >>=1;                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);                    }                }            } else if(s->codec_id != CODEC_ID_WMV2){                add_dct(s, block[0], 0, dest_y                          , dct_linesize);                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);                if(!(s->flags&CODEC_FLAG_GRAY)){                    if(s->chroma_y_shift){//Chroma420                        add_dct(s, block[4], 4, dest_cb, uvlinesize);                        add_dct(s, block[5], 5, dest_cr, uvlinesize);                    }else{                        //chroma422                        dct_linesize = uvlinesize << s->interlaced_dct;                        dct_offset =(s->interlaced_dct)? uvlinesize : uvlinesize*8;                        add_dct(s, block[4], 4, dest_cb, dct_linesize);                        add_dct(s, block[5], 5, dest_cr, dct_linesize);                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);                        if(!s->chroma_x_shift){//Chroma444                            add_dct(s, block[8], 8, dest_cb+8, dct_linesize);                            add_dct(s, block[9], 9, dest_cr+8, dct_linesize);                            add_dct(s, block[10], 10, dest_cb+8+dct_offset, dct_linesize);                            add_dct(s, block[11], 11, dest_cr+8+dct_offset, dct_linesize);                        }                    }                }//fi gray            }            else if (ENABLE_WMV2) {                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);            }        } else {            /* dct only in intra block */            if(s->encoding || !(s->codec_id==CODEC_ID_MPEG1VIDEO || s->codec_id==CODEC_ID_MPEG2VIDEO)){                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);                if(!(s->flags&CODEC_FLAG_GRAY)){                    if(s->chroma_y_shift){                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);                    }else{                        dct_offset >>=1;                        dct_linesize >>=1;                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);                    }                }            }else{                s->dsp.idct_put(dest_y                          , dct_linesize, block[0]);                s->dsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);                s->dsp.idct_put(dest_y + dct_offset             , dct_linesize, block[2]);                s->dsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);                if(!(s->flags&CODEC_FLAG_GRAY)){                    if(s->chroma_y_shift){                        s->dsp.idct_put(dest_cb, uvlinesize, block[4]);                        s->dsp.idct_put(dest_cr, uvlinesize, block[5]);                    }else{                        dct_linesize = uvlinesize << s->interlaced_dct;                        dct_offset =(s->interlaced_dct)? uvlinesize : uvlinesize*8;                        s->dsp.idct_put(dest_cb,              dct_linesize, block[4]);                        s->dsp.idct_put(dest_cr,              dct_linesize, block[5]);                        s->dsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);                        s->dsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);                        if(!s->chroma_x_shift){//Chroma444                            s->dsp.idct_put(dest_cb + 8,              dct_linesize, block[8]);                            s->dsp.idct_put(dest_cr + 8,              dct_linesize, block[9]);                            s->dsp.idct_put(dest_cb + 8 + dct_offset, dct_linesize, block[10]);                            s->dsp.idct_put(dest_cr + 8 + dct_offset, dct_linesize, block[11]);                        }                    }                }//gray            }        }skip_idct:        if(!readable){            s->dsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);            s->dsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);            s->dsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);        }    }}", "idx": 4729}
{"project": "qemu", "commit_id": "e7d81004e486b0e80a674d164d8aec0e83fa812f", "target": 1, "function": "static void audio_pp_nb_voices (const char *typ, int nb){    switch (nb) {    case 0:        printf (\"Does not support %s\\n\", typ);        break;    case 1:        printf (\"One %s voice\\n\", typ);        break;    case INT_MAX:        printf (\"Theoretically supports many %s voices\\n\", typ);        break;    default:        printf (\"Theoretically supports upto %d %s voices\\n\", nb, typ);        break;    }}", "idx": 4778}
{"project": "qemu", "commit_id": "f0aa7a8b2d518c54430e4382309281b93e51981a", "target": 1, "function": "static void do_loadvm(Monitor *mon, const QDict *qdict){    int saved_vm_running  = vm_running;    const char *name = qdict_get_str(qdict, \"name\");    vm_stop(0);    if (load_vmstate(name) >= 0 && saved_vm_running)        vm_start();}", "idx": 4877}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "function": "int inet_connect(const char *str, bool block, Error **errp){    QemuOpts *opts;    int sock = -1;    opts = qemu_opts_create(&dummy_opts, NULL, 0, NULL);    if (inet_parse(opts, str) == 0) {        if (block) {            qemu_opt_set(opts, \"block\", \"on\");        }        sock = inet_connect_opts(opts, errp);    } else {        error_set(errp, QERR_SOCKET_CREATE_FAILED);    }    qemu_opts_del(opts);    return sock;}", "idx": 4943}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "function": "av_cold void rgb2rgb_init_x86(void){#if HAVE_INLINE_ASM    int cpu_flags = av_get_cpu_flags();    if (cpu_flags & AV_CPU_FLAG_MMX)        rgb2rgb_init_MMX();    if (HAVE_AMD3DNOW && cpu_flags & AV_CPU_FLAG_3DNOW)        rgb2rgb_init_3DNOW();    if (HAVE_MMXEXT   && cpu_flags & AV_CPU_FLAG_MMXEXT)        rgb2rgb_init_MMX2();    if (HAVE_SSE      && cpu_flags & AV_CPU_FLAG_SSE2)        rgb2rgb_init_SSE2();#endif /* HAVE_INLINE_ASM */}", "idx": 5055}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "function": "void qemu_ram_free_from_ptr(ram_addr_t addr){    RAMBlock *block;    /* This assumes the iothread lock is taken here too.  */    qemu_mutex_lock_ramlist();    QTAILQ_FOREACH(block, &ram_list.blocks, next) {        if (addr == block->offset) {            QTAILQ_REMOVE(&ram_list.blocks, block, next);            ram_list.mru_block = NULL;            ram_list.version++;            g_free(block);            break;        }    }    qemu_mutex_unlock_ramlist();}", "idx": 5088}
{"project": "FFmpeg", "commit_id": "81d4b3af81b52a79f11705ef02d3f48747047404", "target": 1, "function": "static void qpeg_decode_inter(const uint8_t *src, uint8_t *dst, int size,                            int stride, int width, int height,                            int delta, const uint8_t *ctable, uint8_t *refdata){    int i, j;    int code;    int filled = 0;    int orig_height;    if(!refdata)        refdata= dst;    /* copy prev frame */    for(i = 0; i < height; i++)        memcpy(dst + (i * stride), refdata + (i * stride), width);    orig_height = height;    height--;    dst = dst + height * stride;    while((size > 0) && (height >= 0)) {        code = *src++;        size--;        if(delta) {            /* motion compensation */            while((code & 0xF0) == 0xF0) {                if(delta == 1) {                    int me_idx;                    int me_w, me_h, me_x, me_y;                    uint8_t *me_plane;                    int corr, val;                    /* get block size by index */                    me_idx = code & 0xF;                    me_w = qpeg_table_w[me_idx];                    me_h = qpeg_table_h[me_idx];                    /* extract motion vector */                    corr = *src++;                    size--;                    val = corr >> 4;                    if(val > 7)                        val -= 16;                    me_x = val;                    val = corr & 0xF;                    if(val > 7)                        val -= 16;                    me_y = val;                    /* check motion vector */                    if ((me_x + filled < 0) || (me_x + me_w + filled > width) ||                       (height - me_y - me_h < 0) || (height - me_y > orig_height) ||                       (filled + me_w > width) || (height - me_h < 0))                        av_log(NULL, AV_LOG_ERROR, \"Bogus motion vector (%i,%i), block size %ix%i at %i,%i\\n\",                               me_x, me_y, me_w, me_h, filled, height);                    else {                        /* do motion compensation */                        me_plane = refdata + (filled + me_x) + (height - me_y) * stride;                        for(j = 0; j < me_h; j++) {                            for(i = 0; i < me_w; i++)                                dst[filled + i - (j * stride)] = me_plane[i - (j * stride)];                        }                    }                }                code = *src++;                size--;            }        }        if(code == 0xE0) /* end-of-picture code */            break;        if(code > 0xE0) { /* run code: 0xE1..0xFF */            int p;            code &= 0x1F;            p = *src++;            size--;            for(i = 0; i <= code; i++) {                dst[filled++] = p;                if(filled >= width) {                    filled = 0;                    dst -= stride;                    height--;                    if(height < 0)                        break;                }            }        } else if(code >= 0xC0) { /* copy code: 0xC0..0xDF */            code &= 0x1F;            for(i = 0; i <= code; i++) {                dst[filled++] = *src++;                if(filled >= width) {                    filled = 0;                    dst -= stride;                    height--;                    if(height < 0)                        break;                }            }            size -= code + 1;        } else if(code >= 0x80) { /* skip code: 0x80..0xBF */            int skip;            code &= 0x3F;            /* codes 0x80 and 0x81 are actually escape codes,               skip value minus constant is in the next byte */            if(!code)                skip = (*src++) + 64;            else if(code == 1)                skip = (*src++) + 320;            else                skip = code;            filled += skip;            while( filled >= width) {                filled -= width;                dst -= stride;                height--;                if(height < 0)                    break;            }        } else {            /* zero code treated as one-pixel skip */            if(code)                dst[filled++] = ctable[code & 0x7F];            else                filled++;            if(filled >= width) {                filled = 0;                dst -= stride;                height--;            }        }    }}", "idx": 5164}
{"project": "FFmpeg", "commit_id": "aed84ee4d1b0c9e315a84b1ee0918fa49ee9cc09", "target": 1, "function": "static int svq1_decode_block_non_intra(GetBitContext *bitbuf, uint8_t *pixels,                                       ptrdiff_t pitch){    uint32_t bit_cache;    uint8_t *list[63];    uint32_t *dst;    const uint32_t *codebook;    int entries[6];    int i, j, m, n;    int stages;    unsigned mean;    int x, y, width, height, level;    uint32_t n1, n2, n3, n4;    /* initialize list for breadth first processing of vectors */    list[0] = pixels;    /* recursively process vector */    for (i = 0, m = 1, n = 1, level = 5; i < n; i++) {        SVQ1_PROCESS_VECTOR();        /* destination address and vector size */        dst    = (uint32_t *)list[i];        width  = 1 << ((4 + level) / 2);        height = 1 << ((3 + level) / 2);        /* get number of stages (-1 skips vector, 0 for mean only) */        stages = get_vlc2(bitbuf, svq1_inter_multistage[level].table, 3, 2) - 1;        if (stages == -1)            continue;           /* skip vector */        if ((stages > 0 && level >= 4)) {            ff_dlog(NULL,                    \"Error (svq1_decode_block_non_intra): invalid vector: stages=%i level=%i\\n\",                    stages, level);            return AVERROR_INVALIDDATA;  /* invalid vector */        }        av_assert0(stages >= 0);        mean = get_vlc2(bitbuf, svq1_inter_mean.table, 9, 3) - 256;        SVQ1_CALC_CODEBOOK_ENTRIES(ff_svq1_inter_codebooks);        for (y = 0; y < height; y++) {            for (x = 0; x < width / 4; x++, codebook++) {                n3 = dst[x];                /* add mean value to vector */                n1 = n4 + ((n3 & 0xFF00FF00) >> 8);                n2 = n4 +  (n3 & 0x00FF00FF);                SVQ1_ADD_CODEBOOK()                /* store result */                dst[x] = n1 << 8 | n2;            }            dst += pitch / 4;        }    }    return 0;}", "idx": 5179}
{"project": "qemu", "commit_id": "c6e484707f28b3e115e64122a0570f6b3c585489", "target": 0, "function": "static void qemu_spice_create_update(SimpleSpiceDisplay *ssd){    static const int blksize = 32;    int blocks = (surface_width(ssd->ds) + blksize - 1) / blksize;    int dirty_top[blocks];    int y, yoff, x, xoff, blk, bw;    int bpp = surface_bytes_per_pixel(ssd->ds);    uint8_t *guest, *mirror;    if (qemu_spice_rect_is_empty(&ssd->dirty)) {        return;    };    for (blk = 0; blk < blocks; blk++) {        dirty_top[blk] = -1;    }    guest = surface_data(ssd->ds);    mirror = (void *)pixman_image_get_data(ssd->mirror);    for (y = ssd->dirty.top; y < ssd->dirty.bottom; y++) {        yoff = y * surface_stride(ssd->ds);        for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {            xoff = x * bpp;            blk = x / blksize;            bw = MIN(blksize, ssd->dirty.right - x);            if (memcmp(guest + yoff + xoff,                       mirror + yoff + xoff,                       bw * bpp) == 0) {                if (dirty_top[blk] != -1) {                    QXLRect update = {                        .top    = dirty_top[blk],                        .bottom = y,                        .left   = x,                        .right  = x + bw,                    };                    qemu_spice_create_one_update(ssd, &update);                    dirty_top[blk] = -1;                }            } else {                if (dirty_top[blk] == -1) {                    dirty_top[blk] = y;                }            }        }    }    for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {        blk = x / blksize;        bw = MIN(blksize, ssd->dirty.right - x);        if (dirty_top[blk] != -1) {            QXLRect update = {                .top    = dirty_top[blk],                .bottom = ssd->dirty.bottom,                .left   = x,                .right  = x + bw,            };            qemu_spice_create_one_update(ssd, &update);            dirty_top[blk] = -1;        }    }    memset(&ssd->dirty, 0, sizeof(ssd->dirty));}", "idx": 5230}
{"project": "FFmpeg", "commit_id": "80c702efeb7b4d9edaae52ed5d8dd081a2ccb64b", "target": 0, "function": "static void vc1_inv_trans_4x8_c(uint8_t *dest, int linesize, DCTELEM *block){    int i;    register int t1,t2,t3,t4,t5,t6,t7,t8;    DCTELEM *src, *dst;    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    src = block;    dst = block;    for(i = 0; i < 8; i++){        t1 = 17 * (src[0] + src[2]) + 4;        t2 = 17 * (src[0] - src[2]) + 4;        t3 = 22 * src[1] + 10 * src[3];        t4 = 22 * src[3] - 10 * src[1];        dst[0] = (t1 + t3) >> 3;        dst[1] = (t2 - t4) >> 3;        dst[2] = (t2 + t4) >> 3;        dst[3] = (t1 - t3) >> 3;        src += 8;        dst += 8;    }    src = block;    for(i = 0; i < 4; i++){        t1 = 12 * (src[ 0] + src[32]) + 64;        t2 = 12 * (src[ 0] - src[32]) + 64;        t3 = 16 * src[16] +  6 * src[48];        t4 =  6 * src[16] - 16 * src[48];        t5 = t1 + t3;        t6 = t2 + t4;        t7 = t2 - t4;        t8 = t1 - t3;        t1 = 16 * src[ 8] + 15 * src[24] +  9 * src[40] +  4 * src[56];        t2 = 15 * src[ 8] -  4 * src[24] - 16 * src[40] -  9 * src[56];        t3 =  9 * src[ 8] - 16 * src[24] +  4 * src[40] + 15 * src[56];        t4 =  4 * src[ 8] -  9 * src[24] + 15 * src[40] - 16 * src[56];        dest[0*linesize] = cm[dest[0*linesize] + ((t5 + t1) >> 7)];        dest[1*linesize] = cm[dest[1*linesize] + ((t6 + t2) >> 7)];        dest[2*linesize] = cm[dest[2*linesize] + ((t7 + t3) >> 7)];        dest[3*linesize] = cm[dest[3*linesize] + ((t8 + t4) >> 7)];        dest[4*linesize] = cm[dest[4*linesize] + ((t8 - t4 + 1) >> 7)];        dest[5*linesize] = cm[dest[5*linesize] + ((t7 - t3 + 1) >> 7)];        dest[6*linesize] = cm[dest[6*linesize] + ((t6 - t2 + 1) >> 7)];        dest[7*linesize] = cm[dest[7*linesize] + ((t5 - t1 + 1) >> 7)];        src ++;        dest++;    }}", "idx": 5268}
{"project": "qemu", "commit_id": "94ad93bd976841c26af75322301f5aad925114d6", "target": 0, "function": "void spapr_core_release(DeviceState *dev){    MachineState *ms = MACHINE(qdev_get_hotplug_handler(dev));    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(ms);    CPUCore *cc = CPU_CORE(dev);    CPUArchId *core_slot = spapr_find_cpu_slot(ms, cc->core_id, NULL);    if (smc->pre_2_10_has_unused_icps) {        sPAPRCPUCore *sc = SPAPR_CPU_CORE(OBJECT(dev));        sPAPRCPUCoreClass *scc = SPAPR_CPU_CORE_GET_CLASS(OBJECT(cc));        size_t size = object_type_get_instance_size(scc->cpu_type);        int i;        for (i = 0; i < cc->nr_threads; i++) {            CPUState *cs = CPU(sc->threads + i * size);            pre_2_10_vmstate_register_dummy_icp(cs->cpu_index);        }    }    assert(core_slot);    core_slot->cpu = NULL;    object_unparent(OBJECT(dev));}", "idx": 5307}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "function": "static int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type){    int is_read = (type == SCSI_REQ_STATUS_RETRY_READ);    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);    BlockErrorAction action = bdrv_get_on_error(s->bs, is_read);    if (action == BLOCK_ERR_IGNORE) {        bdrv_mon_event(s->bs, BDRV_ACTION_IGNORE, is_read);        return 0;    }    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)            || action == BLOCK_ERR_STOP_ANY) {        type &= SCSI_REQ_STATUS_RETRY_TYPE_MASK;        r->status |= SCSI_REQ_STATUS_RETRY | type;        bdrv_mon_event(s->bs, BDRV_ACTION_STOP, is_read);        vm_stop(VMSTOP_DISKFULL);    } else {        if (type == SCSI_REQ_STATUS_RETRY_READ) {            scsi_req_data(&r->req, 0);        }        scsi_command_complete(r, CHECK_CONDITION,                HARDWARE_ERROR);        bdrv_mon_event(s->bs, BDRV_ACTION_REPORT, is_read);    }    return 1;}", "idx": 5341}
{"project": "qemu", "commit_id": "ae50b2747f77944faa79eb914272b54eb30b63b3", "target": 1, "function": "VLANClientState *qdev_get_vlan_client(DeviceState *dev,                                      NetCanReceive *can_receive,                                      NetReceive *receive,                                      NetReceiveIOV *receive_iov,                                      NetCleanup *cleanup,                                      void *opaque){    NICInfo *nd = dev->nd;    assert(nd);    return qemu_new_vlan_client(nd->vlan, nd->model, nd->name, can_receive,                                receive, receive_iov, cleanup, opaque);}", "idx": 5346}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "function": "void do_POWER_divo (void){    int64_t tmp;    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {        T0 = (long)((-1) * (T0 >> 31));        env->spr[SPR_MQ] = 0;        xer_ov = 1;        xer_so = 1;    } else {        tmp = ((uint64_t)T0 << 32) | env->spr[SPR_MQ];        env->spr[SPR_MQ] = tmp % T1;        tmp /= Ts1;        if (tmp > (int64_t)INT32_MAX || tmp < (int64_t)INT32_MIN) {            xer_ov = 1;            xer_so = 1;        } else {            xer_ov = 0;        }        T0 = tmp;    }}", "idx": 5423}
{"project": "FFmpeg", "commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "target": 1, "function": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p){    int ret = 0;    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {        AVIOContext pb;        RTSPState *rt = s->priv_data;        AVDictionary *opts = NULL;        int len = strlen(p) * 6 / 8;        char *buf = av_mallocz(len);        AVInputFormat *iformat;        if (!buf)            return AVERROR(ENOMEM);        av_base64_decode(buf, p, len);        if (rtp_asf_fix_header(buf, len) < 0)            av_log(s, AV_LOG_ERROR,                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");        init_packetizer(&pb, buf, len);        if (rt->asf_ctx) {            avformat_close_input(&rt->asf_ctx);        }        if (!(iformat = av_find_input_format(\"asf\")))            return AVERROR_DEMUXER_NOT_FOUND;        rt->asf_ctx = avformat_alloc_context();        if (!rt->asf_ctx) {            av_free(buf);            return AVERROR(ENOMEM);        }        rt->asf_ctx->pb      = &pb;        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {            av_dict_free(&opts);            return ret;        }        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);        av_dict_free(&opts);        if (ret < 0) {            av_free(buf);            return ret;        }        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);        rt->asf_pb_pos = avio_tell(&pb);        av_free(buf);        rt->asf_ctx->pb = NULL;    }    return ret;}", "idx": 5437}
{"project": "qemu", "commit_id": "bdfd065b1f75cacca21af0b8d4811c64cc48d04c", "target": 0, "function": "static void nvdimm_build_ssdt(GSList *device_list, GArray *table_offsets,                              GArray *table_data, BIOSLinker *linker,                              GArray *dsm_dma_arrea){    Aml *ssdt, *sb_scope, *dev;    int mem_addr_offset, nvdimm_ssdt;    acpi_add_table(table_offsets, table_data);    ssdt = init_aml_allocator();    acpi_data_push(ssdt->buf, sizeof(AcpiTableHeader));    sb_scope = aml_scope(\"\\\\_SB\");    dev = aml_device(\"NVDR\");    /*     * ACPI 6.0: 9.20 NVDIMM Devices:     *     * The ACPI Name Space device uses _HID of ACPI0012 to identify the root     * NVDIMM interface device. Platform firmware is required to contain one     * such device in _SB scope if NVDIMMs support is exposed by platform to     * OSPM.     * For each NVDIMM present or intended to be supported by platform,     * platform firmware also exposes an ACPI Namespace Device under the     * root device.     */    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"ACPI0012\")));    nvdimm_build_common_dsm(dev);    /* 0 is reserved for root device. */    nvdimm_build_device_dsm(dev, 0);    nvdimm_build_nvdimm_devices(device_list, dev);    aml_append(sb_scope, dev);    aml_append(ssdt, sb_scope);    nvdimm_ssdt = table_data->len;    /* copy AML table into ACPI tables blob and patch header there */    g_array_append_vals(table_data, ssdt->buf->data, ssdt->buf->len);    mem_addr_offset = build_append_named_dword(table_data,                                               NVDIMM_ACPI_MEM_ADDR);    bios_linker_loader_alloc(linker,                             NVDIMM_DSM_MEM_FILE, dsm_dma_arrea,                             sizeof(NvdimmDsmIn), false /* high memory */);    bios_linker_loader_add_pointer(linker,        ACPI_BUILD_TABLE_FILE, mem_addr_offset, sizeof(uint32_t),        NVDIMM_DSM_MEM_FILE, 0);    build_header(linker, table_data,        (void *)(table_data->data + nvdimm_ssdt),        \"SSDT\", table_data->len - nvdimm_ssdt, 1, NULL, \"NVDIMM\");    free_aml_allocator();}", "idx": 5466}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "function": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags){    BDRVDMGState *s = bs->opaque;    off_t info_begin,info_end,last_in_offset,last_out_offset;    uint32_t count;    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;    int64_t offset;    s->fd = open(filename, O_RDONLY | O_BINARY);    if (s->fd < 0)        return -errno;    bs->read_only = 1;    s->n_chunks = 0;    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;    /* read offset of info blocks */    offset = lseek(s->fd, -0x1d8, SEEK_END);    if (offset < 0) {        goto fail;    }    info_begin = read_off(s->fd, offset);    if (info_begin == 0) {\tgoto fail;    }    if (read_uint32(s->fd, info_begin) != 0x100) {        goto fail;    }    count = read_uint32(s->fd, info_begin + 4);    if (count == 0) {        goto fail;    }    info_end = info_begin + count;    offset = info_begin + 0x100;    /* read offsets */    last_in_offset = last_out_offset = 0;    while (offset < info_end) {        uint32_t type;\tcount = read_uint32(s->fd, offset);\tif(count==0)\t    goto fail;        offset += 4;\ttype = read_uint32(s->fd, offset);\tif (type == 0x6d697368 && count >= 244) {\t    int new_size, chunk_count;            offset += 4;            offset += 200;\t    chunk_count = (count-204)/40;\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\t    s->types = qemu_realloc(s->types, new_size/2);\t    s->offsets = qemu_realloc(s->offsets, new_size);\t    s->lengths = qemu_realloc(s->lengths, new_size);\t    s->sectors = qemu_realloc(s->sectors, new_size);\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\t\ts->types[i] = read_uint32(s->fd, offset);\t\toffset += 4;\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\t\t    if(s->types[i]==0xffffffff) {\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\t\t    }\t\t    chunk_count--;\t\t    i--;\t\t    offset += 36;\t\t    continue;\t\t}\t\toffset += 4;\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\t\toffset += 8;\t\ts->sectorcounts[i] = read_off(s->fd, offset);\t\toffset += 8;\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\t\toffset += 8;\t\ts->lengths[i] = read_off(s->fd, offset);\t\toffset += 8;\t\tif(s->lengths[i]>max_compressed_size)\t\t    max_compressed_size = s->lengths[i];\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\t\t    max_sectors_per_chunk = s->sectorcounts[i];\t    }\t    s->n_chunks+=chunk_count;\t}    }    /* initialize zlib engine */    s->compressed_chunk = qemu_malloc(max_compressed_size+1);    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);    if(inflateInit(&s->zstream) != Z_OK)\tgoto fail;    s->current_chunk = s->n_chunks;    return 0;fail:    close(s->fd);    return -1;}", "idx": 5482}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "function": "static void vmgenid_set_guid_test(void){    QemuUUID expected, measured;    gchar *cmd;    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"                          \"guid=%s\", VGID_GUID);    qtest_start(cmd);    /* Read the GUID from accessing guest memory */    read_guid_from_memory(&measured);    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);    qtest_quit(global_qtest);    g_free(cmd);}", "idx": 5497}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "function": "static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *pkt){    OutputFile *of = output_files[ost->file_index];    int64_t ost_tb_start_time = av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);    AVPacket opkt;    av_init_packet(&opkt);    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) &&        !ost->copy_initial_nonkeyframes)        return;    if (of->recording_time != INT64_MAX &&        ist->last_dts >= of->recording_time + of->start_time) {        ost->finished = 1;        return;    }    /* force the input stream PTS */    if (ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)        audio_size += pkt->size;    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {        video_size += pkt->size;        ost->sync_opts++;    }    if (pkt->pts != AV_NOPTS_VALUE)        opkt.pts = av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;    else        opkt.pts = AV_NOPTS_VALUE;    if (pkt->dts == AV_NOPTS_VALUE)        opkt.dts = av_rescale_q(ist->last_dts, AV_TIME_BASE_Q, ost->st->time_base);    else        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);    opkt.dts -= ost_tb_start_time;    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);    opkt.flags    = pkt->flags;    // FIXME remove the following 2 lines they shall be replaced by the bitstream filters    if (  ost->st->codec->codec_id != AV_CODEC_ID_H264       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG1VIDEO       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG2VIDEO       && ost->st->codec->codec_id != AV_CODEC_ID_VC1       ) {        if (av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY)) {            opkt.buf = av_buffer_create(opkt.data, opkt.size, av_buffer_default_free, NULL, 0);            if (!opkt.buf)                exit(1);        }    } else {        opkt.data = pkt->data;        opkt.size = pkt->size;    }    write_frame(of->ctx, &opkt, ost);    ost->st->codec->frame_number++;}", "idx": 5503}
{"project": "FFmpeg", "commit_id": "e481ba2ed79421d82ed631d187c05c03260c6561", "target": 1, "function": "static int vqf_read_header(AVFormatContext *s){    VqfContext *c = s->priv_data;    AVStream *st  = avformat_new_stream(s, NULL);    int chunk_tag;    int rate_flag = -1;    int header_size;    int read_bitrate = 0;    int size;    uint8_t comm_chunk[12];    if (!st)        return AVERROR(ENOMEM);    avio_skip(s->pb, 12);    header_size = avio_rb32(s->pb);    st->codec->codec_type = AVMEDIA_TYPE_AUDIO;    st->codec->codec_id   = AV_CODEC_ID_TWINVQ;    st->start_time = 0;    do {        int len;        chunk_tag = avio_rl32(s->pb);        if (chunk_tag == MKTAG('D','A','T','A'))            break;        len = avio_rb32(s->pb);        if ((unsigned) len > INT_MAX/2) {            av_log(s, AV_LOG_ERROR, \"Malformed header\\n\");        header_size -= 8;        switch(chunk_tag){        case MKTAG('C','O','M','M'):            avio_read(s->pb, comm_chunk, 12);            st->codec->channels = AV_RB32(comm_chunk    ) + 1;            read_bitrate        = AV_RB32(comm_chunk + 4);            rate_flag           = AV_RB32(comm_chunk + 8);            avio_skip(s->pb, len-12);            st->codec->bit_rate              = read_bitrate*1000;            break;        case MKTAG('D','S','I','Z'): // size of compressed data        {            char buf[8] = {0};            int size = avio_rb32(s->pb);            snprintf(buf, sizeof(buf), \"%d\", size);            av_dict_set(&s->metadata, \"size\", buf, 0);            break;        case MKTAG('Y','E','A','R'): // recording date        case MKTAG('E','N','C','D'): // compression date        case MKTAG('E','X','T','R'): // reserved        case MKTAG('_','Y','M','H'): // reserved        case MKTAG('_','N','T','T'): // reserved        case MKTAG('_','I','D','3'): // reserved for ID3 tags            avio_skip(s->pb, FFMIN(len, header_size));            break;        default:            add_metadata(s, chunk_tag, len, header_size);            break;        header_size -= len;    } while (header_size >= 0);    switch (rate_flag) {    case -1:        av_log(s, AV_LOG_ERROR, \"COMM tag not found!\\n\");    case 44:        st->codec->sample_rate = 44100;        break;    case 22:        st->codec->sample_rate = 22050;        break;    case 11:        st->codec->sample_rate = 11025;        break;    default:        st->codec->sample_rate = rate_flag*1000;        break;    switch (((st->codec->sample_rate/1000) << 8) +            read_bitrate/st->codec->channels) {    case (11<<8) + 8 :    case (8 <<8) + 8 :    case (11<<8) + 10:    case (22<<8) + 32:        size = 512;        break;    case (16<<8) + 16:    case (22<<8) + 20:    case (22<<8) + 24:        size = 1024;        break;    case (44<<8) + 40:    case (44<<8) + 48:        size = 2048;        break;    default:        av_log(s, AV_LOG_ERROR, \"Mode not suported: %d Hz, %d kb/s.\\n\",               st->codec->sample_rate, st->codec->bit_rate);    c->frame_bit_len = st->codec->bit_rate*size/st->codec->sample_rate;    avpriv_set_pts_info(st, 64, size, st->codec->sample_rate);    /* put first 12 bytes of COMM chunk in extradata */    if (!(st->codec->extradata = av_malloc(12 + FF_INPUT_BUFFER_PADDING_SIZE)))        return AVERROR(ENOMEM);    st->codec->extradata_size = 12;    memcpy(st->codec->extradata, comm_chunk, 12);    ff_metadata_conv_ctx(s, NULL, vqf_metadata_conv);    return 0;", "idx": 5515}
{"project": "qemu", "commit_id": "c804c2a71752dd1e150cde768d8c54b02fa8bad9", "target": 1, "function": "static int event_qdev_exit(DeviceState *qdev){    SCLPEvent *event = DO_UPCAST(SCLPEvent, qdev, qdev);    SCLPEventClass *child = SCLP_EVENT_GET_CLASS(event);    if (child->exit) {        child->exit(event);    }    return 0;}", "idx": 5522}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "function": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs){    bs->detect_zeroes = blk->root_state.detect_zeroes;}", "idx": 5581}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "function": "static void gen_flt3_arith (DisasContext *ctx, uint32_t opc, int fd,                            int fr, int fs, int ft){    const char *opn = \"flt3_arith\";    /* All of those work only on 64bit FPUs. */    gen_op_cp1_64bitmode();    switch (opc) {    case OPC_ALNV_PS:        GEN_LOAD_REG_TN(T0, fr);        GEN_LOAD_FREG_FTN(DT0, fs);        GEN_LOAD_FREG_FTN(DT1, ft);        gen_op_float_alnv_ps();        GEN_STORE_FTN_FREG(fd, DT2);        opn = \"alnv.ps\";        break;    case OPC_MADD_S:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        gen_op_float_muladd_s();        GEN_STORE_FTN_FREG(fd, WT2);        opn = \"madd.s\";        break;    case OPC_MADD_D:        GEN_LOAD_FREG_FTN(DT0, fs);        GEN_LOAD_FREG_FTN(DT1, ft);        GEN_LOAD_FREG_FTN(DT2, fr);        gen_op_float_muladd_d();        GEN_STORE_FTN_FREG(fd, DT2);        opn = \"madd.d\";        break;    case OPC_MADD_PS:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WTH0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WTH1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        GEN_LOAD_FREG_FTN(WTH2, fr);        gen_op_float_muladd_ps();        GEN_STORE_FTN_FREG(fd, WT2);        GEN_STORE_FTN_FREG(fd, WTH2);        opn = \"madd.ps\";        break;    case OPC_MSUB_S:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        gen_op_float_mulsub_s();        GEN_STORE_FTN_FREG(fd, WT2);        opn = \"msub.s\";        break;    case OPC_MSUB_D:        GEN_LOAD_FREG_FTN(DT0, fs);        GEN_LOAD_FREG_FTN(DT1, ft);        GEN_LOAD_FREG_FTN(DT2, fr);        gen_op_float_mulsub_d();        GEN_STORE_FTN_FREG(fd, DT2);        opn = \"msub.d\";        break;    case OPC_MSUB_PS:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WTH0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WTH1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        GEN_LOAD_FREG_FTN(WTH2, fr);        gen_op_float_mulsub_ps();        GEN_STORE_FTN_FREG(fd, WT2);        GEN_STORE_FTN_FREG(fd, WTH2);        opn = \"msub.ps\";        break;    case OPC_NMADD_S:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        gen_op_float_nmuladd_s();        GEN_STORE_FTN_FREG(fd, WT2);        opn = \"nmadd.s\";        break;    case OPC_NMADD_D:        GEN_LOAD_FREG_FTN(DT0, fs);        GEN_LOAD_FREG_FTN(DT1, ft);        GEN_LOAD_FREG_FTN(DT2, fr);        gen_op_float_nmuladd_d();        GEN_STORE_FTN_FREG(fd, DT2);        opn = \"nmadd.d\";        break;    case OPC_NMADD_PS:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WTH0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WTH1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        GEN_LOAD_FREG_FTN(WTH2, fr);        gen_op_float_nmuladd_ps();        GEN_STORE_FTN_FREG(fd, WT2);        GEN_STORE_FTN_FREG(fd, WTH2);        opn = \"nmadd.ps\";        break;    case OPC_NMSUB_S:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        gen_op_float_nmulsub_s();        GEN_STORE_FTN_FREG(fd, WT2);        opn = \"nmsub.s\";        break;    case OPC_NMSUB_D:        GEN_LOAD_FREG_FTN(DT0, fs);        GEN_LOAD_FREG_FTN(DT1, ft);        GEN_LOAD_FREG_FTN(DT2, fr);        gen_op_float_nmulsub_d();        GEN_STORE_FTN_FREG(fd, DT2);        opn = \"nmsub.d\";        break;    case OPC_NMSUB_PS:        GEN_LOAD_FREG_FTN(WT0, fs);        GEN_LOAD_FREG_FTN(WTH0, fs);        GEN_LOAD_FREG_FTN(WT1, ft);        GEN_LOAD_FREG_FTN(WTH1, ft);        GEN_LOAD_FREG_FTN(WT2, fr);        GEN_LOAD_FREG_FTN(WTH2, fr);        gen_op_float_nmulsub_ps();        GEN_STORE_FTN_FREG(fd, WT2);        GEN_STORE_FTN_FREG(fd, WTH2);        opn = \"nmsub.ps\";        break;    default:        MIPS_INVAL(opn);        generate_exception (ctx, EXCP_RI);        return;    }    MIPS_DEBUG(\"%s %s, %s, %s, %s\", opn, fregnames[fd], fregnames[fr],               fregnames[fs], fregnames[ft]);}", "idx": 5656}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void nvic_sysreg_write(void *opaque, target_phys_addr_t addr,                              uint64_t value, unsigned size){    uint32_t offset = addr;    if (size == 4) {        nvic_writel(opaque, offset, value);        return;    }    hw_error(\"NVIC: Bad write of size %d at offset 0x%x\\n\", size, offset);}", "idx": 5660}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "function": "static void xtensa_lx200_init(MachineState *machine){    static const LxBoardDesc lx200_board = {        .flash_base = 0xf8000000,        .flash_size = 0x01000000,        .flash_sector_size = 0x20000,        .sram_size = 0x2000000,    };    lx_init(&lx200_board, machine);}", "idx": 5679}
{"project": "qemu", "commit_id": "9aaaa181949e4a23ca298fb7006e2d8bac842e92", "target": 0, "function": "static inline TCGv *compute_ldst_addr(DisasContext *dc, TCGv *t){    unsigned int extimm = dc->tb_flags & IMM_FLAG;    /* Should be set to one if r1 is used by loadstores.  */    int stackprot = 0;    /* All load/stores use ra.  */    if (dc->ra == 1) {        stackprot = 1;    }    /* Treat the common cases first.  */    if (!dc->type_b) {        /* If any of the regs is r0, return a ptr to the other.  */        if (dc->ra == 0) {            return &cpu_R[dc->rb];        } else if (dc->rb == 0) {            return &cpu_R[dc->ra];        }        if (dc->rb == 1) {            stackprot = 1;        }        *t = tcg_temp_new();        tcg_gen_add_tl(*t, cpu_R[dc->ra], cpu_R[dc->rb]);        if (stackprot) {            gen_helper_stackprot(cpu_env, *t);        }        return t;    }    /* Immediate.  */    if (!extimm) {        if (dc->imm == 0) {            return &cpu_R[dc->ra];        }        *t = tcg_temp_new();        tcg_gen_movi_tl(*t, (int32_t)((int16_t)dc->imm));        tcg_gen_add_tl(*t, cpu_R[dc->ra], *t);    } else {        *t = tcg_temp_new();        tcg_gen_add_tl(*t, cpu_R[dc->ra], *(dec_alu_op_b(dc)));    }    if (stackprot) {        gen_helper_stackprot(cpu_env, *t);    }    return t;}", "idx": 5680}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "function": "static inline void mix_3f_1r_to_dolby(AC3DecodeContext *ctx){    int i;    float (*output)[256] = ctx->audio_block.block_output;    for (i = 0; i < 256; i++) {        output[1][i] += (output[2][i] - output[4][i]);        output[2][i] += (output[3][i] + output[4][i]);    }    memset(output[3], 0, sizeof(output[3]));    memset(output[4], 0, sizeof(output[4]));}", "idx": 5747}
{"project": "qemu", "commit_id": "a32ef3bfc12c8d0588f43f74dcc5280885bbdb30", "target": 1, "function": "static void smp_parse(QemuOpts *opts){    if (opts) {        unsigned cpus    = qemu_opt_get_number(opts, \"cpus\", 0);        unsigned sockets = qemu_opt_get_number(opts, \"sockets\", 0);        unsigned cores   = qemu_opt_get_number(opts, \"cores\", 0);        unsigned threads = qemu_opt_get_number(opts, \"threads\", 0);        /* compute missing values, prefer sockets over cores over threads */        if (cpus == 0 || sockets == 0) {            sockets = sockets > 0 ? sockets : 1;            cores = cores > 0 ? cores : 1;            threads = threads > 0 ? threads : 1;            if (cpus == 0) {                cpus = cores * threads * sockets;            }        } else if (cores == 0) {            threads = threads > 0 ? threads : 1;            cores = cpus / (sockets * threads);        } else if (threads == 0) {            threads = cpus / (cores * sockets);        } else if (sockets * cores * threads < cpus) {            fprintf(stderr, \"cpu topology: error: \"                    \"sockets (%u) * cores (%u) * threads (%u) < \"                    \"smp_cpus (%u)\\n\",                    sockets, cores, threads, cpus);            exit(1);        }        max_cpus = qemu_opt_get_number(opts, \"maxcpus\", 0);        smp_cpus = cpus;        smp_cores = cores > 0 ? cores : 1;        smp_threads = threads > 0 ? threads : 1;    }    if (max_cpus == 0) {        max_cpus = smp_cpus;    }    if (max_cpus > MAX_CPUMASK_BITS) {        fprintf(stderr, \"Unsupported number of maxcpus\\n\");        exit(1);    }    if (max_cpus < smp_cpus) {        fprintf(stderr, \"maxcpus must be equal to or greater than smp\\n\");        exit(1);    }}", "idx": 5750}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "function": "static av_cold int roq_encode_init(AVCodecContext *avctx){    RoqContext *enc = avctx->priv_data;    av_lfg_init(&enc->randctx, 1);    enc->framesSinceKeyframe = 0;    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");        return AVERROR(EINVAL);    if (avctx->width > 65535 || avctx->height > 65535) {        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);        return AVERROR(EINVAL);    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");    enc->width = avctx->width;    enc->height = avctx->height;    enc->framesSinceKeyframe = 0;    enc->first_frame = 1;    enc->last_frame    = av_frame_alloc();    enc->current_frame = av_frame_alloc();    if (!enc->last_frame || !enc->current_frame) {    enc->tmpData      = av_malloc(sizeof(RoqTempdata));    enc->this_motion4 =        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));    enc->last_motion4 =        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));    enc->this_motion8 =        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));    enc->last_motion8 =        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));    return 0;", "idx": 5754}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "function": "static int get_num(ByteIOContext *pb, int *len){    int n, n1;    n = get_be16(pb);    (*len)-=2;//    n &= 0x7FFF;    if (n >= 0x4000) {        return n - 0x4000;    } else {        n1 = get_be16(pb);        (*len)-=2;        return (n << 16) | n1;    }}", "idx": 5864}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "function": "static uint16_t nvme_dma_read_prp(NvmeCtrl *n, uint8_t *ptr, uint32_t len,    uint64_t prp1, uint64_t prp2){    QEMUSGList qsg;    QEMUIOVector iov;    uint16_t status = NVME_SUCCESS;    if (nvme_map_prp(&qsg, &iov, prp1, prp2, len, n)) {        return NVME_INVALID_FIELD | NVME_DNR;    }    if (qsg.nsg > 0) {        if (dma_buf_read(ptr, len, &qsg)) {            status = NVME_INVALID_FIELD | NVME_DNR;        }        qemu_sglist_destroy(&qsg);    } else {        if (qemu_iovec_to_buf(&iov, 0, ptr, len) != len) {            status = NVME_INVALID_FIELD | NVME_DNR;        }        qemu_iovec_destroy(&iov);    }    return status;}", "idx": 5937}
{"project": "qemu", "commit_id": "bb572aefbdac290363bfa5ca0e810ccce0a14ed6", "target": 1, "function": "static int64_t alloc_clusters_noref(BlockDriverState *bs, int64_t size){    BDRVQcowState *s = bs->opaque;    int i, nb_clusters, refcount;    nb_clusters = size_to_clusters(s, size);retry:    for(i = 0; i < nb_clusters; i++) {        int64_t next_cluster_index = s->free_cluster_index++;        refcount = get_refcount(bs, next_cluster_index);        if (refcount < 0) {            return refcount;        } else if (refcount != 0) {            goto retry;        }    }#ifdef DEBUG_ALLOC2    fprintf(stderr, \"alloc_clusters: size=%\" PRId64 \" -> %\" PRId64 \"\\n\",            size,            (s->free_cluster_index - nb_clusters) << s->cluster_bits);#endif    return (s->free_cluster_index - nb_clusters) << s->cluster_bits;}", "idx": 5947}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "function": "static void nfs_co_generic_bh_cb(void *opaque){    NFSRPC *task = opaque;    task->complete = 1;    qemu_bh_delete(task->bh);    qemu_coroutine_enter(task->co, NULL);}", "idx": 5976}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "function": "static int coroutine_fn bdrv_co_writev_em(BlockDriverState *bs,                                         int64_t sector_num, int nb_sectors,                                         QEMUIOVector *iov){    return bdrv_co_io_em(bs, sector_num, nb_sectors, iov, true);}", "idx": 6100}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "function": "static int virtio_rng_load(QEMUFile *f, void *opaque, int version_id){    if (version_id != 1) {        return -EINVAL;    }    return virtio_load(VIRTIO_DEVICE(opaque), f, version_id);}", "idx": 6123}
{"project": "FFmpeg", "commit_id": "03289958938e91dc9bc398fdf1489677c6030063", "target": 1, "function": "static void id3v2_read_ttag(AVFormatContext *s, int taglen, char *dst, int dstlen){    char *q;    int len;    if(dstlen > 0)        dst[0]= 0;    if(taglen < 1)        return;    taglen--; /* account for encoding type byte */    dstlen--; /* Leave space for zero terminator */    switch(get_byte(s->pb)) { /* encoding type */    case 0:  /* ISO-8859-1 (0 - 255 maps directly into unicode) */        q = dst;        while(taglen--) {            uint8_t tmp;            PUT_UTF8(get_byte(s->pb), tmp, if (q - dst < dstlen - 1) *q++ = tmp;)        }        *q = '\\0';        break;    case 3:  /* UTF-8 */        len = FFMIN(taglen, dstlen);        get_buffer(s->pb, dst, len);        dst[len] = 0;        break;    }}", "idx": 6173}
{"project": "qemu", "commit_id": "030ffe39dd4128eb90483af82a5b23b23054a466", "target": 1, "function": "static void tcg_out_movi_int(TCGContext *s, TCGType type, TCGReg ret,                             tcg_target_long arg, bool in_prologue){    intptr_t tb_diff;    tcg_target_long tmp;    int shift;    tcg_debug_assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);    if (TCG_TARGET_REG_BITS == 64 && type == TCG_TYPE_I32) {        arg = (int32_t)arg;    }    /* Load 16-bit immediates with one insn.  */    if (tcg_out_movi_one(s, ret, arg)) {        return;    }    /* Load addresses within the TB with one insn.  */    tb_diff = arg - (intptr_t)s->code_gen_ptr;    if (!in_prologue && USE_REG_TB && tb_diff == (int16_t)tb_diff) {        tcg_out32(s, ADDI | TAI(ret, TCG_REG_TB, tb_diff));        return;    }    /* Load 32-bit immediates with two insns.  Note that we've already       eliminated bare ADDIS, so we know both insns are required.  */    if (TCG_TARGET_REG_BITS == 32 || arg == (int32_t)arg) {        tcg_out32(s, ADDIS | TAI(ret, 0, arg >> 16));        tcg_out32(s, ORI | SAI(ret, ret, arg));        return;    }    if (arg == (uint32_t)arg && !(arg & 0x8000)) {        tcg_out32(s, ADDI | TAI(ret, 0, arg));        tcg_out32(s, ORIS | SAI(ret, ret, arg >> 16));        return;    }    /* Load masked 16-bit value.  */    if (arg > 0 && (arg & 0x8000)) {        tmp = arg | 0x7fff;        if ((tmp & (tmp + 1)) == 0) {            int mb = clz64(tmp + 1) + 1;            tcg_out32(s, ADDI | TAI(ret, 0, arg));            tcg_out_rld(s, RLDICL, ret, ret, 0, mb);            return;        }    }    /* Load common masks with 2 insns.  */    shift = ctz64(arg);    tmp = arg >> shift;    if (tmp == (int16_t)tmp) {        tcg_out32(s, ADDI | TAI(ret, 0, tmp));        tcg_out_shli64(s, ret, ret, shift);        return;    }    shift = clz64(arg);    if (tcg_out_movi_one(s, ret, arg << shift)) {        tcg_out_shri64(s, ret, ret, shift);        return;    }    /* Load addresses within 2GB of TB with 2 (or rarely 3) insns.  */    if (!in_prologue && USE_REG_TB && tb_diff == (int32_t)tb_diff) {        tcg_out_mem_long(s, ADDI, ADD, ret, TCG_REG_TB, tb_diff);        return;    }    /* Use the constant pool, if possible.  */    if (!in_prologue && USE_REG_TB) {        new_pool_label(s, arg, R_PPC_ADDR16, s->code_ptr,                       -(intptr_t)s->code_gen_ptr);        tcg_out32(s, LD | TAI(ret, TCG_REG_TB, 0));        return;    }    tmp = arg >> 31 >> 1;    tcg_out_movi(s, TCG_TYPE_I32, ret, tmp);    if (tmp) {        tcg_out_shli64(s, ret, ret, 32);    }    if (arg & 0xffff0000) {        tcg_out32(s, ORIS | SAI(ret, ret, arg >> 16));    }    if (arg & 0xffff) {        tcg_out32(s, ORI | SAI(ret, ret, arg));    }}", "idx": 6204}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "function": "static int uhci_handle_td(UHCIState *s, uint32_t addr, UHCI_TD *td, uint32_t *int_mask){    UHCIAsync *async;    int len = 0, max_len;    uint8_t pid;    /* Is active ? */    if (!(td->ctrl & TD_CTRL_ACTIVE))        return 1;    async = uhci_async_find_td(s, addr, td->token);    if (async) {        /* Already submitted */        async->valid = 32;        if (!async->done)            return 1;        uhci_async_unlink(s, async);        goto done;    }    /* Allocate new packet */    async = uhci_async_alloc(s);    if (!async)        return 1;    async->valid = 10;    async->td    = addr;    async->token = td->token;    max_len = ((td->token >> 21) + 1) & 0x7ff;    pid = td->token & 0xff;    async->packet.pid     = pid;    async->packet.devaddr = (td->token >> 8) & 0x7f;    async->packet.devep   = (td->token >> 15) & 0xf;    async->packet.data    = async->buffer;    async->packet.len     = max_len;    async->packet.complete_cb     = uhci_async_complete;    async->packet.complete_opaque = s;    switch(pid) {    case USB_TOKEN_OUT:    case USB_TOKEN_SETUP:        cpu_physical_memory_read(td->buffer, async->buffer, max_len);        len = uhci_broadcast_packet(s, &async->packet);        if (len >= 0)            len = max_len;        break;    case USB_TOKEN_IN:        len = uhci_broadcast_packet(s, &async->packet);        break;    default:        /* invalid pid : frame interrupted */        uhci_async_free(s, async);        s->status |= UHCI_STS_HCPERR;        uhci_update_irq(s);        return -1;    }     if (len == USB_RET_ASYNC) {        uhci_async_link(s, async);        return 2;    }    async->packet.len = len;done:    len = uhci_complete_td(s, td, async, int_mask);    uhci_async_free(s, async);    return len;}", "idx": 6226}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "function": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size){    int pending = size;    int done = 0;    while (pending > 0) {        int res;        res = qemu_peek_buffer(f, buf, pending, 0);        if (res == 0) {            return done;        }        qemu_file_skip(f, res);        buf += res;        pending -= res;        done += res;    }    return done;}", "idx": 6271}
{"project": "FFmpeg", "commit_id": "898276c16b1683ac77723e97574a3bfdb29507fd", "target": 0, "function": "static int r3d_read_redv(AVFormatContext *s, AVPacket *pkt, Atom *atom){    AVStream *st = s->streams[0];    int tmp;    int av_unused tmp2;    uint64_t pos = avio_tell(s->pb);    unsigned dts;    int ret;    dts = avio_rb32(s->pb);    tmp = avio_rb32(s->pb);    av_dlog(s, \"frame num %d\\n\", tmp);    tmp  = avio_r8(s->pb); // major version    tmp2 = avio_r8(s->pb); // minor version    av_dlog(s, \"version %d.%d\\n\", tmp, tmp2);    tmp = avio_rb16(s->pb); // unknown    av_dlog(s, \"unknown %d\\n\", tmp);    if (tmp > 4) {        tmp = avio_rb16(s->pb); // unknown        av_dlog(s, \"unknown %d\\n\", tmp);        tmp = avio_rb16(s->pb); // unknown        av_dlog(s, \"unknown %d\\n\", tmp);        tmp = avio_rb32(s->pb);        av_dlog(s, \"width %d\\n\", tmp);        tmp = avio_rb32(s->pb);        av_dlog(s, \"height %d\\n\", tmp);        tmp = avio_rb32(s->pb);        av_dlog(s, \"metadata len %d\\n\", tmp);    }    tmp = atom->size - 8 - (avio_tell(s->pb) - pos);    if (tmp < 0)        return -1;    ret = av_get_packet(s->pb, pkt, tmp);    if (ret < 0) {        av_log(s, AV_LOG_ERROR, \"error reading video packet\\n\");        return -1;    }    pkt->stream_index = 0;    pkt->dts = dts;    if (st->avg_frame_rate.num)        pkt->duration = (uint64_t)st->time_base.den*            st->avg_frame_rate.den/st->avg_frame_rate.num;    av_dlog(s, \"pkt dts %\"PRId64\" duration %d\\n\", pkt->dts, pkt->duration);    return 0;}", "idx": 6278}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void exynos4210_i2c_write(void *opaque, target_phys_addr_t offset,                              uint64_t value, unsigned size){    Exynos4210I2CState *s = (Exynos4210I2CState *)opaque;    uint8_t v = value & 0xff;    DPRINT(\"write %s [0x%02x] <- 0x%02x\\n\", exynos4_i2c_get_regname(offset),            (unsigned int)offset, v);    switch (offset) {    case I2CCON_ADDR:        s->i2ccon = (v & ~I2CCON_INT_PEND) | (s->i2ccon & I2CCON_INT_PEND);        if ((s->i2ccon & I2CCON_INT_PEND) && !(v & I2CCON_INT_PEND)) {            s->i2ccon &= ~I2CCON_INT_PEND;            qemu_irq_lower(s->irq);            if (!(s->i2ccon & I2CCON_INTRS_EN)) {                s->i2cstat &= ~I2CSTAT_START_BUSY;            }            if (s->i2cstat & I2CSTAT_START_BUSY) {                if (s->scl_free) {                    if (EXYNOS4_I2C_MODE(s->i2cstat) == I2CMODE_MASTER_Tx) {                        exynos4210_i2c_data_send(s);                    } else if (EXYNOS4_I2C_MODE(s->i2cstat) ==                            I2CMODE_MASTER_Rx) {                        exynos4210_i2c_data_receive(s);                    }                } else {                    s->i2ccon |= I2CCON_INT_PEND;                    qemu_irq_raise(s->irq);                }            }        }        break;    case I2CSTAT_ADDR:        s->i2cstat =                (s->i2cstat & I2CSTAT_START_BUSY) | (v & ~I2CSTAT_START_BUSY);        if (!(s->i2cstat & I2CSTAT_OUTPUT_EN)) {            s->i2cstat &= ~I2CSTAT_START_BUSY;            s->scl_free = true;            qemu_irq_lower(s->irq);            break;        }        /* Nothing to do if in i2c slave mode */        if (!I2C_IN_MASTER_MODE(s->i2cstat)) {            break;        }        if (v & I2CSTAT_START_BUSY) {            s->i2cstat &= ~I2CSTAT_LAST_BIT;            s->i2cstat |= I2CSTAT_START_BUSY;    /* Line is busy */            s->scl_free = false;            /* Generate start bit and send slave address */            if (i2c_start_transfer(s->bus, s->i2cds >> 1, s->i2cds & 0x1) &&                    (s->i2ccon & I2CCON_ACK_GEN)) {                s->i2cstat |= I2CSTAT_LAST_BIT;            } else if (EXYNOS4_I2C_MODE(s->i2cstat) == I2CMODE_MASTER_Rx) {                exynos4210_i2c_data_receive(s);            }            exynos4210_i2c_raise_interrupt(s);        } else {            i2c_end_transfer(s->bus);            if (!(s->i2ccon & I2CCON_INT_PEND)) {                s->i2cstat &= ~I2CSTAT_START_BUSY;            }            s->scl_free = true;        }        break;    case I2CADD_ADDR:        if ((s->i2cstat & I2CSTAT_OUTPUT_EN) == 0) {            s->i2cadd = v;        }        break;    case I2CDS_ADDR:        if (s->i2cstat & I2CSTAT_OUTPUT_EN) {            s->i2cds = v;            s->scl_free = true;            if (EXYNOS4_I2C_MODE(s->i2cstat) == I2CMODE_MASTER_Tx &&                    (s->i2cstat & I2CSTAT_START_BUSY) &&                    !(s->i2ccon & I2CCON_INT_PEND)) {                exynos4210_i2c_data_send(s);            }        }        break;    case I2CLC_ADDR:        s->i2clc = v;        break;    default:        DPRINT(\"ERROR: Bad write offset 0x%x\\n\", (unsigned int)offset);        break;    }}", "idx": 6281}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "function": "static inline void dv_encode_video_segment(DVVideoContext *s,                                            uint8_t *dif,                                            const uint16_t *mb_pos_ptr){    int mb_index, i, j, v;    int mb_x, mb_y, c_offset, linesize;     uint8_t*  y_ptr;    uint8_t*  data;    uint8_t*  ptr;    int       do_edge_wrap;    DCTELEM   block[64] __align8;    DCTELEM   sblock[5*6][64] __align8;    EncBlockInfo  enc_blks[5*6];    PutBitContext pbs[5*6];    PutBitContext* pb;     EncBlockInfo* enc_blk;    int       vs_bit_size = 0;    int       qnos[5];       enc_blk = &enc_blks[0];    pb = &pbs[0];    for(mb_index = 0; mb_index < 5; mb_index++) {        v = *mb_pos_ptr++;        mb_x = v & 0xff;        mb_y = v >> 8;        y_ptr = s->picture.data[0] + (mb_y * s->picture.linesize[0] * 8) + (mb_x * 8);\tc_offset = (s->sys->pix_fmt == PIX_FMT_YUV411P) ?\t           ((mb_y * s->picture.linesize[1] * 8) + ((mb_x >> 2) * 8)) :\t\t   (((mb_y >> 1) * s->picture.linesize[1] * 8) + ((mb_x >> 1) * 8));\tdo_edge_wrap = 0;\tqnos[mb_index] = 15; /* No quantization */        ptr = dif + mb_index*80 + 4;        for(j = 0;j < 6; j++) {            if (j < 4) {  /* Four Y blocks */\t\t/* NOTE: at end of line, the macroblock is handled as 420 */\t\tif (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x < (704 / 8)) {                    data = y_ptr + (j * 8);                } else {                    data = y_ptr + ((j & 1) * 8) + ((j >> 1) * 8 * s->picture.linesize[0]);                }\t\tlinesize = s->picture.linesize[0];            } else {      /* Cr and Cb blocks */\t        /* don't ask Fabrice why they inverted Cb and Cr ! */\t        data = s->picture.data[6 - j] + c_offset;\t\tlinesize = s->picture.linesize[6 - j];\t\tif (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8))\t\t    do_edge_wrap = 1;\t    }\t            \t    /* Everything is set up -- now just copy data -> DCT block */\t    if (do_edge_wrap) {  /* Edge wrap copy: 4x16 -> 8x8 */\t\tuint8_t* d;\t\tDCTELEM *b = block;\t        for (i=0;i<8;i++) {\t\t   d = data + 8 * linesize;\t\t   b[0] = data[0]; b[1] = data[1]; b[2] = data[2]; b[3] = data[3];                   b[4] =    d[0]; b[5] =    d[1]; b[6] =    d[2]; b[7] =    d[3];\t\t   data += linesize;\t\t   b += 8;\t\t}\t    } else {             /* Simple copy: 8x8 -> 8x8 */\t        s->get_pixels(block, data, linesize);\t    }\t              enc_blk->dct_mode = dv_guess_dct_mode(block);\t    enc_blk->mb = &sblock[mb_index*6+j][0];\t    enc_blk->area_q[0] = enc_blk->area_q[1] = enc_blk->area_q[2] = enc_blk->area_q[3] = 0;\t    enc_blk->partial_bit_count = 0;\t    enc_blk->partial_bit_buffer = 0;\t    enc_blk->cur_ac = 1;\t    \t    s->fdct[enc_blk->dct_mode](block);\t    \t    dv_set_class_number(block, enc_blk, \t                        enc_blk->dct_mode ? ff_zigzag248_direct : ff_zigzag_direct,\t\t\t\tj/4*(j%2));                       init_put_bits(pb, ptr, block_sizes[j]/8);\t    put_bits(pb, 9, (uint16_t)(((enc_blk->mb[0] >> 3) - 1024) >> 2));\t    put_bits(pb, 1, enc_blk->dct_mode);\t    put_bits(pb, 2, enc_blk->cno);\t    \t    vs_bit_size += enc_blk->bit_size[0] + enc_blk->bit_size[1] +\t                   enc_blk->bit_size[2] + enc_blk->bit_size[3];\t    ++enc_blk;\t    ++pb;\t    ptr += block_sizes[j]/8;        }    }    if (vs_total_ac_bits < vs_bit_size)        dv_guess_qnos(&enc_blks[0], &qnos[0]);    for (i=0; i<5; i++) {       dif[i*80 + 3] = qnos[i];    }    /* First pass over individual cells only */    for (j=0; j<5*6; j++)       dv_encode_ac(&enc_blks[j], &pbs[j], 1);    /* Second pass over each MB space */    for (j=0; j<5*6; j++) {       if (enc_blks[j].cur_ac < 65 || enc_blks[j].partial_bit_count)           dv_encode_ac(&enc_blks[j], &pbs[(j/6)*6], 6);    }    /* Third and final pass over the whole vides segment space */    for (j=0; j<5*6; j++) {       if (enc_blks[j].cur_ac < 65 || enc_blks[j].partial_bit_count)           dv_encode_ac(&enc_blks[j], &pbs[0], 6*5);    }    for (j=0; j<5*6; j++)       flush_put_bits(&pbs[j]);}", "idx": 6327}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "function": "int bdrv_flush(BlockDriverState *bs){    Coroutine *co;    FlushCo flush_co = {        .bs = bs,        .ret = NOT_DONE,    };    if (qemu_in_coroutine()) {        /* Fast-path if already in coroutine context */        bdrv_flush_co_entry(&flush_co);    } else {        co = qemu_coroutine_create(bdrv_flush_co_entry, &flush_co);        qemu_coroutine_enter(co);        BDRV_POLL_WHILE(bs, flush_co.ret == NOT_DONE);    }    return flush_co.ret;}", "idx": 6347}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "function": "void scsi_req_complete(SCSIRequest *req){    assert(req->status != -1);    scsi_req_ref(req);    scsi_req_dequeue(req);    req->bus->ops->complete(req->bus, SCSI_REASON_DONE,                            req->tag,                            req->status);    scsi_req_unref(req);}", "idx": 6348}
{"project": "qemu", "commit_id": "0426d53c6530606bf7641b83f2b755fe61c280ee", "target": 1, "function": "static void qmp_input_get_next_type(Visitor *v, int *kind, const int *qobjects,                                    const char *name, Error **errp){    QmpInputVisitor *qiv = to_qiv(v);    QObject *qobj = qmp_input_get_object(qiv, name, false);    if (!qobj) {        error_setg(errp, QERR_MISSING_PARAMETER, name ? name : \"null\");        return;    }    *kind = qobjects[qobject_type(qobj)];}", "idx": 6370}
{"project": "qemu", "commit_id": "c20fd872257fb9abd2ce99741937c0f65aa162b7", "target": 0, "function": "static void virtio_blk_dma_restart_bh(void *opaque){    VirtIOBlock *s = opaque;    VirtIOBlockReq *req = s->rq;    MultiReqBuffer mrb = {        .num_writes = 0,    };    qemu_bh_delete(s->bh);    s->bh = NULL;    s->rq = NULL;    while (req) {        virtio_blk_handle_request(req, &mrb);        req = req->next;    }    if (mrb.num_writes > 0) {        do_multiwrite(s->bs, mrb.blkreq, mrb.num_writes);    }}", "idx": 6407}
{"project": "FFmpeg", "commit_id": "5b220e1e19c17b202d83d9be0868d152109ae8f0", "target": 1, "function": "static MpegTSService *mpegts_add_service(MpegTSWrite *ts, int sid,                                         const char *provider_name,                                         const char *name){    MpegTSService *service;    service = av_mallocz(sizeof(MpegTSService));    if (!service)        return NULL;    service->pmt.pid       = ts->pmt_start_pid + ts->nb_services;    service->sid           = sid;    service->provider_name = av_strdup(provider_name);    service->name          = av_strdup(name);    service->pcr_pid       = 0x1fff;    dynarray_add(&ts->services, &ts->nb_services, service);    return service;}", "idx": 6412}
{"project": "FFmpeg", "commit_id": "635ac8e1be91e941908f85642e4bbb609e48193f", "target": 1, "function": "static int handle_ping(URLContext *s, RTMPPacket *pkt){    RTMPContext *rt = s->priv_data;    int t, ret;    if (pkt->data_size < 2) {        av_log(s, AV_LOG_ERROR, \"Too short ping packet (%d)\\n\",               pkt->data_size);        return AVERROR_INVALIDDATA;    t = AV_RB16(pkt->data);    if (t == 6) {        if ((ret = gen_pong(s, rt, pkt)) < 0)    return 0;", "idx": 6418}
{"project": "qemu", "commit_id": "9ab1b6053f03d58ba8e7accc8f19c882fbffb66f", "target": 1, "function": "static void gic_cpu_write(gic_state *s, int cpu, int offset, uint32_t value){    switch (offset) {    case 0x00: /* Control */        s->cpu_enabled[cpu] = (value & 1);        DPRINTF(\"CPU %d %sabled\\n\", cpu, s->cpu_enabled ? \"En\" : \"Dis\");        break;    case 0x04: /* Priority mask */        s->priority_mask[cpu] = (value & 0xff);        break;    case 0x08: /* Binary Point */        /* ??? Not implemented.  */        break;    case 0x10: /* End Of Interrupt */        return gic_complete_irq(s, cpu, value & 0x3ff);    default:        hw_error(\"gic_cpu_write: Bad offset %x\\n\", (int)offset);        return;    }    gic_update(s);}", "idx": 6421}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "function": "static inline void RENAME(rgb32tobgr15)(const uint8_t *src, uint8_t *dst, unsigned src_size){\tconst uint8_t *s = src;\tconst uint8_t *end;#ifdef HAVE_MMX\tconst uint8_t *mm_end;#endif\tuint16_t *d = (uint16_t *)dst;\tend = s + src_size;#ifdef HAVE_MMX\t__asm __volatile(PREFETCH\"\t%0\"::\"m\"(*src):\"memory\");\t__asm __volatile(\t    \"movq\t%0, %%mm7\\n\\t\"\t    \"movq\t%1, %%mm6\\n\\t\"\t    ::\"m\"(red_15mask),\"m\"(green_15mask));\tmm_end = end - 15;\twhile(s < mm_end)\t{\t    __asm __volatile(\t\tPREFETCH\" 32%1\\n\\t\"\t\t\"movd\t%1, %%mm0\\n\\t\"\t\t\"movd\t4%1, %%mm3\\n\\t\"\t\t\"punpckldq 8%1, %%mm0\\n\\t\"\t\t\"punpckldq 12%1, %%mm3\\n\\t\"\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\t\t\"movq\t%%mm3, %%mm4\\n\\t\"\t\t\"movq\t%%mm3, %%mm5\\n\\t\"\t\t\"psllq\t$7, %%mm0\\n\\t\"\t\t\"psllq\t$7, %%mm3\\n\\t\"\t\t\"pand\t%%mm7, %%mm0\\n\\t\"\t\t\"pand\t%%mm7, %%mm3\\n\\t\"\t\t\"psrlq\t$6, %%mm1\\n\\t\"\t\t\"psrlq\t$6, %%mm4\\n\\t\"\t\t\"pand\t%%mm6, %%mm1\\n\\t\"\t\t\"pand\t%%mm6, %%mm4\\n\\t\"\t\t\"psrlq\t$19, %%mm2\\n\\t\"\t\t\"psrlq\t$19, %%mm5\\n\\t\"\t\t\"pand\t%2, %%mm2\\n\\t\"\t\t\"pand\t%2, %%mm5\\n\\t\"\t\t\"por\t%%mm1, %%mm0\\n\\t\"\t\t\"por\t%%mm4, %%mm3\\n\\t\"\t\t\"por\t%%mm2, %%mm0\\n\\t\"\t\t\"por\t%%mm5, %%mm3\\n\\t\"\t\t\"psllq\t$16, %%mm3\\n\\t\"\t\t\"por\t%%mm3, %%mm0\\n\\t\"\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\t\t:\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\t\td += 4;\t\ts += 16;\t}\t__asm __volatile(SFENCE:::\"memory\");\t__asm __volatile(EMMS:::\"memory\");#endif\twhile(s < end)\t{\t\t// FIXME on bigendian\t\tconst int src= *s; s += 4;\t\t*d++ = ((src&0xF8)<<7) + ((src&0xF800)>>6) + ((src&0xF80000)>>19);\t}}", "idx": 6474}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "function": "static void unterminated_string(void){    QObject *obj = qobject_from_json(\"\\\"abc\", NULL);    g_assert(obj == NULL);}", "idx": 6502}
{"project": "qemu", "commit_id": "d28d6505bd72f0d6e3e7a968c60c27f893da976e", "target": 1, "function": "static void sdl_switch(DisplayChangeListener *dcl,                       DisplaySurface *new_surface){    PixelFormat pf = qemu_pixelformat_from_pixman(new_surface->format);    /* temporary hack: allows to call sdl_switch to handle scaling changes */    if (new_surface) {        surface = new_surface;    }    if (!scaling_active) {        do_sdl_resize(surface_width(surface), surface_height(surface), 0);    } else if (real_screen->format->BitsPerPixel !=               surface_bits_per_pixel(surface)) {        do_sdl_resize(real_screen->w, real_screen->h,                      surface_bits_per_pixel(surface));    }    if (guest_screen != NULL) {        SDL_FreeSurface(guest_screen);    }#ifdef DEBUG_SDL    printf(\"SDL: Creating surface with masks: %08x %08x %08x %08x\\n\",           pf.rmask, pf.gmask, pf.bmask, pf.amask);#endif    guest_screen = SDL_CreateRGBSurfaceFrom        (surface_data(surface),         surface_width(surface), surface_height(surface),         surface_bits_per_pixel(surface), surface_stride(surface),         pf.rmask, pf.gmask,         pf.bmask, pf.amask);}", "idx": 6561}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "function": "static int qed_read_table(BDRVQEDState *s, uint64_t offset, QEDTable *table){    QEMUIOVector qiov;    int noffsets;    int i, ret;    struct iovec iov = {        .iov_base = table->offsets,        .iov_len = s->header.cluster_size * s->header.table_size,    };    qemu_iovec_init_external(&qiov, &iov, 1);    trace_qed_read_table(s, offset, table);    ret = bdrv_preadv(s->bs->file, offset, &qiov);    if (ret < 0) {        goto out;    }    /* Byteswap offsets */    qed_acquire(s);    noffsets = qiov.size / sizeof(uint64_t);    for (i = 0; i < noffsets; i++) {        table->offsets[i] = le64_to_cpu(table->offsets[i]);    }    qed_release(s);    ret = 0;out:    /* Completion */    trace_qed_read_table_cb(s, table, ret);    return ret;}", "idx": 6603}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "function": "void helper_fcmp_eq_DT(CPUSH4State *env, float64 t0, float64 t1){    int relation;    set_float_exception_flags(0, &env->fp_status);    relation = float64_compare(t0, t1, &env->fp_status);    if (unlikely(relation == float_relation_unordered)) {        update_fpscr(env, GETPC());    } else {        env->sr_t = (relation == float_relation_equal);    }}", "idx": 6614}
{"project": "FFmpeg", "commit_id": "420d1df2e2a857eae45fa947e16eae7494793d57", "target": 0, "function": "static inline int ape_decode_value(APEContext *ctx, APERice *rice){    int x, overflow;    if (ctx->fileversion < 3990) {        int tmpk;        overflow = range_get_symbol(ctx, counts_3970, counts_diff_3970);        if (overflow == (MODEL_ELEMENTS - 1)) {            tmpk = range_decode_bits(ctx, 5);            overflow = 0;        } else            tmpk = (rice->k < 1) ? 0 : rice->k - 1;        if (tmpk <= 16)            x = range_decode_bits(ctx, tmpk);        else {            x = range_decode_bits(ctx, 16);            x |= (range_decode_bits(ctx, tmpk - 16) << 16);        }        x += overflow << tmpk;    } else {        int base, pivot;        pivot = rice->ksum >> 5;        if (pivot == 0)            pivot = 1;        overflow = range_get_symbol(ctx, counts_3980, counts_diff_3980);        if (overflow == (MODEL_ELEMENTS - 1)) {            overflow  = range_decode_bits(ctx, 16) << 16;            overflow |= range_decode_bits(ctx, 16);        }        if (pivot < 0x10000) {            base = range_decode_culfreq(ctx, pivot);            range_decode_update(ctx, 1, base);        } else {            int base_hi = pivot, base_lo;            int bbits = 0;            while (base_hi & ~0xFFFF) {                base_hi >>= 1;                bbits++;            }            base_hi = range_decode_culfreq(ctx, base_hi + 1);            range_decode_update(ctx, 1, base_hi);            base_lo = range_decode_culfreq(ctx, 1 << bbits);            range_decode_update(ctx, 1, base_lo);            base = (base_hi << bbits) + base_lo;        }        x = base + overflow * pivot;    }    update_rice(rice, x);    /* Convert to signed */    if (x & 1)        return (x >> 1) + 1;    else        return -(x >> 1);}", "idx": 6618}
{"project": "FFmpeg", "commit_id": "114f3f526e5ad1557c514fe1213dd87f4ebe6f6a", "target": 0, "function": "static int plot_cqt(AVFilterLink *inlink){    AVFilterContext *ctx = inlink->dst;    ShowCQTContext *s = ctx->priv;    AVFilterLink *outlink = ctx->outputs[0];    int fft_len = 1 << s->fft_bits;    FFTSample result[VIDEO_WIDTH][4];    int x, y, ret = 0;    int linesize = s->outpicref->linesize[0];    int video_scale = s->fullhd ? 2 : 1;    int video_width = (VIDEO_WIDTH/2) * video_scale;    int spectogram_height = (SPECTOGRAM_HEIGHT/2) * video_scale;    int spectogram_start = (SPECTOGRAM_START/2) * video_scale;    int font_height = (FONT_HEIGHT/2) * video_scale;    /* real part contains left samples, imaginary part contains right samples */    memcpy(s->fft_result, s->fft_data, fft_len * sizeof(*s->fft_data));    av_fft_permute(s->fft_context, s->fft_result);    av_fft_calc(s->fft_context, s->fft_result);    s->fft_result[fft_len] = s->fft_result[0];    /* calculating cqt */    for (x = 0; x < VIDEO_WIDTH; x++) {        int u;        FFTComplex v = {0,0};        FFTComplex w = {0,0};        FFTComplex l, r;        for (u = 0; u < s->coeffs[x].len; u++) {            FFTSample value = s->coeffs[x].values[u];            int index = s->coeffs[x].start + u;            v.re += value * s->fft_result[index].re;            v.im += value * s->fft_result[index].im;            w.re += value * s->fft_result[fft_len - index].re;            w.im += value * s->fft_result[fft_len - index].im;        }        /* separate left and right, (and multiply by 2.0) */        l.re = v.re + w.re;        l.im = v.im - w.im;        r.re = w.im + v.im;        r.im = w.re - v.re;        /* result is power, not amplitude */        result[x][0] = l.re * l.re + l.im * l.im;        result[x][2] = r.re * r.re + r.im * r.im;        result[x][1] = 0.5f * (result[x][0] + result[x][2]);        if (s->gamma2 == 1.0f)            result[x][3] = result[x][1];        else if (s->gamma2 == 2.0f)            result[x][3] = sqrtf(result[x][1]);        else if (s->gamma2 == 3.0f)            result[x][3] = cbrtf(result[x][1]);        else if (s->gamma2 == 4.0f)            result[x][3] = sqrtf(sqrtf(result[x][1]));        else            result[x][3] = expf(logf(result[x][1]) * (1.0f / s->gamma2));        result[x][0] = FFMIN(1.0f, result[x][0]);        result[x][1] = FFMIN(1.0f, result[x][1]);        result[x][2] = FFMIN(1.0f, result[x][2]);        if (s->gamma == 1.0f) {            result[x][0] = 255.0f * result[x][0];            result[x][1] = 255.0f * result[x][1];            result[x][2] = 255.0f * result[x][2];        } else if (s->gamma == 2.0f) {            result[x][0] = 255.0f * sqrtf(result[x][0]);            result[x][1] = 255.0f * sqrtf(result[x][1]);            result[x][2] = 255.0f * sqrtf(result[x][2]);        } else if (s->gamma == 3.0f) {            result[x][0] = 255.0f * cbrtf(result[x][0]);            result[x][1] = 255.0f * cbrtf(result[x][1]);            result[x][2] = 255.0f * cbrtf(result[x][2]);        } else if (s->gamma == 4.0f) {            result[x][0] = 255.0f * sqrtf(sqrtf(result[x][0]));            result[x][1] = 255.0f * sqrtf(sqrtf(result[x][1]));            result[x][2] = 255.0f * sqrtf(sqrtf(result[x][2]));        } else {            result[x][0] = 255.0f * expf(logf(result[x][0]) * (1.0f / s->gamma));            result[x][1] = 255.0f * expf(logf(result[x][1]) * (1.0f / s->gamma));            result[x][2] = 255.0f * expf(logf(result[x][2]) * (1.0f / s->gamma));        }    }    if (!s->fullhd) {        for (x = 0; x < video_width; x++) {            result[x][0] = 0.5f * (result[2*x][0] + result[2*x+1][0]);            result[x][1] = 0.5f * (result[2*x][1] + result[2*x+1][1]);            result[x][2] = 0.5f * (result[2*x][2] + result[2*x+1][2]);            result[x][3] = 0.5f * (result[2*x][3] + result[2*x+1][3]);        }    }    for (x = 0; x < video_width; x++) {        s->spectogram[s->spectogram_index*linesize + 3*x] = result[x][0] + 0.5f;        s->spectogram[s->spectogram_index*linesize + 3*x + 1] = result[x][1] + 0.5f;        s->spectogram[s->spectogram_index*linesize + 3*x + 2] = result[x][2] + 0.5f;    }    /* drawing */    if (!s->spectogram_count) {        uint8_t *data = (uint8_t*) s->outpicref->data[0];        float rcp_result[VIDEO_WIDTH];        int total_length = linesize * spectogram_height;        int back_length = linesize * s->spectogram_index;        for (x = 0; x < video_width; x++)            rcp_result[x] = 1.0f / (result[x][3]+0.0001f);        /* drawing bar */        for (y = 0; y < spectogram_height; y++) {            float height = (spectogram_height - y) * (1.0f/spectogram_height);            uint8_t *lineptr = data + y * linesize;            for (x = 0; x < video_width; x++) {                float mul;                if (result[x][3] <= height) {                    *lineptr++ = 0;                    *lineptr++ = 0;                    *lineptr++ = 0;                } else {                    mul = (result[x][3] - height) * rcp_result[x];                    *lineptr++ = mul * result[x][0] + 0.5f;                    *lineptr++ = mul * result[x][1] + 0.5f;                    *lineptr++ = mul * result[x][2] + 0.5f;                }            }        }        /* drawing font */        if (s->font_alpha && s->draw_text) {            for (y = 0; y < font_height; y++) {                uint8_t *lineptr = data + (spectogram_height + y) * linesize;                uint8_t *spectogram_src = s->spectogram + s->spectogram_index * linesize;                uint8_t *fontcolor_value = s->fontcolor_value;                for (x = 0; x < video_width; x++) {                    uint8_t alpha = s->font_alpha[y*video_width+x];                    lineptr[3*x] = (spectogram_src[3*x] * (255-alpha) + fontcolor_value[0] * alpha + 255) >> 8;                    lineptr[3*x+1] = (spectogram_src[3*x+1] * (255-alpha) + fontcolor_value[1] * alpha + 255) >> 8;                    lineptr[3*x+2] = (spectogram_src[3*x+2] * (255-alpha) + fontcolor_value[2] * alpha + 255) >> 8;                    fontcolor_value += 3;                }            }        } else if (s->draw_text) {            for (y = 0; y < font_height; y++) {                uint8_t *lineptr = data + (spectogram_height + y) * linesize;                memcpy(lineptr, s->spectogram + s->spectogram_index * linesize, video_width*3);            }            for (x = 0; x < video_width; x += video_width/10) {                int u;                static const char str[] = \"EF G A BC D \";                uint8_t *startptr = data + spectogram_height * linesize + x * 3;                for (u = 0; str[u]; u++) {                    int v;                    for (v = 0; v < 16; v++) {                        uint8_t *p = startptr + v * linesize * video_scale + 8 * 3 * u * video_scale;                        int ux = x + 8 * u * video_scale;                        int mask;                        for (mask = 0x80; mask; mask >>= 1) {                            if (mask & avpriv_vga16_font[str[u] * 16 + v]) {                                p[0] = s->fontcolor_value[3*ux];                                p[1] = s->fontcolor_value[3*ux+1];                                p[2] = s->fontcolor_value[3*ux+2];                                if (video_scale == 2) {                                    p[linesize] = p[0];                                    p[linesize+1] = p[1];                                    p[linesize+2] = p[2];                                    p[3] = p[linesize+3] = s->fontcolor_value[3*ux+3];                                    p[4] = p[linesize+4] = s->fontcolor_value[3*ux+4];                                    p[5] = p[linesize+5] = s->fontcolor_value[3*ux+5];                                }                            }                            p  += 3 * video_scale;                            ux += video_scale;                        }                    }                }            }        } else {            for (y = 0; y < font_height; y++) {                uint8_t *lineptr = data + (spectogram_height + y) * linesize;                uint8_t *spectogram_src = s->spectogram + s->spectogram_index * linesize;                for (x = 0; x < video_width; x++) {                    lineptr[3*x] = spectogram_src[3*x];                    lineptr[3*x+1] = spectogram_src[3*x+1];                    lineptr[3*x+2] = spectogram_src[3*x+2];                }            }        }        /* drawing spectogram/sonogram */        data += spectogram_start * linesize;        memcpy(data, s->spectogram + s->spectogram_index*linesize, total_length - back_length);        data += total_length - back_length;        if (back_length)            memcpy(data, s->spectogram, back_length);        s->outpicref->pts = s->frame_count;        ret = ff_filter_frame(outlink, av_frame_clone(s->outpicref));        s->req_fullfilled = 1;        s->frame_count++;    }    s->spectogram_count = (s->spectogram_count + 1) % s->count;    s->spectogram_index = (s->spectogram_index + spectogram_height - 1) % spectogram_height;    return ret;}", "idx": 6632}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "function": "static int normalize_bits(int num, int width){    if (!num)        return 0;    if (num == -1)        return width;    if (num < 0)        num = ~num;    return width - av_log2(num);}", "idx": 6670}
{"project": "FFmpeg", "commit_id": "4a2da83a787b24c4027aa963d9db9b453e91f413", "target": 1, "function": "static int dnxhd_decode_header(DNXHDContext *ctx, const uint8_t *buf, int buf_size, int first_field){    static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 };    int i, cid;    if (buf_size < 0x280)        return -1;    if (memcmp(buf, header_prefix, 5)) {        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");        return -1;    }    if (buf[5] & 2) { /* interlaced */        ctx->cur_field = buf[5] & 1;        ctx->picture.interlaced_frame = 1;        ctx->picture.top_field_first = first_field ^ ctx->cur_field;        av_log(ctx->avctx, AV_LOG_DEBUG, \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);    }    ctx->height = AV_RB16(buf + 0x18);    ctx->width  = AV_RB16(buf + 0x1a);    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);    if (buf[0x21] & 0x40) {        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;        ctx->avctx->bits_per_raw_sample = 10;        if (ctx->bit_depth != 10) {            ff_dsputil_init(&ctx->dsp, ctx->avctx);            ctx->bit_depth = 10;            ctx->decode_dct_block = dnxhd_decode_dct_block_10;        }    } else {        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;        ctx->avctx->bits_per_raw_sample = 8;        if (ctx->bit_depth != 8) {            ff_dsputil_init(&ctx->dsp, ctx->avctx);            ctx->bit_depth = 8;            ctx->decode_dct_block = dnxhd_decode_dct_block_8;        }    }    cid = AV_RB32(buf + 0x28);    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);    if (dnxhd_init_vlc(ctx, cid) < 0)        return -1;    if (buf_size < ctx->cid_table->coding_unit_size) {        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");        return -1;    }    ctx->mb_width = ctx->width>>4;    ctx->mb_height = buf[0x16d];    av_dlog(ctx->avctx, \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);    if ((ctx->height+15)>>4 == ctx->mb_height && ctx->picture.interlaced_frame)        ctx->height <<= 1;    if (ctx->mb_height > 68 ||        (ctx->mb_height<<ctx->picture.interlaced_frame) > (ctx->height+15)>>4) {        av_log(ctx->avctx, AV_LOG_ERROR, \"mb height too big: %d\\n\", ctx->mb_height);        return -1;    }    for (i = 0; i < ctx->mb_height; i++) {        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i<<2));        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);        if (buf_size < ctx->mb_scan_index[i] + 0x280) {            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");            return -1;        }    }    return 0;}", "idx": 6702}
{"project": "FFmpeg", "commit_id": "511e10f673a69c05744be0355cc9ce5705407bc2", "target": 0, "function": "static int avi_sync(AVFormatContext *s, int exit_early){    AVIContext *avi = s->priv_data;    AVIOContext *pb = s->pb;    int n;    unsigned int d[8];    unsigned int size;    int64_t i, sync;start_sync:    memset(d, -1, sizeof(d));    for (i = sync = avio_tell(pb); !avio_feof(pb); i++) {        int j;        for (j = 0; j < 7; j++)            d[j] = d[j + 1];        d[7] = avio_r8(pb);        size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24);        n = get_stream_idx(d + 2);        ff_tlog(s, \"%X %X %X %X %X %X %X %X %\"PRId64\" %u %d\\n\",                d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n);        if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127)            continue;        // parse ix##        if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) ||            // parse JUNK            (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') ||            (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') ||            (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) {            avio_skip(pb, size);            goto start_sync;        }        // parse stray LIST        if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') {            avio_skip(pb, 4);            goto start_sync;        }        n = get_stream_idx(d);        if (!((i - avi->last_pkt_pos) & 1) &&            get_stream_idx(d + 1) < s->nb_streams)            continue;        // detect ##ix chunk and skip        if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) {            avio_skip(pb, size);            goto start_sync;        }        if (avi->dv_demux && n != 0)            continue;        // parse ##dc/##wb        if (n < s->nb_streams) {            AVStream *st;            AVIStream *ast;            st  = s->streams[n];            ast = st->priv_data;            if (!ast) {                av_log(s, AV_LOG_WARNING, \"Skipping foreign stream %d packet\\n\", n);                continue;            }            if (s->nb_streams >= 2) {                AVStream *st1   = s->streams[1];                AVIStream *ast1 = st1->priv_data;                // workaround for broken small-file-bug402.avi                if (   d[2] == 'w' && d[3] == 'b'                   && n == 0                   && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO                   && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO                   && ast->prefix == 'd'*256+'c'                   && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)                  ) {                    n   = 1;                    st  = st1;                    ast = ast1;                    av_log(s, AV_LOG_WARNING,                           \"Invalid stream + prefix combination, assuming audio.\\n\");                }            }            if (!avi->dv_demux &&                ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||                 // FIXME: needs a little reordering                 (st->discard >= AVDISCARD_NONKEY &&                 !(pkt->flags & AV_PKT_FLAG_KEY)) */                || st->discard >= AVDISCARD_ALL)) {                if (!exit_early) {                    ast->frame_offset += get_duration(ast, size);                    avio_skip(pb, size);                    goto start_sync;                }            }            if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) {                int k    = avio_r8(pb);                int last = (k + avio_r8(pb) - 1) & 0xFF;                avio_rl16(pb); // flags                // b + (g << 8) + (r << 16);                for (; k <= last; k++)                    ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8;                ast->has_pal = 1;                goto start_sync;            } else if (((ast->prefix_count < 5 || sync + 9 > i) &&                        d[2] < 128 && d[3] < 128) ||                       d[2] * 256 + d[3] == ast->prefix /* ||                       (d[2] == 'd' && d[3] == 'c') ||                       (d[2] == 'w' && d[3] == 'b') */) {                if (exit_early)                    return 0;                if (d[2] * 256 + d[3] == ast->prefix)                    ast->prefix_count++;                else {                    ast->prefix       = d[2] * 256 + d[3];                    ast->prefix_count = 0;                }                avi->stream_index = n;                ast->packet_size  = size + 8;                ast->remaining    = size;                if (size) {                    uint64_t pos = avio_tell(pb) - 8;                    if (!st->index_entries || !st->nb_index_entries ||                        st->index_entries[st->nb_index_entries - 1].pos < pos) {                        av_add_index_entry(st, pos, ast->frame_offset, size,                                           0, AVINDEX_KEYFRAME);                    }                }                return 0;            }        }    }    if (pb->error)        return pb->error;    return AVERROR_EOF;}", "idx": 6705}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "function": "static int qdm2_decode(QDM2Context *q, const uint8_t *in, int16_t *out){    int ch, i;    const int frame_size = (q->frame_size * q->channels);    /* select input buffer */    q->compressed_data = in;    q->compressed_size = q->checksum_size;    /* copy old block, clear new block of output samples */    memmove(q->output_buffer, &q->output_buffer[frame_size], frame_size * sizeof(float));    memset(&q->output_buffer[frame_size], 0, frame_size * sizeof(float));    /* decode block of QDM2 compressed data */    if (q->sub_packet == 0) {        q->has_errors = 0; // zero it for a new super block        av_log(NULL,AV_LOG_DEBUG,\"Superblock follows\\n\");        qdm2_decode_super_block(q);    }    /* parse subpackets */    if (!q->has_errors) {        if (q->sub_packet == 2)            qdm2_decode_fft_packets(q);        qdm2_fft_tone_synthesizer(q, q->sub_packet);    }    /* sound synthesis stage 1 (FFT) */    for (ch = 0; ch < q->channels; ch++) {        qdm2_calculate_fft(q, ch, q->sub_packet);        if (!q->has_errors && q->sub_packet_list_C[0].packet != NULL) {            SAMPLES_NEEDED_2(\"has errors, and C list is not empty\")            return -1;        }    }    /* sound synthesis stage 2 (MPEG audio like synthesis filter) */    if (!q->has_errors && q->do_synth_filter)        qdm2_synthesis_filter(q, q->sub_packet);    q->sub_packet = (q->sub_packet + 1) % 16;    /* clip and convert output float[] to 16bit signed samples */    for (i = 0; i < frame_size; i++) {        int value = (int)q->output_buffer[i];        if (value > SOFTCLIP_THRESHOLD)            value = (value >  HARDCLIP_THRESHOLD) ?  32767 :  softclip_table[ value - SOFTCLIP_THRESHOLD];        else if (value < -SOFTCLIP_THRESHOLD)            value = (value < -HARDCLIP_THRESHOLD) ? -32767 : -softclip_table[-value - SOFTCLIP_THRESHOLD];        out[i] = value;    }    return 0;}", "idx": 6731}
{"project": "qemu", "commit_id": "d663640c04f2aab810915c556390211d75457704", "target": 1, "function": "static int alloc_f(BlockDriverState *bs, int argc, char **argv){    int64_t offset, sector_num;    int nb_sectors, remaining;    char s1[64];    int num, sum_alloc;    int ret;    offset = cvtnum(argv[1]);    if (offset < 0) {        printf(\"non-numeric offset argument -- %s\\n\", argv[1]);    } else if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",               offset);    if (argc == 3) {        nb_sectors = cvtnum(argv[2]);        if (nb_sectors < 0) {            printf(\"non-numeric length argument -- %s\\n\", argv[2]);    } else {        nb_sectors = 1;    remaining = nb_sectors;    sum_alloc = 0;    sector_num = offset >> 9;    while (remaining) {        ret = bdrv_is_allocated(bs, sector_num, remaining, &num);        sector_num += num;        remaining -= num;        if (ret) {            sum_alloc += num;        if (num == 0) {            nb_sectors -= remaining;            remaining = 0;    cvtstr(offset, s1, sizeof(s1));    printf(\"%d/%d sectors allocated at offset %s\\n\",           sum_alloc, nb_sectors, s1);", "idx": 6769}
{"project": "FFmpeg", "commit_id": "ce558c8f590610fc68596ef0b4ac2a9d299fbcb2", "target": 0, "function": "x11grab_read_packet(AVFormatContext *s1, AVPacket *pkt){    struct x11_grab *s = s1->priv_data;    Display *dpy = s->dpy;    XImage *image = s->image;    int x_off = s->x_off;    int y_off = s->y_off;    int64_t curtime, delay;    struct timespec ts;    /* Calculate the time of the next frame */    s->time_frame += INT64_C(1000000);    /* wait based on the frame rate */    for(;;) {        curtime = av_gettime();        delay = s->time_frame * av_q2d(s->time_base) - curtime;        if (delay <= 0) {            if (delay < INT64_C(-1000000) * av_q2d(s->time_base)) {                s->time_frame += INT64_C(1000000);            }            break;        }        ts.tv_sec = delay / 1000000;        ts.tv_nsec = (delay % 1000000) * 1000;        nanosleep(&ts, NULL);    }    av_init_packet(pkt);    pkt->data = image->data;    pkt->size = s->frame_size;    pkt->pts = curtime;    if(s->use_shm) {        if (!XShmGetImage(dpy, RootWindow(dpy, DefaultScreen(dpy)), image, x_off, y_off, AllPlanes)) {            av_log (s1, AV_LOG_INFO, \"XShmGetImage() failed\\n\");        }    } else {        if (!xget_zpixmap(dpy, RootWindow(dpy, DefaultScreen(dpy)), image, x_off, y_off)) {            av_log (s1, AV_LOG_INFO, \"XGetZPixmap() failed\\n\");        }    }    if(!s->nomouse){        paint_mouse_pointer(image, s);    }    return s->frame_size;}", "idx": 6804}
{"project": "FFmpeg", "commit_id": "b5da848facd41169283d7bfe568b83bdfa7fc42e", "target": 1, "function": "static void mp_decode_line(MotionPixelsContext *mp, GetBitContext *gb, int y){    YuvPixel p;    const int y0 = y * mp->avctx->width;    int w, i, x = 0;    p = mp->vpt[y];    if (mp->changes_map[y0 + x] == 0) {        memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));        ++x;    }    while (x < mp->avctx->width) {        w = mp->changes_map[y0 + x];        if (w != 0) {            if ((y & 3) == 0) {                if (mp->changes_map[y0 + x + mp->avctx->width] < w ||                    mp->changes_map[y0 + x + mp->avctx->width * 2] < w ||                    mp->changes_map[y0 + x + mp->avctx->width * 3] < w) {                    for (i = (x + 3) & ~3; i < x + w; i += 4) {                        mp->hpt[((y / 4) * mp->avctx->width + i) / 4] = mp_get_yuv_from_rgb(mp, i, y);                    }                }            }            x += w;            memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));            p = mp_get_yuv_from_rgb(mp, x - 1, y);        } else {            p.y += mp_gradient(mp, 0, mp_get_vlc(mp, gb));            if ((x & 3) == 0) {                if ((y & 3) == 0) {                    p.v += mp_gradient(mp, 1, mp_get_vlc(mp, gb));                    p.u += mp_gradient(mp, 2, mp_get_vlc(mp, gb));                    mp->hpt[((y / 4) * mp->avctx->width + x) / 4] = p;                } else {                    p.v = mp->hpt[((y / 4) * mp->avctx->width + x) / 4].v;                    p.u = mp->hpt[((y / 4) * mp->avctx->width + x) / 4].u;                }            }            mp_set_rgb_from_yuv(mp, x, y, &p);            ++x;        }    }}", "idx": 6814}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "function": "static QIOChannelSocket *nbd_establish_connection(SocketAddress *saddr_flat,                                                  Error **errp){    SocketAddressLegacy *saddr = socket_address_crumple(saddr_flat);    QIOChannelSocket *sioc;    Error *local_err = NULL;    sioc = qio_channel_socket_new();    qio_channel_set_name(QIO_CHANNEL(sioc), \"nbd-client\");    qio_channel_socket_connect_sync(sioc,                                    saddr,                                    &local_err);    qapi_free_SocketAddressLegacy(saddr);    if (local_err) {        object_unref(OBJECT(sioc));        error_propagate(errp, local_err);        return NULL;    }    qio_channel_set_delay(QIO_CHANNEL(sioc), false);    return sioc;}", "idx": 6858}
{"project": "FFmpeg", "commit_id": "c8dcff0cdb17d0aa03ac729eba12d1a20f1f59c8", "target": 0, "function": "int ff_h264_field_end(H264Context *h, H264SliceContext *sl, int in_setup){    AVCodecContext *const avctx = h->avctx;    int err = 0;    h->mb_y = 0;    if (!in_setup && !h->droppable)        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,                                  h->picture_structure == PICT_BOTTOM_FIELD);    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {        if (!h->droppable) {            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);            h->prev_poc_msb = h->poc_msb;            h->prev_poc_lsb = h->poc_lsb;        }        h->prev_frame_num_offset = h->frame_num_offset;        h->prev_frame_num        = h->frame_num;    }    if (avctx->hwaccel) {        if (avctx->hwaccel->end_frame(avctx) < 0)            av_log(avctx, AV_LOG_ERROR,                   \"hardware accelerator failed to decode picture\\n\");    }#if CONFIG_ERROR_RESILIENCE    /*     * FIXME: Error handling code does not seem to support interlaced     * when slices span multiple rows     * The ff_er_add_slice calls don't work right for bottom     * fields; they cause massive erroneous error concealing     * Error marking covers both fields (top and bottom).     * This causes a mismatched s->error_count     * and a bad error table. Further, the error count goes to     * INT_MAX when called for bottom field, because mb_y is     * past end by one (callers fault) and resync_mb_y != 0     * causes problems for the first MB line, too.     */    if (!FIELD_PICTURE(h) && h->enable_er) {        h264_set_erpic(&sl->er.cur_pic, h->cur_pic_ptr);        h264_set_erpic(&sl->er.last_pic,                       sl->ref_count[0] ? sl->ref_list[0][0].parent : NULL);        h264_set_erpic(&sl->er.next_pic,                       sl->ref_count[1] ? sl->ref_list[1][0].parent : NULL);        ff_er_frame_end(&sl->er);    }#endif /* CONFIG_ERROR_RESILIENCE */    emms_c();    h->current_slice = 0;    return err;}", "idx": 6913}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "function": "static void virtio_scsi_request_cancelled(SCSIRequest *r){    VirtIOSCSIReq *req = r->hba_private;    if (!req) {        return;    }    if (req->dev->resetting) {        req->resp.cmd->response = VIRTIO_SCSI_S_RESET;    } else {        req->resp.cmd->response = VIRTIO_SCSI_S_ABORTED;    }    virtio_scsi_complete_cmd_req(req);}", "idx": 6924}
{"project": "qemu", "commit_id": "f1af19d767073a0926ce12c19b1f06c4933bca35", "target": 1, "function": "void kvmppc_set_papr(CPUPPCState *env){    struct kvm_enable_cap cap = {};    struct kvm_one_reg reg = {};    struct kvm_sregs sregs = {};    int ret;    uint64_t hior = env->spr[SPR_HIOR];    cap.cap = KVM_CAP_PPC_PAPR;    ret = kvm_vcpu_ioctl(env, KVM_ENABLE_CAP, &cap);    if (ret) {        goto fail;    }    /*     * XXX We set HIOR here. It really should be a qdev property of     *     the CPU node, but we don't have CPUs converted to qdev yet.     *     *     Once we have qdev CPUs, move HIOR to a qdev property and     *     remove this chunk.     */    reg.id = KVM_REG_PPC_HIOR;    reg.addr = (uintptr_t)&hior;    ret = kvm_vcpu_ioctl(env, KVM_SET_ONE_REG, &reg);    if (ret) {        fprintf(stderr, \"Couldn't set HIOR. Maybe you're running an old \\n\"                        \"kernel with support for HV KVM but no PAPR PR \\n\"                        \"KVM in which case things will work. If they don't \\n\"                        \"please update your host kernel!\\n\");    }    /* Set SDR1 so kernel space finds the HTAB */    ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);    if (ret) {        goto fail;    }    sregs.u.s.sdr1 = env->spr[SPR_SDR1];    ret = kvm_vcpu_ioctl(env, KVM_SET_SREGS, &sregs);    if (ret) {        goto fail;    }    return;fail:    cpu_abort(env, \"This KVM version does not support PAPR\\n\");}", "idx": 6980}
{"project": "FFmpeg", "commit_id": "6701c92fa4269872856c70c3170a9b3291b46247", "target": 0, "function": "static int libopus_encode(AVCodecContext *avctx, AVPacket *avpkt,                          const AVFrame *frame, int *got_packet_ptr){    LibopusEncContext *opus = avctx->priv_data;    const int sample_size   = avctx->channels *                              av_get_bytes_per_sample(avctx->sample_fmt);    uint8_t *audio;    int ret;    int discard_padding;    if (frame) {        ret = ff_af_queue_add(&opus->afq, frame);        if (ret < 0)            return ret;        if (frame->nb_samples < opus->opts.packet_size) {            audio = opus->samples;            memcpy(audio, frame->data[0], frame->nb_samples * sample_size);        } else            audio = frame->data[0];    } else {        if (!opus->afq.remaining_samples)            return 0;        audio = opus->samples;        memset(audio, 0, opus->opts.packet_size * sample_size);    }    /* Maximum packet size taken from opusenc in opus-tools. 60ms packets     * consist of 3 frames in one packet. The maximum frame size is 1275     * bytes along with the largest possible packet header of 7 bytes. */    if ((ret = ff_alloc_packet2(avctx, avpkt, (1275 * 3 + 7) * opus->stream_count, 0)) < 0)        return ret;    if (avctx->sample_fmt == AV_SAMPLE_FMT_FLT)        ret = opus_multistream_encode_float(opus->enc, (float *)audio,                                            opus->opts.packet_size,                                            avpkt->data, avpkt->size);    else        ret = opus_multistream_encode(opus->enc, (opus_int16 *)audio,                                      opus->opts.packet_size,                                      avpkt->data, avpkt->size);    if (ret < 0) {        av_log(avctx, AV_LOG_ERROR,               \"Error encoding frame: %s\\n\", opus_strerror(ret));        return ff_opus_error_to_averror(ret);    }    av_shrink_packet(avpkt, ret);    ff_af_queue_remove(&opus->afq, opus->opts.packet_size,                       &avpkt->pts, &avpkt->duration);    discard_padding = opus->opts.packet_size - avpkt->duration;    // Check if subtraction resulted in an overflow    if ((discard_padding < opus->opts.packet_size) != (avpkt->duration > 0)) {        av_free_packet(avpkt);        av_free(avpkt);        return AVERROR(EINVAL);    }    if (discard_padding > 0) {        uint8_t* side_data = av_packet_new_side_data(avpkt,                                                     AV_PKT_DATA_SKIP_SAMPLES,                                                     10);        if(!side_data) {            av_free_packet(avpkt);            av_free(avpkt);            return AVERROR(ENOMEM);        }        AV_WL32(side_data + 4, discard_padding);    }    *got_packet_ptr = 1;    return 0;}", "idx": 7055}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint32_t slow_bar_readb(void *opaque, target_phys_addr_t addr){    AssignedDevRegion *d = opaque;    uint8_t *in = d->u.r_virtbase + addr;    uint32_t r;    r = *in;    DEBUG(\"slow_bar_readl addr=0x\" TARGET_FMT_plx \" val=0x%08x\\n\", addr, r);    return r;}", "idx": 7093}
{"project": "qemu", "commit_id": "ba801af429aaa68f6cc03842c8b6be81a6ede65a", "target": 0, "function": "void helper_mtc0_pagemask(CPUMIPSState *env, target_ulong arg1){    /* 1k pages not implemented */    env->CP0_PageMask = arg1 & (0x1FFFFFFF & (TARGET_PAGE_MASK << 1));}", "idx": 7118}
{"project": "FFmpeg", "commit_id": "a5b5ce2658bf7506bb31f0b2b4cb44ddbf9a3955", "target": 1, "function": "static int pcm_read_header(AVFormatContext *s){    PCMAudioDemuxerContext *s1 = s->priv_data;    AVStream *st;    uint8_t *mime_type = NULL;    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;    st->codecpar->codec_id    = s->iformat->raw_codec_id;    st->codecpar->sample_rate = s1->sample_rate;    st->codecpar->channels    = s1->channels;    av_opt_get(s->pb, \"mime_type\", AV_OPT_SEARCH_CHILDREN, &mime_type);    if (mime_type && s->iformat->mime_type) {        int rate = 0, channels = 0;        size_t len = strlen(s->iformat->mime_type);        if (!strncmp(s->iformat->mime_type, mime_type, len)) {            uint8_t *options = mime_type + len;            len = strlen(mime_type);            while (options < mime_type + len) {                options = strstr(options, \";\");                if (!options++)                    break;                if (!rate)                    sscanf(options, \" rate=%d\",     &rate);                if (!channels)                    sscanf(options, \" channels=%d\", &channels);            }            if (rate <= 0) {                av_log(s, AV_LOG_ERROR,                       \"Invalid sample_rate found in mime_type \\\"%s\\\"\\n\",                       mime_type);                return AVERROR_INVALIDDATA;            }            st->codecpar->sample_rate = rate;            if (channels > 0)                st->codecpar->channels = channels;        }    }    st->codecpar->bits_per_coded_sample =        av_get_bits_per_sample(st->codecpar->codec_id);    av_assert0(st->codecpar->bits_per_coded_sample > 0);    st->codecpar->block_align =        st->codecpar->bits_per_coded_sample * st->codecpar->channels / 8;    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);    return 0;}", "idx": 7129}
{"project": "qemu", "commit_id": "3f3a16990b09e62d787bd2eb2dd51aafbe90019a", "target": 1, "function": "static int local_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,                       const char *name, FsCred *credp){    char *path;    int err = -1;    int serrno = 0;    V9fsString fullname;    char *buffer = NULL;    v9fs_string_init(&fullname);    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);    path = fullname.data;    /* Determine the security model */    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {        buffer = rpath(fs_ctx, path);        err = mkdir(buffer, SM_LOCAL_DIR_MODE_BITS);        if (err == -1) {            goto out;        }        credp->fc_mode = credp->fc_mode|S_IFDIR;        err = local_set_xattr(buffer, credp);        if (err == -1) {            serrno = errno;            goto err_end;        }    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {        buffer = rpath(fs_ctx, path);        err = mkdir(buffer, SM_LOCAL_DIR_MODE_BITS);        if (err == -1) {            goto out;        }        credp->fc_mode = credp->fc_mode|S_IFDIR;        err = local_set_mapped_file_attr(fs_ctx, path, credp);        if (err == -1) {            serrno = errno;            goto err_end;        }    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||               (fs_ctx->export_flags & V9FS_SM_NONE)) {        buffer = rpath(fs_ctx, path);        err = mkdir(buffer, credp->fc_mode);        if (err == -1) {            goto out;        }        err = local_post_create_passthrough(fs_ctx, path, credp);        if (err == -1) {            serrno = errno;            goto err_end;        }    }    goto out;err_end:    remove(buffer);    errno = serrno;out:    g_free(buffer);    v9fs_string_free(&fullname);    return err;}", "idx": 7144}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "function": "void qemu_mutex_unlock_iothread(void) {}", "idx": 7152}
{"project": "FFmpeg", "commit_id": "3317414fc11a9a187b474141f4ac13f895c0b493", "target": 1, "function": "static AVIOContext * wtvfile_open_sector(int first_sector, uint64_t length, int depth, AVFormatContext *s){    AVIOContext *pb;    WtvFile *wf;    uint8_t *buffer;    if (avio_seek(s->pb, (int64_t)first_sector << WTV_SECTOR_BITS, SEEK_SET) < 0)        return NULL;    wf = av_mallocz(sizeof(WtvFile));    if (!wf)        return NULL;    if (depth == 0) {        wf->sectors = av_malloc(sizeof(uint32_t));        if (!wf->sectors) {            av_free(wf);            return NULL;        }        wf->sectors[0]  = first_sector;        wf->nb_sectors  = 1;    } else if (depth == 1) {        wf->sectors = av_malloc(WTV_SECTOR_SIZE);        if (!wf->sectors) {            av_free(wf);            return NULL;        }        wf->nb_sectors  = read_ints(s->pb, wf->sectors, WTV_SECTOR_SIZE / 4);    } else if (depth == 2) {        uint32_t sectors1[WTV_SECTOR_SIZE / 4];        int nb_sectors1 = read_ints(s->pb, sectors1, WTV_SECTOR_SIZE / 4);        int i;        wf->sectors = av_malloc(nb_sectors1 << WTV_SECTOR_BITS);        if (!wf->sectors) {            av_free(wf);            return NULL;        }        wf->nb_sectors = 0;        for (i = 0; i < nb_sectors1; i++) {            if (avio_seek(s->pb, (int64_t)sectors1[i] << WTV_SECTOR_BITS, SEEK_SET) < 0)                break;            wf->nb_sectors += read_ints(s->pb, wf->sectors + i * WTV_SECTOR_SIZE / 4, WTV_SECTOR_SIZE / 4);        }    } else {        av_log(s, AV_LOG_ERROR, \"unsupported file allocation table depth (0x%x)\\n\", depth);        av_free(wf);        return NULL;    }    wf->sector_bits = length & (1ULL<<63) ? WTV_SECTOR_BITS : WTV_BIGSECTOR_BITS;    if (!wf->nb_sectors) {        av_free(wf->sectors);        av_free(wf);        return NULL;    }    if (wf->sectors[wf->nb_sectors - 1] << WTV_SECTOR_BITS > avio_tell(s->pb))        av_log(s, AV_LOG_WARNING, \"truncated file\\n\");    /* check length */    length &= 0xFFFFFFFFFFFF;    if (length > ((int64_t)wf->nb_sectors << wf->sector_bits)) {        av_log(s, AV_LOG_WARNING, \"reported file length (0x%\"PRIx64\") exceeds number of available sectors (0x%\"PRIx64\")\\n\", length, (int64_t)wf->nb_sectors << wf->sector_bits);        length = (int64_t)wf->nb_sectors <<  wf->sector_bits;    }    wf->length = length;    /* seek to initial sector */    wf->position = 0;    if (avio_seek(s->pb, (int64_t)wf->sectors[0] << WTV_SECTOR_BITS, SEEK_SET) < 0) {        av_free(wf->sectors);        av_free(wf);        return NULL;    }    wf->pb_filesystem = s->pb;    buffer = av_malloc(1 << wf->sector_bits);    if (!buffer) {        av_free(wf->sectors);        av_free(wf);        return NULL;    }    pb = avio_alloc_context(buffer, 1 << wf->sector_bits, 0, wf,                           wtvfile_read_packet, NULL, wtvfile_seek);    if (!pb) {        av_free(buffer);        av_free(wf->sectors);        av_free(wf);    }    return pb;}", "idx": 7166}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "function": "static void gen_logicq_cc(TCGv_i64 val){    TCGv tmp = new_tmp();    gen_helper_logicq_cc(tmp, val);    gen_logic_CC(tmp);    dead_tmp(tmp);}", "idx": 7190}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "function": "void memory_region_del_eventfd(MemoryRegion *mr,                               hwaddr addr,                               unsigned size,                               bool match_data,                               uint64_t data,                               EventNotifier *e){    MemoryRegionIoeventfd mrfd = {        .addr.start = int128_make64(addr),        .addr.size = int128_make64(size),        .match_data = match_data,        .data = data,        .e = e,    };    unsigned i;    adjust_endianness(mr, &mrfd.data, size);    memory_region_transaction_begin();    for (i = 0; i < mr->ioeventfd_nb; ++i) {        if (memory_region_ioeventfd_equal(mrfd, mr->ioeventfds[i])) {            break;        }    }    assert(i != mr->ioeventfd_nb);    memmove(&mr->ioeventfds[i], &mr->ioeventfds[i+1],            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));    --mr->ioeventfd_nb;    mr->ioeventfds = g_realloc(mr->ioeventfds,                                  sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);    ioeventfd_update_pending |= mr->enabled;    memory_region_transaction_commit();}", "idx": 7196}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "function": "static void sdp_parse_fmtp(AVStream *st, const char *p){    char attr[256];    /* Vorbis setup headers can be up to 12KB and are sent base64     * encoded, giving a 12KB * (4/3) = 16KB FMTP line. */    char value[16384];    int i;    RTSPStream *rtsp_st = st->priv_data;    AVCodecContext *codec = st->codec;    RTPPayloadData *rtp_payload_data = &rtsp_st->rtp_payload_data;    /* loop on each attribute */    while(rtsp_next_attr_and_value(&p, attr, sizeof(attr), value, sizeof(value)))    {        /* grab the codec extra_data from the config parameter of the fmtp line */        sdp_parse_fmtp_config(codec, rtsp_st->dynamic_protocol_context,                              attr, value);        /* Looking for a known attribute */        for (i = 0; attr_names[i].str; ++i) {            if (!strcasecmp(attr, attr_names[i].str)) {                if (attr_names[i].type == ATTR_NAME_TYPE_INT)                    *(int *)((char *)rtp_payload_data + attr_names[i].offset) = atoi(value);                else if (attr_names[i].type == ATTR_NAME_TYPE_STR)                    *(char **)((char *)rtp_payload_data + attr_names[i].offset) = av_strdup(value);            }        }    }}", "idx": 7258}
{"project": "qemu", "commit_id": "b0b1d69079fcb9453f45aade9e9f6b71422147b0", "target": 1, "function": "int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info){    int handle = 0;    int n;    if (arch_info->exception == 1) {        if (arch_info->dr6 & (1 << 14)) {            if (cpu_single_env->singlestep_enabled)                handle = 1;        } else {            for (n = 0; n < 4; n++)                if (arch_info->dr6 & (1 << n))                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {                    case 0x0:                        handle = 1;                        break;                    case 0x1:                        handle = 1;                        cpu_single_env->watchpoint_hit = &hw_watchpoint;                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;                        hw_watchpoint.flags = BP_MEM_WRITE;                        break;                    case 0x3:                        handle = 1;                        cpu_single_env->watchpoint_hit = &hw_watchpoint;                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;                        hw_watchpoint.flags = BP_MEM_ACCESS;                        break;                    }        }    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))        handle = 1;    if (!handle)        kvm_update_guest_debug(cpu_single_env,                        (arch_info->exception == 1) ?                        KVM_GUESTDBG_INJECT_DB : KVM_GUESTDBG_INJECT_BP);    return handle;}", "idx": 7301}
{"project": "FFmpeg", "commit_id": "e9064c9ce8ed18c3a3aab61e58e663b8f5b0c551", "target": 1, "function": "static void cmv_decode_inter(CmvContext * s, const uint8_t *buf, const uint8_t *buf_end){    const uint8_t *raw = buf + (s->avctx->width*s->avctx->height/16);    int x,y,i;    i = 0;    for(y=0; y<s->avctx->height/4; y++)    for(x=0; x<s->avctx->width/4 && buf+i<buf_end; x++) {        if (buf[i]==0xFF) {            unsigned char *dst = s->frame.data[0] + (y*4)*s->frame.linesize[0] + x*4;            if (raw+16<buf_end && *raw==0xFF) { /* intra */                raw++;                memcpy(dst, raw, 4);                memcpy(dst+s->frame.linesize[0], raw+4, 4);                memcpy(dst+2*s->frame.linesize[0], raw+8, 4);                memcpy(dst+3*s->frame.linesize[0], raw+12, 4);                raw+=16;            }else if(raw<buf_end) {  /* inter using second-last frame as reference */                int xoffset = (*raw & 0xF) - 7;                int yoffset = ((*raw >> 4)) - 7;                if (s->last2_frame.data[0])                    cmv_motcomp(s->frame.data[0], s->frame.linesize[0],                                s->last2_frame.data[0], s->last2_frame.linesize[0],                                x*4, y*4, xoffset, yoffset, s->avctx->width, s->avctx->height);                raw++;            }        }else{  /* inter using last frame as reference */            int xoffset = (buf[i] & 0xF) - 7;            int yoffset = ((buf[i] >> 4)) - 7;            cmv_motcomp(s->frame.data[0], s->frame.linesize[0],                      s->last_frame.data[0], s->last_frame.linesize[0],                      x*4, y*4, xoffset, yoffset, s->avctx->width, s->avctx->height);        }        i++;    }}", "idx": 7304}
{"project": "qemu", "commit_id": "99f2cf4b2dad7b37c69759deb0d0b19d3ec1a24a", "target": 1, "function": "static void local_mapped_file_attr(int dirfd, const char *name,                                   struct stat *stbuf){    FILE *fp;    char buf[ATTR_MAX];    int map_dirfd;    map_dirfd = openat(dirfd, VIRTFS_META_DIR,                       O_RDONLY | O_DIRECTORY | O_NOFOLLOW);    if (map_dirfd == -1) {        return;    }    fp = local_fopenat(map_dirfd, name, \"r\");    close_preserve_errno(map_dirfd);    if (!fp) {        return;    }    memset(buf, 0, ATTR_MAX);    while (fgets(buf, ATTR_MAX, fp)) {        if (!strncmp(buf, \"virtfs.uid\", 10)) {            stbuf->st_uid = atoi(buf+11);        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {            stbuf->st_gid = atoi(buf+11);        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {            stbuf->st_mode = atoi(buf+12);        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {            stbuf->st_rdev = atoi(buf+12);        }        memset(buf, 0, ATTR_MAX);    }    fclose(fp);}", "idx": 7308}
{"project": "qemu", "commit_id": "96c05abc904c6f74b60981d956cee531920e4cdf", "target": 0, "function": "static int qxl_init_common(PCIQXLDevice *qxl){    uint8_t* config = qxl->pci.config;    uint32_t pci_device_id;    uint32_t pci_device_rev;    uint32_t io_size;    qxl->mode = QXL_MODE_UNDEFINED;    qxl->generation = 1;    qxl->num_memslots = NUM_MEMSLOTS;    qxl->num_surfaces = NUM_SURFACES;    switch (qxl->revision) {    case 1: /* spice 0.4 -- qxl-1 */        pci_device_id  = QXL_DEVICE_ID_STABLE;        pci_device_rev = QXL_REVISION_STABLE_V04;        break;    case 2: /* spice 0.6 -- qxl-2 */        pci_device_id  = QXL_DEVICE_ID_STABLE;        pci_device_rev = QXL_REVISION_STABLE_V06;        break;    default: /* experimental */        pci_device_id  = QXL_DEVICE_ID_DEVEL;        pci_device_rev = 1;        break;    }    pci_config_set_vendor_id(config, REDHAT_PCI_VENDOR_ID);    pci_config_set_device_id(config, pci_device_id);    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);    qxl->rom_size = qxl_rom_size();    qxl->rom_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vrom\", qxl->rom_size);    init_qxl_rom(qxl);    init_qxl_ram(qxl);    if (qxl->vram_size < 16 * 1024 * 1024) {        qxl->vram_size = 16 * 1024 * 1024;    }    if (qxl->revision == 1) {        qxl->vram_size = 4096;    }    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);    qxl->vram_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vram\", qxl->vram_size);    io_size = msb_mask(QXL_IO_RANGE_SIZE * 2 - 1);    if (qxl->revision == 1) {        io_size = 8;    }    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,                     io_size, PCI_BASE_ADDRESS_SPACE_IO, qxl_map);    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,                     qxl->rom_size, PCI_BASE_ADDRESS_SPACE_MEMORY,                     qxl_map);    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,                     qxl->vga.vram_size, PCI_BASE_ADDRESS_SPACE_MEMORY,                     qxl_map);    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, qxl->vram_size,                     PCI_BASE_ADDRESS_SPACE_MEMORY, qxl_map);    qxl->ssd.qxl.base.sif = &qxl_interface.base;    qxl->ssd.qxl.id = qxl->id;    qemu_spice_add_interface(&qxl->ssd.qxl.base);    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);    init_pipe_signaling(qxl);    qxl_reset_state(qxl);    return 0;}", "idx": 7325}
{"project": "qemu", "commit_id": "b5ec5ce0e39d6e7ea707d5604a5f6d567dfd2f48", "target": 0, "function": "static void add_flagname_to_bitmaps(const char *flagname, uint32_t *features,                                    uint32_t *ext_features,                                    uint32_t *ext2_features,                                    uint32_t *ext3_features,                                    uint32_t *kvm_features){    int i;    int found = 0;    for ( i = 0 ; i < 32 ; i++ )        if (feature_name[i] && !strcmp (flagname, feature_name[i])) {            *features |= 1 << i;            found = 1;        }    for ( i = 0 ; i < 32 ; i++ )        if (ext_feature_name[i] && !strcmp (flagname, ext_feature_name[i])) {            *ext_features |= 1 << i;            found = 1;        }    for ( i = 0 ; i < 32 ; i++ )        if (ext2_feature_name[i] && !strcmp (flagname, ext2_feature_name[i])) {            *ext2_features |= 1 << i;            found = 1;        }    for ( i = 0 ; i < 32 ; i++ )        if (ext3_feature_name[i] && !strcmp (flagname, ext3_feature_name[i])) {            *ext3_features |= 1 << i;            found = 1;        }    for ( i = 0 ; i < 32 ; i++ )        if (kvm_feature_name[i] && !strcmp (flagname, kvm_feature_name[i])) {            *kvm_features |= 1 << i;            found = 1;        }    if (!found) {        fprintf(stderr, \"CPU feature %s not found\\n\", flagname);    }}", "idx": 7333}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "function": "static void unterminated_literal(void){    QObject *obj = qobject_from_json(\"nul\", NULL);    g_assert(obj == NULL);}", "idx": 7349}
{"project": "qemu", "commit_id": "6886b98036a8f8f5bce8b10756ce080084cef11b", "target": 0, "function": "static void cpu_exit_tb_from_sighandler(CPUState *cpu, void *puc){#ifdef __linux__    struct ucontext *uc = puc;#elif defined(__OpenBSD__)    struct sigcontext *uc = puc;#endif    /* XXX: use siglongjmp ? */#ifdef __linux__#ifdef __ia64    sigprocmask(SIG_SETMASK, (sigset_t *)&uc->uc_sigmask, NULL);#else    sigprocmask(SIG_SETMASK, &uc->uc_sigmask, NULL);#endif#elif defined(__OpenBSD__)    sigprocmask(SIG_SETMASK, &uc->sc_mask, NULL);#endif    cpu_resume_from_signal(cpu, NULL);}", "idx": 7370}
{"project": "FFmpeg", "commit_id": "26ae9a5d7c448a3eb42641b546ee8d585ab716e6", "target": 1, "function": "static int update_context_from_thread(AVCodecContext *dst, AVCodecContext *src, int for_user){    int err = 0;    if (dst != src) {        dst->sub_id    = src->sub_id;        dst->time_base = src->time_base;        dst->width     = src->width;        dst->height    = src->height;        dst->pix_fmt   = src->pix_fmt;        dst->coded_width  = src->coded_width;        dst->coded_height = src->coded_height;        dst->has_b_frames = src->has_b_frames;        dst->idct_algo    = src->idct_algo;        dst->slice_count  = src->slice_count;        dst->bits_per_coded_sample = src->bits_per_coded_sample;        dst->sample_aspect_ratio   = src->sample_aspect_ratio;        dst->dtg_active_format     = src->dtg_active_format;        dst->profile = src->profile;        dst->level   = src->level;        dst->bits_per_raw_sample = src->bits_per_raw_sample;        dst->ticks_per_frame     = src->ticks_per_frame;        dst->color_primaries     = src->color_primaries;        dst->color_trc   = src->color_trc;        dst->colorspace  = src->colorspace;        dst->color_range = src->color_range;        dst->chroma_sample_location = src->chroma_sample_location;    }    if (for_user) {        dst->coded_frame   = src->coded_frame;        dst->has_b_frames += src->thread_count - 1;    } else {        if (dst->codec->update_thread_context)            err = dst->codec->update_thread_context(dst, src);    }    return err;}", "idx": 7391}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "function": "static void qemu_chr_parse_udp(QemuOpts *opts, ChardevBackend *backend,                               Error **errp){    const char *host = qemu_opt_get(opts, \"host\");    const char *port = qemu_opt_get(opts, \"port\");    const char *localaddr = qemu_opt_get(opts, \"localaddr\");    const char *localport = qemu_opt_get(opts, \"localport\");    bool has_local = false;    SocketAddress *addr;    if (host == NULL || strlen(host) == 0) {        host = \"localhost\";    }    if (port == NULL || strlen(port) == 0) {        error_setg(errp, \"chardev: udp: remote port not specified\");        return;    }    if (localport == NULL || strlen(localport) == 0) {        localport = \"0\";    } else {        has_local = true;    }    if (localaddr == NULL || strlen(localaddr) == 0) {        localaddr = \"\";    } else {        has_local = true;    }    backend->udp = g_new0(ChardevUdp, 1);    addr = g_new0(SocketAddress, 1);    addr->kind = SOCKET_ADDRESS_KIND_INET;    addr->inet = g_new0(InetSocketAddress, 1);    addr->inet->host = g_strdup(host);    addr->inet->port = g_strdup(port);    addr->inet->has_ipv4 = qemu_opt_get(opts, \"ipv4\");    addr->inet->ipv4 = qemu_opt_get_bool(opts, \"ipv4\", 0);    addr->inet->has_ipv6 = qemu_opt_get(opts, \"ipv6\");    addr->inet->ipv6 = qemu_opt_get_bool(opts, \"ipv6\", 0);    backend->udp->remote = addr;    if (has_local) {        backend->udp->has_local = true;        addr = g_new0(SocketAddress, 1);        addr->kind = SOCKET_ADDRESS_KIND_INET;        addr->inet = g_new0(InetSocketAddress, 1);        addr->inet->host = g_strdup(localaddr);        addr->inet->port = g_strdup(localport);        backend->udp->local = addr;    }}", "idx": 7453}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "function": "target_ulong do_arm_semihosting(CPUARMState *env){    ARMCPU *cpu = arm_env_get_cpu(env);    CPUState *cs = CPU(cpu);    target_ulong args;    target_ulong arg0, arg1, arg2, arg3;    char * s;    int nr;    uint32_t ret;    uint32_t len;#ifdef CONFIG_USER_ONLY    TaskState *ts = cs->opaque;#else    CPUARMState *ts = env;#endif    if (is_a64(env)) {        /* Note that the syscall number is in W0, not X0 */        nr = env->xregs[0] & 0xffffffffU;        args = env->xregs[1];    } else {        nr = env->regs[0];        args = env->regs[1];    }    switch (nr) {    case TARGET_SYS_OPEN:        GET_ARG(0);        GET_ARG(1);        GET_ARG(2);        s = lock_user_string(arg0);        if (!s) {            /* FIXME - should this error code be -TARGET_EFAULT ? */            return (uint32_t)-1;        }        if (arg1 >= 12) {            unlock_user(s, arg0, 0);            return (uint32_t)-1;        }        if (strcmp(s, \":tt\") == 0) {            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;            unlock_user(s, arg0, 0);            return result_fileno;        }        if (use_gdb_syscalls()) {            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,                                  (int)arg2+1, gdb_open_modeflags[arg1]);        } else {            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));        }        unlock_user(s, arg0, 0);        return ret;    case TARGET_SYS_CLOSE:        GET_ARG(0);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);        } else {            return set_swi_errno(ts, close(arg0));        }    case TARGET_SYS_WRITEC:        {          char c;          if (get_user_u8(c, args))              /* FIXME - should this error code be -TARGET_EFAULT ? */              return (uint32_t)-1;          /* Write to debug console.  stderr is near enough.  */          if (use_gdb_syscalls()) {                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);          } else {                return write(STDERR_FILENO, &c, 1);          }        }    case TARGET_SYS_WRITE0:        if (!(s = lock_user_string(args)))            /* FIXME - should this error code be -TARGET_EFAULT ? */            return (uint32_t)-1;        len = strlen(s);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",                                   args, len);        } else {            ret = write(STDERR_FILENO, s, len);        }        unlock_user(s, args, 0);        return ret;    case TARGET_SYS_WRITE:        GET_ARG(0);        GET_ARG(1);        GET_ARG(2);        len = arg2;        if (use_gdb_syscalls()) {            arm_semi_syscall_len = len;            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",                                   arg0, arg1, len);        } else {            s = lock_user(VERIFY_READ, arg1, len, 1);            if (!s) {                /* FIXME - should this error code be -TARGET_EFAULT ? */                return (uint32_t)-1;            }            ret = set_swi_errno(ts, write(arg0, s, len));            unlock_user(s, arg1, 0);            if (ret == (uint32_t)-1)                return -1;            return len - ret;        }    case TARGET_SYS_READ:        GET_ARG(0);        GET_ARG(1);        GET_ARG(2);        len = arg2;        if (use_gdb_syscalls()) {            arm_semi_syscall_len = len;            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",                                   arg0, arg1, len);        } else {            s = lock_user(VERIFY_WRITE, arg1, len, 0);            if (!s) {                /* FIXME - should this error code be -TARGET_EFAULT ? */                return (uint32_t)-1;            }            do {                ret = set_swi_errno(ts, read(arg0, s, len));            } while (ret == -1 && errno == EINTR);            unlock_user(s, arg1, len);            if (ret == (uint32_t)-1)                return -1;            return len - ret;        }    case TARGET_SYS_READC:       /* XXX: Read from debug console. Not implemented.  */        return 0;    case TARGET_SYS_ISTTY:        GET_ARG(0);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);        } else {            return isatty(arg0);        }    case TARGET_SYS_SEEK:        GET_ARG(0);        GET_ARG(1);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",                                   arg0, arg1);        } else {            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));            if (ret == (uint32_t)-1)              return -1;            return 0;        }    case TARGET_SYS_FLEN:        GET_ARG(0);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",                                   arg0, arm_flen_buf(cpu));        } else {            struct stat buf;            ret = set_swi_errno(ts, fstat(arg0, &buf));            if (ret == (uint32_t)-1)                return -1;            return buf.st_size;        }    case TARGET_SYS_TMPNAM:        /* XXX: Not implemented.  */        return -1;    case TARGET_SYS_REMOVE:        GET_ARG(0);        GET_ARG(1);        if (use_gdb_syscalls()) {            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",                                  arg0, (int)arg1+1);        } else {            s = lock_user_string(arg0);            if (!s) {                /* FIXME - should this error code be -TARGET_EFAULT ? */                return (uint32_t)-1;            }            ret =  set_swi_errno(ts, remove(s));            unlock_user(s, arg0, 0);        }        return ret;    case TARGET_SYS_RENAME:        GET_ARG(0);        GET_ARG(1);        GET_ARG(2);        GET_ARG(3);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",                                   arg0, (int)arg1+1, arg2, (int)arg3+1);        } else {            char *s2;            s = lock_user_string(arg0);            s2 = lock_user_string(arg2);            if (!s || !s2)                /* FIXME - should this error code be -TARGET_EFAULT ? */                ret = (uint32_t)-1;            else                ret = set_swi_errno(ts, rename(s, s2));            if (s2)                unlock_user(s2, arg2, 0);            if (s)                unlock_user(s, arg0, 0);            return ret;        }    case TARGET_SYS_CLOCK:        return clock() / (CLOCKS_PER_SEC / 100);    case TARGET_SYS_TIME:        return set_swi_errno(ts, time(NULL));    case TARGET_SYS_SYSTEM:        GET_ARG(0);        GET_ARG(1);        if (use_gdb_syscalls()) {            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",                                   arg0, (int)arg1+1);        } else {            s = lock_user_string(arg0);            if (!s) {                /* FIXME - should this error code be -TARGET_EFAULT ? */                return (uint32_t)-1;            }            ret = set_swi_errno(ts, system(s));            unlock_user(s, arg0, 0);            return ret;        }    case TARGET_SYS_ERRNO:#ifdef CONFIG_USER_ONLY        return ts->swi_errno;#else        return syscall_err;#endif    case TARGET_SYS_GET_CMDLINE:        {            /* Build a command-line from the original argv.             *             * The inputs are:             *     * arg0, pointer to a buffer of at least the size             *               specified in arg1.             *     * arg1, size of the buffer pointed to by arg0 in             *               bytes.             *             * The outputs are:             *     * arg0, pointer to null-terminated string of the             *               command line.             *     * arg1, length of the string pointed to by arg0.             */            char *output_buffer;            size_t input_size;            size_t output_size;            int status = 0;#if !defined(CONFIG_USER_ONLY)            const char *cmdline;#endif            GET_ARG(0);            GET_ARG(1);            input_size = arg1;            /* Compute the size of the output string.  */#if !defined(CONFIG_USER_ONLY)            cmdline = semihosting_get_cmdline();            if (cmdline == NULL) {                cmdline = \"\"; /* Default to an empty line. */            }            output_size = strlen(cmdline) + 1; /* Count terminating 0. */#else            unsigned int i;            output_size = ts->info->arg_end - ts->info->arg_start;            if (!output_size) {                /* We special-case the \"empty command line\" case (argc==0).                   Just provide the terminating 0. */                output_size = 1;            }#endif            if (output_size > input_size) {                 /* Not enough space to store command-line arguments.  */                return -1;            }            /* Adjust the command-line length.  */            if (SET_ARG(1, output_size - 1)) {                /* Couldn't write back to argument block */                return -1;            }            /* Lock the buffer on the ARM side.  */            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);            if (!output_buffer) {                return -1;            }            /* Copy the command-line arguments.  */#if !defined(CONFIG_USER_ONLY)            pstrcpy(output_buffer, output_size, cmdline);#else            if (output_size == 1) {                /* Empty command-line.  */                output_buffer[0] = '\\0';                goto out;            }            if (copy_from_user(output_buffer, ts->info->arg_start,                               output_size)) {                status = -1;                goto out;            }            /* Separate arguments by white spaces.  */            for (i = 0; i < output_size - 1; i++) {                if (output_buffer[i] == 0) {                    output_buffer[i] = ' ';                }            }        out:#endif            /* Unlock the buffer on the ARM side.  */            unlock_user(output_buffer, arg0, output_size);            return status;        }    case TARGET_SYS_HEAPINFO:        {            target_ulong retvals[4];            uint32_t limit;            int i;            GET_ARG(0);#ifdef CONFIG_USER_ONLY            /* Some C libraries assume the heap immediately follows .bss, so               allocate it using sbrk.  */            if (!ts->heap_limit) {                abi_ulong ret;                ts->heap_base = do_brk(0);                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;                /* Try a big heap, and reduce the size if that fails.  */                for (;;) {                    ret = do_brk(limit);                    if (ret >= limit) {                        break;                    }                    limit = (ts->heap_base >> 1) + (limit >> 1);                }                ts->heap_limit = limit;            }            retvals[0] = ts->heap_base;            retvals[1] = ts->heap_limit;            retvals[2] = ts->stack_base;            retvals[3] = 0; /* Stack limit.  */#else            limit = ram_size;            /* TODO: Make this use the limit of the loaded application.  */            retvals[0] = limit / 2;            retvals[1] = limit;            retvals[2] = limit; /* Stack base */            retvals[3] = 0; /* Stack limit.  */#endif            for (i = 0; i < ARRAY_SIZE(retvals); i++) {                bool fail;                if (is_a64(env)) {                    fail = put_user_u64(retvals[i], arg0 + i * 8);                } else {                    fail = put_user_u32(retvals[i], arg0 + i * 4);                }                if (fail) {                    /* Couldn't write back to argument block */                    return -1;                }            }            return 0;        }    case TARGET_SYS_EXIT:        if (is_a64(env)) {            /* The A64 version of this call takes a parameter block,             * so the application-exit type can return a subcode which             * is the exit status code from the application.             */            GET_ARG(0);            GET_ARG(1);            if (arg0 == ADP_Stopped_ApplicationExit) {                ret = arg1;            } else {                ret = 1;            }        } else {            /* ARM specifies only Stopped_ApplicationExit as normal             * exit, everything else is considered an error */            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;        }        gdb_exit(env, ret);        exit(ret);    case TARGET_SYS_SYNCCACHE:        /* Clean the D-cache and invalidate the I-cache for the specified         * virtual address range. This is a nop for us since we don't         * implement caches. This is only present on A64.         */        if (is_a64(env)) {            return 0;        }        /* fall through -- invalid for A32/T32 */    default:        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);        cpu_dump_state(cs, stderr, fprintf, 0);        abort();    }}", "idx": 7462}
{"project": "FFmpeg", "commit_id": "b073819bc974965056f435d69dc51e9ec5877395", "target": 0, "function": "static void do_audio_out(AVFormatContext *s, OutputStream *ost,                         InputStream *ist, AVFrame *decoded_frame){    uint8_t *buftmp;    int size_out, frame_bytes, resample_changed;    AVCodecContext *enc = ost->st->codec;    AVCodecContext *dec = ist->st->codec;    int osize = av_get_bytes_per_sample(enc->sample_fmt);    int isize = av_get_bytes_per_sample(dec->sample_fmt);    uint8_t *buf = decoded_frame->data[0];    int size     = decoded_frame->nb_samples * dec->channels * isize;    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples) < 0) {        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");        exit_program(1);    }    if (enc->channels != dec->channels || enc->sample_rate != dec->sample_rate)        ost->audio_resample = 1;    resample_changed = ost->resample_sample_fmt  != dec->sample_fmt ||                       ost->resample_channels    != dec->channels   ||                       ost->resample_sample_rate != dec->sample_rate;    if ((ost->audio_resample && !ost->resample) || resample_changed) {        if (resample_changed) {            av_log(NULL, AV_LOG_INFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d to rate:%d fmt:%s ch:%d\\n\",                   ist->file_index, ist->st->index,                   ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt), ost->resample_channels,                   dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt), dec->channels);            ost->resample_sample_fmt  = dec->sample_fmt;            ost->resample_channels    = dec->channels;            ost->resample_sample_rate = dec->sample_rate;            if (ost->resample)                audio_resample_close(ost->resample);        }        /* if audio_sync_method is >1 the resampler is needed for audio drift compensation */        if (audio_sync_method <= 1 &&            ost->resample_sample_fmt  == enc->sample_fmt &&            ost->resample_channels    == enc->channels   &&            ost->resample_sample_rate == enc->sample_rate) {            ost->resample = NULL;            ost->audio_resample = 0;        } else if (ost->audio_resample) {            if (dec->sample_fmt != AV_SAMPLE_FMT_S16)                av_log(NULL, AV_LOG_WARNING, \"Using s16 intermediate sample format for resampling\\n\");            ost->resample = av_audio_resample_init(enc->channels,    dec->channels,                                                   enc->sample_rate, dec->sample_rate,                                                   enc->sample_fmt,  dec->sample_fmt,                                                   16, 10, 0, 0.8);            if (!ost->resample) {                av_log(NULL, AV_LOG_FATAL, \"Can not resample %d channels @ %d Hz to %d channels @ %d Hz\\n\",                       dec->channels, dec->sample_rate,                       enc->channels, enc->sample_rate);                exit_program(1);            }        }    }#define MAKE_SFMT_PAIR(a,b) ((a)+AV_SAMPLE_FMT_NB*(b))    if (!ost->audio_resample && dec->sample_fmt != enc->sample_fmt &&        MAKE_SFMT_PAIR(enc->sample_fmt,dec->sample_fmt) != ost->reformat_pair) {        if (ost->reformat_ctx)            av_audio_convert_free(ost->reformat_ctx);        ost->reformat_ctx = av_audio_convert_alloc(enc->sample_fmt, 1,                                                   dec->sample_fmt, 1, NULL, 0);        if (!ost->reformat_ctx) {            av_log(NULL, AV_LOG_FATAL, \"Cannot convert %s sample format to %s sample format\\n\",                   av_get_sample_fmt_name(dec->sample_fmt),                   av_get_sample_fmt_name(enc->sample_fmt));            exit_program(1);        }        ost->reformat_pair = MAKE_SFMT_PAIR(enc->sample_fmt,dec->sample_fmt);    }    if (audio_sync_method) {        double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts -                       av_fifo_size(ost->fifo) / (enc->channels * osize);        int idelta = delta * dec->sample_rate / enc->sample_rate;        int byte_delta = idelta * isize * dec->channels;        // FIXME resample delay        if (fabs(delta) > 50) {            if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) {                if (byte_delta < 0) {                    byte_delta = FFMAX(byte_delta, -size);                    size += byte_delta;                    buf  -= byte_delta;                    av_log(NULL, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\",                           -byte_delta / (isize * dec->channels));                    if (!size)                        return;                    ist->is_start = 0;                } else {                    av_fast_malloc(&async_buf, &allocated_async_buf_size,                                   byte_delta + size);                    if (!async_buf) {                        av_log(NULL, AV_LOG_FATAL, \"Out of memory in do_audio_out\\n\");                        exit_program(1);                    }                    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta) < 0) {                        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");                        exit_program(1);                    }                    ist->is_start = 0;                    generate_silence(async_buf, dec->sample_fmt, byte_delta);                    memcpy(async_buf + byte_delta, buf, size);                    buf = async_buf;                    size += byte_delta;                    av_log(NULL, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", idelta);                }            } else if (audio_sync_method > 1) {                int comp = av_clip(delta, -audio_sync_method, audio_sync_method);                av_assert0(ost->audio_resample);                av_log(NULL, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\",                       delta, comp, enc->sample_rate);//                fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));                av_resample_compensate(*(struct AVResampleContext**)ost->resample, comp, enc->sample_rate);            }        }    } else        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong    if (ost->audio_resample) {        buftmp = audio_buf;        size_out = audio_resample(ost->resample,                                  (short *)buftmp, (short *)buf,                                  size / (dec->channels * isize));        size_out = size_out * enc->channels * osize;    } else {        buftmp = buf;        size_out = size;    }    if (!ost->audio_resample && dec->sample_fmt != enc->sample_fmt) {        const void *ibuf[6] = { buftmp };        void *obuf[6]  = { audio_buf };        int istride[6] = { isize };        int ostride[6] = { osize };        int len = size_out / istride[0];        if (av_audio_convert(ost->reformat_ctx, obuf, ostride, ibuf, istride, len) < 0) {            printf(\"av_audio_convert() failed\\n\");            if (exit_on_error)                exit_program(1);            return;        }        buftmp = audio_buf;        size_out = len * osize;    }    /* now encode as many frames as possible */    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {        /* output resampled raw samples */        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");            exit_program(1);        }        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);        frame_bytes = enc->frame_size * osize * enc->channels;        while (av_fifo_size(ost->fifo) >= frame_bytes) {            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);            encode_audio_frame(s, ost, audio_buf, frame_bytes);        }    } else {        encode_audio_frame(s, ost, buftmp, size_out);    }}", "idx": 7473}
{"project": "qemu", "commit_id": "a8ff4316795c7051b38727ec4a81c65dfcf63dc6", "target": 0, "function": "static void xen_io_add(MemoryListener *listener,                       MemoryRegionSection *section){    XenIOState *state = container_of(listener, XenIOState, io_listener);    memory_region_ref(section->mr);    xen_map_io_section(xen_xc, xen_domid, state->ioservid, section);}", "idx": 7488}
{"project": "qemu", "commit_id": "a9a86ae95d24c587285856405dffc9cacdf2b683", "target": 0, "function": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,                const TCGArg *args, const int *const_args){    int c;    switch (opc) {    case INDEX_op_exit_tb:        {            uint8_t *ld_ptr = s->code_ptr;            if (args[0] >> 8)                tcg_out_ld32_12(s, COND_AL, TCG_REG_R0, TCG_REG_PC, 0);            else                tcg_out_dat_imm(s, COND_AL, ARITH_MOV, TCG_REG_R0, 0, args[0]);            tcg_out_goto(s, COND_AL, (tcg_target_ulong) tb_ret_addr);            if (args[0] >> 8) {                *ld_ptr = (uint8_t) (s->code_ptr - ld_ptr) - 8;                tcg_out32(s, args[0]);            }        }        break;    case INDEX_op_goto_tb:        if (s->tb_jmp_offset) {            /* Direct jump method */#if defined(USE_DIRECT_JUMP)            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;            tcg_out_b_noaddr(s, COND_AL);#else            tcg_out_ld32_12(s, COND_AL, TCG_REG_PC, TCG_REG_PC, -4);            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;            tcg_out32(s, 0);#endif        } else {            /* Indirect jump method */#if 1            c = (int) (s->tb_next + args[0]) - ((int) s->code_ptr + 8);            if (c > 0xfff || c < -0xfff) {                tcg_out_movi32(s, COND_AL, TCG_REG_R0,                                (tcg_target_long) (s->tb_next + args[0]));                tcg_out_ld32_12(s, COND_AL, TCG_REG_PC, TCG_REG_R0, 0);            } else                tcg_out_ld32_12(s, COND_AL, TCG_REG_PC, TCG_REG_PC, c);#else            tcg_out_ld32_12(s, COND_AL, TCG_REG_R0, TCG_REG_PC, 0);            tcg_out_ld32_12(s, COND_AL, TCG_REG_PC, TCG_REG_R0, 0);            tcg_out32(s, (tcg_target_long) (s->tb_next + args[0]));#endif        }        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;        break;    case INDEX_op_call:        if (const_args[0])            tcg_out_call(s, args[0]);        else            tcg_out_callr(s, COND_AL, args[0]);        break;    case INDEX_op_br:        tcg_out_goto_label(s, COND_AL, args[0]);        break;    case INDEX_op_ld8u_i32:        tcg_out_ld8u(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_ld8s_i32:        tcg_out_ld8s(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_ld16u_i32:        tcg_out_ld16u(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_ld16s_i32:        tcg_out_ld16s(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_ld_i32:        tcg_out_ld32u(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_st8_i32:        tcg_out_st8(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_st16_i32:        tcg_out_st16(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_st_i32:        tcg_out_st32(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_mov_i32:        tcg_out_dat_reg(s, COND_AL, ARITH_MOV,                        args[0], 0, args[1], SHIFT_IMM_LSL(0));        break;    case INDEX_op_movi_i32:        tcg_out_movi32(s, COND_AL, args[0], args[1]);        break;    case INDEX_op_movcond_i32:        /* Constraints mean that v2 is always in the same register as dest,         * so we only need to do \"if condition passed, move v1 to dest\".         */        tcg_out_dat_rI(s, COND_AL, ARITH_CMP, 0,                       args[1], args[2], const_args[2]);        tcg_out_dat_rI(s, tcg_cond_to_arm_cond[args[5]],                       ARITH_MOV, args[0], 0, args[3], const_args[3]);        break;    case INDEX_op_add_i32:        c = ARITH_ADD;        goto gen_arith;    case INDEX_op_sub_i32:        c = ARITH_SUB;        goto gen_arith;    case INDEX_op_and_i32:        tcg_out_dat_rIK(s, COND_AL, ARITH_AND, ARITH_BIC,                        args[0], args[1], args[2], const_args[2]);        break;    case INDEX_op_andc_i32:        tcg_out_dat_rIK(s, COND_AL, ARITH_BIC, ARITH_AND,                        args[0], args[1], args[2], const_args[2]);        break;    case INDEX_op_or_i32:        c = ARITH_ORR;        goto gen_arith;    case INDEX_op_xor_i32:        c = ARITH_EOR;        /* Fall through.  */    gen_arith:        tcg_out_dat_rI(s, COND_AL, c, args[0], args[1], args[2], const_args[2]);        break;    case INDEX_op_add2_i32:        tcg_out_dat_reg2(s, COND_AL, ARITH_ADD, ARITH_ADC,                        args[0], args[1], args[2], args[3],                        args[4], args[5], SHIFT_IMM_LSL(0));        break;    case INDEX_op_sub2_i32:        tcg_out_dat_reg2(s, COND_AL, ARITH_SUB, ARITH_SBC,                        args[0], args[1], args[2], args[3],                        args[4], args[5], SHIFT_IMM_LSL(0));        break;    case INDEX_op_neg_i32:        tcg_out_dat_imm(s, COND_AL, ARITH_RSB, args[0], args[1], 0);        break;    case INDEX_op_not_i32:        tcg_out_dat_reg(s, COND_AL,                        ARITH_MVN, args[0], 0, args[1], SHIFT_IMM_LSL(0));        break;    case INDEX_op_mul_i32:        tcg_out_mul32(s, COND_AL, args[0], args[1], args[2]);        break;    case INDEX_op_mulu2_i32:        tcg_out_umull32(s, COND_AL, args[0], args[1], args[2], args[3]);        break;    case INDEX_op_muls2_i32:        tcg_out_smull32(s, COND_AL, args[0], args[1], args[2], args[3]);        break;    /* XXX: Perhaps args[2] & 0x1f is wrong */    case INDEX_op_shl_i32:        c = const_args[2] ?                SHIFT_IMM_LSL(args[2] & 0x1f) : SHIFT_REG_LSL(args[2]);        goto gen_shift32;    case INDEX_op_shr_i32:        c = const_args[2] ? (args[2] & 0x1f) ? SHIFT_IMM_LSR(args[2] & 0x1f) :                SHIFT_IMM_LSL(0) : SHIFT_REG_LSR(args[2]);        goto gen_shift32;    case INDEX_op_sar_i32:        c = const_args[2] ? (args[2] & 0x1f) ? SHIFT_IMM_ASR(args[2] & 0x1f) :                SHIFT_IMM_LSL(0) : SHIFT_REG_ASR(args[2]);        goto gen_shift32;    case INDEX_op_rotr_i32:        c = const_args[2] ? (args[2] & 0x1f) ? SHIFT_IMM_ROR(args[2] & 0x1f) :                SHIFT_IMM_LSL(0) : SHIFT_REG_ROR(args[2]);        /* Fall through.  */    gen_shift32:        tcg_out_dat_reg(s, COND_AL, ARITH_MOV, args[0], 0, args[1], c);        break;    case INDEX_op_rotl_i32:        if (const_args[2]) {            tcg_out_dat_reg(s, COND_AL, ARITH_MOV, args[0], 0, args[1],                            ((0x20 - args[2]) & 0x1f) ?                            SHIFT_IMM_ROR((0x20 - args[2]) & 0x1f) :                            SHIFT_IMM_LSL(0));        } else {            tcg_out_dat_imm(s, COND_AL, ARITH_RSB, TCG_REG_R8, args[1], 0x20);            tcg_out_dat_reg(s, COND_AL, ARITH_MOV, args[0], 0, args[1],                            SHIFT_REG_ROR(TCG_REG_R8));        }        break;    case INDEX_op_brcond_i32:        tcg_out_dat_rI(s, COND_AL, ARITH_CMP, 0,                       args[0], args[1], const_args[1]);        tcg_out_goto_label(s, tcg_cond_to_arm_cond[args[2]], args[3]);        break;    case INDEX_op_brcond2_i32:        /* The resulting conditions are:         * TCG_COND_EQ    -->  a0 == a2 && a1 == a3,         * TCG_COND_NE    --> (a0 != a2 && a1 == a3) ||  a1 != a3,         * TCG_COND_LT(U) --> (a0 <  a2 && a1 == a3) ||  a1 <  a3,         * TCG_COND_GE(U) --> (a0 >= a2 && a1 == a3) || (a1 >= a3 && a1 != a3),         * TCG_COND_LE(U) --> (a0 <= a2 && a1 == a3) || (a1 <= a3 && a1 != a3),         * TCG_COND_GT(U) --> (a0 >  a2 && a1 == a3) ||  a1 >  a3,         */        tcg_out_dat_reg(s, COND_AL, ARITH_CMP, 0,                        args[1], args[3], SHIFT_IMM_LSL(0));        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,                        args[0], args[2], SHIFT_IMM_LSL(0));        tcg_out_goto_label(s, tcg_cond_to_arm_cond[args[4]], args[5]);        break;    case INDEX_op_setcond_i32:        tcg_out_dat_rI(s, COND_AL, ARITH_CMP, 0,                       args[1], args[2], const_args[2]);        tcg_out_dat_imm(s, tcg_cond_to_arm_cond[args[3]],                        ARITH_MOV, args[0], 0, 1);        tcg_out_dat_imm(s, tcg_cond_to_arm_cond[tcg_invert_cond(args[3])],                        ARITH_MOV, args[0], 0, 0);        break;    case INDEX_op_setcond2_i32:        /* See brcond2_i32 comment */        tcg_out_dat_reg(s, COND_AL, ARITH_CMP, 0,                        args[2], args[4], SHIFT_IMM_LSL(0));        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,                        args[1], args[3], SHIFT_IMM_LSL(0));        tcg_out_dat_imm(s, tcg_cond_to_arm_cond[args[5]],                        ARITH_MOV, args[0], 0, 1);        tcg_out_dat_imm(s, tcg_cond_to_arm_cond[tcg_invert_cond(args[5])],                        ARITH_MOV, args[0], 0, 0);        break;    case INDEX_op_qemu_ld8u:        tcg_out_qemu_ld(s, args, 0);        break;    case INDEX_op_qemu_ld8s:        tcg_out_qemu_ld(s, args, 0 | 4);        break;    case INDEX_op_qemu_ld16u:        tcg_out_qemu_ld(s, args, 1);        break;    case INDEX_op_qemu_ld16s:        tcg_out_qemu_ld(s, args, 1 | 4);        break;    case INDEX_op_qemu_ld32:        tcg_out_qemu_ld(s, args, 2);        break;    case INDEX_op_qemu_ld64:        tcg_out_qemu_ld(s, args, 3);        break;    case INDEX_op_qemu_st8:        tcg_out_qemu_st(s, args, 0);        break;    case INDEX_op_qemu_st16:        tcg_out_qemu_st(s, args, 1);        break;    case INDEX_op_qemu_st32:        tcg_out_qemu_st(s, args, 2);        break;    case INDEX_op_qemu_st64:        tcg_out_qemu_st(s, args, 3);        break;    case INDEX_op_bswap16_i32:        tcg_out_bswap16(s, COND_AL, args[0], args[1]);        break;    case INDEX_op_bswap32_i32:        tcg_out_bswap32(s, COND_AL, args[0], args[1]);        break;    case INDEX_op_ext8s_i32:        tcg_out_ext8s(s, COND_AL, args[0], args[1]);        break;    case INDEX_op_ext16s_i32:        tcg_out_ext16s(s, COND_AL, args[0], args[1]);        break;    case INDEX_op_ext16u_i32:        tcg_out_ext16u(s, COND_AL, args[0], args[1]);        break;    default:        tcg_abort();    }}", "idx": 7501}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "function": "static void virtio_net_tx_complete(NetClientState *nc, ssize_t len){    VirtIONet *n = qemu_get_nic_opaque(nc);    VirtIONetQueue *q = virtio_net_get_subqueue(nc);    VirtIODevice *vdev = VIRTIO_DEVICE(n);    virtqueue_push(q->tx_vq, &q->async_tx.elem, 0);    virtio_notify(vdev, q->tx_vq);    q->async_tx.elem.out_num = 0;    virtio_queue_set_notification(q->tx_vq, 1);    virtio_net_flush_tx(q);}", "idx": 7502}
{"project": "qemu", "commit_id": "a15fcc3cf69ee3d408f60d6cc316488d2b0249b4", "target": 1, "function": "void visit_start_alternate(Visitor *v, const char *name,                           GenericAlternate **obj, size_t size,                           bool promote_int, Error **errp){    Error *err = NULL;    assert(obj && size >= sizeof(GenericAlternate));    assert(v->type != VISITOR_OUTPUT || *obj);    if (v->start_alternate) {        v->start_alternate(v, name, obj, size, promote_int, &err);    }    if (v->type == VISITOR_INPUT) {        assert(v->start_alternate && !err != !*obj);    }    error_propagate(errp, err);}", "idx": 7617}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "function": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t *refcount_table,                              int refcount_table_size,                              int64_t l1_table_offset, int l1_size,                              int flags){    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table, l2_offset, l1_size2;    int i, ret;    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    inc_refcounts(bs, res, refcount_table, refcount_table_size,        l1_table_offset, l1_size2);    /* Read L1 table entries from disk */    if (l1_size2 == 0) {        l1_table = NULL;    } else {        l1_table = g_malloc(l1_size2);        if (bdrv_pread(bs->file, l1_table_offset,                       l1_table, l1_size2) != l1_size2)            goto fail;        for(i = 0;i < l1_size; i++)            be64_to_cpus(&l1_table[i]);    }    /* Do the actual checks */    for(i = 0; i < l1_size; i++) {        l2_offset = l1_table[i];        if (l2_offset) {            /* Mark L2 table as used */            l2_offset &= L1E_OFFSET_MASK;            inc_refcounts(bs, res, refcount_table, refcount_table_size,                l2_offset, s->cluster_size);            /* L2 tables are cluster aligned */            if (offset_into_cluster(s, l2_offset)) {                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);                res->corruptions++;            }            /* Process and check L2 entries */            ret = check_refcounts_l2(bs, res, refcount_table,                                     refcount_table_size, l2_offset, flags);            if (ret < 0) {                goto fail;            }        }    }    g_free(l1_table);    return 0;fail:    fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");    res->check_errors++;    g_free(l1_table);    return -EIO;}", "idx": 7664}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "function": "void do_405_check_ov (void){    if (likely(((T1 ^ T2) >> 31) || !((T0 ^ T2) >> 31))) {        xer_ov = 0;    } else {        xer_ov = 1;        xer_so = 1;    }}", "idx": 7742}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "function": "static int cpu_mips_register (CPUMIPSState *env, const mips_def_t *def){    env->CP0_PRid = def->CP0_PRid;    env->CP0_Config0 = def->CP0_Config0;#ifdef TARGET_WORDS_BIGENDIAN    env->CP0_Config0 |= (1 << CP0C0_BE);#endif    env->CP0_Config1 = def->CP0_Config1;    env->CP0_Config2 = def->CP0_Config2;    env->CP0_Config3 = def->CP0_Config3;    env->CP0_Config6 = def->CP0_Config6;    env->CP0_Config7 = def->CP0_Config7;    env->SYNCI_Step = def->SYNCI_Step;    env->CCRes = def->CCRes;    env->CP0_Status_rw_bitmask = def->CP0_Status_rw_bitmask;    env->CP0_TCStatus_rw_bitmask = def->CP0_TCStatus_rw_bitmask;    env->CP0_SRSCtl = def->CP0_SRSCtl;    env->current_tc = 0;    env->SEGBITS = def->SEGBITS;    env->SEGMask = (target_ulong)((1ULL << def->SEGBITS) - 1);#if defined(TARGET_MIPS64)    if (def->insn_flags & ISA_MIPS3) {        env->hflags |= MIPS_HFLAG_64;        env->SEGMask |= 3ULL << 62;    }#endif    env->PABITS = def->PABITS;    env->PAMask = (target_ulong)((1ULL << def->PABITS) - 1);    env->CP0_SRSConf0_rw_bitmask = def->CP0_SRSConf0_rw_bitmask;    env->CP0_SRSConf0 = def->CP0_SRSConf0;    env->CP0_SRSConf1_rw_bitmask = def->CP0_SRSConf1_rw_bitmask;    env->CP0_SRSConf1 = def->CP0_SRSConf1;    env->CP0_SRSConf2_rw_bitmask = def->CP0_SRSConf2_rw_bitmask;    env->CP0_SRSConf2 = def->CP0_SRSConf2;    env->CP0_SRSConf3_rw_bitmask = def->CP0_SRSConf3_rw_bitmask;    env->CP0_SRSConf3 = def->CP0_SRSConf3;    env->CP0_SRSConf4_rw_bitmask = def->CP0_SRSConf4_rw_bitmask;    env->CP0_SRSConf4 = def->CP0_SRSConf4;    env->insn_flags = def->insn_flags;#ifndef CONFIG_USER_ONLY    if (!env->user_mode_only)        mmu_init(env, def);#endif    fpu_init(env, def);    mvp_init(env, def);    return 0;}", "idx": 7751}
{"project": "qemu", "commit_id": "3c638d0690a0b21c6acef7ce3132f821d8c1e25d", "target": 0, "function": "bool cpu_exec_all(void){    int ret = 0;    if (next_cpu == NULL)        next_cpu = first_cpu;    for (; next_cpu != NULL && !exit_request; next_cpu = next_cpu->next_cpu) {        CPUState *env = next_cpu;        qemu_clock_enable(vm_clock,                          (env->singlestep_enabled & SSTEP_NOTIMER) == 0);        if (qemu_alarm_pending())            break;        if (cpu_can_run(env))            ret = qemu_cpu_exec(env);        else if (env->stop)            break;        if (ret == EXCP_DEBUG) {            gdb_set_stop_cpu(env);            debug_requested = EXCP_DEBUG;            break;        }    }    exit_request = 0;    return any_cpu_has_work();}", "idx": 7758}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "function": "static void tcg_out_ext8s(TCGContext *s, int dest, int src, int rexw){    /* movsbl */    assert(src < 4 || TCG_TARGET_REG_BITS == 64);    tcg_out_modrm(s, OPC_MOVSBL + P_REXB_RM + rexw, dest, src);}", "idx": 7857}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "function": "static int filter_frame(AVFilterLink *inlink, AVFrame *buf){    AVFilterContext *ctx = inlink->dst;    VolumeContext *vol    = inlink->dst->priv;    AVFilterLink *outlink = inlink->dst->outputs[0];    int nb_samples        = buf->nb_samples;    AVFrame *out_buf;    int64_t pos;    AVFrameSideData *sd = av_frame_get_side_data(buf, AV_FRAME_DATA_REPLAYGAIN);    int ret;    if (sd && vol->replaygain != REPLAYGAIN_IGNORE) {        if (vol->replaygain != REPLAYGAIN_DROP) {            AVReplayGain *replaygain = (AVReplayGain*)sd->data;            int32_t gain  = 100000;            uint32_t peak = 100000;            float g, p;            if (vol->replaygain == REPLAYGAIN_TRACK &&                replaygain->track_gain != INT32_MIN) {                gain = replaygain->track_gain;                if (replaygain->track_peak != 0)                    peak = replaygain->track_peak;            } else if (replaygain->album_gain != INT32_MIN) {                gain = replaygain->album_gain;                if (replaygain->album_peak != 0)                    peak = replaygain->album_peak;            } else {                av_log(inlink->dst, AV_LOG_WARNING, \"Both ReplayGain gain \"                       \"values are unknown.\\n\");            }            g = gain / 100000.0f;            p = peak / 100000.0f;            av_log(inlink->dst, AV_LOG_VERBOSE,                   \"Using gain %f dB from replaygain side data.\\n\", g);            vol->volume   = ff_exp10((g + vol->replaygain_preamp) / 20);            if (vol->replaygain_noclip)                vol->volume = FFMIN(vol->volume, 1.0 / p);            vol->volume_i = (int)(vol->volume * 256 + 0.5);            volume_init(vol);        }        av_frame_remove_side_data(buf, AV_FRAME_DATA_REPLAYGAIN);    }    if (isnan(vol->var_values[VAR_STARTPTS])) {        vol->var_values[VAR_STARTPTS] = TS2D(buf->pts);        vol->var_values[VAR_STARTT  ] = TS2T(buf->pts, inlink->time_base);    }    vol->var_values[VAR_PTS] = TS2D(buf->pts);    vol->var_values[VAR_T  ] = TS2T(buf->pts, inlink->time_base);    vol->var_values[VAR_N  ] = inlink->frame_count_out;    pos = buf->pkt_pos;    vol->var_values[VAR_POS] = pos == -1 ? NAN : pos;    if (vol->eval_mode == EVAL_MODE_FRAME)        set_volume(ctx);    if (vol->volume == 1.0 || vol->volume_i == 256) {        out_buf = buf;        goto end;    }    /* do volume scaling in-place if input buffer is writable */    if (av_frame_is_writable(buf)            && (vol->precision != PRECISION_FIXED || vol->volume_i > 0)) {        out_buf = buf;    } else {        out_buf = ff_get_audio_buffer(inlink, nb_samples);        if (!out_buf)            return AVERROR(ENOMEM);        ret = av_frame_copy_props(out_buf, buf);        if (ret < 0) {            av_frame_free(&out_buf);            av_frame_free(&buf);            return ret;        }    }    if (vol->precision != PRECISION_FIXED || vol->volume_i > 0) {        int p, plane_samples;        if (av_sample_fmt_is_planar(buf->format))            plane_samples = FFALIGN(nb_samples, vol->samples_align);        else            plane_samples = FFALIGN(nb_samples * vol->channels, vol->samples_align);        if (vol->precision == PRECISION_FIXED) {            for (p = 0; p < vol->planes; p++) {                vol->scale_samples(out_buf->extended_data[p],                                   buf->extended_data[p], plane_samples,                                   vol->volume_i);            }        } else if (av_get_packed_sample_fmt(vol->sample_fmt) == AV_SAMPLE_FMT_FLT) {            for (p = 0; p < vol->planes; p++) {                vol->fdsp->vector_fmul_scalar((float *)out_buf->extended_data[p],                                             (const float *)buf->extended_data[p],                                             vol->volume, plane_samples);            }        } else {            for (p = 0; p < vol->planes; p++) {                vol->fdsp->vector_dmul_scalar((double *)out_buf->extended_data[p],                                             (const double *)buf->extended_data[p],                                             vol->volume, plane_samples);            }        }    }    emms_c();    if (buf != out_buf)        av_frame_free(&buf);end:    vol->var_values[VAR_NB_CONSUMED_SAMPLES] += out_buf->nb_samples;    return ff_filter_frame(outlink, out_buf);}", "idx": 7904}
{"project": "FFmpeg", "commit_id": "f6b195cfb9712ae5032881d5dd8c4effb26be0fb", "target": 0, "function": "static int vc1_decode_p_mb_intfr(VC1Context *v){    MpegEncContext *s = &v->s;    GetBitContext *gb = &s->gb;    int i;    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;    int cbp = 0; /* cbp decoding stuff */    int mqdiff, mquant; /* MB quantization */    int ttmb = v->ttfrm; /* MB Transform type */    int mb_has_coeffs = 1; /* last_flag */    int dmv_x, dmv_y; /* Differential MV components */    int val; /* temp value */    int first_block = 1;    int dst_idx, off;    int skipped, fourmv = 0, twomv = 0;    int block_cbp = 0, pat, block_tt = 0;    int idx_mbmode = 0, mvbp;    int stride_y, fieldtx;    mquant = v->pq; /* Lossy initialization */    if (v->skip_is_raw)        skipped = get_bits1(gb);    else        skipped = v->s.mbskip_table[mb_pos];    if (!skipped) {        if (v->fourmvswitch)            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_4MV_MBMODE_VLC_BITS, 2); // try getting this done        else            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); // in a single line        switch (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0]) {        /* store the motion vector type in a flag (useful later) */        case MV_PMODE_INTFR_4MV:            fourmv = 1;            v->blk_mv_type[s->block_index[0]] = 0;            v->blk_mv_type[s->block_index[1]] = 0;            v->blk_mv_type[s->block_index[2]] = 0;            v->blk_mv_type[s->block_index[3]] = 0;            break;        case MV_PMODE_INTFR_4MV_FIELD:            fourmv = 1;            v->blk_mv_type[s->block_index[0]] = 1;            v->blk_mv_type[s->block_index[1]] = 1;            v->blk_mv_type[s->block_index[2]] = 1;            v->blk_mv_type[s->block_index[3]] = 1;            break;        case MV_PMODE_INTFR_2MV_FIELD:            twomv = 1;            v->blk_mv_type[s->block_index[0]] = 1;            v->blk_mv_type[s->block_index[1]] = 1;            v->blk_mv_type[s->block_index[2]] = 1;            v->blk_mv_type[s->block_index[3]] = 1;            break;        case MV_PMODE_INTFR_1MV:            v->blk_mv_type[s->block_index[0]] = 0;            v->blk_mv_type[s->block_index[1]] = 0;            v->blk_mv_type[s->block_index[2]] = 0;            v->blk_mv_type[s->block_index[3]] = 0;            break;        }        if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB            for (i = 0; i < 4; i++) {                s->current_picture.motion_val[1][s->block_index[i]][0] = 0;                s->current_picture.motion_val[1][s->block_index[i]][1] = 0;            }            v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.            s->mb_intra          = 1;            s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;            fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);            mb_has_coeffs = get_bits1(gb);            if (mb_has_coeffs)                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);            v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);            GET_MQUANT();            s->current_picture.qscale_table[mb_pos] = mquant;            /* Set DC scale - y and c use the same (not sure if necessary here) */            s->y_dc_scale = s->y_dc_scale_table[mquant];            s->c_dc_scale = s->c_dc_scale_table[mquant];            dst_idx = 0;            for (i = 0; i < 6; i++) {                v->a_avail = v->c_avail          = 0;                v->mb_type[0][s->block_index[i]] = 1;                s->dc_val[0][s->block_index[i]]  = 0;                dst_idx += i >> 2;                val = ((cbp >> (5 - i)) & 1);                if (i == 2 || i == 3 || !s->first_slice_line)                    v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];                if (i == 1 || i == 3 || s->mb_x)                    v->c_avail = v->mb_type[0][s->block_index[i] - 1];                vc1_decode_intra_block(v, s->block[i], i, val, mquant,                                       (i & 4) ? v->codingset2 : v->codingset);                if ((i>3) && (s->flags & CODEC_FLAG_GRAY)) continue;                v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);                if (i < 4) {                    stride_y = s->linesize << fieldtx;                    off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;                } else {                    stride_y = s->uvlinesize;                    off = 0;                }                s->idsp.put_signed_pixels_clamped(s->block[i],                                                  s->dest[dst_idx] + off,                                                  stride_y);                //TODO: loop filter            }        } else { // inter MB            mb_has_coeffs = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][3];            if (mb_has_coeffs)                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);            if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {                v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);            } else {                if ((ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV)                    || (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV_FIELD)) {                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);                }            }            s->mb_intra = v->is_intra[s->mb_x] = 0;            for (i = 0; i < 6; i++)                v->mb_type[0][s->block_index[i]] = 0;            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][1];            /* for all motion vector read MVDATA and motion compensate each block */            dst_idx = 0;            if (fourmv) {                mvbp = v->fourmvbp;                for (i = 0; i < 6; i++) {                    if (i < 4) {                        dmv_x = dmv_y = 0;                        val   = ((mvbp >> (3 - i)) & 1);                        if (val) {                            get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                        }                        ff_vc1_pred_mv_intfr(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0);                        ff_vc1_mc_4mv_luma(v, i, 0, 0);                    } else if (i == 4) {                        ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);                    }                }            } else if (twomv) {                mvbp  = v->twomvbp;                dmv_x = dmv_y = 0;                if (mvbp & 2) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);                ff_vc1_mc_4mv_luma(v, 0, 0, 0);                ff_vc1_mc_4mv_luma(v, 1, 0, 0);                dmv_x = dmv_y = 0;                if (mvbp & 1) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0);                ff_vc1_mc_4mv_luma(v, 2, 0, 0);                ff_vc1_mc_4mv_luma(v, 3, 0, 0);                ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);            } else {                mvbp = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][2];                dmv_x = dmv_y = 0;                if (mvbp) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0);                ff_vc1_mc_1mv(v, 0);            }            if (cbp)                GET_MQUANT();  // p. 227            s->current_picture.qscale_table[mb_pos] = mquant;            if (!v->ttmbf && cbp)                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);            for (i = 0; i < 6; i++) {                s->dc_val[0][s->block_index[i]] = 0;                dst_idx += i >> 2;                val = ((cbp >> (5 - i)) & 1);                if (!fieldtx)                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);                else                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));                if (val) {                    pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,                                             first_block, s->dest[dst_idx] + off,                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),                                             (i & 4) && (s->flags & CODEC_FLAG_GRAY), &block_tt);                    block_cbp |= pat << (i << 2);                    if (!v->ttmbf && ttmb < 8)                        ttmb = -1;                    first_block = 0;                }            }        }    } else { // skipped        s->mb_intra = v->is_intra[s->mb_x] = 0;        for (i = 0; i < 6; i++) {            v->mb_type[0][s->block_index[i]] = 0;            s->dc_val[0][s->block_index[i]] = 0;        }        s->current_picture.mb_type[mb_pos]      = MB_TYPE_SKIP;        s->current_picture.qscale_table[mb_pos] = 0;        v->blk_mv_type[s->block_index[0]] = 0;        v->blk_mv_type[s->block_index[1]] = 0;        v->blk_mv_type[s->block_index[2]] = 0;        v->blk_mv_type[s->block_index[3]] = 0;        ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0);        ff_vc1_mc_1mv(v, 0);    }    if (s->mb_x == s->mb_width - 1)        memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0])*s->mb_stride);    return 0;}", "idx": 7912}
{"project": "qemu", "commit_id": "08a9635b68757e18a6a8bf8569353b40bb6c1fd1", "target": 0, "function": "static void xilinx_spips_flush_txfifo(XilinxSPIPS *s){    for (;;) {        int i;        uint8_t rx;        uint8_t tx = 0;        for (i = 0; i < num_effective_busses(s); ++i) {            if (!i || s->snoop_state == SNOOP_STRIPING) {                if (fifo8_is_empty(&s->tx_fifo)) {                    s->regs[R_INTR_STATUS] |= IXR_TX_FIFO_UNDERFLOW;                    xilinx_spips_update_ixr(s);                    return;                } else {                    tx = fifo8_pop(&s->tx_fifo);                }            }            rx = ssi_transfer(s->spi[i], (uint32_t)tx);            DB_PRINT(\"tx = %02x rx = %02x\\n\", tx, rx);            if (!i || s->snoop_state == SNOOP_STRIPING) {                if (fifo8_is_full(&s->rx_fifo)) {                    s->regs[R_INTR_STATUS] |= IXR_RX_FIFO_OVERFLOW;                    DB_PRINT(\"rx FIFO overflow\");                } else {                    fifo8_push(&s->rx_fifo, (uint8_t)rx);                }            }        }        switch (s->snoop_state) {        case (SNOOP_CHECKING):            switch (tx) { /* new instruction code */            case 0x0b: /* dual/quad output read DOR/QOR */            case 0x6b:                s->snoop_state = 4;                break;            /* FIXME: these vary between vendor - set to spansion */            case 0xbb: /* high performance dual read DIOR */                s->snoop_state = 4;                break;            case 0xeb: /* high performance quad read QIOR */                s->snoop_state = 6;                break;            default:                s->snoop_state = SNOOP_NONE;            }            break;        case (SNOOP_STRIPING):        case (SNOOP_NONE):            break;        default:            s->snoop_state--;        }    }}", "idx": 7932}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "function": "static char *pxb_host_ofw_unit_address(const SysBusDevice *dev){    const PCIHostState *pxb_host;    const PCIBus *pxb_bus;    const PXBDev *pxb_dev;    int position;    const DeviceState *pxb_dev_base;    const PCIHostState *main_host;    const SysBusDevice *main_host_sbd;    pxb_host = PCI_HOST_BRIDGE(dev);    pxb_bus = pxb_host->bus;    pxb_dev = PXB_DEV(pxb_bus->parent_dev);    position = g_list_index(pxb_dev_list, pxb_dev);    assert(position >= 0);    pxb_dev_base = DEVICE(pxb_dev);    main_host = PCI_HOST_BRIDGE(pxb_dev_base->parent_bus->parent);    main_host_sbd = SYS_BUS_DEVICE(main_host);    if (main_host_sbd->num_mmio > 0) {        return g_strdup_printf(TARGET_FMT_plx \",%x\",                               main_host_sbd->mmio[0].addr, position + 1);    }    if (main_host_sbd->num_pio > 0) {        return g_strdup_printf(\"i%04x,%x\",                               main_host_sbd->pio[0], position + 1);    }    return NULL;}", "idx": 8020}
{"project": "FFmpeg", "commit_id": "4860625236475da20d0da954017e8c7fe412dea2", "target": 1, "function": "yuv2rgb48_2_c_template(SwsContext *c, const int32_t *buf[2],                       const int32_t *ubuf[2], const int32_t *vbuf[2],                       const int32_t *abuf[2], uint16_t *dest, int dstW,                       int yalpha, int uvalpha, int y,                       enum PixelFormat target){    const int32_t *buf0  = buf[0],  *buf1  = buf[1],                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1];    int  yalpha1 = 4095 - yalpha;    int uvalpha1 = 4095 - uvalpha;    int i;    for (i = 0; i < ((dstW + 1) >> 1); i++) {        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha) >> 14;        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha) >> 14;        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha + (-128 << 23)) >> 14;        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha + (-128 << 23)) >> 14;        int R, G, B;        Y1 -= c->yuv2rgb_y_offset;        Y2 -= c->yuv2rgb_y_offset;        Y1 *= c->yuv2rgb_y_coeff;        Y2 *= c->yuv2rgb_y_coeff;        Y1 += 1 << 13;        Y2 += 1 << 13;        R = V * c->yuv2rgb_v2r_coeff;        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;        B =                            U * c->yuv2rgb_u2b_coeff;        output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);        output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);        output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);        output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);        output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);        output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);        dest += 6;    }}", "idx": 8034}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "function": "static void cubieboard_init(QEMUMachineInitArgs *args){    CubieBoardState *s = g_new(CubieBoardState, 1);    Error *err = NULL;    s->a10 = AW_A10(object_new(TYPE_AW_A10));    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);    if (err != NULL) {        error_report(\"Couldn't realize Allwinner A10: %s\\n\",                error_get_pretty(err));        exit(1);    }    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);    vmstate_register_ram_global(&s->sdram);    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,                                &s->sdram);    cubieboard_binfo.ram_size = args->ram_size;    cubieboard_binfo.kernel_filename = args->kernel_filename;    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);}", "idx": 8049}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "function": "static uint64_t pxa2xx_i2c_read(void *opaque, hwaddr addr,                                unsigned size){    PXA2xxI2CState *s = (PXA2xxI2CState *) opaque;    I2CSlave *slave;    addr -= s->offset;    switch (addr) {    case ICR:        return s->control;    case ISR:        return s->status | (i2c_bus_busy(s->bus) << 2);    case ISAR:        slave = I2C_SLAVE(s->slave);        return slave->address;    case IDBR:        return s->data;    case IBMR:        if (s->status & (1 << 2))            s->ibmr ^= 3;\t/* Fake SCL and SDA pin changes */        else            s->ibmr = 0;        return s->ibmr;    default:        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);        break;    }    return 0;}", "idx": 8051}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "function": "static void tcg_out_r(TCGContext *s, TCGArg t0){    assert(t0 < TCG_TARGET_NB_REGS);    tcg_out8(s, t0);}", "idx": 8076}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "function": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,                                const uint8_t *s2, int stride){    int i;    vec_u8 perm1 = vec_lvsl(0, s1);    vec_u8 perm2 = vec_lvsl(0, s2);    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);    vec_s16 shorts1, shorts2;    for (i = 0; i < 4; i++) {        /* Read potentially unaligned pixels.         * We're reading 16 pixels, and actually only want 8,         * but we simply ignore the extras. */        vec_u8 pixl  = vec_ld(0,  s1);        vec_u8 pixr  = vec_ld(15, s1);        vec_u8 bytes = vec_perm(pixl, pixr, perm1);        // Convert the bytes into shorts.        shorts1 = (vec_s16)vec_mergeh(zero, bytes);        // Do the same for the second block of pixels.        pixl  = vec_ld(0,  s2);        pixr  = vec_ld(15, s2);        bytes = vec_perm(pixl, pixr, perm2);        // Convert the bytes into shorts.        shorts2 = (vec_s16)vec_mergeh(zero, bytes);        // Do the subtraction.        shorts1 = vec_sub(shorts1, shorts2);        // Save the data to the block, we assume the block is 16-byte aligned.        vec_st(shorts1, 0, (vec_s16 *)block);        s1    += stride;        s2    += stride;        block += 8;        /* The code below is a copy of the code above...         * This is a manual unroll. */        /* Read potentially unaligned pixels.         * We're reading 16 pixels, and actually only want 8,         * but we simply ignore the extras. */        pixl  = vec_ld(0,  s1);        pixr  = vec_ld(15, s1);        bytes = vec_perm(pixl, pixr, perm1);        // Convert the bytes into shorts.        shorts1 = (vec_s16)vec_mergeh(zero, bytes);        // Do the same for the second block of pixels.        pixl  = vec_ld(0,  s2);        pixr  = vec_ld(15, s2);        bytes = vec_perm(pixl, pixr, perm2);        // Convert the bytes into shorts.        shorts2 = (vec_s16)vec_mergeh(zero, bytes);        // Do the subtraction.        shorts1 = vec_sub(shorts1, shorts2);        // Save the data to the block, we assume the block is 16-byte aligned.        vec_st(shorts1, 0, (vec_s16 *)block);        s1    += stride;        s2    += stride;        block += 8;    }}", "idx": 8103}
{"project": "qemu", "commit_id": "4e588a4d0e1683488282658c057d4b44976d77d8", "target": 0, "function": "uint32_t cpu_ppc_load_decr (CPUState *env){    ppc_tb_t *tb_env = env->tb_env;    uint32_t decr;    decr = muldiv64(tb_env->decr_next - qemu_get_clock(vm_clock),                    tb_env->tb_freq, ticks_per_sec);#if defined(DEBUG_TB)    printf(\"%s: 0x%08x\\n\", __func__, decr);#endif    return decr;}", "idx": 8269}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "function": "static enum AVHWDeviceType hw_device_match_type_by_hwaccel(enum HWAccelID hwaccel_id){    int i;    if (hwaccel_id == HWACCEL_NONE)        return AV_HWDEVICE_TYPE_NONE;    for (i = 0; hwaccels[i].name; i++) {        if (hwaccels[i].id == hwaccel_id)            return hwaccels[i].device_type;    }    return AV_HWDEVICE_TYPE_NONE;}", "idx": 8310}
{"project": "qemu", "commit_id": "fe52840c8760122257be7b7e4893dd951480a71f", "target": 0, "function": "static void coroutine_enter_cb(void *opaque, int ret){    Coroutine *co = opaque;    qemu_coroutine_enter(co, NULL);}", "idx": 8392}
{"project": "FFmpeg", "commit_id": "c8f9f9b91a3d3254e62f4fbcd6065a504164b06b", "target": 1, "function": "static int vmdaudio_decode_frame(AVCodecContext *avctx,                                 void *data, int *data_size,                                 uint8_t *buf, int buf_size){    VmdAudioContext *s = (VmdAudioContext *)avctx->priv_data;    unsigned int sound_flags;    unsigned char *output_samples = (unsigned char *)data;    /* point to the start of the encoded data */    unsigned char *p = buf + 16;    unsigned char *p_end = buf + buf_size;    if (buf_size < 16)        return buf_size;    if (buf[6] == 1) {        /* the chunk contains audio */        *data_size = vmdaudio_loadsound(s, output_samples, p, 0);    } else if (buf[6] == 2) {        /* the chunk contains audio and silence mixed together */        sound_flags = LE_32(p);        p += 4;        /* do something with extrabufs here? */        while (p < p_end) {            if (sound_flags & 0x01)                /* silence */                *data_size += vmdaudio_loadsound(s, output_samples, p, 1);            else {                /* audio */                *data_size += vmdaudio_loadsound(s, output_samples, p, 0);                p += s->block_align;            }            output_samples += (s->block_align * s->bits / 8);            sound_flags >>= 1;        }    } else if (buf[6] == 3) {        /* silent chunk */        *data_size = vmdaudio_loadsound(s, output_samples, p, 1);    }    return buf_size;}", "idx": 8460}
{"project": "qemu", "commit_id": "31ca6d077c24b7aaa322d8930e3e5debbdb4a047", "target": 1, "function": "int bdrv_open(BlockDriverState *bs, const char *filename, QDict *options,              int flags, BlockDriver *drv){    int ret;    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */    char tmp_filename[PATH_MAX + 1];    BlockDriverState *file = NULL;    QDict *file_options = NULL;    /* NULL means an empty set of options */    if (options == NULL) {        options = qdict_new();    }    bs->options = options;    options = qdict_clone_shallow(options);    /* For snapshot=on, create a temporary qcow2 overlay */    if (flags & BDRV_O_SNAPSHOT) {        BlockDriverState *bs1;        int64_t total_size;        BlockDriver *bdrv_qcow2;        QEMUOptionParameter *create_options;        char backing_filename[PATH_MAX];        if (qdict_size(options) != 0) {            error_report(\"Can't use snapshot=on with driver-specific options\");            ret = -EINVAL;            goto fail;        }        assert(filename != NULL);        /* if snapshot, we create a temporary backing file and open it           instead of opening 'filename' directly */        /* if there is a backing file, use it */        bs1 = bdrv_new(\"\");        ret = bdrv_open(bs1, filename, NULL, 0, drv);        if (ret < 0) {            bdrv_delete(bs1);            goto fail;        }        total_size = bdrv_getlength(bs1) & BDRV_SECTOR_MASK;        bdrv_delete(bs1);        ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));        if (ret < 0) {            goto fail;        }        /* Real path is meaningless for protocols */        if (path_has_protocol(filename)) {            snprintf(backing_filename, sizeof(backing_filename),                     \"%s\", filename);        } else if (!realpath(filename, backing_filename)) {            ret = -errno;            goto fail;        }        bdrv_qcow2 = bdrv_find_format(\"qcow2\");        create_options = parse_option_parameters(\"\", bdrv_qcow2->create_options,                                                 NULL);        set_option_parameter_int(create_options, BLOCK_OPT_SIZE, total_size);        set_option_parameter(create_options, BLOCK_OPT_BACKING_FILE,                             backing_filename);        if (drv) {            set_option_parameter(create_options, BLOCK_OPT_BACKING_FMT,                drv->format_name);        }        ret = bdrv_create(bdrv_qcow2, tmp_filename, create_options);        free_option_parameters(create_options);        if (ret < 0) {            goto fail;        }        filename = tmp_filename;        drv = bdrv_qcow2;        bs->is_temporary = 1;    }    /* Open image file without format layer */    if (flags & BDRV_O_RDWR) {        flags |= BDRV_O_ALLOW_RDWR;    }    extract_subqdict(options, &file_options, \"file.\");    ret = bdrv_file_open(&file, filename, file_options,                         bdrv_open_flags(bs, flags));    if (ret < 0) {        goto fail;    }    /* Find the right image format driver */    if (!drv) {        ret = find_image_format(file, filename, &drv);    }    if (!drv) {        goto unlink_and_fail;    }    /* Open the image */    ret = bdrv_open_common(bs, file, filename, options, flags, drv);    if (ret < 0) {        goto unlink_and_fail;    }    if (bs->file != file) {        bdrv_delete(file);        file = NULL;    }    /* If there is a backing file, use it */    if ((flags & BDRV_O_NO_BACKING) == 0) {        ret = bdrv_open_backing_file(bs);        if (ret < 0) {            goto close_and_fail;        }    }    /* Check if any unknown options were used */    if (qdict_size(options) != 0) {        const QDictEntry *entry = qdict_first(options);        qerror_report(ERROR_CLASS_GENERIC_ERROR, \"Block format '%s' used by \"            \"device '%s' doesn't support the option '%s'\",            drv->format_name, bs->device_name, entry->key);        ret = -EINVAL;        goto close_and_fail;    }    QDECREF(options);    if (!bdrv_key_required(bs)) {        bdrv_dev_change_media_cb(bs, true);    }    /* throttling disk I/O limits */    if (bs->io_limits_enabled) {        bdrv_io_limits_enable(bs);    }    return 0;unlink_and_fail:    if (file != NULL) {        bdrv_delete(file);    }    if (bs->is_temporary) {        unlink(filename);    }fail:    QDECREF(bs->options);    QDECREF(options);    bs->options = NULL;    return ret;close_and_fail:    bdrv_close(bs);    QDECREF(options);    return ret;}", "idx": 8462}
{"project": "qemu", "commit_id": "24355b79bdaf6ab12f7c610b032fc35ec045cd55", "target": 1, "function": "static void scsi_write_same_complete(void *opaque, int ret){    WriteSameCBData *data = opaque;    SCSIDiskReq *r = data->r;    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);    assert(r->req.aiocb != NULL);    r->req.aiocb = NULL;    aio_context_acquire(blk_get_aio_context(s->qdev.conf.blk));    if (scsi_disk_req_check_error(r, ret, true)) {        goto done;    }    block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);    data->nb_sectors -= data->iov.iov_len / 512;    data->sector += data->iov.iov_len / 512;    data->iov.iov_len = MIN(data->nb_sectors * 512, data->iov.iov_len);    if (data->iov.iov_len) {        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,                         data->iov.iov_len, BLOCK_ACCT_WRITE);        /* Reinitialize qiov, to handle unaligned WRITE SAME request         * where final qiov may need smaller size */        qemu_iovec_init_external(&data->qiov, &data->iov, 1);        r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,                                       data->sector << BDRV_SECTOR_BITS,                                       &data->qiov, 0,                                       scsi_write_same_complete, data);        return;    }    scsi_req_complete(&r->req, GOOD);done:    scsi_req_unref(&r->req);    qemu_vfree(data->iov.iov_base);    g_free(data);}", "idx": 8469}
{"project": "FFmpeg", "commit_id": "f3c9d66bafde9b8586bd63dd3307daa87352af75", "target": 0, "function": "static int libspeex_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    LibSpeexContext *s = avctx->priv_data;    int16_t *output;    int ret, consumed = 0;    /* get output buffer */    s->frame.nb_samples = s->frame_size;    if ((ret = ff_get_buffer(avctx, &s->frame)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    output = (int16_t *)s->frame.data[0];    /* if there is not enough data left for the smallest possible frame or the       next 5 bits are a terminator code, reset the libspeex buffer using the       current packet, otherwise ignore the current packet and keep decoding       frames from the libspeex buffer. */    if (speex_bits_remaining(&s->bits) < 5 ||        speex_bits_peek_unsigned(&s->bits, 5) == 0x1F) {        /* check for flush packet */        if (!buf || !buf_size) {            *got_frame_ptr = 0;            return buf_size;        }        /* set new buffer */        speex_bits_read_from(&s->bits, buf, buf_size);        consumed = buf_size;    }    /* decode a single frame */    ret = speex_decode_int(s->dec_state, &s->bits, output);    if (ret <= -2) {        av_log(avctx, AV_LOG_ERROR, \"Error decoding Speex frame.\\n\");        return AVERROR_INVALIDDATA;    }    if (avctx->channels == 2)        speex_decode_stereo_int(output, s->frame_size, &s->stereo);    *got_frame_ptr   = 1;    *(AVFrame *)data = s->frame;    return consumed;}", "idx": 8475}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "function": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr){    unsigned access_size_min = mr->ops->impl.min_access_size;    unsigned access_size_max = mr->ops->impl.max_access_size;    /* Regions are assumed to support 1-4 byte accesses unless       otherwise specified.  */    if (access_size_min == 0) {        access_size_min = 1;    }    if (access_size_max == 0) {        access_size_max = 4;    }    /* Bound the maximum access by the alignment of the address.  */    if (!mr->ops->impl.unaligned) {        unsigned align_size_max = addr & -addr;        if (align_size_max != 0 && align_size_max < access_size_max) {            access_size_max = align_size_max;        }    }    /* Don't attempt accesses larger than the maximum.  */    if (l > access_size_max) {        l = access_size_max;    }    /* ??? The users of this function are wrong, not supporting minimums larger       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */    assert(l >= access_size_min);    return l;}", "idx": 8518}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "function": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, int dstW, int chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if(!(c->flags & SWS_BITEXACT)) {        long p= 4;        const uint8_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};        uint8_t *dst[4]= {aDest, dest, uDest, vDest};        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};        if (c->flags & SWS_ACCURATE_RND) {            while(p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                        \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while(p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                        \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i=0; i<dstW; i++) {        int val= (lumSrc[i]+64)>>7;        if (val&256) {            if (val<0) val=0;            else       val=255;        }        dest[i]= val;    }    if (uDest)        for (i=0; i<chrDstW; i++) {            int u=(chrSrc[i       ]+64)>>7;            int v=(chrSrc[i + VOFW]+64)>>7;            if ((u|v)&256) {                if (u<0)        u=0;                else if (u>255) u=255;                if (v<0)        v=0;                else if (v>255) v=255;            }            uDest[i]= u;            vDest[i]= v;        }    if (CONFIG_SWSCALE_ALPHA && aDest)        for (i=0; i<dstW; i++) {            int val= (alpSrc[i]+64)>>7;            aDest[i]= av_clip_uint8(val);        }}", "idx": 8520}
{"project": "FFmpeg", "commit_id": "366d919016a679d3955f6fe5278fa7ce4f47b81e", "target": 1, "function": "static av_always_inline int vorbis_residue_decode_internal(vorbis_context *vc,                                                           vorbis_residue *vr,                                                           uint_fast8_t ch,                                                           uint_fast8_t *do_not_decode,                                                           float *vec,                                                           uint_fast16_t vlen,                                                           int vr_type){    GetBitContext *gb = &vc->gb;    uint_fast8_t c_p_c = vc->codebooks[vr->classbook].dimensions;    uint_fast16_t ptns_to_read = vr->ptns_to_read;    uint_fast8_t *classifs = vr->classifs;    uint_fast8_t pass;    uint_fast8_t ch_used;    uint_fast8_t i,j,l;    uint_fast16_t k;    if (vr_type == 2) {        for (j = 1; j < ch; ++j)            do_not_decode[0] &= do_not_decode[j];  // FIXME - clobbering input        if (do_not_decode[0])            return 0;        ch_used = 1;    } else {        ch_used = ch;    }    AV_DEBUG(\" residue type 0/1/2 decode begin, ch: %d  cpc %d  \\n\", ch, c_p_c);    for (pass = 0; pass <= vr->maxpass; ++pass) { // FIXME OPTIMIZE?        uint_fast16_t voffset;        uint_fast16_t partition_count;        uint_fast16_t j_times_ptns_to_read;        voffset = vr->begin;        for (partition_count = 0; partition_count < ptns_to_read;) {  // SPEC        error            if (!pass) {                uint_fast32_t inverse_class = ff_inverse[vr->classifications];                for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) {                    if (!do_not_decode[j]) {                        uint_fast32_t temp = get_vlc2(gb, vc->codebooks[vr->classbook].vlc.table,                        vc->codebooks[vr->classbook].nb_bits, 3);                        AV_DEBUG(\"Classword: %d \\n\", temp);                        assert(vr->classifications > 1 && temp <= 65536); //needed for inverse[]                        for (i = 0; i < c_p_c; ++i) {                            uint_fast32_t temp2;                            temp2 = (((uint_fast64_t)temp) * inverse_class) >> 32;                            if (partition_count + c_p_c - 1 - i < ptns_to_read)                                classifs[j_times_ptns_to_read + partition_count + c_p_c - 1 - i] = temp - temp2 * vr->classifications;                            temp = temp2;                        }                    }                    j_times_ptns_to_read += ptns_to_read;                }            }            for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) {                for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) {                    uint_fast16_t voffs;                    if (!do_not_decode[j]) {                        uint_fast8_t vqclass = classifs[j_times_ptns_to_read+partition_count];                        int_fast16_t vqbook = vr->books[vqclass][pass];                        if (vqbook >= 0 && vc->codebooks[vqbook].codevectors) {                            uint_fast16_t coffs;                            unsigned dim =  vc->codebooks[vqbook].dimensions; // not uint_fast8_t: 64bit is slower here on amd64                            uint_fast16_t step = dim == 1 ? vr->partition_size                                                          : FASTDIV(vr->partition_size, dim);                            vorbis_codebook codebook = vc->codebooks[vqbook];                            if (vr_type == 0) {                                voffs = voffset+j*vlen;                                for (k = 0; k < step; ++k) {                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;                                    for (l = 0; l < dim; ++l)                                        vec[voffs + k + l * step] += codebook.codevectors[coffs + l];  // FPMATH                                }                            } else if (vr_type == 1) {                                voffs = voffset + j * vlen;                                for (k = 0; k < step; ++k) {                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;                                    for (l = 0; l < dim; ++l, ++voffs) {                                        vec[voffs]+=codebook.codevectors[coffs+l];  // FPMATH                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d  \\n\", pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs);                                    }                                }                            } else if (vr_type == 2 && ch == 2 && (voffset & 1) == 0 && (dim & 1) == 0) { // most frequent case optimized                                voffs = voffset >> 1;                                if (dim == 2) {                                    for (k = 0; k < step; ++k) {                                        coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2;                                        vec[voffs + k       ] += codebook.codevectors[coffs    ];  // FPMATH                                        vec[voffs + k + vlen] += codebook.codevectors[coffs + 1];  // FPMATH                                    }                                } else if (dim == 4) {                                    for (k = 0; k < step; ++k, voffs += 2) {                                        coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 4;                                        vec[voffs           ] += codebook.codevectors[coffs    ];  // FPMATH                                        vec[voffs + 1       ] += codebook.codevectors[coffs + 2];  // FPMATH                                        vec[voffs + vlen    ] += codebook.codevectors[coffs + 1];  // FPMATH                                        vec[voffs + vlen + 1] += codebook.codevectors[coffs + 3];  // FPMATH                                    }                                } else                                for (k = 0; k < step; ++k) {                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;                                    for (l = 0; l < dim; l += 2, voffs++) {                                        vec[voffs       ] += codebook.codevectors[coffs + l    ];  // FPMATH                                        vec[voffs + vlen] += codebook.codevectors[coffs + l + 1];  // FPMATH                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\", pass, voffset / ch + (voffs % ch) * vlen, vec[voffset / ch + (voffs % ch) * vlen], codebook.codevectors[coffs + l], coffs, l);                                    }                                }                            } else if (vr_type == 2) {                                voffs = voffset;                                for (k = 0; k < step; ++k) {                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;                                    for (l = 0; l < dim; ++l, ++voffs) {                                        vec[voffs / ch + (voffs % ch) * vlen] += codebook.codevectors[coffs + l];  // FPMATH FIXME use if and counter instead of / and %                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\", pass, voffset / ch + (voffs % ch) * vlen, vec[voffset / ch + (voffs % ch) * vlen], codebook.codevectors[coffs + l], coffs, l);                                    }                                }                            }                        }                    }                    j_times_ptns_to_read += ptns_to_read;                }                ++partition_count;                voffset += vr->partition_size;            }        }    }    return 0;}", "idx": 8547}
{"project": "qemu", "commit_id": "dd26eb43337adf53d22b3fda3591e3837bc08b8c", "target": 0, "function": "static sd_rsp_type_t sd_app_command(SDState *sd,                                    SDRequest req){    DPRINTF(\"ACMD%d 0x%08x\\n\", req.cmd, req.arg);    sd->card_status |= APP_CMD;    switch (req.cmd) {    case 6:\t/* ACMD6:  SET_BUS_WIDTH */        switch (sd->state) {        case sd_transfer_state:            sd->sd_status[0] &= 0x3f;            sd->sd_status[0] |= (req.arg & 0x03) << 6;            return sd_r1;        default:            break;        }        break;    case 13:\t/* ACMD13: SD_STATUS */        switch (sd->state) {        case sd_transfer_state:            sd->state = sd_sendingdata_state;            sd->data_start = 0;            sd->data_offset = 0;            return sd_r1;        default:            break;        }        break;    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */        switch (sd->state) {        case sd_transfer_state:            *(uint32_t *) sd->data = sd->blk_written;            sd->state = sd_sendingdata_state;            sd->data_start = 0;            sd->data_offset = 0;            return sd_r1;        default:            break;        }        break;    case 23:\t/* ACMD23: SET_WR_BLK_ERASE_COUNT */        switch (sd->state) {        case sd_transfer_state:            return sd_r1;        default:            break;        }        break;    case 41:\t/* ACMD41: SD_APP_OP_COND */        if (sd->spi) {            /* SEND_OP_CMD */            sd->state = sd_transfer_state;            return sd_r1;        }        switch (sd->state) {        case sd_idle_state:            /* We accept any voltage.  10000 V is nothing.             *             * We don't model init delay so just advance straight to ready state             * unless it's an enquiry ACMD41 (bits 23:0 == 0).             */            if (req.arg & ACMD41_ENQUIRY_MASK) {                sd->state = sd_ready_state;            }            return sd_r3;        default:            break;        }        break;    case 42:\t/* ACMD42: SET_CLR_CARD_DETECT */        switch (sd->state) {        case sd_transfer_state:            /* Bringing in the 50KOhm pull-up resistor... Done.  */            return sd_r1;        default:            break;        }        break;    case 51:\t/* ACMD51: SEND_SCR */        switch (sd->state) {        case sd_transfer_state:            sd->state = sd_sendingdata_state;            sd->data_start = 0;            sd->data_offset = 0;            return sd_r1;        default:            break;        }        break;    default:        /* Fall back to standard commands.  */        return sd_normal_command(sd, req);    }    fprintf(stderr, \"SD: ACMD%i in a wrong state\\n\", req.cmd);    return sd_illegal;}", "idx": 8553}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static void t_gen_btst(TCGv d, TCGv a, TCGv b){        TCGv sbit;        TCGv bset;        TCGv t0;\tint l1;        /* des ref:           The N flag is set according to the selected bit in the dest reg.           The Z flag is set if the selected bit and all bits to the right are           zero.           The X flag is cleared.           Other flags are left untouched.           The destination reg is not affected.        unsigned int fz, sbit, bset, mask, masked_t0;        sbit = T1 & 31;        bset = !!(T0 & (1 << sbit));        mask = sbit == 31 ? -1 : (1 << (sbit + 1)) - 1;        masked_t0 = T0 & mask;        fz = !(masked_t0 | bset);        // Clear the X, N and Z flags.        T0 = env->pregs[PR_CCS] & ~(X_FLAG | N_FLAG | Z_FLAG);        // Set the N and Z flags accordingly.        T0 |= (bset << 3) | (fz << 2);        */\tl1 = gen_new_label();        sbit = tcg_temp_new(TCG_TYPE_TL);        bset = tcg_temp_new(TCG_TYPE_TL);        t0 = tcg_temp_new(TCG_TYPE_TL);        /* Compute bset and sbit.  */        tcg_gen_andi_tl(sbit, b, 31);        tcg_gen_shl_tl(t0, tcg_const_tl(1), sbit);        tcg_gen_and_tl(bset, a, t0);        tcg_gen_shr_tl(bset, bset, sbit);\t/* Displace to N_FLAG.  */        tcg_gen_shli_tl(bset, bset, 3);        tcg_gen_shl_tl(sbit, tcg_const_tl(2), sbit);        tcg_gen_subi_tl(sbit, sbit, 1);        tcg_gen_and_tl(sbit, a, sbit);        tcg_gen_andi_tl(d, cpu_PR[PR_CCS], ~(X_FLAG | N_FLAG | Z_FLAG));\t/* or in the N_FLAG.  */        tcg_gen_or_tl(d, d, bset);\ttcg_gen_brcondi_tl(TCG_COND_NE, sbit, 0, l1);\t/* or in the Z_FLAG.  */\ttcg_gen_ori_tl(d, d, Z_FLAG);\tgen_set_label(l1);        tcg_temp_free(sbit);        tcg_temp_free(bset);}", "idx": 8750}
{"project": "qemu", "commit_id": "2bfe11c8fac96db4f94abbe818fbc964a6744130", "target": 1, "function": "static void cpu_common_realizefn(DeviceState *dev, Error **errp){    CPUState *cpu = CPU(dev);    if (dev->hotplugged) {        cpu_synchronize_post_init(cpu);        cpu_resume(cpu);    }}", "idx": 8777}
{"project": "FFmpeg", "commit_id": "631c56a8e46dea41585f3e7b3ef9c52b49faa385", "target": 0, "function": "int ff_network_init(void){#if HAVE_WINSOCK2_H    WSADATA wsaData;#endif    if (!ff_network_inited_globally)        av_log(NULL, AV_LOG_WARNING, \"Using network protocols without global \"                                     \"network initialization. Please use \"                                     \"avformat_network_init(), this will \"                                     \"become mandatory later.\\n\");#if HAVE_WINSOCK2_H    if (WSAStartup(MAKEWORD(1,1), &wsaData))        return 0;#endif    return 1;}", "idx": 8801}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "function": "void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){#if HAVE_YASM    int mm_flags = av_get_cpu_flags();    if (mm_flags & AV_CPU_FLAG_SSE && HAVE_SSE) {        fdsp->vector_fmul = ff_vector_fmul_sse;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;    }    if (mm_flags & AV_CPU_FLAG_AVX && HAVE_AVX) {        fdsp->vector_fmul = ff_vector_fmul_avx;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;    }#endif}", "idx": 8823}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "function": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPREnvironment *spapr,                                uint32_t token, uint32_t nargs,                                target_ulong args, uint32_t nret,                                target_ulong rets){    uint32_t config_addr = rtas_ld(args, 0);    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);    unsigned int func = rtas_ld(args, 3);    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */    unsigned int seq_num = rtas_ld(args, 5);    unsigned int ret_intr_type;    unsigned int irq, max_irqs = 0, num = 0;    sPAPRPHBState *phb = NULL;    PCIDevice *pdev = NULL;    spapr_pci_msi *msi;    int *config_addr_key;    switch (func) {    case RTAS_CHANGE_MSI_FN:    case RTAS_CHANGE_FN:        ret_intr_type = RTAS_TYPE_MSI;        break;    case RTAS_CHANGE_MSIX_FN:        ret_intr_type = RTAS_TYPE_MSIX;        break;    default:        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);        return;    }    /* Fins sPAPRPHBState */    phb = find_phb(spapr, buid);    if (phb) {        pdev = find_dev(spapr, buid, config_addr);    }    if (!phb || !pdev) {        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);        return;    }    /* Releasing MSIs */    if (!req_num) {        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);        if (!msi) {            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);            return;        }        xics_free(spapr->icp, msi->first_irq, msi->num);        if (msi_present(pdev)) {            spapr_msi_setmsg(pdev, 0, false, 0, num);        }        if (msix_present(pdev)) {            spapr_msi_setmsg(pdev, 0, true, 0, num);        }        g_hash_table_remove(phb->msi, &config_addr);        trace_spapr_pci_msi(\"Released MSIs\", config_addr);        rtas_st(rets, 0, RTAS_OUT_SUCCESS);        rtas_st(rets, 1, 0);        return;    }    /* Enabling MSI */    /* Check if the device supports as many IRQs as requested */    if (ret_intr_type == RTAS_TYPE_MSI) {        max_irqs = msi_nr_vectors_allocated(pdev);    } else if (ret_intr_type == RTAS_TYPE_MSIX) {        max_irqs = pdev->msix_entries_nr;    }    if (!max_irqs) {        error_report(\"Requested interrupt type %d is not enabled for device %x\",                     ret_intr_type, config_addr);        rtas_st(rets, 0, -1); /* Hardware error */        return;    }    /* Correct the number if the guest asked for too many */    if (req_num > max_irqs) {        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);        req_num = max_irqs;        irq = 0; /* to avoid misleading trace */        goto out;    }    /* Allocate MSIs */    irq = xics_alloc_block(spapr->icp, 0, req_num, false,                           ret_intr_type == RTAS_TYPE_MSI);    if (!irq) {        error_report(\"Cannot allocate MSIs for device %x\", config_addr);        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);        return;    }    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,                     irq, req_num);    /* Add MSI device to cache */    msi = g_new(spapr_pci_msi, 1);    msi->first_irq = irq;    msi->num = req_num;    config_addr_key = g_new(int, 1);    *config_addr_key = config_addr;    g_hash_table_insert(phb->msi, config_addr_key, msi);out:    rtas_st(rets, 0, RTAS_OUT_SUCCESS);    rtas_st(rets, 1, req_num);    rtas_st(rets, 2, ++seq_num);    rtas_st(rets, 3, ret_intr_type);    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);}", "idx": 8950}
{"project": "qemu", "commit_id": "4295e15aa730a95003a3639d6dad2eb1e65a59e2", "target": 0, "function": "void qxl_guest_bug(PCIQXLDevice *qxl, const char *msg, ...){#if SPICE_INTERFACE_QXL_MINOR >= 1    qxl_send_events(qxl, QXL_INTERRUPT_ERROR);#endif    if (qxl->guestdebug) {        va_list ap;        va_start(ap, msg);        fprintf(stderr, \"qxl-%d: guest bug: \", qxl->id);        vfprintf(stderr, msg, ap);        fprintf(stderr, \"\\n\");        va_end(ap);    }}", "idx": 8994}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "function": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic){    DeviceState *dev;    PCIBus *b;    PCIDevice *d;    I440FXState *s;    PIIX3State *piix3;    dev = qdev_create(NULL, \"i440FX-pcihost\");    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));    b = pci_bus_new(&s->busdev.qdev, NULL, 0);    s->bus = b;    qdev_init(dev);    d = pci_create_simple(b, 0, \"i440FX\");    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);    piix3 = DO_UPCAST(PIIX3State, dev,                                 pci_create_simple(b, -1, \"PIIX3\"));    piix3->pic = pic;    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);    (*pi440fx_state)->piix3 = piix3;    *piix3_devfn = piix3->dev.devfn;    return b;}", "idx": 9017}
{"project": "FFmpeg", "commit_id": "b50e003e1cb6a215df44ffa3354603bf600b4aa3", "target": 0, "function": "static av_always_inline int cmp_inline(MpegEncContext *s, const int x, const int y, const int subx, const int suby,                      const int size, const int h, int ref_index, int src_index,                      me_cmp_func cmp_func, me_cmp_func chroma_cmp_func, int qpel, int chroma){    MotionEstContext * const c= &s->me;    const int stride= c->stride;    const int uvstride= c->uvstride;    const int dxy= subx + (suby<<(1+qpel)); //FIXME log2_subpel?    const int hx= subx + (x<<(1+qpel));    const int hy= suby + (y<<(1+qpel));    uint8_t * const * const ref= c->ref[ref_index];    uint8_t * const * const src= c->src[src_index];    int d;    //FIXME check chroma 4mv, (no crashes ...)        int uvdxy;              /* no, it might not be used uninitialized */        if(dxy){            if(qpel){                c->qpel_put[size][dxy](c->temp, ref[0] + x + y*stride, stride); //FIXME prototype (add h)                if(chroma){                    int cx= hx/2;                    int cy= hy/2;                    cx= (cx>>1)|(cx&1);                    cy= (cy>>1)|(cy&1);                    uvdxy= (cx&1) + 2*(cy&1);                    //FIXME x/y wrong, but mpeg4 qpel is sick anyway, we should drop as much of it as possible in favor for h264                }            }else{                c->hpel_put[size][dxy](c->temp, ref[0] + x + y*stride, stride, h);                if(chroma)                    uvdxy= dxy | (x&1) | (2*(y&1));            }            d = cmp_func(s, c->temp, src[0], stride, h);        }else{            d = cmp_func(s, src[0], ref[0] + x + y*stride, stride, h);            if(chroma)                uvdxy= (x&1) + 2*(y&1);        }        if(chroma){            uint8_t * const uvtemp= c->temp + 16*stride;            c->hpel_put[size+1][uvdxy](uvtemp  , ref[1] + (x>>1) + (y>>1)*uvstride, uvstride, h>>1);            c->hpel_put[size+1][uvdxy](uvtemp+8, ref[2] + (x>>1) + (y>>1)*uvstride, uvstride, h>>1);            d += chroma_cmp_func(s, uvtemp  , src[1], uvstride, h>>1);            d += chroma_cmp_func(s, uvtemp+8, src[2], uvstride, h>>1);        }    return d;}", "idx": 9104}
{"project": "qemu", "commit_id": "7a05995361a7b4376dffb3c7f04a95644251d29f", "target": 1, "function": "CPUX86State *cpu_x86_init(const char *cpu_model){    X86CPU *cpu;    CPUX86State *env;    static int inited;    cpu = X86_CPU(object_new(TYPE_X86_CPU));    env = &cpu->env;    env->cpu_model_str = cpu_model;    /* init various static tables used in TCG mode */    if (tcg_enabled() && !inited) {        inited = 1;        optimize_flags_init();#ifndef CONFIG_USER_ONLY        prev_debug_excp_handler =            cpu_set_debug_excp_handler(breakpoint_handler);#endif    }    if (cpu_x86_register(cpu, cpu_model) < 0) {        object_delete(OBJECT(cpu));        return NULL;    }    qemu_init_vcpu(env);    return env;}", "idx": 9121}
{"project": "FFmpeg", "commit_id": "3715d841a619f1cbc4776d9b00575dae6fb6534a", "target": 0, "function": "WINDOW_FUNC(eight_short){    const float *swindow = sce->ics.use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;    const float *pwindow = sce->ics.use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;    const float *in = audio + 448;    float *out = sce->ret;    for (int w = 0; w < 8; w++) {        dsp->vector_fmul        (out, in, w ? pwindow : swindow, 128);        out += 128;        in  += 128;        dsp->vector_fmul_reverse(out, in, swindow, 128);        out += 128;    }}", "idx": 9133}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static inline void t_gen_swapw(TCGv d, TCGv s){\tTCGv t;\t/* d and s refer the same object.  */\tt = tcg_temp_new(TCG_TYPE_TL);\ttcg_gen_mov_tl(t, s);\ttcg_gen_shli_tl(d, t, 16);\ttcg_gen_shri_tl(t, t, 16);\ttcg_gen_or_tl(d, d, t);\ttcg_temp_free(t);}", "idx": 9251}
{"project": "qemu", "commit_id": "72902672dc2ed6281cdb205259c1d52ecf01f6b2", "target": 1, "function": "NEON_TYPE4(s8, int8_t)NEON_TYPE4(u8, uint8_t)NEON_TYPE2(s16, int16_t)NEON_TYPE2(u16, uint16_t)NEON_TYPE1(s32, int32_t)NEON_TYPE1(u32, uint32_t)#undef NEON_TYPE4#undef NEON_TYPE2#undef NEON_TYPE1/* Copy from a uint32_t to a vector structure type.  */#define NEON_UNPACK(vtype, dest, val) do { \\    union { \\        vtype v; \\        uint32_t i; \\    } conv_u; \\    conv_u.i = (val); \\    dest = conv_u.v; \\    } while(0)/* Copy from a vector structure type to a uint32_t.  */#define NEON_PACK(vtype, dest, val) do { \\    union { \\        vtype v; \\        uint32_t i; \\    } conv_u; \\    conv_u.v = (val); \\    dest = conv_u.i; \\    } while(0)#define NEON_DO1 \\    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1);#define NEON_DO2 \\    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1); \\    NEON_FN(vdest.v2, vsrc1.v2, vsrc2.v2);#define NEON_DO4 \\    NEON_FN(vdest.v1, vsrc1.v1, vsrc2.v1); \\    NEON_FN(vdest.v2, vsrc1.v2, vsrc2.v2); \\    NEON_FN(vdest.v3, vsrc1.v3, vsrc2.v3); \\    NEON_FN(vdest.v4, vsrc1.v4, vsrc2.v4);#define NEON_VOP_BODY(vtype, n) \\{ \\    uint32_t res; \\    vtype vsrc1; \\    vtype vsrc2; \\    vtype vdest; \\    NEON_UNPACK(vtype, vsrc1, arg1); \\    NEON_UNPACK(vtype, vsrc2, arg2); \\    NEON_DO##n; \\    NEON_PACK(vtype, res, vdest); \\    return res; \\#define NEON_VOP(name, vtype, n) \\uint32_t HELPER(glue(neon_,name))(uint32_t arg1, uint32_t arg2) \\NEON_VOP_BODY(vtype, n)#define NEON_VOP_ENV(name, vtype, n) \\uint32_t HELPER(glue(neon_,name))(CPUState *env, uint32_t arg1, uint32_t arg2) \\NEON_VOP_BODY(vtype, n)/* Pairwise operations.  *//* For 32-bit elements each segment only contains a single element, so   the elementwise and pairwise operations are the same.  */#define NEON_PDO2 \\    NEON_FN(vdest.v1, vsrc1.v1, vsrc1.v2); \\    NEON_FN(vdest.v2, vsrc2.v1, vsrc2.v2);#define NEON_PDO4 \\    NEON_FN(vdest.v1, vsrc1.v1, vsrc1.v2); \\    NEON_FN(vdest.v2, vsrc1.v3, vsrc1.v4); \\    NEON_FN(vdest.v3, vsrc2.v1, vsrc2.v2); \\    NEON_FN(vdest.v4, vsrc2.v3, vsrc2.v4); \\#define NEON_POP(name, vtype, n) \\uint32_t HELPER(glue(neon_,name))(uint32_t arg1, uint32_t arg2) \\{ \\    uint32_t res; \\    vtype vsrc1; \\    vtype vsrc2; \\    vtype vdest; \\    NEON_UNPACK(vtype, vsrc1, arg1); \\    NEON_UNPACK(vtype, vsrc2, arg2); \\    NEON_PDO##n; \\    NEON_PACK(vtype, res, vdest); \\    return res; \\/* Unary operators.  */#define NEON_VOP1(name, vtype, n) \\uint32_t HELPER(glue(neon_,name))(uint32_t arg) \\{ \\    vtype vsrc1; \\    vtype vdest; \\    NEON_UNPACK(vtype, vsrc1, arg); \\    NEON_DO##n; \\    NEON_PACK(vtype, arg, vdest); \\    return arg; \\#define NEON_USAT(dest, src1, src2, type) do { \\    uint32_t tmp = (uint32_t)src1 + (uint32_t)src2; \\    if (tmp != (type)tmp) { \\        SET_QC(); \\        dest = ~0; \\    } else { \\        dest = tmp; \\    }} while(0)#define NEON_FN(dest, src1, src2) NEON_USAT(dest, src1, src2, uint8_t)NEON_VOP_ENV(qadd_u8, neon_u8, 4)#undef NEON_FN#define NEON_FN(dest, src1, src2) NEON_USAT(dest, src1, src2, uint16_t)NEON_VOP_ENV(qadd_u16, neon_u16, 2)#undef NEON_FN#undef NEON_USAT", "idx": 9328}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint64_t fw_cfg_comb_read(void *opaque, target_phys_addr_t addr,                                 unsigned size){    return fw_cfg_read(opaque);}", "idx": 9381}
{"project": "qemu", "commit_id": "96e35046e4a97df5b4e1e24e217eb1e1701c7c71", "target": 1, "function": "static void rxfilter_notify(NetClientState *nc){    QObject *event_data;    VirtIONet *n = qemu_get_nic_opaque(nc);    if (nc->rxfilter_notify_enabled) {        if (n->netclient_name) {            event_data = qobject_from_jsonf(\"{ 'name': %s, 'path': %s }\",                                    n->netclient_name,                                    object_get_canonical_path(OBJECT(n->qdev)));        } else {            event_data = qobject_from_jsonf(\"{ 'path': %s }\",                                    object_get_canonical_path(OBJECT(n->qdev)));        }        monitor_protocol_event(QEVENT_NIC_RX_FILTER_CHANGED, event_data);        qobject_decref(event_data);        /* disable event notification to avoid events flooding */        nc->rxfilter_notify_enabled = 0;    }}", "idx": 9414}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "function": "static void uc32_cpu_initfn(Object *obj){    CPUState *cs = CPU(obj);    UniCore32CPU *cpu = UNICORE32_CPU(obj);    CPUUniCore32State *env = &cpu->env;    static bool inited;    cs->env_ptr = env;    cpu_exec_init(cs, &error_abort);#ifdef CONFIG_USER_ONLY    env->uncached_asr = ASR_MODE_USER;    env->regs[31] = 0;#else    env->uncached_asr = ASR_MODE_PRIV;    env->regs[31] = 0x03000000;#endif    tlb_flush(cs, 1);    if (tcg_enabled() && !inited) {        inited = true;        uc32_translate_init();    }}", "idx": 9432}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "function": "static int decode_b_mbs(VC9Context *v){    MpegEncContext *s = &v->s;    GetBitContext *gb = &v->s.gb;    int current_mb = 0, i /* MB / B postion information */;    int b_mv_type = BMV_TYPE_BACKWARD;    int mquant, mqdiff; /* MB quant stuff */    int ttmb; /* MacroBlock transform type */        static const int size_table[6] = { 0, 2, 3, 4, 5, 8 },        offset_table[6] = { 0, 1, 3, 7, 15, 31 };    int mb_has_coeffs = 1; /* last_flag */    int dmv1_x, dmv1_y, dmv2_x, dmv2_y; /* Differential MV components */    int k_x, k_y; /* Long MV fixed bitlength */    int hpel_flag; /* Some MB properties */    int index, index1; /* LUT indices */    int val, sign; /* MVDATA temp values */        /* Select proper long MV range */    switch (v->mvrange)    {    case 1: k_x = 10; k_y = 9; break;    case 2: k_x = 12; k_y = 10; break;    case 3: k_x = 13; k_y = 11; break;    default: /*case 0 too */ k_x = 9; k_y = 8; break;    }    hpel_flag = v->mv_mode & 1; //MV_PMODE is HPEL    k_x -= hpel_flag;    k_y -= hpel_flag;    /* Select ttmb table depending on pq */    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];    else v->ttmb_vlc = &vc9_ttmb_vlc[2];    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)    {        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++)        {            if (v->direct_mb_plane.is_raw)                v->direct_mb_plane.data[current_mb] = get_bits(gb, 1);            if (v->skip_mb_plane.is_raw)                v->skip_mb_plane.data[current_mb] = get_bits(gb, 1);                        if (!v->direct_mb_plane.data[current_mb])            {                if (v->skip_mb_plane.data[current_mb])                {                    b_mv_type = decode012(gb);                    if (v->bfraction > 420 /*1/2*/ &&                        b_mv_type < 3) b_mv_type = 1-b_mv_type;                }                else                {                     GET_MVDATA(dmv1_x, dmv1_y);                    if (!s->mb_intra /* b_mv1 tells not intra */)                    {                        b_mv_type = decode012(gb);                        if (v->bfraction > 420 /*1/2*/ &&                            b_mv_type < 3) b_mv_type = 1-b_mv_type;                    }                }            }            if (!v->skip_mb_plane.data[current_mb])            {                if (mb_has_coeffs /* BMV1 == \"last\" */)                {                    GET_MQUANT();                    if (s->mb_intra /* intra mb */)                        s->ac_pred = get_bits(gb, 1);                }                else                {                    /* if bmv1 tells MVs are interpolated */                    if (b_mv_type == BMV_TYPE_INTERPOLATED)                    {                        GET_MVDATA(dmv2_x, dmv2_y);                    }                    /* GET_MVDATA has reset some stuff */                    if (mb_has_coeffs /* b_mv2 == \"last\" */)                    {                        if (s->mb_intra /* intra_mb */)                            s->ac_pred = get_bits(gb, 1);                        GET_MQUANT();                    }                }            }            //End1            if (v->ttmbf)                ttmb = get_vlc2(gb, v->ttmb_vlc->table,                                   VC9_TTMB_VLC_BITS, 12);            //End2            for (i=0; i<6; i++)            {                /* FIXME: process the block */            }            current_mb++;        }    }    return 0;}", "idx": 9470}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "function": "static int shall_we_drop(AVFormatContext *s){    struct dshow_ctx *ctx = s->priv_data;    static const uint8_t dropscore[] = {62, 75, 87, 100};    const int ndropscores = FF_ARRAY_ELEMS(dropscore);    unsigned int buffer_fullness = (ctx->curbufsize*100)/s->max_picture_buffer;    if(dropscore[++ctx->video_frame_num%ndropscores] <= buffer_fullness) {        av_log(s, AV_LOG_ERROR,              \"real-time buffer %d%% full! frame dropped!\\n\", buffer_fullness);        return 1;    }    return 0;}", "idx": 9506}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "function": "void ff_bink_idct_c(DCTELEM *block){    int i;    DCTELEM temp[64];    for (i = 0; i < 8; i++)        bink_idct_col(&temp[i], &block[i]);    for (i = 0; i < 8; i++) {        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );    }}", "idx": 9607}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "function": "static void qtrle_decode_32bpp(QtrleContext *s, int stream_ptr, int row_ptr, int lines_to_change){    int rle_code;    int pixel_ptr;    int row_inc = s->frame.linesize[0];    unsigned char a, r, g, b;    unsigned int argb;    unsigned char *rgb = s->frame.data[0];    int pixel_limit = s->frame.linesize[0] * s->avctx->height;    while (lines_to_change--) {        CHECK_STREAM_PTR(2);        pixel_ptr = row_ptr + (s->buf[stream_ptr++] - 1) * 4;        while ((rle_code = (signed char)s->buf[stream_ptr++]) != -1) {            if (rle_code == 0) {                /* there's another skip code in the stream */                CHECK_STREAM_PTR(1);                pixel_ptr += (s->buf[stream_ptr++] - 1) * 4;            } else if (rle_code < 0) {                /* decode the run length code */                rle_code = -rle_code;                CHECK_STREAM_PTR(4);                a = s->buf[stream_ptr++];                r = s->buf[stream_ptr++];                g = s->buf[stream_ptr++];                b = s->buf[stream_ptr++];                argb = (a << 24) | (r << 16) | (g << 8) | (b << 0);                CHECK_PIXEL_PTR(rle_code * 4);                while (rle_code--) {                    *(unsigned int *)(&rgb[pixel_ptr]) = argb;                    pixel_ptr += 4;                }            } else {                CHECK_STREAM_PTR(rle_code * 4);                CHECK_PIXEL_PTR(rle_code * 4);                /* copy pixels directly to output */                while (rle_code--) {                    a = s->buf[stream_ptr++];                    r = s->buf[stream_ptr++];                    g = s->buf[stream_ptr++];                    b = s->buf[stream_ptr++];                    argb = (a << 24) | (r << 16) | (g << 8) | (b << 0);                    *(unsigned int *)(&rgb[pixel_ptr]) = argb;                    pixel_ptr += 4;                }            }        }        row_ptr += row_inc;    }}", "idx": 9608}
{"project": "qemu", "commit_id": "26572b8a0e90ee0c77587173a78fa293a1d2beb6", "target": 0, "function": "void vga_hw_invalidate(void){    if (active_console->hw_invalidate)        active_console->hw_invalidate(active_console->hw);}", "idx": 9635}
{"project": "qemu", "commit_id": "f689d2811a36894618087e1e2cc3ade78e758e94", "target": 1, "function": "static int create_shared_memory_BAR(IVShmemState *s, int fd, uint8_t attr,                                    Error **errp){    void * ptr;    ptr = mmap(0, s->ivshmem_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);    if (ptr == MAP_FAILED) {        error_setg_errno(errp, errno, \"Failed to mmap shared memory\");        return -1;    }    s->shm_fd = fd;    memory_region_init_ram_ptr(&s->ivshmem, OBJECT(s), \"ivshmem.bar2\",                               s->ivshmem_size, ptr);    vmstate_register_ram(&s->ivshmem, DEVICE(s));    memory_region_add_subregion(&s->bar, 0, &s->ivshmem);    /* region for shared memory */    pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);    return 0;}", "idx": 9648}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "function": "static inline void gen_op_addq_ESP_im(int32_t val){    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));}", "idx": 9675}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "function": "static int default_start_frame(AVFilterLink *inlink, AVFilterBufferRef *picref){    AVFilterLink *outlink = NULL;    if (inlink->dst->nb_outputs)        outlink = inlink->dst->outputs[0];    if (outlink) {        outlink->out_buf = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);        if (!outlink->out_buf)            return AVERROR(ENOMEM);        avfilter_copy_buffer_ref_props(outlink->out_buf, picref);        return ff_start_frame(outlink, avfilter_ref_buffer(outlink->out_buf, ~0));    }    return 0;}", "idx": 9694}
{"project": "qemu", "commit_id": "f5bebbbb28dc7a149a891f0f1e112fb50bb72664", "target": 0, "function": "BlockDriverState *bdrv_new(const char *device_name, Error **errp){    BlockDriverState *bs;    int i;    if (*device_name && !bdrv_is_valid_name(device_name)) {        error_setg(errp, \"Invalid device name\");        return NULL;    }    if (bdrv_find(device_name)) {        error_setg(errp, \"Device with id '%s' already exists\",                   device_name);        return NULL;    }    if (bdrv_find_node(device_name)) {        error_setg(errp,                   \"Device name '%s' conflicts with an existing node name\",                   device_name);        return NULL;    }    bs = g_new0(BlockDriverState, 1);    QLIST_INIT(&bs->dirty_bitmaps);    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);    if (device_name[0] != '\\0') {        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);    }    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {        QLIST_INIT(&bs->op_blockers[i]);    }    bdrv_iostatus_disable(bs);    notifier_list_init(&bs->close_notifiers);    notifier_with_return_list_init(&bs->before_write_notifiers);    qemu_co_queue_init(&bs->throttled_reqs[0]);    qemu_co_queue_init(&bs->throttled_reqs[1]);    bs->refcnt = 1;    bs->aio_context = qemu_get_aio_context();    return bs;}", "idx": 9708}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "function": "static inline void reset_bit(uint32_t *field, int bit){    field[bit >> 5] &= ~(1 << (bit & 0x1F));}", "idx": 9712}
{"project": "qemu", "commit_id": "374ec0669a1aa3affac7850a16c6cad18221c439", "target": 1, "function": "static ssize_t sdp_svc_search(struct bt_l2cap_sdp_state_s *sdp,                uint8_t *rsp, const uint8_t *req, ssize_t len){    ssize_t seqlen;    int i, count, start, end, max;    int32_t handle;    /* Perform the search */    for (i = 0; i < sdp->services; i ++)        sdp->service_list[i].match = 0;    if (len < 1)        return -SDP_INVALID_SYNTAX;    if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {        seqlen = sdp_datalen(&req, &len);        if (seqlen < 3 || len < seqlen)            return -SDP_INVALID_SYNTAX;        len -= seqlen;        while (seqlen)            if (sdp_svc_match(sdp, &req, &seqlen))                return -SDP_INVALID_SYNTAX;    } else if (sdp_svc_match(sdp, &req, &seqlen))        return -SDP_INVALID_SYNTAX;    if (len < 3)        return -SDP_INVALID_SYNTAX;    max = (req[0] << 8) | req[1];    req += 2;    len -= 2;    if (*req) {        if (len <= sizeof(int))            return -SDP_INVALID_SYNTAX;        len -= sizeof(int);        memcpy(&start, req + 1, sizeof(int));    } else        start = 0;    if (len > 1)        return -SDP_INVALID_SYNTAX;    /* Output the results */    len = 4;    count = 0;    end = start;    for (i = 0; i < sdp->services; i ++)        if (sdp->service_list[i].match) {            if (count >= start && count < max && len + 4 < MAX_RSP_PARAM_SIZE) {                handle = i;                memcpy(rsp + len, &handle, 4);                len += 4;                end = count + 1;            }            count ++;        }    rsp[0] = count >> 8;    rsp[1] = count & 0xff;    rsp[2] = (end - start) >> 8;    rsp[3] = (end - start) & 0xff;    if (end < count) {        rsp[len ++] = sizeof(int);        memcpy(rsp + len, &end, sizeof(int));        len += 4;    } else        rsp[len ++] = 0;    return len;}", "idx": 9794}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "function": "void qdev_prop_set_drive(DeviceState *dev, const char *name,                         BlockBackend *value, Error **errp){    object_property_set_str(OBJECT(dev), value ? blk_name(value) : \"\",                            name, errp);}", "idx": 9893}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "function": "static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size){    uint16_t cmd;    int i, sz, offset, code;    unsigned char *dst_end = dst + dst_size;    const unsigned char *src_end = src + src_size;    while (src < src_end && dst < dst_end) {        code = *src++;        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {            if (code & (1 << i)) {                *dst++ = *src++;            } else {                cmd = AV_RL16(src); src += 2;                offset = cmd >> 4;                sz = (cmd & 0xF) + 2;                /* don't use memcpy/memmove here as the decoding routine (ab)uses */                /* buffer overlappings to repeat bytes in the destination */                sz = FFMIN(sz, dst_end - dst);                while (sz--) {                    *dst = *(dst - offset - 1);                    ++dst;                }            }        }    }}", "idx": 9896}
{"project": "qemu", "commit_id": "9d6f106552fa5ad9e3128b5052863835526ba271", "target": 0, "function": "void ppc_set_compat(PowerPCCPU *cpu, uint32_t compat_pvr, Error **errp){    int ret = 0;    CPUPPCState *env = &cpu->env;    PowerPCCPUClass *host_pcc;    cpu->compat_pvr = compat_pvr;    switch (compat_pvr) {    case CPU_POWERPC_LOGICAL_2_05:        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_VSX_DIS | PCR_COMPAT_2_07 |                            PCR_COMPAT_2_06 | PCR_COMPAT_2_05;        break;    case CPU_POWERPC_LOGICAL_2_06:    case CPU_POWERPC_LOGICAL_2_06_PLUS:        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_COMPAT_2_07 | PCR_COMPAT_2_06;        break;    case CPU_POWERPC_LOGICAL_2_07:        env->spr[SPR_PCR] = PCR_COMPAT_2_07;        break;    default:        env->spr[SPR_PCR] = 0;        break;    }    host_pcc = kvm_ppc_get_host_cpu_class();    if (host_pcc) {        env->spr[SPR_PCR] &= host_pcc->pcr_mask;    }    if (kvm_enabled()) {        ret = kvmppc_set_compat(cpu, cpu->compat_pvr);        if (ret < 0) {            error_setg_errno(errp, -ret,                             \"Unable to set CPU compatibility mode in KVM\");        }    }}", "idx": 9969}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "function": "static void vnc_zlib_start(VncState *vs){    buffer_reset(&vs->zlib);    // make the output buffer be the zlib buffer, so we can compress it later    vs->zlib_tmp = vs->output;    vs->output = vs->zlib;}", "idx": 10011}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "function": "void qjson_finish(QJSON *json){    json_end_object(json);}", "idx": 10037}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "function": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,                                     TCGv cmp, int32_t disp){    uint64_t dest = ctx->pc + (disp << 2);    int lab_true = gen_new_label();    if (use_goto_tb(ctx, dest)) {        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);        tcg_gen_goto_tb(0);        tcg_gen_movi_i64(cpu_pc, ctx->pc);        tcg_gen_exit_tb((uintptr_t)ctx->tb);        gen_set_label(lab_true);        tcg_gen_goto_tb(1);        tcg_gen_movi_i64(cpu_pc, dest);        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);        return EXIT_GOTO_TB;    } else {        TCGv_i64 z = tcg_const_i64(0);        TCGv_i64 d = tcg_const_i64(dest);        TCGv_i64 p = tcg_const_i64(ctx->pc);        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);        tcg_temp_free_i64(z);        tcg_temp_free_i64(d);        tcg_temp_free_i64(p);        return EXIT_PC_UPDATED;    }}", "idx": 10064}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "function": "static inline void start_exclusive(void){    CPUState *other;    pthread_mutex_lock(&exclusive_lock);    exclusive_idle();    pending_cpus = 1;    /* Make all other cpus stop executing.  */    for (other = first_cpu; other; other = other->next_cpu) {        if (other->running) {            pending_cpus++;            cpu_interrupt(other, CPU_INTERRUPT_EXIT);        }    }    if (pending_cpus > 1) {        pthread_cond_wait(&exclusive_cond, &exclusive_lock);    }}", "idx": 10095}
{"project": "qemu", "commit_id": "fd97fd4408040a9a6dfaf2fdaeca1c566db6d0aa", "target": 1, "function": "static long gethugepagesize(const char *path, Error **errp){    struct statfs fs;    int ret;    do {        ret = statfs(path, &fs);    } while (ret != 0 && errno == EINTR);    if (ret != 0) {        error_setg_errno(errp, errno, \"failed to get page size of file %s\",                         path);        return 0;    }    return fs.f_bsize;}", "idx": 10101}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "function": "static int create_stream(AVFormatContext *s){    XCBGrabContext *c = s->priv_data;    AVStream *st      = avformat_new_stream(s, NULL);    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo;    int ret;    if (!st)        return AVERROR(ENOMEM);    ret = av_parse_video_size(&c->width, &c->height, c->video_size);    if (ret < 0)        return ret;    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);    if (ret < 0)        return ret;    avpriv_set_pts_info(st, 64, 1, 1000000);    gc  = xcb_get_geometry(c->conn, c->screen->root);    geo = xcb_get_geometry_reply(c->conn, gc, NULL);    c->width      = FFMIN(geo->width, c->width);    c->height     = FFMIN(geo->height, c->height);    c->time_base  = (AVRational){ st->avg_frame_rate.den,                                  st->avg_frame_rate.num };    c->time_frame = av_gettime();    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;    st->codec->width      = c->width;    st->codec->height     = c->height;    st->codec->time_base  = c->time_base;    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);    free(geo);    return ret;}", "idx": 10161}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "function": "static abi_long do_socket(int domain, int type, int protocol){    int target_type = type;    int ret;    ret = target_to_host_sock_type(&type);    if (ret) {        return ret;    }    if (domain == PF_NETLINK)        return -TARGET_EAFNOSUPPORT;    if (domain == AF_PACKET ||        (domain == AF_INET && type == SOCK_PACKET)) {        protocol = tswap16(protocol);    }    ret = get_errno(socket(domain, type, protocol));    if (ret >= 0) {        ret = sock_flags_fixup(ret, target_type);        if (type == SOCK_PACKET) {            /* Manage an obsolete case :             * if socket type is SOCK_PACKET, bind by name             */            fd_trans_register(ret, &target_packet_trans);        }    }    return ret;}", "idx": 10190}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "function": "static bool cmd_read_dma(IDEState *s, uint8_t cmd){    bool lba48 = (cmd == WIN_READDMA_EXT);    if (!s->bs) {        ide_abort_command(s);        return true;    }    ide_cmd_lba48_transform(s, lba48);    ide_sector_start_dma(s, IDE_DMA_READ);    return false;}", "idx": 10255}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "function": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,                                        const uint8_t *in, uint32_t in_len,                                        uint8_t *out, uint32_t out_len){    int ret;    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);    if (ret != in_len) {        error_report(\"tpm_passthrough: error while transmitting data \"                     \"to TPM: %s (%i)\\n\",                     strerror(errno), errno);        goto err_exit;    }    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);    if (ret < 0) {        error_report(\"tpm_passthrough: error while reading data from \"                     \"TPM: %s (%i)\\n\",                     strerror(errno), errno);    } else if (ret < sizeof(struct tpm_resp_hdr) ||               tpm_passthrough_get_size_from_buffer(out) != ret) {        ret = -1;        error_report(\"tpm_passthrough: received invalid response \"                     \"packet from TPM\\n\");    }err_exit:    if (ret < 0) {        tpm_write_fatal_error_response(out, out_len);    }    return ret;}", "idx": 10269}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "function": "void qxl_log_command(PCIQXLDevice *qxl, const char *ring, QXLCommandExt *ext){    bool compat = ext->flags & QXL_COMMAND_FLAG_COMPAT;    void *data;    if (!qxl->cmdlog) {        return;    }    fprintf(stderr, \"%\" PRId64 \" qxl-%d/%s:\", qemu_get_clock_ns(vm_clock),            qxl->id, ring);    fprintf(stderr, \" cmd @ 0x%\" PRIx64 \" %s%s\", ext->cmd.data,            qxl_name(qxl_type, ext->cmd.type),            compat ? \"(compat)\" : \"\");    data = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);    switch (ext->cmd.type) {    case QXL_CMD_DRAW:        if (!compat) {            qxl_log_cmd_draw(qxl, data, ext->group_id);        } else {            qxl_log_cmd_draw_compat(qxl, data, ext->group_id);        }        break;    case QXL_CMD_SURFACE:        qxl_log_cmd_surface(qxl, data);        break;    case QXL_CMD_CURSOR:        qxl_log_cmd_cursor(qxl, data, ext->group_id);        break;    }    fprintf(stderr, \"\\n\");}", "idx": 10283}
{"project": "FFmpeg", "commit_id": "403ee835e7913eb9536b22c2b22edfdd700166a9", "target": 0, "function": "AVFormatContext *ff_rtp_chain_mux_open(AVFormatContext *s, AVStream *st,                                       URLContext *handle, int packet_size){    AVFormatContext *rtpctx;    int ret;    AVOutputFormat *rtp_format = av_guess_format(\"rtp\", NULL, NULL);    if (!rtp_format)        return NULL;    /* Allocate an AVFormatContext for each output stream */    rtpctx = avformat_alloc_context();    if (!rtpctx)        return NULL;    rtpctx->oformat = rtp_format;    if (!av_new_stream(rtpctx, 0)) {        av_free(rtpctx);        return NULL;    }    /* Copy the max delay setting; the rtp muxer reads this. */    rtpctx->max_delay = s->max_delay;    /* Copy other stream parameters. */    rtpctx->streams[0]->sample_aspect_ratio = st->sample_aspect_ratio;    /* Set the synchronized start time. */    rtpctx->start_time_realtime = s->start_time_realtime;    avcodec_copy_context(rtpctx->streams[0]->codec, st->codec);    if (handle) {        url_fdopen(&rtpctx->pb, handle);    } else        url_open_dyn_packet_buf(&rtpctx->pb, packet_size);    ret = av_write_header(rtpctx);    if (ret) {        if (handle) {            avio_close(rtpctx->pb);        } else {            uint8_t *ptr;            avio_close_dyn_buf(rtpctx->pb, &ptr);            av_free(ptr);        }        avformat_free_context(rtpctx);        return NULL;    }    return rtpctx;}", "idx": 10307}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static always_inline void gen_farith3 (void *helper,                                       int ra, int rb, int rc){    if (unlikely(rc == 31))        return;    if (ra != 31) {        if (rb != 31)            tcg_gen_helper_1_2(helper, cpu_fir[rc], cpu_fir[ra], cpu_fir[rb]);        else {            TCGv tmp = tcg_const_i64(0);            tcg_gen_helper_1_2(helper, cpu_fir[rc], cpu_fir[ra], tmp);            tcg_temp_free(tmp);        }    } else {        TCGv tmp = tcg_const_i64(0);        if (rb != 31)            tcg_gen_helper_1_2(helper, cpu_fir[rc], tmp, cpu_fir[rb]);        else            tcg_gen_helper_1_2(helper, cpu_fir[rc], tmp, tmp);        tcg_temp_free(tmp);    }}", "idx": 10314}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "function": "long check_dcbzl_effect(void){  register char *fakedata = (char*)av_malloc(1024);  register char *fakedata_middle;  register long zero = 0;  register long i = 0;  long count = 0;  if (!fakedata)  {    return 0L;  }  fakedata_middle = (fakedata + 512);  memset(fakedata, 0xFF, 1024);  /* below the constraint \"b\" seems to mean \"Address base register\"     in gcc-3.3 / RS/6000 speaks. seems to avoid using r0, so.... */  asm volatile(\"dcbzl %0, %1\" : : \"b\" (fakedata_middle), \"r\" (zero));  for (i = 0; i < 1024 ; i ++)  {    if (fakedata[i] == (char)0)      count++;  }  av_free(fakedata);  return count;}", "idx": 10348}
{"project": "qemu", "commit_id": "a307d59434ba78b97544b42b8cfd24a1b62e39a6", "target": 0, "function": "static void vty_receive(void *opaque, const uint8_t *buf, int size){    VIOsPAPRVTYDevice *dev = (VIOsPAPRVTYDevice *)opaque;    int i;    if ((dev->in == dev->out) && size) {        /* toggle line to simulate edge interrupt */        qemu_irq_pulse(dev->sdev.qirq);    }    for (i = 0; i < size; i++) {        assert((dev->in - dev->out) < VTERM_BUFSIZE);        dev->buf[dev->in++ % VTERM_BUFSIZE] = buf[i];    }}", "idx": 10373}
{"project": "qemu", "commit_id": "f1f57066573e832438cd87600310589fa9cee202", "target": 0, "function": "void blk_dev_change_media_cb(BlockBackend *blk, bool load){    if (blk->dev_ops && blk->dev_ops->change_media_cb) {        bool tray_was_closed = !blk_dev_is_tray_open(blk);        blk->dev_ops->change_media_cb(blk->dev_opaque, load);        if (tray_was_closed) {            /* tray open */            qapi_event_send_device_tray_moved(blk_name(blk),                                              true, &error_abort);        }        if (load) {            /* tray close */            qapi_event_send_device_tray_moved(blk_name(blk),                                              false, &error_abort);        }    }}", "idx": 10482}
{"project": "qemu", "commit_id": "342368aff7d61a32b5853068b92039a2b15507c5", "target": 0, "function": "gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb,                               bool search_pc){    CPUState *cs = CPU(cpu);    CPUMIPSState *env = &cpu->env;    DisasContext ctx;    target_ulong pc_start;    uint16_t *gen_opc_end;    CPUBreakpoint *bp;    int j, lj = -1;    int num_insns;    int max_insns;    int insn_bytes;    int is_slot;    if (search_pc)        qemu_log(\"search pc %d\\n\", search_pc);    pc_start = tb->pc;    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;    ctx.pc = pc_start;    ctx.saved_pc = -1;    ctx.singlestep_enabled = cs->singlestep_enabled;    ctx.insn_flags = env->insn_flags;    ctx.CP0_Config1 = env->CP0_Config1;    ctx.tb = tb;    ctx.bstate = BS_NONE;    ctx.kscrexist = (env->CP0_Config4 >> CP0C4_KScrExist) & 0xff;    ctx.rxi = (env->CP0_Config3 >> CP0C3_RXI) & 1;    ctx.ie = (env->CP0_Config4 >> CP0C4_IE) & 3;    ctx.bi = (env->CP0_Config3 >> CP0C3_BI) & 1;    ctx.bp = (env->CP0_Config3 >> CP0C3_BP) & 1;    /* Restore delay slot state from the tb context.  */    ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */    ctx.ulri = env->CP0_Config3 & (1 << CP0C3_ULRI);    restore_cpu_state(env, &ctx);#ifdef CONFIG_USER_ONLY        ctx.mem_idx = MIPS_HFLAG_UM;#else        ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU;#endif    num_insns = 0;    max_insns = tb->cflags & CF_COUNT_MASK;    if (max_insns == 0)        max_insns = CF_COUNT_MASK;    LOG_DISAS(\"\\ntb %p idx %d hflags %04x\\n\", tb, ctx.mem_idx, ctx.hflags);    gen_tb_start();    while (ctx.bstate == BS_NONE) {        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {                if (bp->pc == ctx.pc) {                    save_cpu_state(&ctx, 1);                    ctx.bstate = BS_BRANCH;                    gen_helper_0e0i(raise_exception, EXCP_DEBUG);                    /* Include the breakpoint location or the tb won't                     * be flushed when it must be.  */                    ctx.pc += 4;                    goto done_generating;                }            }        }        if (search_pc) {            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;            if (lj < j) {                lj++;                while (lj < j)                    tcg_ctx.gen_opc_instr_start[lj++] = 0;            }            tcg_ctx.gen_opc_pc[lj] = ctx.pc;            gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK;            gen_opc_btarget[lj] = ctx.btarget;            tcg_ctx.gen_opc_instr_start[lj] = 1;            tcg_ctx.gen_opc_icount[lj] = num_insns;        }        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))            gen_io_start();        is_slot = ctx.hflags & MIPS_HFLAG_BMASK;        if (!(ctx.hflags & MIPS_HFLAG_M16)) {            ctx.opcode = cpu_ldl_code(env, ctx.pc);            insn_bytes = 4;            decode_opc(env, &ctx);        } else if (ctx.insn_flags & ASE_MICROMIPS) {            ctx.opcode = cpu_lduw_code(env, ctx.pc);            insn_bytes = decode_micromips_opc(env, &ctx);        } else if (ctx.insn_flags & ASE_MIPS16) {            ctx.opcode = cpu_lduw_code(env, ctx.pc);            insn_bytes = decode_mips16_opc(env, &ctx);        } else {            generate_exception(&ctx, EXCP_RI);            ctx.bstate = BS_STOP;            break;        }        if (ctx.hflags & MIPS_HFLAG_BMASK) {            if (!(ctx.hflags & (MIPS_HFLAG_BDS16 | MIPS_HFLAG_BDS32 |                                MIPS_HFLAG_FBNSLOT))) {                /* force to generate branch as there is neither delay nor                   forbidden slot */                is_slot = 1;            }        }        if (is_slot) {            gen_branch(&ctx, insn_bytes);        }        ctx.pc += insn_bytes;        num_insns++;        /* Execute a branch and its delay slot as a single instruction.           This is what GDB expects and is consistent with what the           hardware does (e.g. if a delay slot instruction faults, the           reported PC is the PC of the branch).  */        if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) {            break;        }        if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0)            break;        if (tcg_ctx.gen_opc_ptr >= gen_opc_end) {            break;        }        if (num_insns >= max_insns)            break;        if (singlestep)            break;    }    if (tb->cflags & CF_LAST_IO) {        gen_io_end();    }    if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) {        save_cpu_state(&ctx, ctx.bstate == BS_NONE);        gen_helper_0e0i(raise_exception, EXCP_DEBUG);    } else {        switch (ctx.bstate) {        case BS_STOP:            gen_goto_tb(&ctx, 0, ctx.pc);            break;        case BS_NONE:            save_cpu_state(&ctx, 0);            gen_goto_tb(&ctx, 0, ctx.pc);            break;        case BS_EXCP:            tcg_gen_exit_tb(0);            break;        case BS_BRANCH:        default:            break;        }    }done_generating:    gen_tb_end(tb, num_insns);    *tcg_ctx.gen_opc_ptr = INDEX_op_end;    if (search_pc) {        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;        lj++;        while (lj <= j)            tcg_ctx.gen_opc_instr_start[lj++] = 0;    } else {        tb->size = ctx.pc - pc_start;        tb->icount = num_insns;    }#ifdef DEBUG_DISAS    LOG_DISAS(\"\\n\");    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));        log_target_disas(env, pc_start, ctx.pc - pc_start, 0);        qemu_log(\"\\n\");    }#endif}", "idx": 10488}
{"project": "qemu", "commit_id": "38f3adc34de83bf75d2023831dc520d32568a2d9", "target": 1, "function": "FWCfgState *fw_cfg_init_io_dma(uint32_t iobase, uint32_t dma_iobase,                                AddressSpace *dma_as){    DeviceState *dev;    SysBusDevice *sbd;    FWCfgIoState *ios;    FWCfgState *s;    bool dma_requested = dma_iobase && dma_as;    dev = qdev_create(NULL, TYPE_FW_CFG_IO);    if (!dma_requested) {        qdev_prop_set_bit(dev, \"dma_enabled\", false);    }    fw_cfg_init1(dev);    sbd = SYS_BUS_DEVICE(dev);    ios = FW_CFG_IO(dev);    sysbus_add_io(sbd, iobase, &ios->comb_iomem);    s = FW_CFG(dev);    if (s->dma_enabled) {        /* 64 bits for the address field */        s->dma_as = dma_as;        s->dma_addr = 0;        sysbus_add_io(sbd, dma_iobase, &s->dma_iomem);    }    return s;}", "idx": 10518}
{"project": "FFmpeg", "commit_id": "0d632b35a04f4a54e7cd228c85cbad82549182ec", "target": 0, "function": "static av_always_inline void decode_bgr_1(HYuvContext *s, int count,                                          int decorrelate, int alpha){    int i;    OPEN_READER(re, &s->gb);    for (i = 0; i < count; i++) {        unsigned int index;        int code, n;        UPDATE_CACHE(re, &s->gb);        index = SHOW_UBITS(re, &s->gb, VLC_BITS);        code  = s->vlc[4].table[index][0];        n     = s->vlc[4].table[index][1];        if (code != -1) {            *(uint32_t*)&s->temp[0][4 * i] = s->pix_bgr_map[code];            LAST_SKIP_BITS(re, &s->gb, n);        } else {            int nb_bits;            if(decorrelate) {                VLC_INTERN(s->temp[0][4 * i + G], s->vlc[1].table,                           &s->gb, re, VLC_BITS, 3);                UPDATE_CACHE(re, &s->gb);                index = SHOW_UBITS(re, &s->gb, VLC_BITS);                VLC_INTERN(code, s->vlc[0].table, &s->gb, re, VLC_BITS, 3);                s->temp[0][4 * i + B] = code + s->temp[0][4 * i + G];                UPDATE_CACHE(re, &s->gb);                index = SHOW_UBITS(re, &s->gb, VLC_BITS);                VLC_INTERN(code, s->vlc[2].table, &s->gb, re, VLC_BITS, 3);                s->temp[0][4 * i + R] = code + s->temp[0][4 * i + G];            } else {                VLC_INTERN(s->temp[0][4 * i + B], s->vlc[0].table,                           &s->gb, re, VLC_BITS, 3);                UPDATE_CACHE(re, &s->gb);                index = SHOW_UBITS(re, &s->gb, VLC_BITS);                VLC_INTERN(s->temp[0][4 * i + G], s->vlc[1].table,                           &s->gb, re, VLC_BITS, 3);                UPDATE_CACHE(re, &s->gb);                index = SHOW_UBITS(re, &s->gb, VLC_BITS);                VLC_INTERN(s->temp[0][4 * i + R], s->vlc[2].table,                           &s->gb, re, VLC_BITS, 3);            }            if (alpha) {                UPDATE_CACHE(re, &s->gb);                index = SHOW_UBITS(re, &s->gb, VLC_BITS);                VLC_INTERN(s->temp[0][4 * i + A], s->vlc[2].table,                           &s->gb, re, VLC_BITS, 3);            }        }    }    CLOSE_READER(re, &s->gb);}", "idx": 10549}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "function": "static void gen_dmfc0 (DisasContext *ctx, int reg, int sel){    const char *rn = \"invalid\";    switch (reg) {    case 0:        switch (sel) {        case 0:           gen_op_mfc0_index();            rn = \"Index\";            break;        case 1://         gen_op_dmfc0_mvpcontrol(); /* MT ASE */            rn = \"MVPControl\";//         break;        case 2://         gen_op_dmfc0_mvpconf0(); /* MT ASE */            rn = \"MVPConf0\";//         break;        case 3://         gen_op_dmfc0_mvpconf1(); /* MT ASE */            rn = \"MVPConf1\";//         break;        default:            goto die;        }        break;    case 1:        switch (sel) {        case 0:            gen_op_mfc0_random();            rn = \"Random\";           break;        case 1://         gen_op_dmfc0_vpecontrol(); /* MT ASE */            rn = \"VPEControl\";//         break;        case 2://         gen_op_dmfc0_vpeconf0(); /* MT ASE */            rn = \"VPEConf0\";//         break;        case 3://         gen_op_dmfc0_vpeconf1(); /* MT ASE */            rn = \"VPEConf1\";//         break;        case 4://         gen_op_dmfc0_YQMask(); /* MT ASE */            rn = \"YQMask\";//         break;        case 5://         gen_op_dmfc0_vpeschedule(); /* MT ASE */            rn = \"VPESchedule\";//         break;        case 6://         gen_op_dmfc0_vpeschefback(); /* MT ASE */            rn = \"VPEScheFBack\";//         break;        case 7://         gen_op_dmfc0_vpeopt(); /* MT ASE */            rn = \"VPEOpt\";//         break;        default:            goto die;        }        break;    case 2:        switch (sel) {        case 0:           gen_op_dmfc0_entrylo0();           rn = \"EntryLo0\";           break;        case 1://         gen_op_dmfc0_tcstatus(); /* MT ASE */           rn = \"TCStatus\";//         break;        case 2://         gen_op_dmfc0_tcbind(); /* MT ASE */           rn = \"TCBind\";//         break;        case 3://         gen_op_dmfc0_tcrestart(); /* MT ASE */           rn = \"TCRestart\";//         break;        case 4://         gen_op_dmfc0_tchalt(); /* MT ASE */           rn = \"TCHalt\";//         break;        case 5://         gen_op_dmfc0_tccontext(); /* MT ASE */           rn = \"TCContext\";//         break;        case 6://         gen_op_dmfc0_tcschedule(); /* MT ASE */           rn = \"TCSchedule\";//         break;        case 7://         gen_op_dmfc0_tcschefback(); /* MT ASE */           rn = \"TCScheFBack\";//         break;        default:            goto die;        }        break;    case 3:        switch (sel) {        case 0:           gen_op_dmfc0_entrylo1();           rn = \"EntryLo1\";           break;        default:            goto die;       }        break;    case 4:        switch (sel) {        case 0:           gen_op_dmfc0_context();           rn = \"Context\";           break;        case 1://         gen_op_dmfc0_contextconfig(); /* SmartMIPS ASE */           rn = \"ContextConfig\";//         break;        default:            goto die;       }        break;    case 5:        switch (sel) {        case 0:           gen_op_mfc0_pagemask();           rn = \"PageMask\";           break;        case 1:           gen_op_mfc0_pagegrain();           rn = \"PageGrain\";           break;        default:            goto die;       }        break;    case 6:        switch (sel) {        case 0:           gen_op_mfc0_wired();           rn = \"Wired\";           break;        case 1://         gen_op_dmfc0_srsconf0(); /* shadow registers */           rn = \"SRSConf0\";//         break;        case 2://         gen_op_dmfc0_srsconf1(); /* shadow registers */           rn = \"SRSConf1\";//         break;        case 3://         gen_op_dmfc0_srsconf2(); /* shadow registers */           rn = \"SRSConf2\";//         break;        case 4://         gen_op_dmfc0_srsconf3(); /* shadow registers */           rn = \"SRSConf3\";//         break;        case 5://         gen_op_dmfc0_srsconf4(); /* shadow registers */           rn = \"SRSConf4\";//         break;        default:            goto die;       }        break;    case 7:        switch (sel) {        case 0:           gen_op_mfc0_hwrena();           rn = \"HWREna\";           break;        default:            goto die;       }        break;    case 8:        switch (sel) {        case 0:           gen_op_dmfc0_badvaddr();           rn = \"BadVaddr\";           break;        default:            goto die;       }        break;    case 9:        switch (sel) {        case 0:           gen_op_mfc0_count();           rn = \"Count\";           break;       /* 6,7 are implementation dependent */        default:            goto die;       }        break;    case 10:        switch (sel) {        case 0:           gen_op_dmfc0_entryhi();           rn = \"EntryHi\";           break;        default:            goto die;       }        break;    case 11:        switch (sel) {        case 0:           gen_op_mfc0_compare();           rn = \"Compare\";           break;       /* 6,7 are implementation dependent */        default:            goto die;       }        break;    case 12:        switch (sel) {        case 0:           gen_op_mfc0_status();           rn = \"Status\";           break;        case 1:           gen_op_mfc0_intctl();           rn = \"IntCtl\";           break;        case 2:           gen_op_mfc0_srsctl();           rn = \"SRSCtl\";           break;        case 3:           gen_op_mfc0_srsmap(); /* shadow registers */           rn = \"SRSMap\";           break;        default:            goto die;       }        break;    case 13:        switch (sel) {        case 0:           gen_op_mfc0_cause();           rn = \"Cause\";           break;        default:            goto die;       }        break;    case 14:        switch (sel) {        case 0:           gen_op_dmfc0_epc();           rn = \"EPC\";           break;        default:            goto die;       }        break;    case 15:        switch (sel) {        case 0:           gen_op_mfc0_prid();           rn = \"PRid\";           break;        case 1:           gen_op_dmfc0_ebase();           rn = \"EBase\";           break;        default:            goto die;       }        break;    case 16:        switch (sel) {        case 0:           gen_op_mfc0_config0();            rn = \"Config\";            break;        case 1:           gen_op_mfc0_config1();            rn = \"Config1\";            break;        case 2:           gen_op_mfc0_config2();            rn = \"Config2\";            break;        case 3:           gen_op_mfc0_config3();            rn = \"Config3\";            break;       /* 6,7 are implementation dependent */        default:            goto die;        }        break;    case 17:        switch (sel) {        case 0:           gen_op_dmfc0_lladdr();           rn = \"LLAddr\";           break;        default:            goto die;        }        break;    case 18:        switch (sel) {        case 0:           gen_op_dmfc0_watchlo0();           rn = \"WatchLo\";           break;        case 1://         gen_op_dmfc0_watchlo1();           rn = \"WatchLo1\";//         break;        case 2://         gen_op_dmfc0_watchlo2();           rn = \"WatchLo2\";//         break;        case 3://         gen_op_dmfc0_watchlo3();           rn = \"WatchLo3\";//         break;        case 4://         gen_op_dmfc0_watchlo4();           rn = \"WatchLo4\";//         break;        case 5://         gen_op_dmfc0_watchlo5();           rn = \"WatchLo5\";//         break;        case 6://         gen_op_dmfc0_watchlo6();           rn = \"WatchLo6\";//         break;        case 7://         gen_op_dmfc0_watchlo7();           rn = \"WatchLo7\";//         break;        default:            goto die;        }        break;    case 19:        switch (sel) {        case 0:           gen_op_mfc0_watchhi0();           rn = \"WatchHi\";           break;        case 1://         gen_op_mfc0_watchhi1();           rn = \"WatchHi1\";//         break;        case 2://         gen_op_mfc0_watchhi2();           rn = \"WatchHi2\";//         break;        case 3://         gen_op_mfc0_watchhi3();           rn = \"WatchHi3\";//         break;        case 4://         gen_op_mfc0_watchhi4();           rn = \"WatchHi4\";//         break;        case 5://         gen_op_mfc0_watchhi5();           rn = \"WatchHi5\";//         break;        case 6://         gen_op_mfc0_watchhi6();           rn = \"WatchHi6\";//         break;        case 7://         gen_op_mfc0_watchhi7();           rn = \"WatchHi7\";//         break;        default:            goto die;        }        break;    case 20:        switch (sel) {        case 0:           /* 64 bit MMU only */           gen_op_dmfc0_xcontext();           rn = \"XContext\";           break;        default:            goto die;        }        break;    case 21:       /* Officially reserved, but sel 0 is used for R1x000 framemask */        switch (sel) {        case 0:           gen_op_mfc0_framemask();           rn = \"Framemask\";           break;        default:            goto die;        }        break;    case 22:       /* ignored */       rn = \"'Diagnostic\"; /* implementation dependent */       break;    case 23:        switch (sel) {        case 0:           gen_op_mfc0_debug(); /* EJTAG support */           rn = \"Debug\";           break;        case 1://         gen_op_dmfc0_tracecontrol(); /* PDtrace support */           rn = \"TraceControl\";//         break;        case 2://         gen_op_dmfc0_tracecontrol2(); /* PDtrace support */           rn = \"TraceControl2\";//         break;        case 3://         gen_op_dmfc0_usertracedata(); /* PDtrace support */           rn = \"UserTraceData\";//         break;        case 4://         gen_op_dmfc0_debug(); /* PDtrace support */           rn = \"TraceBPC\";//         break;        default:            goto die;        }        break;    case 24:        switch (sel) {        case 0:           gen_op_dmfc0_depc(); /* EJTAG support */           rn = \"DEPC\";           break;        default:            goto die;        }        break;    case 25:        switch (sel) {        case 0:           gen_op_mfc0_performance0();           rn = \"Performance0\";            break;        case 1://         gen_op_dmfc0_performance1();           rn = \"Performance1\";//         break;        case 2://         gen_op_dmfc0_performance2();           rn = \"Performance2\";//         break;        case 3://         gen_op_dmfc0_performance3();           rn = \"Performance3\";//         break;        case 4://         gen_op_dmfc0_performance4();           rn = \"Performance4\";//         break;        case 5://         gen_op_dmfc0_performance5();           rn = \"Performance5\";//         break;        case 6://         gen_op_dmfc0_performance6();           rn = \"Performance6\";//         break;        case 7://         gen_op_dmfc0_performance7();           rn = \"Performance7\";//         break;        default:            goto die;        }        break;    case 26:       rn = \"ECC\";       break;    case 27:        switch (sel) {        /* ignored */        case 0 ... 3:           rn = \"CacheErr\";           break;        default:            goto die;        }        break;    case 28:        switch (sel) {        case 0:        case 2:        case 4:        case 6:            gen_op_mfc0_taglo();            rn = \"TagLo\";            break;        case 1:        case 3:        case 5:        case 7:            gen_op_mfc0_datalo();            rn = \"DataLo\";            break;        default:            goto die;        }        break;    case 29:        switch (sel) {        case 0:        case 2:        case 4:        case 6:            gen_op_mfc0_taghi();            rn = \"TagHi\";            break;        case 1:        case 3:        case 5:        case 7:            gen_op_mfc0_datahi();            rn = \"DataHi\";            break;        default:            goto die;        }        break;    case 30:        switch (sel) {        case 0:           gen_op_dmfc0_errorepc();           rn = \"ErrorEPC\";           break;        default:            goto die;        }        break;    case 31:        switch (sel) {        case 0:           gen_op_mfc0_desave(); /* EJTAG support */           rn = \"DESAVE\";           break;        default:            goto die;        }        break;    default:       goto die;    }#if defined MIPS_DEBUG_DISAS    if (loglevel & CPU_LOG_TB_IN_ASM) {        fprintf(logfile, \"dmfc0 %s (reg %d sel %d)\\n\",                rn, reg, sel);    }#endif    return;die:#if defined MIPS_DEBUG_DISAS    if (loglevel & CPU_LOG_TB_IN_ASM) {        fprintf(logfile, \"dmfc0 %s (reg %d sel %d)\\n\",                rn, reg, sel);    }#endif    generate_exception(ctx, EXCP_RI);}", "idx": 10568}
{"project": "FFmpeg", "commit_id": "77693c541a541661357a0edd5bbaae69c64b2039", "target": 0, "function": "static int xan_decode_frame_type1(AVCodecContext *avctx){    XanContext *s = avctx->priv_data;    uint8_t *ybuf, *src = s->scratch_buffer;    int cur, last;    int i, j;    int ret;    if ((ret = xan_decode_chroma(avctx, bytestream2_get_le32(&s->gb))) != 0)        return ret;    bytestream2_seek(&s->gb, 16, SEEK_SET);    ret = xan_unpack_luma(s, src,                          s->buffer_size >> 1);    if (ret) {        av_log(avctx, AV_LOG_ERROR, \"Luma decoding failed\\n\");        return ret;    }    ybuf = s->y_buffer;    for (i = 0; i < avctx->height; i++) {        last = (ybuf[0] + (*src++ << 1)) & 0x3F;        ybuf[0] = last;        for (j = 1; j < avctx->width - 1; j += 2) {            cur = (ybuf[j + 1] + (*src++ << 1)) & 0x3F;            ybuf[j]   = (last + cur) >> 1;            ybuf[j+1] = cur;            last = cur;        }        ybuf[j] = last;        ybuf += avctx->width;    }    src = s->y_buffer;    ybuf = s->pic.data[0];    for (j = 0; j < avctx->height; j++) {        for (i = 0; i < avctx->width; i++)            ybuf[i] = (src[i] << 2) | (src[i] >> 3);        src  += avctx->width;        ybuf += s->pic.linesize[0];    }    return 0;}", "idx": 10577}
{"project": "qemu", "commit_id": "2ad645d2854746b55ddfd1d8e951f689cca5d78f", "target": 1, "function": "static int setup_common(char *argv[], int argv_sz){    memset(cur_ide, 0, sizeof(cur_ide));    return append_arg(0, argv, argv_sz,                      g_strdup(\"-nodefaults -display none\"));}", "idx": 10726}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "function": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,                                        QGuestAllocator *alloc, uint16_t entry){    uint16_t vector;    uint32_t control;    void *addr;    g_assert(d->pdev->msix_enabled);    addr = d->pdev->msix_table + (entry * 16);    g_assert_cmpint(entry, >=, 0);    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));    d->config_msix_entry = entry;    d->config_msix_data = 0x12345678;    d->config_msix_addr = guest_alloc(alloc, 4);    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,                                                    d->config_msix_addr & ~0UL);    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,                                            (d->config_msix_addr >> 32) & ~0UL);    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);}", "idx": 10727}
{"project": "FFmpeg", "commit_id": "4ea7c179325f61736040f2ff22c2f27c702727d4", "target": 1, "function": "static int filter_frame(AVFilterLink *link, AVFilterBufferRef *picref){    AVFilterContext *ctx = link->dst;    YADIFContext *yadif = ctx->priv;    av_assert0(picref);    if (picref->video->h < 3 || picref->video->w < 3) {        av_log(ctx, AV_LOG_ERROR, \"Video of less than 3 columns or lines is not supported\\n\");        return AVERROR(EINVAL);    }    if (yadif->frame_pending)        return_frame(ctx, 1);    if (yadif->prev)        avfilter_unref_buffer(yadif->prev);    yadif->prev = yadif->cur;    yadif->cur  = yadif->next;    yadif->next = picref;    if (!yadif->cur)        return 0;    if (yadif->auto_enable && !yadif->cur->video->interlaced) {        yadif->out  = avfilter_ref_buffer(yadif->cur, ~AV_PERM_WRITE);        if (!yadif->out)            return AVERROR(ENOMEM);        avfilter_unref_bufferp(&yadif->prev);        if (yadif->out->pts != AV_NOPTS_VALUE)            yadif->out->pts *= 2;        return ff_filter_frame(ctx->outputs[0], yadif->out);    }    if (!yadif->prev &&        !(yadif->prev = avfilter_ref_buffer(yadif->cur, ~AV_PERM_WRITE)))        return AVERROR(ENOMEM);    yadif->out = ff_get_video_buffer(ctx->outputs[0], PERM_RWP,                                     link->w, link->h);    if (!yadif->out)        return AVERROR(ENOMEM);    avfilter_copy_buffer_ref_props(yadif->out, yadif->cur);    yadif->out->video->interlaced = 0;    if (yadif->out->pts != AV_NOPTS_VALUE)        yadif->out->pts *= 2;    return return_frame(ctx, 0);}", "idx": 10736}
{"project": "FFmpeg", "commit_id": "2c21d34ea44d38835f85b90de3cbbf54abb894be", "target": 1, "function": "void av_free(void *ptr){#if CONFIG_MEMALIGN_HACK    if (ptr)        free((char *)ptr - ((char *)ptr)[-1]);#elif HAVE_ALIGNED_MALLOC    _aligned_free(ptr);#else    free(ptr);#endif}", "idx": 10740}
{"project": "FFmpeg", "commit_id": "16f753f43fba3b9b16cb9fa62e99f481aaa29ae9", "target": 0, "function": "static int flac_probe(AVProbeData *p){    uint8_t *bufptr = p->buf;    if(ff_id3v2_match(bufptr))        bufptr += ff_id3v2_tag_len(bufptr);    if(memcmp(bufptr, \"fLaC\", 4)) return 0;    else                          return AVPROBE_SCORE_MAX / 2;}", "idx": 10769}
{"project": "FFmpeg", "commit_id": "d565fef1b83b6c5f8afb32229260b79f67c68109", "target": 1, "function": "int av_vdpau_bind_context(AVCodecContext *avctx, VdpDevice device,                          VdpGetProcAddress *get_proc, unsigned flags){    VDPAUHWContext *hwctx;    if (flags != 0)        return AVERROR(EINVAL);    if (av_reallocp(&avctx->hwaccel_context, sizeof(*hwctx)))        return AVERROR(ENOMEM);    hwctx = avctx->hwaccel_context;    memset(hwctx, 0, sizeof(*hwctx));    hwctx->context.decoder  = VDP_INVALID_HANDLE;    hwctx->device           = device;    hwctx->get_proc_address = get_proc;    hwctx->reset            = 1;    return 0;}", "idx": 10771}
{"project": "qemu", "commit_id": "b5bd049fa907bccc4600ad1855e1c9c0e62f0be3", "target": 1, "function": "static int vfio_early_setup_msix(VFIOPCIDevice *vdev){    uint8_t pos;    uint16_t ctrl;    uint32_t table, pba;    int fd = vdev->vbasedev.fd;    pos = pci_find_capability(&vdev->pdev, PCI_CAP_ID_MSIX);    if (!pos) {        return 0;    }    if (pread(fd, &ctrl, sizeof(ctrl),              vdev->config_offset + pos + PCI_CAP_FLAGS) != sizeof(ctrl)) {        return -errno;    }    if (pread(fd, &table, sizeof(table),              vdev->config_offset + pos + PCI_MSIX_TABLE) != sizeof(table)) {        return -errno;    }    if (pread(fd, &pba, sizeof(pba),              vdev->config_offset + pos + PCI_MSIX_PBA) != sizeof(pba)) {        return -errno;    }    ctrl = le16_to_cpu(ctrl);    table = le32_to_cpu(table);    pba = le32_to_cpu(pba);    vdev->msix = g_malloc0(sizeof(*(vdev->msix)));    vdev->msix->table_bar = table & PCI_MSIX_FLAGS_BIRMASK;    vdev->msix->table_offset = table & ~PCI_MSIX_FLAGS_BIRMASK;    vdev->msix->pba_bar = pba & PCI_MSIX_FLAGS_BIRMASK;    vdev->msix->pba_offset = pba & ~PCI_MSIX_FLAGS_BIRMASK;    vdev->msix->entries = (ctrl & PCI_MSIX_FLAGS_QSIZE) + 1;    /*     * Test the size of the pba_offset variable and catch if it extends outside     * of the specified BAR. If it is the case, we need to apply a hardware     * specific quirk if the device is known or we have a broken configuration.     */    if (vdev->msix->pba_offset >=        vdev->bars[vdev->msix->pba_bar].region.size) {        PCIDevice *pdev = &vdev->pdev;        uint16_t vendor = pci_get_word(pdev->config + PCI_VENDOR_ID);        uint16_t device = pci_get_word(pdev->config + PCI_DEVICE_ID);        /*         * Chelsio T5 Virtual Function devices are encoded as 0x58xx for T5         * adapters. The T5 hardware returns an incorrect value of 0x8000 for         * the VF PBA offset while the BAR itself is only 8k. The correct value         * is 0x1000, so we hard code that here.         */        if (vendor == PCI_VENDOR_ID_CHELSIO && (device & 0xff00) == 0x5800) {            vdev->msix->pba_offset = 0x1000;        } else {            error_report(\"vfio: Hardware reports invalid configuration, \"                         \"MSIX PBA outside of specified BAR\");            return -EINVAL;        }    }    trace_vfio_early_setup_msix(vdev->vbasedev.name, pos,                                vdev->msix->table_bar,                                vdev->msix->table_offset,                                vdev->msix->entries);    return 0;}", "idx": 10854}
{"project": "FFmpeg", "commit_id": "eba1ff31304e407db3cefd7532108408f364367b", "target": 1, "function": "static int decode_bytes(const uint8_t *input, uint8_t *out, int bytes){    int i, off;    uint32_t c;    const uint32_t *buf;    uint32_t *output = (uint32_t *)out;    off = (intptr_t)input & 3;    buf = (const uint32_t *)(input - off);    c   = av_be2ne32((0x537F6103 >> (off * 8)) | (0x537F6103 << (32 - (off * 8))));    bytes += 3 + off;    for (i = 0; i < bytes / 4; i++)        output[i] = c ^ buf[i];    if (off)        avpriv_request_sample(NULL, \"Offset of %d\", off);    return off;}", "idx": 10862}
{"project": "qemu", "commit_id": "ee640c625e190a0c0e6b8966adc0e4720fb75200", "target": 1, "function": "static void ivshmem_common_realize(PCIDevice *dev, Error **errp){    IVShmemState *s = IVSHMEM_COMMON(dev);    Error *err = NULL;    uint8_t *pci_conf;    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |        PCI_BASE_ADDRESS_MEM_PREFETCH;    Error *local_err = NULL;    /* IRQFD requires MSI */    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&        !ivshmem_has_feature(s, IVSHMEM_MSI)) {        error_setg(errp, \"ioeventfd/irqfd requires MSI\");        return;    }    pci_conf = dev->config;    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);    /* region for registers*/    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,                     &s->ivshmem_mmio);    if (s->not_legacy_32bit) {        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;    }    if (s->hostmem != NULL) {        IVSHMEM_DPRINTF(\"using hostmem\\n\");        s->ivshmem_bar2 = host_memory_backend_get_memory(s->hostmem,                                                         &error_abort);    } else {        Chardev *chr = qemu_chr_fe_get_driver(&s->server_chr);        assert(chr);        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",                        chr->filename);        /* we allocate enough space for 16 peers and grow as needed */        resize_peers(s, 16);        /*         * Receive setup messages from server synchronously.         * Older versions did it asynchronously, but that creates a         * number of entertaining race conditions.         */        ivshmem_recv_setup(s, &err);        if (err) {            error_propagate(errp, err);            return;        }        if (s->master == ON_OFF_AUTO_ON && s->vm_id != 0) {            error_setg(errp,                       \"master must connect to the server before any peers\");            return;        }        qemu_chr_fe_set_handlers(&s->server_chr, ivshmem_can_receive,                                 ivshmem_read, NULL, s, NULL, true);        if (ivshmem_setup_interrupts(s) < 0) {            error_setg(errp, \"failed to initialize interrupts\");            return;        }    }    if (s->master == ON_OFF_AUTO_AUTO) {        s->master = s->vm_id == 0 ? ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;    }    if (!ivshmem_is_master(s)) {        error_setg(&s->migration_blocker,                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");        migrate_add_blocker(s->migration_blocker, &local_err);        if (local_err) {            error_propagate(errp, local_err);            error_free(s->migration_blocker);            return;        }    }    vmstate_register_ram(s->ivshmem_bar2, DEVICE(s));    pci_register_bar(PCI_DEVICE(s), 2, attr, s->ivshmem_bar2);}", "idx": 10901}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "function": "static AioContext *thread_pool_get_aio_context(BlockAIOCB *acb){    ThreadPoolElement *elem = (ThreadPoolElement *)acb;    ThreadPool *pool = elem->pool;    return pool->ctx;}", "idx": 10953}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "function": "static void vga_precise_update_retrace_info(VGAState *s){    int htotal_chars;    int hretr_start_char;    int hretr_skew_chars;    int hretr_end_char;    int vtotal_lines;    int vretr_start_line;    int vretr_end_line;    int div2, sldiv2, dots;    int clocking_mode;    int clock_sel;    const int hz[] = {25175000, 28322000, 25175000, 25175000};    int64_t chars_per_sec;    struct vga_precise_retrace *r = &s->retrace_info.precise;    htotal_chars = s->cr[0x00] + 5;    hretr_start_char = s->cr[0x04];    hretr_skew_chars = (s->cr[0x05] >> 5) & 3;    hretr_end_char = s->cr[0x05] & 0x1f;    vtotal_lines = (s->cr[0x06]                    | (((s->cr[0x07] & 1) | ((s->cr[0x07] >> 4) & 2)) << 8)) + 2        ;    vretr_start_line = s->cr[0x10]        | ((((s->cr[0x07] >> 2) & 1) | ((s->cr[0x07] >> 6) & 2)) << 8)        ;    vretr_end_line = s->cr[0x11] & 0xf;    div2 = (s->cr[0x17] >> 2) & 1;    sldiv2 = (s->cr[0x17] >> 3) & 1;    clocking_mode = (s->sr[0x01] >> 3) & 1;    clock_sel = (s->msr >> 2) & 3;    dots = (s->msr & 1) ? 8 : 9;    chars_per_sec = hz[clock_sel] / dots;    htotal_chars <<= clocking_mode;    r->total_chars = vtotal_lines * htotal_chars;    if (r->freq) {        r->ticks_per_char = ticks_per_sec / (r->total_chars * r->freq);    } else {        r->ticks_per_char = ticks_per_sec / chars_per_sec;    }    r->vstart = vretr_start_line;    r->vend = r->vstart + vretr_end_line + 1;    r->hstart = hretr_start_char + hretr_skew_chars;    r->hend = r->hstart + hretr_end_char + 1;    r->htotal = htotal_chars;#if 0    printf (        \"hz=%f\\n\"        \"htotal = %d\\n\"        \"hretr_start = %d\\n\"        \"hretr_skew = %d\\n\"        \"hretr_end = %d\\n\"        \"vtotal = %d\\n\"        \"vretr_start = %d\\n\"        \"vretr_end = %d\\n\"        \"div2 = %d sldiv2 = %d\\n\"        \"clocking_mode = %d\\n\"        \"clock_sel = %d %d\\n\"        \"dots = %d\\n\"        \"ticks/char = %lld\\n\"        \"\\n\",        (double) ticks_per_sec / (r->ticks_per_char * r->total_chars),        htotal_chars,        hretr_start_char,        hretr_skew_chars,        hretr_end_char,        vtotal_lines,        vretr_start_line,        vretr_end_line,        div2, sldiv2,        clocking_mode,        clock_sel,        hz[clock_sel],        dots,        r->ticks_per_char        );#endif}", "idx": 10956}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "function": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status){    VirtIODevice *vdev = VIRTIO_DEVICE(n);    NetClientState *nc = qemu_get_queue(n->nic);    int queues = n->multiqueue ? n->max_queues : 1;    if (!get_vhost_net(nc->peer)) {        return;    }    if (!!n->vhost_started ==        (virtio_net_started(n, status) && !nc->peer->link_down)) {        return;    }    if (!n->vhost_started) {        int r;        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {            return;        }        n->vhost_started = 1;        r = vhost_net_start(vdev, n->nic->ncs, queues);        if (r < 0) {            error_report(\"unable to start vhost net: %d: \"                         \"falling back on userspace virtio\", -r);            n->vhost_started = 0;        }    } else {        vhost_net_stop(vdev, n->nic->ncs, queues);        n->vhost_started = 0;    }}", "idx": 10982}
{"project": "qemu", "commit_id": "5255fcf8e47acd059e2f0d414841c40231c1bd22", "target": 0, "function": "static int nvic_pending_prio(NVICState *s){    /* return the priority of the current pending interrupt,     * or NVIC_NOEXC_PRIO if no interrupt is pending     */    return s->vectpending ? s->vectors[s->vectpending].prio : NVIC_NOEXC_PRIO;}", "idx": 11008}
{"project": "FFmpeg", "commit_id": "f0ff9eb49394d4ba06eff30e0dac2f3ce590e311", "target": 0, "function": "static void probe_codec(AVFormatContext *s, AVStream *st, const AVPacket *pkt){    if(st->codec->codec_id == CODEC_ID_PROBE){        AVProbeData *pd = &st->probe_data;        av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);        --st->probe_packets;        pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);        memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);        pd->buf_size += pkt->size;        memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);        if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){            //FIXME we do not reduce score to 0 for the case of running out of buffer space in bytes            set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);            if(st->codec->codec_id != CODEC_ID_PROBE){                pd->buf_size=0;                av_freep(&pd->buf);                av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);            }        }    }}", "idx": 11033}
{"project": "FFmpeg", "commit_id": "80137531139588774e048d6e1dae34ab5cbbbfa2", "target": 0, "function": "static int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom){    MOVStreamContext *sc;    int i, edit_count, version;    if (c->fc->nb_streams < 1 || c->ignore_editlist)        return 0;    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;    version = avio_r8(pb); /* version */    avio_rb24(pb); /* flags */    edit_count = avio_rb32(pb); /* entries */    if (!edit_count)        return 0;    if (sc->elst_data)        av_log(c->fc, AV_LOG_WARNING, \"Duplicated ELST atom\\n\");    av_free(sc->elst_data);    sc->elst_count = 0;    sc->elst_data = av_malloc_array(edit_count, sizeof(*sc->elst_data));    if (!sc->elst_data)        return AVERROR(ENOMEM);    av_log(c->fc, AV_LOG_TRACE, \"track[%u].edit_count = %i\\n\", c->fc->nb_streams - 1, edit_count);    for (i = 0; i < edit_count && !pb->eof_reached; i++) {        MOVElst *e = &sc->elst_data[i];        if (version == 1) {            e->duration = avio_rb64(pb);            e->time     = avio_rb64(pb);        } else {            e->duration = avio_rb32(pb); /* segment duration */            e->time     = (int32_t)avio_rb32(pb); /* media time */        }        e->rate = avio_rb32(pb) / 65536.0;        av_log(c->fc, AV_LOG_TRACE, \"duration=%\"PRId64\" time=%\"PRId64\" rate=%f\\n\",               e->duration, e->time, e->rate);        if (e->time < 0 && e->time != -1 &&            c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {            av_log(c->fc, AV_LOG_ERROR, \"Track %d, edit %d: Invalid edit list media time=%\"PRId64\"\\n\",                   c->fc->nb_streams-1, i, e->time);            return AVERROR_INVALIDDATA;        }    }    sc->elst_count = i;    return 0;}", "idx": 11082}
{"project": "FFmpeg", "commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "target": 1, "function": "static int subtitle_thread(void *arg){    VideoState *is = arg;    Frame *sp;    int got_subtitle;    double pts;    int i, j;    int r, g, b, y, u, v, a;    for (;;) {        while (is->paused && !is->subtitleq.abort_request) {            SDL_Delay(10);        }        if (!(sp = frame_queue_peek_writable(&is->subpq)))            return 0;        if ((got_subtitle = decoder_decode_frame(&is->subdec, &sp->sub)) < 0)            break;        pts = 0;        if (got_subtitle && sp->sub.format == 0) {            if (sp->sub.pts != AV_NOPTS_VALUE)                pts = sp->sub.pts / (double)AV_TIME_BASE;            sp->pts = pts;            sp->serial = is->subdec.pkt_serial;            for (i = 0; i < sp->sub.num_rects; i++)            {                for (j = 0; j < sp->sub.rects[i]->nb_colors; j++)                {                    RGBA_IN(r, g, b, a, (uint32_t*)sp->sub.rects[i]->pict.data[1] + j);                    y = RGB_TO_Y_CCIR(r, g, b);                    u = RGB_TO_U_CCIR(r, g, b, 0);                    v = RGB_TO_V_CCIR(r, g, b, 0);                    YUVA_OUT((uint32_t*)sp->sub.rects[i]->pict.data[1] + j, y, u, v, a);                }            }            /* now we can update the picture count */            frame_queue_push(&is->subpq);        } else if (got_subtitle) {            avsubtitle_free(&sp->sub);        }    }    return 0;}", "idx": 11119}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint64_t omap_lpg_read(void *opaque, target_phys_addr_t addr,                              unsigned size){    struct omap_lpg_s *s = (struct omap_lpg_s *) opaque;    int offset = addr & OMAP_MPUI_REG_MASK;    if (size != 1) {        return omap_badwidth_read8(opaque, addr);    }    switch (offset) {    case 0x00:\t/* LCR */        return s->control;    case 0x04:\t/* PMR */        return s->power;    }    OMAP_BAD_REG(addr);    return 0;}", "idx": 11132}
{"project": "qemu", "commit_id": "430eb509d2d05bd568c1394213fd12cb447467a7", "target": 0, "function": "void bdrv_info(void){    BlockDriverState *bs;    for (bs = bdrv_first; bs != NULL; bs = bs->next) {        term_printf(\"%s:\", bs->device_name);        term_printf(\" type=\");        switch(bs->type) {        case BDRV_TYPE_HD:            term_printf(\"hd\");            break;        case BDRV_TYPE_CDROM:            term_printf(\"cdrom\");            break;        case BDRV_TYPE_FLOPPY:            term_printf(\"floppy\");            break;        }        term_printf(\" removable=%d\", bs->removable);        if (bs->removable) {            term_printf(\" locked=%d\", bs->locked);        }        if (bs->drv) {            term_printf(\" file=\");\t    term_print_filename(bs->filename);            if (bs->backing_file[0] != '\\0') {                term_printf(\" backing_file=\");\t\tterm_print_filename(bs->backing_file);\t    }            term_printf(\" ro=%d\", bs->read_only);            term_printf(\" drv=%s\", bs->drv->format_name);            if (bs->encrypted)                term_printf(\" encrypted\");        } else {            term_printf(\" [not inserted]\");        }        term_printf(\"\\n\");    }}", "idx": 11149}
{"project": "FFmpeg", "commit_id": "c2d3f561072132044114588a5f56b8e1974a2af7", "target": 1, "function": "void ff_imdct_half_3dn2(FFTContext *s, FFTSample *output, const FFTSample *input){    x86_reg j, k;    long n = s->mdct_size;    long n2 = n >> 1;    long n4 = n >> 2;    long n8 = n >> 3;    const uint16_t *revtab = s->revtab;    const FFTSample *tcos = s->tcos;    const FFTSample *tsin = s->tsin;    const FFTSample *in1, *in2;    FFTComplex *z = (FFTComplex *)output;    /* pre rotation */    in1 = input;    in2 = input + n2 - 1;#ifdef EMULATE_3DNOWEXT    __asm__ volatile(\"movd %0, %%mm7\" ::\"r\"(1<<31));#endif    for(k = 0; k < n4; k++) {        // FIXME a single block is faster, but gcc 2.95 and 3.4.x on 32bit can't compile it        __asm__ volatile(            \"movd         %0, %%mm0 \\n\"            \"movd         %2, %%mm1 \\n\"            \"punpckldq    %1, %%mm0 \\n\"            \"punpckldq    %3, %%mm1 \\n\"            \"movq      %%mm0, %%mm2 \\n\"            PSWAPD(    %%mm1, %%mm3 )            \"pfmul     %%mm1, %%mm0 \\n\"            \"pfmul     %%mm3, %%mm2 \\n\"#ifdef EMULATE_3DNOWEXT            \"movq      %%mm0, %%mm1 \\n\"            \"punpckhdq %%mm2, %%mm0 \\n\"            \"punpckldq %%mm2, %%mm1 \\n\"            \"pxor      %%mm7, %%mm0 \\n\"            \"pfadd     %%mm1, %%mm0 \\n\"#else            \"pfpnacc   %%mm2, %%mm0 \\n\"#endif            ::\"m\"(in2[-2*k]), \"m\"(in1[2*k]),              \"m\"(tcos[k]), \"m\"(tsin[k])        );        __asm__ volatile(            \"movq    %%mm0, %0    \\n\\t\"            :\"=m\"(z[revtab[k]])        );    }    ff_fft_dispatch_3dn2(z, s->nbits);#define CMUL(j,mm0,mm1)\\        \"movq  (%2,\"#j\",2), %%mm6 \\n\"\\        \"movq 8(%2,\"#j\",2), \"#mm0\"\\n\"\\        \"movq        %%mm6, \"#mm1\"\\n\"\\        \"movq        \"#mm0\",%%mm7 \\n\"\\        \"pfmul   (%3,\"#j\"), %%mm6 \\n\"\\        \"pfmul   (%4,\"#j\"), \"#mm0\"\\n\"\\        \"pfmul   (%4,\"#j\"), \"#mm1\"\\n\"\\        \"pfmul   (%3,\"#j\"), %%mm7 \\n\"\\        \"pfsub       %%mm6, \"#mm0\"\\n\"\\        \"pfadd       %%mm7, \"#mm1\"\\n\"    /* post rotation */    j = -n2;    k = n2-8;    __asm__ volatile(        \"1: \\n\"        CMUL(%0, %%mm0, %%mm1)        CMUL(%1, %%mm2, %%mm3)        \"movd   %%mm0,  (%2,%0,2) \\n\"        \"movd   %%mm1,12(%2,%1,2) \\n\"        \"movd   %%mm2,  (%2,%1,2) \\n\"        \"movd   %%mm3,12(%2,%0,2) \\n\"        \"psrlq  $32,   %%mm0 \\n\"        \"psrlq  $32,   %%mm1 \\n\"        \"psrlq  $32,   %%mm2 \\n\"        \"psrlq  $32,   %%mm3 \\n\"        \"movd   %%mm0, 8(%2,%0,2) \\n\"        \"movd   %%mm1, 4(%2,%1,2) \\n\"        \"movd   %%mm2, 8(%2,%1,2) \\n\"        \"movd   %%mm3, 4(%2,%0,2) \\n\"        \"sub $8, %1 \\n\"        \"add $8, %0 \\n\"        \"jl 1b \\n\"        :\"+r\"(j), \"+r\"(k)        :\"r\"(z+n8), \"r\"(tcos+n8), \"r\"(tsin+n8)        :\"memory\"    );    __asm__ volatile(\"femms\");}", "idx": 11199}
{"project": "qemu", "commit_id": "1c02e2a17104fe7fc11893125864dc0daf1e6d5b", "target": 1, "function": "static int l2_load(BlockDriverState *bs, uint64_t l2_offset,    uint64_t **l2_table){    BDRVQcowState *s = bs->opaque;    int min_index;    int ret;    /* seek if the table for the given offset is in the cache */    *l2_table = seek_l2_table(s, l2_offset);    if (*l2_table != NULL) {        return 0;    }    /* not found: load a new entry in the least used one */    min_index = l2_cache_new_entry(bs);    *l2_table = s->l2_cache + (min_index << s->l2_bits);    BLKDBG_EVENT(bs->file, BLKDBG_L2_LOAD);    ret = bdrv_pread(bs->file, l2_offset, *l2_table,        s->l2_size * sizeof(uint64_t));    if (ret < 0) {        return ret;    }    s->l2_cache_offsets[min_index] = l2_offset;    s->l2_cache_counts[min_index] = 1;    return 0;}", "idx": 11218}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "function": "static int apc_read_header(AVFormatContext *s){    AVIOContext *pb = s->pb;    AVStream *st;    avio_rl32(pb); /* CRYO */    avio_rl32(pb); /* _APC */    avio_rl32(pb); /* 1.20 */    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;    st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_APC;    avio_rl32(pb); /* number of samples */    st->codecpar->sample_rate = avio_rl32(pb);    /* initial predictor values for adpcm decoder */    if (ff_get_extradata(s, st->codecpar, pb, 2 * 4) < 0)        return AVERROR(ENOMEM);    if (avio_rl32(pb)) {        st->codecpar->channels       = 2;        st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;    } else {        st->codecpar->channels       = 1;        st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;    }    st->codecpar->bits_per_coded_sample = 4;    st->codecpar->bit_rate = st->codecpar->bits_per_coded_sample * st->codecpar->channels                          * st->codecpar->sample_rate;    st->codecpar->block_align = 1;    return 0;}", "idx": 11295}
{"project": "qemu", "commit_id": "1bf03e66fd03af46ff0f98dd04b6e28f432ac1e3", "target": 1, "function": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,        int64_t offset, unsigned int bytes, QEMUIOVector *qiov){    BlockDriverState *bs = child->bs;    /* Perform I/O through a temporary buffer so that users who scribble over     * their read buffer while the operation is in progress do not end up     * modifying the image file.  This is critical for zero-copy guest I/O     * where anything might happen inside guest memory.     */    void *bounce_buffer;    BlockDriver *drv = bs->drv;    struct iovec iov;    QEMUIOVector bounce_qiov;    int64_t cluster_offset;    unsigned int cluster_bytes;    size_t skip_bytes;    int ret;    assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));    /* Cover entire cluster so no additional backing file I/O is required when     * allocating cluster in the image file.     */    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,                                   cluster_offset, cluster_bytes);    iov.iov_len = cluster_bytes;    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);    if (bounce_buffer == NULL) {        ret = -ENOMEM;        goto err;    }    qemu_iovec_init_external(&bounce_qiov, &iov, 1);    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,                             &bounce_qiov, 0);    if (ret < 0) {        goto err;    }    if (drv->bdrv_co_pwrite_zeroes &&        buffer_is_zero(bounce_buffer, iov.iov_len)) {        /* FIXME: Should we (perhaps conditionally) be setting         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy         * that still correctly reads as zero? */        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);    } else {        /* This does not change the data on the disk, it is not necessary         * to flush even in cache=writethrough mode.         */        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,                                  &bounce_qiov, 0);    }    if (ret < 0) {        /* It might be okay to ignore write errors for guest requests.  If this         * is a deliberate copy-on-read then we don't want to ignore the error.         * Simply report it in all cases.         */        goto err;    }    skip_bytes = offset - cluster_offset;    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);err:    qemu_vfree(bounce_buffer);    return ret;}", "idx": 11360}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "function": "static inline void RENAME(rgb32tobgr24)(const uint8_t *src, uint8_t *dst, int src_size){    uint8_t *dest = dst;    const uint8_t *s = src;    const uint8_t *end;    const uint8_t *mm_end;    end = s + src_size;    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");    mm_end = end - 31;    while (s < mm_end) {        __asm__ volatile(            PREFETCH\"    32%1           \\n\\t\"            \"movq          %1, %%mm0    \\n\\t\"            \"movq         8%1, %%mm1    \\n\\t\"            \"movq        16%1, %%mm4    \\n\\t\"            \"movq        24%1, %%mm5    \\n\\t\"            \"movq       %%mm0, %%mm2    \\n\\t\"            \"movq       %%mm1, %%mm3    \\n\\t\"            \"movq       %%mm4, %%mm6    \\n\\t\"            \"movq       %%mm5, %%mm7    \\n\\t\"            STORE_BGR24_MMX            :\"=m\"(*dest)            :\"m\"(*s)            :\"memory\");        dest += 24;        s += 32;    }    __asm__ volatile(SFENCE:::\"memory\");    __asm__ volatile(EMMS:::\"memory\");    while (s < end) {        *dest++ = *s++;        *dest++ = *s++;        *dest++ = *s++;        s++;    }}", "idx": 11365}
{"project": "qemu", "commit_id": "dc523cd348c47372faa7271c9aab2030f94c290d", "target": 0, "function": "int qemu_opts_do_parse(QemuOpts *opts, const char *params, const char *firstname){    Error *err = NULL;    opts_do_parse(opts, params, firstname, false, &err);    if (err) {        qerror_report_err(err);        error_free(err);        return -1;    }    return 0;}", "idx": 11403}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "function": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,                                    unsigned size){    BostonState *s = opaque;    uint32_t gic_freq, val;    if (size != 4) {        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);        return 0;    }    switch (addr & 0xffff) {    case PLAT_FPGA_BUILD:    case PLAT_CORE_CL:    case PLAT_WRAPPER_CL:        return 0;    case PLAT_DDR3_STATUS:        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;    case PLAT_MMCM_DIV:        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;        return val;    case PLAT_BUILD_CFG:        val = PLAT_BUILD_CFG_PCIE0_EN;        val |= PLAT_BUILD_CFG_PCIE1_EN;        val |= PLAT_BUILD_CFG_PCIE2_EN;        return val;    case PLAT_DDR_CFG:        val = s->mach->ram_size / G_BYTE;        assert(!(val & ~PLAT_DDR_CFG_SIZE));        val |= PLAT_DDR_CFG_MHZ;        return val;    default:        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,                      addr & 0xffff);        return 0;    }}", "idx": 11439}
{"project": "qemu", "commit_id": "454b580ae9ae3e7722f1cd5f6da7bb479f86bbd8", "target": 1, "function": "static sPAPRDIMMState *spapr_recover_pending_dimm_state(sPAPRMachineState *ms,                                                        PCDIMMDevice *dimm){    sPAPRDRConnector *drc;    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);    MemoryRegion *mr = ddc->get_memory_region(dimm);    uint64_t size = memory_region_size(mr);    uint32_t nr_lmbs = size / SPAPR_MEMORY_BLOCK_SIZE;    uint32_t avail_lmbs = 0;    uint64_t addr_start, addr;    int i;    sPAPRDIMMState *ds;    addr_start = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP,                                         &error_abort);    addr = addr_start;    for (i = 0; i < nr_lmbs; i++) {        drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,                              addr / SPAPR_MEMORY_BLOCK_SIZE);        g_assert(drc);        if (drc->indicator_state != SPAPR_DR_INDICATOR_STATE_INACTIVE) {            avail_lmbs++;        }        addr += SPAPR_MEMORY_BLOCK_SIZE;    }    ds = g_malloc0(sizeof(sPAPRDIMMState));    ds->nr_lmbs = avail_lmbs;    ds->dimm = dimm;    spapr_pending_dimm_unplugs_add(ms, ds);    return ds;}", "idx": 11513}
{"project": "qemu", "commit_id": "e389be1673052b538534643165111725a79e5afd", "target": 0, "function": "static inline bool extended_addresses_enabled(CPUARMState *env){    return arm_el_is_aa64(env, 1)        || ((arm_feature(env, ARM_FEATURE_LPAE)             && (env->cp15.c2_control & (1U << 31))));}", "idx": 11637}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "function": "void qmp_block_job_pause(const char *device, Error **errp){    BlockJob *job = find_block_job(device);    if (!job) {        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);        return;    }    trace_qmp_block_job_pause(job);    block_job_pause(job);}", "idx": 11638}
{"project": "qemu", "commit_id": "d812b3d68ddf0efe91a088ecc8b177865b0bab8d", "target": 0, "function": "static void port92_init(ISADevice *dev, qemu_irq *a20_out){    Port92State *s = PORT92(dev);    s->a20_out = a20_out;}", "idx": 11669}
{"project": "qemu", "commit_id": "71ed827abd57dc7947ce3316118d0e601e70fac9", "target": 0, "function": "int ioinst_handle_ssch(CPUS390XState *env, uint64_t reg1, uint32_t ipb){    int cssid, ssid, schid, m;    SubchDev *sch;    ORB *orig_orb, orb;    uint64_t addr;    int ret = -ENODEV;    int cc;    hwaddr len = sizeof(*orig_orb);    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {        program_interrupt(env, PGM_OPERAND, 2);        return -EIO;    }    trace_ioinst_sch_id(\"ssch\", cssid, ssid, schid);    addr = decode_basedisp_s(env, ipb);    if (addr & 3) {        program_interrupt(env, PGM_SPECIFICATION, 2);        return -EIO;    }    orig_orb = s390_cpu_physical_memory_map(env, addr, &len, 0);    if (!orig_orb || len != sizeof(*orig_orb)) {        program_interrupt(env, PGM_ADDRESSING, 2);        cc = -EIO;        goto out;    }    copy_orb_from_guest(&orb, orig_orb);    if (!ioinst_orb_valid(&orb)) {        program_interrupt(env, PGM_OPERAND, 2);        cc = -EIO;        goto out;    }    sch = css_find_subch(m, cssid, ssid, schid);    if (sch && css_subch_visible(sch)) {        ret = css_do_ssch(sch, &orb);    }    switch (ret) {    case -ENODEV:        cc = 3;        break;    case -EBUSY:        cc = 2;        break;    case 0:        cc = 0;        break;    default:        cc = 1;        break;    }out:    s390_cpu_physical_memory_unmap(env, orig_orb, len, 0);    return cc;}", "idx": 11672}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "function": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk){    VirtIOBlock *s;    int cylinders, heads, secs;    static int virtio_blk_id;    DriveInfo *dinfo;    if (!blk->conf.bs) {        error_report(\"drive property not set\");        return NULL;    }    if (!bdrv_is_inserted(blk->conf.bs)) {        error_report(\"Device needs media, but drive is empty\");        return NULL;    }    if (!blk->serial) {        /* try to fall back to value set with legacy -drive serial=... */        dinfo = drive_get_by_blockdev(blk->conf.bs);        if (*dinfo->serial) {            blk->serial = strdup(dinfo->serial);        }    }    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,                                          sizeof(struct virtio_blk_config),                                          sizeof(VirtIOBlock));    s->vdev.get_config = virtio_blk_update_config;    s->vdev.get_features = virtio_blk_get_features;    s->vdev.reset = virtio_blk_reset;    s->bs = blk->conf.bs;    s->conf = &blk->conf;    s->blk = blk;    s->rq = NULL;    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);    s->qdev = dev;    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,                    virtio_blk_save, virtio_blk_load, s);    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);    bdrv_iostatus_enable(s->bs);    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");    return &s->vdev;}", "idx": 11685}
{"project": "FFmpeg", "commit_id": "6a63ff19b6a7fe3bc32c7fb4a62fca8f65786432", "target": 0, "function": "static int mov_read_stsz(MOVContext *c, ByteIOContext *pb, MOVAtom atom){    AVStream *st = c->fc->streams[c->fc->nb_streams-1];    MOVStreamContext *sc = st->priv_data;    unsigned int i, entries, sample_size, field_size, num_bytes;    GetBitContext gb;    unsigned char* buf;    get_byte(pb); /* version */    get_be24(pb); /* flags */    if (atom.type == MKTAG('s','t','s','z')) {        sample_size = get_be32(pb);        if (!sc->sample_size) /* do not overwrite value computed in stsd */            sc->sample_size = sample_size;        field_size = 32;    } else {        sample_size = 0;        get_be24(pb); /* reserved */        field_size = get_byte(pb);    }    entries = get_be32(pb);    dprintf(c->fc, \"sample_size = %d sample_count = %d\\n\", sc->sample_size, entries);    sc->sample_count = entries;    if (sample_size)        return 0;    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %d\\n\", field_size);        return -1;    }    if(entries >= UINT_MAX / sizeof(int))        return -1;    sc->sample_sizes = av_malloc(entries * sizeof(int));    if (!sc->sample_sizes)        return AVERROR(ENOMEM);    num_bytes = (entries*field_size+4)>>3;    buf = av_malloc(num_bytes+FF_INPUT_BUFFER_PADDING_SIZE);    if (!buf) {        av_freep(&sc->sample_sizes);        return AVERROR(ENOMEM);    }    if (get_buffer(pb, buf, num_bytes) < num_bytes) {        av_freep(&sc->sample_sizes);        av_free(buf);        return -1;    }    init_get_bits(&gb, buf, 8*num_bytes);    for(i=0; i<entries; i++)        sc->sample_sizes[i] = get_bits_long(&gb, field_size);    av_free(buf);    return 0;}", "idx": 11707}
{"project": "qemu", "commit_id": "19ebd13ed45ad5d5f277f5914d55b83f13eb09eb", "target": 1, "function": "static void commit_complete(BlockJob *job, void *opaque){    CommitBlockJob *s = container_of(job, CommitBlockJob, common);    CommitCompleteData *data = opaque;    BlockDriverState *active = s->active;    BlockDriverState *top = blk_bs(s->top);    BlockDriverState *base = blk_bs(s->base);    BlockDriverState *overlay_bs = bdrv_find_overlay(active, s->commit_top_bs);    int ret = data->ret;    bool remove_commit_top_bs = false;    /* Make sure overlay_bs and top stay around until bdrv_set_backing_hd() */    bdrv_ref(top);    bdrv_ref(overlay_bs);    /* Remove base node parent that still uses BLK_PERM_WRITE/RESIZE before     * the normal backing chain can be restored. */    blk_unref(s->base);    if (!block_job_is_cancelled(&s->common) && ret == 0) {        /* success */        ret = bdrv_drop_intermediate(active, s->commit_top_bs, base,                                     s->backing_file_str);    } else if (overlay_bs) {        /* XXX Can (or should) we somehow keep 'consistent read' blocked even         * after the failed/cancelled commit job is gone? If we already wrote         * something to base, the intermediate images aren't valid any more. */        remove_commit_top_bs = true;    }    /* restore base open flags here if appropriate (e.g., change the base back     * to r/o). These reopens do not need to be atomic, since we won't abort     * even on failure here */    if (s->base_flags != bdrv_get_flags(base)) {        bdrv_reopen(base, s->base_flags, NULL);    }    if (overlay_bs && s->orig_overlay_flags != bdrv_get_flags(overlay_bs)) {        bdrv_reopen(overlay_bs, s->orig_overlay_flags, NULL);    }    g_free(s->backing_file_str);    blk_unref(s->top);    block_job_completed(&s->common, ret);    g_free(data);    /* If bdrv_drop_intermediate() didn't already do that, remove the commit     * filter driver from the backing chain. Do this as the final step so that     * the 'consistent read' permission can be granted.  */    if (remove_commit_top_bs) {        bdrv_set_backing_hd(overlay_bs, top, &error_abort);    }}", "idx": 11751}
{"project": "qemu", "commit_id": "30fd3e27907dfd1c0c66cc1339657af1a2ce1d4b", "target": 0, "function": "static ssize_t qio_channel_socket_readv(QIOChannel *ioc,                                        const struct iovec *iov,                                        size_t niov,                                        int **fds,                                        size_t *nfds,                                        Error **errp){    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(ioc);    ssize_t ret;    struct msghdr msg = { NULL, };    char control[CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS)];    int sflags = 0;    memset(control, 0, CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS));#ifdef MSG_CMSG_CLOEXEC    sflags |= MSG_CMSG_CLOEXEC;#endif    msg.msg_iov = (struct iovec *)iov;    msg.msg_iovlen = niov;    if (fds && nfds) {        msg.msg_control = control;        msg.msg_controllen = sizeof(control);    } retry:    ret = recvmsg(sioc->fd, &msg, sflags);    if (ret < 0) {        if (socket_error() == EAGAIN ||            socket_error() == EWOULDBLOCK) {            return QIO_CHANNEL_ERR_BLOCK;        }        if (socket_error() == EINTR) {            goto retry;        }        error_setg_errno(errp, socket_error(),                         \"Unable to read from socket\");        return -1;    }    if (fds && nfds) {        qio_channel_socket_copy_fds(&msg, fds, nfds);    }    return ret;}", "idx": 11770}
{"project": "FFmpeg", "commit_id": "03cef34aa66662e2ab3681d290e7c5a6634f4058", "target": 0, "function": "static void qsv_uninit(AVCodecContext *s){    InputStream *ist = s->opaque;    QSVContext  *qsv = ist->hwaccel_ctx;    av_freep(&qsv->ost->enc_ctx->hwaccel_context);    av_freep(&s->hwaccel_context);    av_buffer_unref(&qsv->opaque_surfaces_buf);    av_freep(&qsv->surface_used);    av_freep(&qsv->surface_ptrs);    av_freep(&qsv);}", "idx": 11796}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "function": "static inline void vhost_dev_log_resize(struct vhost_dev* dev, uint64_t size){    vhost_log_chunk_t *log;    uint64_t log_base;    int r;    if (size) {        log = g_malloc0(size * sizeof *log);    } else {        log = NULL;    }    log_base = (uint64_t)(unsigned long)log;    r = ioctl(dev->control, VHOST_SET_LOG_BASE, &log_base);    assert(r >= 0);    vhost_client_sync_dirty_bitmap(&dev->client, 0,                                   (target_phys_addr_t)~0x0ull);    if (dev->log) {        g_free(dev->log);    }    dev->log = log;    dev->log_size = size;}", "idx": 11818}
{"project": "FFmpeg", "commit_id": "7439475e69f333541c3647f6b9eb5b5af073cb64", "target": 0, "function": "int ff_listen_connect(int fd, const struct sockaddr *addr,                      socklen_t addrlen, int timeout, URLContext *h,                      int will_try_next){    struct pollfd p = {fd, POLLOUT, 0};    int ret;    socklen_t optlen;    ff_socket_nonblock(fd, 1);    while ((ret = connect(fd, addr, addrlen))) {        ret = ff_neterrno();        switch (ret) {        case AVERROR(EINTR):            if (ff_check_interrupt(&h->interrupt_callback))                return AVERROR_EXIT;            continue;        case AVERROR(EINPROGRESS):        case AVERROR(EAGAIN):            ret = ff_poll_interrupt(&p, 1, timeout, &h->interrupt_callback);            if (ret < 0)                return ret;            optlen = sizeof(ret);            if (getsockopt (fd, SOL_SOCKET, SO_ERROR, &ret, &optlen))                ret = AVUNERROR(ff_neterrno());            if (ret != 0) {                char errbuf[100];                ret = AVERROR(ret);                av_strerror(ret, errbuf, sizeof(errbuf));                if (will_try_next)                    av_log(h, AV_LOG_WARNING,                           \"Connection to %s failed (%s), trying next address\\n\",                           h->filename, errbuf);                else                    av_log(h, AV_LOG_ERROR, \"Connection to %s failed: %s\\n\",                           h->filename, errbuf);            }        default:            return ret;        }    }    return ret;}", "idx": 11827}
{"project": "qemu", "commit_id": "b80bb016d8c8e9d74345a90ab6dac1cb547904e0", "target": 0, "function": "static void tcg_opt_gen_mov(TCGArg *gen_args, TCGArg dst, TCGArg src,                            int nb_temps, int nb_globals){        reset_temp(dst, nb_temps, nb_globals);        assert(temps[src].state != TCG_TEMP_COPY);        if (src >= nb_globals) {            assert(temps[src].state != TCG_TEMP_CONST);            if (temps[src].state != TCG_TEMP_HAS_COPY) {                temps[src].state = TCG_TEMP_HAS_COPY;                temps[src].next_copy = src;                temps[src].prev_copy = src;            }            temps[dst].state = TCG_TEMP_COPY;            temps[dst].val = src;            temps[dst].next_copy = temps[src].next_copy;            temps[dst].prev_copy = src;            temps[temps[dst].next_copy].prev_copy = dst;            temps[src].next_copy = dst;        }        gen_args[0] = dst;        gen_args[1] = src;}", "idx": 11829}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "function": "static void put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,                                 ptrdiff_t line_size){    int i;    /* read the pixels */    for (i = 0; i < 8; i++) {        pixels[0] = av_clip_uint8(block[0]);        pixels[1] = av_clip_uint8(block[1]);        pixels[2] = av_clip_uint8(block[2]);        pixels[3] = av_clip_uint8(block[3]);        pixels[4] = av_clip_uint8(block[4]);        pixels[5] = av_clip_uint8(block[5]);        pixels[6] = av_clip_uint8(block[6]);        pixels[7] = av_clip_uint8(block[7]);        pixels += line_size;        block  += 8;    }}", "idx": 11873}
{"project": "qemu", "commit_id": "b5469b1104a4b0c870dd805d9fb9d844b56d987e", "target": 1, "function": "void vnc_tight_clear(VncState *vs){    int i;    for (i=0; i<ARRAY_SIZE(vs->tight.stream); i++) {        if (vs->tight.stream[i].opaque) {            deflateEnd(&vs->tight.stream[i]);        }    }    buffer_free(&vs->tight.tight);    buffer_free(&vs->tight.zlib);    buffer_free(&vs->tight.gradient);#ifdef CONFIG_VNC_JPEG    buffer_free(&vs->tight.jpeg);}", "idx": 11887}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "function": "int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame){    BufferSourceContext *s = ctx->priv;    AVFrame *copy;    int ret;    if (!frame) {        s->eof = 1;        return 0;    } else if (s->eof)        return AVERROR(EINVAL);    switch (ctx->outputs[0]->type) {    case AVMEDIA_TYPE_VIDEO:        CHECK_VIDEO_PARAM_CHANGE(ctx, s, frame->width, frame->height,                                 frame->format);        break;    case AVMEDIA_TYPE_AUDIO:        CHECK_AUDIO_PARAM_CHANGE(ctx, s, frame->sample_rate, frame->channel_layout,                                 frame->format);        break;    default:        return AVERROR(EINVAL);    }    if (!av_fifo_space(s->fifo) &&        (ret = av_fifo_realloc2(s->fifo, av_fifo_size(s->fifo) +                                         sizeof(copy))) < 0)        return ret;    if (!(copy = av_frame_alloc()))        return AVERROR(ENOMEM);    av_frame_move_ref(copy, frame);    if ((ret = av_fifo_generic_write(s->fifo, &copy, sizeof(copy), NULL)) < 0) {        av_frame_move_ref(frame, copy);        av_frame_free(&copy);        return ret;    }    return 0;}", "idx": 11892}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "function": "static inline void tcg_out_goto(TCGContext *s, tcg_insn_unit *target){    ptrdiff_t offset = target - s->code_ptr;    assert(offset == sextract64(offset, 0, 26));    tcg_out_insn(s, 3206, B, offset);}", "idx": 11909}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "function": "int cpu_x86_register(X86CPU *cpu, const char *cpu_model){    CPUX86State *env = &cpu->env;    x86_def_t def1, *def = &def1;    Error *error = NULL;    memset(def, 0, sizeof(*def));    if (cpu_x86_find_by_name(def, cpu_model) < 0)        return -1;    if (def->vendor1) {        env->cpuid_vendor1 = def->vendor1;        env->cpuid_vendor2 = def->vendor2;        env->cpuid_vendor3 = def->vendor3;    } else {        env->cpuid_vendor1 = CPUID_VENDOR_INTEL_1;        env->cpuid_vendor2 = CPUID_VENDOR_INTEL_2;        env->cpuid_vendor3 = CPUID_VENDOR_INTEL_3;    }    env->cpuid_vendor_override = def->vendor_override;    object_property_set_int(OBJECT(cpu), def->level, \"level\", &error);    object_property_set_int(OBJECT(cpu), def->family, \"family\", &error);    object_property_set_int(OBJECT(cpu), def->model, \"model\", &error);    object_property_set_int(OBJECT(cpu), def->stepping, \"stepping\", &error);    env->cpuid_features = def->features;    env->cpuid_ext_features = def->ext_features;    env->cpuid_ext2_features = def->ext2_features;    env->cpuid_ext3_features = def->ext3_features;    object_property_set_int(OBJECT(cpu), def->xlevel, \"xlevel\", &error);    env->cpuid_kvm_features = def->kvm_features;    env->cpuid_svm_features = def->svm_features;    env->cpuid_ext4_features = def->ext4_features;    env->cpuid_7_0_ebx = def->cpuid_7_0_ebx_features;    env->cpuid_xlevel2 = def->xlevel2;    object_property_set_int(OBJECT(cpu), (int64_t)def->tsc_khz * 1000,                            \"tsc-frequency\", &error);    /* On AMD CPUs, some CPUID[8000_0001].EDX bits must match the bits on     * CPUID[1].EDX.     */    if (env->cpuid_vendor1 == CPUID_VENDOR_AMD_1 &&            env->cpuid_vendor2 == CPUID_VENDOR_AMD_2 &&            env->cpuid_vendor3 == CPUID_VENDOR_AMD_3) {        env->cpuid_ext2_features &= ~CPUID_EXT2_AMD_ALIASES;        env->cpuid_ext2_features |= (def->features & CPUID_EXT2_AMD_ALIASES);    }    if (!kvm_enabled()) {        env->cpuid_features &= TCG_FEATURES;        env->cpuid_ext_features &= TCG_EXT_FEATURES;        env->cpuid_ext2_features &= (TCG_EXT2_FEATURES#ifdef TARGET_X86_64            | CPUID_EXT2_SYSCALL | CPUID_EXT2_LM#endif            );        env->cpuid_ext3_features &= TCG_EXT3_FEATURES;        env->cpuid_svm_features &= TCG_SVM_FEATURES;    }    object_property_set_str(OBJECT(cpu), def->model_id, \"model-id\", &error);    if (error_is_set(&error)) {        error_free(error);        return -1;    }    return 0;}", "idx": 11916}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "function": "static int pte64_check(struct mmu_ctx_hash64 *ctx, target_ulong pte0,                       target_ulong pte1, int h, int rw, int type){    target_ulong mmask;    int access, ret, pp;    ret = -1;    /* Check validity and table match */    if ((pte0 & HPTE64_V_VALID) && (h == !!(pte0 & HPTE64_V_SECONDARY))) {        /* Check vsid & api */        mmask = PTE64_CHECK_MASK;        pp = (pte1 & HPTE64_R_PP) | ((pte1 & HPTE64_R_PP0) >> 61);        /* No execute if either noexec or guarded bits set */        ctx->nx = (pte1 & HPTE64_R_N) || (pte1 & HPTE64_R_G);        if (HPTE64_V_COMPARE(pte0, ctx->ptem)) {            if (ctx->raddr != (hwaddr)-1ULL) {                /* all matches should have equal RPN, WIMG & PP */                if ((ctx->raddr & mmask) != (pte1 & mmask)) {                    qemu_log(\"Bad RPN/WIMG/PP\\n\");                    return -3;                }            }            /* Compute access rights */            access = ppc_hash64_pp_check(ctx->key, pp, ctx->nx);            /* Keep the matching PTE informations */            ctx->raddr = pte1;            ctx->prot = access;            ret = ppc_hash64_check_prot(ctx->prot, rw, type);            if (ret == 0) {                /* Access granted */                LOG_MMU(\"PTE access granted !\\n\");            } else {                /* Access right violation */                LOG_MMU(\"PTE access rejected\\n\");            }        }    }    return ret;}", "idx": 11926}
{"project": "qemu", "commit_id": "49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8", "target": 0, "function": "pvscsi_convert_sglist(PVSCSIRequest *r){    int chunk_size;    uint64_t data_length = r->req.dataLen;    PVSCSISGState sg = r->sg;    while (data_length) {        while (!sg.resid) {            pvscsi_get_next_sg_elem(&sg);            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,                                        r->sg.resid);        }        assert(data_length > 0);        chunk_size = MIN((unsigned) data_length, sg.resid);        if (chunk_size) {            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);        }        sg.dataAddr += chunk_size;        data_length -= chunk_size;        sg.resid -= chunk_size;    }}", "idx": 11956}
{"project": "FFmpeg", "commit_id": "f0f2218dce194ff50d1fe7ed39011595660143ad", "target": 0, "function": "static int mov_read_trun(MOVContext *c, ByteIOContext *pb, MOVAtom atom){    MOVFragment *frag = &c->fragment;    AVStream *st = NULL;    MOVStreamContext *sc;    uint64_t offset;    int64_t dts;    int data_offset = 0;    unsigned entries, first_sample_flags = frag->flags;    int flags, distance, i;    for (i = 0; i < c->fc->nb_streams; i++) {        if (c->fc->streams[i]->id == frag->track_id) {            st = c->fc->streams[i];            break;        }    }    if (!st) {        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %d\\n\", frag->track_id);        return -1;    }    sc = st->priv_data;    if (sc->pseudo_stream_id+1 != frag->stsd_id)        return 0;    get_byte(pb); /* version */    flags = get_be24(pb);    entries = get_be32(pb);    dprintf(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);    if (flags & 0x001) data_offset        = get_be32(pb);    if (flags & 0x004) first_sample_flags = get_be32(pb);    if (flags & 0x800) {        MOVStts *ctts_data;        if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))            return -1;        ctts_data = av_realloc(sc->ctts_data,                               (entries+sc->ctts_count)*sizeof(*sc->ctts_data));        if (!ctts_data)            return AVERROR(ENOMEM);        sc->ctts_data = ctts_data;    }    dts = st->duration;    offset = frag->base_data_offset + data_offset;    distance = 0;    dprintf(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);    for (i = 0; i < entries; i++) {        unsigned sample_size = frag->size;        int sample_flags = i ? frag->flags : first_sample_flags;        unsigned sample_duration = frag->duration;        int keyframe;        if (flags & 0x100) sample_duration = get_be32(pb);        if (flags & 0x200) sample_size     = get_be32(pb);        if (flags & 0x400) sample_flags    = get_be32(pb);        if (flags & 0x800) {            sc->ctts_data[sc->ctts_count].count = 1;            sc->ctts_data[sc->ctts_count].duration = get_be32(pb);            sc->ctts_count++;        }        if ((keyframe = st->codec->codec_type == CODEC_TYPE_AUDIO ||             (flags & 0x004 && !i && !sample_flags) || sample_flags & 0x2000000))            distance = 0;        av_add_index_entry(st, offset, dts, sample_size, distance,                           keyframe ? AVINDEX_KEYFRAME : 0);        dprintf(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,                offset, dts, sample_size, distance, keyframe);        distance++;        assert(sample_duration % sc->time_rate == 0);        dts += sample_duration / sc->time_rate;        offset += sample_size;    }    frag->moof_offset = offset;    sc->sample_count = st->nb_index_entries;    st->duration = dts;    return 0;}", "idx": 12012}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "function": "static void pxa2xx_i2c_write(void *opaque, hwaddr addr,                             uint64_t value64, unsigned size){    PXA2xxI2CState *s = (PXA2xxI2CState *) opaque;    uint32_t value = value64;    int ack;    addr -= s->offset;    switch (addr) {    case ICR:        s->control = value & 0xfff7;        if ((value & (1 << 3)) && (value & (1 << 6))) {\t/* TB and IUE */            /* TODO: slave mode */            if (value & (1 << 0)) {\t\t\t/* START condition */                if (s->data & 1)                    s->status |= 1 << 0;\t\t/* set RWM */                else                    s->status &= ~(1 << 0);\t\t/* clear RWM */                ack = !i2c_start_transfer(s->bus, s->data >> 1, s->data & 1);            } else {                if (s->status & (1 << 0)) {\t\t/* RWM */                    s->data = i2c_recv(s->bus);                    if (value & (1 << 2))\t\t/* ACKNAK */                        i2c_nack(s->bus);                    ack = 1;                } else                    ack = !i2c_send(s->bus, s->data);            }            if (value & (1 << 1))\t\t\t/* STOP condition */                i2c_end_transfer(s->bus);            if (ack) {                if (value & (1 << 0))\t\t\t/* START condition */                    s->status |= 1 << 6;\t\t/* set ITE */                else                    if (s->status & (1 << 0))\t\t/* RWM */                        s->status |= 1 << 7;\t\t/* set IRF */                    else                        s->status |= 1 << 6;\t\t/* set ITE */                s->status &= ~(1 << 1);\t\t\t/* clear ACKNAK */            } else {                s->status |= 1 << 6;\t\t\t/* set ITE */                s->status |= 1 << 10;\t\t\t/* set BED */                s->status |= 1 << 1;\t\t\t/* set ACKNAK */            }        }        if (!(value & (1 << 3)) && (value & (1 << 6)))\t/* !TB and IUE */            if (value & (1 << 4))\t\t\t/* MA */                i2c_end_transfer(s->bus);        pxa2xx_i2c_update(s);        break;    case ISR:        s->status &= ~(value & 0x07f0);        pxa2xx_i2c_update(s);        break;    case ISAR:        i2c_set_slave_address(I2C_SLAVE(s->slave), value & 0x7f);        break;    case IDBR:        s->data = value & 0xff;        break;    default:        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);    }}", "idx": 12027}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static unsigned int dec_subu_r(DisasContext *dc){\tTCGv t0;\tint size = memsize_z(dc);\tDIS(fprintf (logfile, \"subu.%c $r%u, $r%u\\n\",\t\t    memsize_char(size),\t\t    dc->op1, dc->op2));\tcris_cc_mask(dc, CC_MASK_NZVC);\tt0 = tcg_temp_new(TCG_TYPE_TL);\t/* Size can only be qi or hi.  */\tt_gen_zext(t0, cpu_R[dc->op1], size);\tcris_alu(dc, CC_OP_SUB,\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\ttcg_temp_free(t0);\treturn 2;}", "idx": 12035}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "function": "void *etraxfs_dmac_init(CPUState *env, \t\t\ttarget_phys_addr_t base, int nr_channels){\tstruct fs_dma_ctrl *ctrl = NULL;\tint i;\tctrl = qemu_mallocz(sizeof *ctrl);\tif (!ctrl)\t\treturn NULL;\tctrl->base = base;\tctrl->env = env;\tctrl->nr_channels = nr_channels;\tctrl->channels = qemu_mallocz(sizeof ctrl->channels[0] * nr_channels);\tif (!ctrl->channels)\t\tgoto err;\tfor (i = 0; i < nr_channels; i++)\t{\t\tctrl->channels[i].regmap = cpu_register_io_memory(0,\t\t\t\t\t\t\t\t  dma_read, \t\t\t\t\t\t\t\t  dma_write, \t\t\t\t\t\t\t\t  ctrl);\t\tcpu_register_physical_memory (base + i * 0x2000,\t\t\t\t\t      sizeof ctrl->channels[i].regs, \t\t\t\t\t      ctrl->channels[i].regmap);\t}\t/* Hax, we only support one DMA controller at a time.  */\tetraxfs_dmac = ctrl;\treturn ctrl;  err:\tqemu_free(ctrl->channels);\tqemu_free(ctrl);\treturn NULL;}", "idx": 12048}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "function": "static int vhost_user_reset_device(struct vhost_dev *dev){    VhostUserMsg msg = {        .request = VHOST_USER_RESET_OWNER,        .flags = VHOST_USER_VERSION,    };    vhost_user_write(dev, &msg, NULL, 0);    return 0;}", "idx": 12062}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "function": "static void virtio_pci_modern_regions_init(VirtIOPCIProxy *proxy){    static const MemoryRegionOps common_ops = {        .read = virtio_pci_common_read,        .write = virtio_pci_common_write,        .impl = {            .min_access_size = 1,            .max_access_size = 4,        },        .endianness = DEVICE_LITTLE_ENDIAN,    };    static const MemoryRegionOps isr_ops = {        .read = virtio_pci_isr_read,        .write = virtio_pci_isr_write,        .impl = {            .min_access_size = 1,            .max_access_size = 4,        },        .endianness = DEVICE_LITTLE_ENDIAN,    };    static const MemoryRegionOps device_ops = {        .read = virtio_pci_device_read,        .write = virtio_pci_device_write,        .impl = {            .min_access_size = 1,            .max_access_size = 4,        },        .endianness = DEVICE_LITTLE_ENDIAN,    };    static const MemoryRegionOps notify_ops = {        .read = virtio_pci_notify_read,        .write = virtio_pci_notify_write,        .impl = {            .min_access_size = 1,            .max_access_size = 4,        },        .endianness = DEVICE_LITTLE_ENDIAN,    };    memory_region_init_io(&proxy->common.mr, OBJECT(proxy),                          &common_ops,                          proxy,                          \"virtio-pci-common\", 0x1000);    proxy->common.offset = 0x0;    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;    memory_region_init_io(&proxy->isr.mr, OBJECT(proxy),                          &isr_ops,                          proxy,                          \"virtio-pci-isr\", 0x1000);    proxy->isr.offset = 0x1000;    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;    memory_region_init_io(&proxy->device.mr, OBJECT(proxy),                          &device_ops,                          virtio_bus_get_device(&proxy->bus),                          \"virtio-pci-device\", 0x1000);    proxy->device.offset = 0x2000;    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;    memory_region_init_io(&proxy->notify.mr, OBJECT(proxy),                          &notify_ops,                          virtio_bus_get_device(&proxy->bus),                          \"virtio-pci-notify\",                          QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *                          VIRTIO_QUEUE_MAX);    proxy->notify.offset = 0x3000;    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;}", "idx": 12112}
{"project": "qemu", "commit_id": "0a852417564bc59441dc09509beacf7b49bc1e57", "target": 1, "function": "bool trace_init_backends(void){#ifdef CONFIG_TRACE_SIMPLE    if (!st_init()) {        fprintf(stderr, \"failed to initialize simple tracing backend.\\n\");        return false;    }#ifdef CONFIG_TRACE_FTRACE    if (!ftrace_init()) {        fprintf(stderr, \"failed to initialize ftrace backend.\\n\");        return false;    }    return true;}", "idx": 12162}
{"project": "FFmpeg", "commit_id": "96d0494123a05fb78a0fd3f03b0b5aaefc170b1c", "target": 0, "function": "static int lag_decode_frame(AVCodecContext *avctx,                            void *data, int *data_size, AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    LagarithContext *l = avctx->priv_data;    AVFrame *const p = &l->picture;    uint8_t frametype = 0;    uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9;    int offs[4];    uint8_t *srcs[4], *dst;    int i, j, planes = 3;    AVFrame *picture = data;    if (p->data[0])        avctx->release_buffer(avctx, p);    p->reference = 0;    p->key_frame = 1;    frametype = buf[0];    offset_gu = AV_RL32(buf + 1);    offset_bv = AV_RL32(buf + 5);    switch (frametype) {    case FRAME_SOLID_RGBA:        avctx->pix_fmt = PIX_FMT_RGB32;        if (avctx->get_buffer(avctx, p) < 0) {            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");            return -1;        }        dst = p->data[0];        for (j = 0; j < avctx->height; j++) {            for (i = 0; i < avctx->width; i++)                AV_WN32(dst + i * 4, offset_gu);            dst += p->linesize[0];        }        break;    case FRAME_ARITH_RGBA:        avctx->pix_fmt = PIX_FMT_RGB32;        planes = 4;        offset_ry += 4;        offs[3] = AV_RL32(buf + 9);    case FRAME_ARITH_RGB24:        if (frametype == FRAME_ARITH_RGB24)            avctx->pix_fmt = PIX_FMT_RGB24;        if (avctx->get_buffer(avctx, p) < 0) {            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");            return -1;        }        offs[0] = offset_bv;        offs[1] = offset_gu;        offs[2] = offset_ry;        if (!l->rgb_planes) {            l->rgb_stride = FFALIGN(avctx->width, 16);            l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 16);            if (!l->rgb_planes) {                av_log(avctx, AV_LOG_ERROR, \"cannot allocate temporary buffer\\n\");                return AVERROR(ENOMEM);            }        }        for (i = 0; i < planes; i++)            srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride;        for (i = 0; i < planes; i++)            lag_decode_arith_plane(l, srcs[i],                                   avctx->width, avctx->height,                                   -l->rgb_stride, buf + offs[i],                                   buf_size);        dst = p->data[0];        for (i = 0; i < planes; i++)            srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height;        for (j = 0; j < avctx->height; j++) {            for (i = 0; i < avctx->width; i++) {                uint8_t r, g, b, a;                r = srcs[0][i];                g = srcs[1][i];                b = srcs[2][i];                r += g;                b += g;                if (frametype == FRAME_ARITH_RGBA) {                    a = srcs[3][i];                    AV_WN32(dst + i * 4, MKBETAG(a, r, g, b));                } else {                    dst[i * 3 + 0] = r;                    dst[i * 3 + 1] = g;                    dst[i * 3 + 2] = b;                }            }            dst += p->linesize[0];            for (i = 0; i < planes; i++)                srcs[i] += l->rgb_stride;        }        break;    case FRAME_ARITH_YV12:        avctx->pix_fmt = PIX_FMT_YUV420P;        if (avctx->get_buffer(avctx, p) < 0) {            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");            return -1;        }        lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,                               p->linesize[0], buf + offset_ry,                               buf_size);        lag_decode_arith_plane(l, p->data[2], avctx->width / 2,                               avctx->height / 2, p->linesize[2],                               buf + offset_gu, buf_size);        lag_decode_arith_plane(l, p->data[1], avctx->width / 2,                               avctx->height / 2, p->linesize[1],                               buf + offset_bv, buf_size);        break;    default:        av_log(avctx, AV_LOG_ERROR,               \"Unsupported Lagarith frame type: %#x\\n\", frametype);        return -1;    }    *picture = *p;    *data_size = sizeof(AVFrame);    return buf_size;}", "idx": 12185}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "function": "static int xen_host_pci_get_value(XenHostPCIDevice *d, const char *name,                                  unsigned int *pvalue, int base){    char path[PATH_MAX];    char buf[XEN_HOST_PCI_GET_VALUE_BUFFER_SIZE];    int fd, rc;    unsigned long value;    char *endptr;    rc = xen_host_pci_sysfs_path(d, name, path, sizeof (path));    if (rc) {        return rc;    }    fd = open(path, O_RDONLY);    if (fd == -1) {        XEN_HOST_PCI_LOG(\"Error: Can't open %s: %s\\n\", path, strerror(errno));        return -errno;    }    do {        rc = read(fd, &buf, sizeof (buf) - 1);        if (rc < 0 && errno != EINTR) {            rc = -errno;            goto out;        }    } while (rc < 0);    buf[rc] = 0;    value = strtol(buf, &endptr, base);    if (endptr == buf || *endptr != '\\n') {        rc = -1;    } else if ((value == LONG_MIN || value == LONG_MAX) && errno == ERANGE) {        rc = -errno;    } else {        rc = 0;        *pvalue = value;    }out:    close(fd);    return rc;}", "idx": 12237}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "function": "static int vhost_user_set_mem_table(struct vhost_dev *dev,                                    struct vhost_memory *mem){    int fds[VHOST_MEMORY_MAX_NREGIONS];    int i, fd;    size_t fd_num = 0;    bool reply_supported = virtio_has_feature(dev->protocol_features,                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);    VhostUserMsg msg = {        .hdr.request = VHOST_USER_SET_MEM_TABLE,        .hdr.flags = VHOST_USER_VERSION,    };    if (reply_supported) {        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;    }    for (i = 0; i < dev->mem->nregions; ++i) {        struct vhost_memory_region *reg = dev->mem->regions + i;        ram_addr_t offset;        MemoryRegion *mr;        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,                                     &offset);        fd = memory_region_get_fd(mr);        if (fd > 0) {            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;            msg.payload.memory.regions[fd_num].mmap_offset = offset;            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);            fds[fd_num++] = fd;        }    }    msg.payload.memory.nregions = fd_num;    if (!fd_num) {        error_report(\"Failed initializing vhost-user memory map, \"                     \"consider using -object memory-backend-file share=on\");        return -1;    }    msg.hdr.size = sizeof(msg.payload.memory.nregions);    msg.hdr.size += sizeof(msg.payload.memory.padding);    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {        return -1;    }    if (reply_supported) {        return process_message_reply(dev, &msg);    }    return 0;}", "idx": 12245}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "function": "static uint8_t get_sot(J2kDecoderContext *s){    if (s->buf_end - s->buf < 4)        return AVERROR(EINVAL);    s->curtileno = bytestream_get_be16(&s->buf); ///< Isot    if((unsigned)s->curtileno >= s->numXtiles * s->numYtiles){        s->curtileno=0;        return AVERROR(EINVAL);    }    s->buf += 4; ///< Psot (ignored)    if (!bytestream_get_byte(&s->buf)){ ///< TPsot        J2kTile *tile = s->tile + s->curtileno;        /* copy defaults */        memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(J2kCodingStyle));        memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(J2kQuantStyle));    }    bytestream_get_byte(&s->buf); ///< TNsot    return 0;}", "idx": 12254}
{"project": "qemu", "commit_id": "e638073c569e801ce9def2016a84f955cbbca779", "target": 1, "function": "static void vfio_pci_load_rom(VFIODevice *vdev){    struct vfio_region_info reg_info = {        .argsz = sizeof(reg_info),        .index = VFIO_PCI_ROM_REGION_INDEX    };    uint64_t size;    off_t off = 0;    size_t bytes;    if (ioctl(vdev->fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {        error_report(\"vfio: Error getting ROM info: %m\");        return;    }    DPRINTF(\"Device %04x:%02x:%02x.%x ROM:\\n\", vdev->host.domain,            vdev->host.bus, vdev->host.slot, vdev->host.function);    DPRINTF(\"  size: 0x%lx, offset: 0x%lx, flags: 0x%lx\\n\",            (unsigned long)reg_info.size, (unsigned long)reg_info.offset,            (unsigned long)reg_info.flags);    vdev->rom_size = size = reg_info.size;    vdev->rom_offset = reg_info.offset;    if (!vdev->rom_size) {        error_report(\"vfio-pci: Cannot read device rom at \"                    \"%04x:%02x:%02x.%x\\n\",                    vdev->host.domain, vdev->host.bus, vdev->host.slot,                    vdev->host.function);        error_printf(\"Device option ROM contents are probably invalid \"                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"                    \"or load from file with romfile=\\n\");        return;    }    vdev->rom = g_malloc(size);    memset(vdev->rom, 0xff, size);    while (size) {        bytes = pread(vdev->fd, vdev->rom + off, size, vdev->rom_offset + off);        if (bytes == 0) {            break;        } else if (bytes > 0) {            off += bytes;            size -= bytes;        } else {            if (errno == EINTR || errno == EAGAIN) {                continue;            }            error_report(\"vfio: Error reading device ROM: %m\");            break;        }    }}", "idx": 12275}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "function": "static int fdctrl_init_common(FDCtrl *fdctrl){    int i, j;    static int command_tables_inited = 0;    /* Fill 'command_to_handler' lookup table */    if (!command_tables_inited) {        command_tables_inited = 1;        for (i = ARRAY_SIZE(handlers) - 1; i >= 0; i--) {            for (j = 0; j < sizeof(command_to_handler); j++) {                if ((j & handlers[i].mask) == handlers[i].value) {                    command_to_handler[j] = i;                }            }        }    }    FLOPPY_DPRINTF(\"init controller\\n\");    fdctrl->fifo = qemu_memalign(512, FD_SECTOR_LEN);    fdctrl->fifo_size = 512;    fdctrl->result_timer = qemu_new_timer(vm_clock,                                          fdctrl_result_timer, fdctrl);    fdctrl->version = 0x90; /* Intel 82078 controller */    fdctrl->config = FD_CONFIG_EIS | FD_CONFIG_EFIFO; /* Implicit seek, polling & FIFO enabled */    fdctrl->num_floppies = MAX_FD;    if (fdctrl->dma_chann != -1)        DMA_register_channel(fdctrl->dma_chann, &fdctrl_transfer_handler, fdctrl);    fdctrl_connect_drives(fdctrl);    return 0;}", "idx": 12277}
{"project": "FFmpeg", "commit_id": "631f7484918a9e7260377c3cea878be708609e64", "target": 1, "function": "static int h263_decode_block(MpegEncContext * s, int16_t * block,                             int n, int coded){    int level, i, j, run;    RLTable *rl = &ff_h263_rl_inter;    const uint8_t *scan_table;    GetBitContext gb= s->gb;    scan_table = s->intra_scantable.permutated;    if (s->h263_aic && s->mb_intra) {        rl = &ff_rl_intra_aic;        i = 0;        if (s->ac_pred) {            if (s->h263_aic_dir)                scan_table = s->intra_v_scantable.permutated; /* left */            else                scan_table = s->intra_h_scantable.permutated; /* top */        }    } else if (s->mb_intra) {        /* DC coef */        if (CONFIG_RV10_DECODER && s->codec_id == AV_CODEC_ID_RV10) {          if (s->rv10_version == 3 && s->pict_type == AV_PICTURE_TYPE_I) {            int component, diff;            component = (n <= 3 ? 0 : n - 4 + 1);            level = s->last_dc[component];            if (s->rv10_first_dc_coded[component]) {                diff = ff_rv_decode_dc(s, n);                if (diff == 0xffff)                    return -1;                level += diff;                level = level & 0xff; /* handle wrap round */                s->last_dc[component] = level;            } else {                s->rv10_first_dc_coded[component] = 1;            }          } else {                level = get_bits(&s->gb, 8);                if (level == 255)                    level = 128;          }        }else{            level = get_bits(&s->gb, 8);            if((level&0x7F) == 0){                av_log(s->avctx, AV_LOG_ERROR, \"illegal dc %d at %d %d\\n\", level, s->mb_x, s->mb_y);                if (s->avctx->err_recognition & (AV_EF_BITSTREAM|AV_EF_COMPLIANT))                    return -1;            }            if (level == 255)                level = 128;        }        block[0] = level;        i = 1;    } else {        i = 0;    }    if (!coded) {        if (s->mb_intra && s->h263_aic)            goto not_coded;        s->block_last_index[n] = i - 1;        return 0;    }retry:    {    OPEN_READER(re, &s->gb);    i--; // offset by -1 to allow direct indexing of scan_table    for(;;) {        UPDATE_CACHE(re, &s->gb);        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);        if (run == 66) {            if (level){                CLOSE_READER(re, &s->gb);                av_log(s->avctx, AV_LOG_ERROR, \"illegal ac vlc code at %dx%d\\n\", s->mb_x, s->mb_y);                return -1;            }            /* escape */            if (CONFIG_FLV_DECODER && s->h263_flv > 1) {                int is11 = SHOW_UBITS(re, &s->gb, 1);                SKIP_CACHE(re, &s->gb, 1);                run = SHOW_UBITS(re, &s->gb, 7) + 1;                if (is11) {                    SKIP_COUNTER(re, &s->gb, 1 + 7);                    UPDATE_CACHE(re, &s->gb);                    level = SHOW_SBITS(re, &s->gb, 11);                    SKIP_COUNTER(re, &s->gb, 11);                } else {                    SKIP_CACHE(re, &s->gb, 7);                    level = SHOW_SBITS(re, &s->gb, 7);                    SKIP_COUNTER(re, &s->gb, 1 + 7 + 7);                }            } else {                run = SHOW_UBITS(re, &s->gb, 7) + 1;                SKIP_CACHE(re, &s->gb, 7);                level = (int8_t)SHOW_UBITS(re, &s->gb, 8);                SKIP_COUNTER(re, &s->gb, 7 + 8);                if(level == -128){                    UPDATE_CACHE(re, &s->gb);                    if (s->codec_id == AV_CODEC_ID_RV10) {                        /* XXX: should patch encoder too */                        level = SHOW_SBITS(re, &s->gb, 12);                        SKIP_COUNTER(re, &s->gb, 12);                    }else{                        level = SHOW_UBITS(re, &s->gb, 5);                        SKIP_CACHE(re, &s->gb, 5);                        level |= SHOW_SBITS(re, &s->gb, 6)<<5;                        SKIP_COUNTER(re, &s->gb, 5 + 6);                    }                }            }        } else {            if (SHOW_UBITS(re, &s->gb, 1))                level = -level;            SKIP_COUNTER(re, &s->gb, 1);        }        i += run;        if (i >= 64){            CLOSE_READER(re, &s->gb);            // redo update without last flag, revert -1 offset            i = i - run + ((run-1)&63) + 1;            if (i < 64) {                // only last marker, no overrun                block[scan_table[i]] = level;                break;            }            if(s->alt_inter_vlc && rl == &ff_h263_rl_inter && !s->mb_intra){                //Looks like a hack but no, it's the way it is supposed to work ...                rl = &ff_rl_intra_aic;                i = 0;                s->gb= gb;                s->bdsp.clear_block(block);                goto retry;            }            av_log(s->avctx, AV_LOG_ERROR, \"run overflow at %dx%d i:%d\\n\", s->mb_x, s->mb_y, s->mb_intra);            return -1;        }        j = scan_table[i];        block[j] = level;    }    }not_coded:    if (s->mb_intra && s->h263_aic) {        ff_h263_pred_acdc(s, block, n);        i = 63;    }    s->block_last_index[n] = i;    return 0;}", "idx": 12287}
{"project": "FFmpeg", "commit_id": "1693336aed3988e0c13ad1ff880257d80d6ae69d", "target": 1, "function": "static double lfo_get_value(SimpleLFO *lfo){    double phs = FFMIN(100, lfo->phase / FFMIN(1.99, FFMAX(0.01, lfo->pwidth)) + lfo->offset);    double val;    if (phs > 1)        phs = fmod(phs, 1.);    switch (lfo->mode) {    case SINE:        val = sin(phs * 2 * M_PI);        break;    case TRIANGLE:        if (phs > 0.75)            val = (phs - 0.75) * 4 - 1;        else if (phs > 0.25)            val = -4 * phs + 2;        else            val = phs * 4;        break;    case SQUARE:        val = phs < 0.5 ? -1 : +1;        break;    case SAWUP:        val = phs * 2 - 1;        break;    case SAWDOWN:        val = 1 - phs * 2;        break;    }    return val * lfo->amount;}", "idx": 12291}
{"project": "FFmpeg", "commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "target": 1, "function": "static int parse_audio(DBEContext *s, int start, int end, int seg_id){    int ch, ret, key = parse_key(s);    for (ch = start; ch < end; ch++) {        if (!s->ch_size[ch]) {            s->channels[seg_id][ch].nb_groups = 0;            continue;        }        if ((ret = convert_input(s, s->ch_size[ch], key)) < 0)            return ret;        if ((ret = parse_channel(s, ch, seg_id)) < 0) {            if (s->avctx->err_recognition & AV_EF_EXPLODE)                return ret;            s->channels[seg_id][ch].nb_groups = 0;        }        skip_input(s, s->ch_size[ch]);    }    skip_input(s, 1);    return 0;}", "idx": 12338}
{"project": "FFmpeg", "commit_id": "19b41f86457d945e98c236f67faf59d560861a4c", "target": 0, "function": "int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,                          AVPacket *avpkt){    AVFrame     *frame = data;    const uint8_t *buf = avpkt->data;    int buf_size       = avpkt->size;    MJpegDecodeContext *s = avctx->priv_data;    const uint8_t *buf_end, *buf_ptr;    const uint8_t *unescaped_buf_ptr;    int hshift, vshift;    int unescaped_buf_size;    int start_code;    int i, index;    int ret = 0;    av_dict_free(&s->exif_metadata);    av_freep(&s->stereo3d);    buf_ptr = buf;    buf_end = buf + buf_size;    while (buf_ptr < buf_end) {        /* find start next marker */        start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,                                          &unescaped_buf_ptr,                                          &unescaped_buf_size);        /* EOF */        if (start_code < 0) {            break;        } else if (unescaped_buf_size > INT_MAX / 8) {            av_log(avctx, AV_LOG_ERROR,                   \"MJPEG packet 0x%x too big (%d/%d), corrupt data?\\n\",                   start_code, unescaped_buf_size, buf_size);            return AVERROR_INVALIDDATA;        }        av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%td\\n\",               start_code, buf_end - buf_ptr);        ret = init_get_bits8(&s->gb, unescaped_buf_ptr, unescaped_buf_size);        if (ret < 0) {            av_log(avctx, AV_LOG_ERROR, \"invalid buffer\\n\");            goto fail;        }        s->start_code = start_code;        if (s->avctx->debug & FF_DEBUG_STARTCODE)            av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);        /* process markers */        if (start_code >= 0xd0 && start_code <= 0xd7)            av_log(avctx, AV_LOG_DEBUG,                   \"restart marker: %d\\n\", start_code & 0x0f);            /* APP fields */        else if (start_code >= APP0 && start_code <= APP15)            mjpeg_decode_app(s);            /* Comment */        else if (start_code == COM)            mjpeg_decode_com(s);        ret = -1;        if (!CONFIG_JPEGLS_DECODER &&            (start_code == SOF48 || start_code == LSE)) {            av_log(avctx, AV_LOG_ERROR, \"JPEG-LS support not enabled.\\n\");            return AVERROR(ENOSYS);        }        switch (start_code) {        case SOI:            s->restart_interval = 0;            s->restart_count    = 0;            /* nothing to do on SOI */            break;        case DQT:            ff_mjpeg_decode_dqt(s);            break;        case DHT:            if ((ret = ff_mjpeg_decode_dht(s)) < 0) {                av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");                goto fail;            }            break;        case SOF0:        case SOF1:            s->lossless    = 0;            s->ls          = 0;            s->progressive = 0;            if ((ret = ff_mjpeg_decode_sof(s)) < 0)                goto fail;            break;        case SOF2:            s->lossless    = 0;            s->ls          = 0;            s->progressive = 1;            if ((ret = ff_mjpeg_decode_sof(s)) < 0)                goto fail;            break;        case SOF3:            s->lossless    = 1;            s->ls          = 0;            s->progressive = 0;            if ((ret = ff_mjpeg_decode_sof(s)) < 0)                goto fail;            break;        case SOF48:            s->lossless    = 1;            s->ls          = 1;            s->progressive = 0;            if ((ret = ff_mjpeg_decode_sof(s)) < 0)                goto fail;            break;        case LSE:            if (!CONFIG_JPEGLS_DECODER ||                (ret = ff_jpegls_decode_lse(s)) < 0)                goto fail;            break;        case EOI:eoi_parser:            s->cur_scan = 0;            if (!s->got_picture) {                av_log(avctx, AV_LOG_WARNING,                       \"Found EOI before any SOF, ignoring\\n\");                break;            }            if (s->interlaced) {                s->bottom_field ^= 1;                /* if not bottom field, do not output image yet */                if (s->bottom_field == !s->interlace_polarity)                    break;            }            if ((ret = av_frame_ref(frame, s->picture_ptr)) < 0)                return ret;            *got_frame = 1;            s->got_picture = 0;            if (!s->lossless) {                int qp = FFMAX3(s->qscale[0],                                s->qscale[1],                                s->qscale[2]);                int qpw = (s->width + 15) / 16;                AVBufferRef *qp_table_buf = av_buffer_alloc(qpw);                if (qp_table_buf) {                    memset(qp_table_buf->data, qp, qpw);                    av_frame_set_qp_table(data, qp_table_buf, 0, FF_QSCALE_TYPE_MPEG1);                }                if(avctx->debug & FF_DEBUG_QP)                    av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", qp);            }            goto the_end;        case SOS:            s->cur_scan++;            if ((ret = ff_mjpeg_decode_sos(s, NULL, 0, NULL)) < 0 &&                (avctx->err_recognition & AV_EF_EXPLODE))                goto fail;            break;        case DRI:            mjpeg_decode_dri(s);            break;        case SOF5:        case SOF6:        case SOF7:        case SOF9:        case SOF10:        case SOF11:        case SOF13:        case SOF14:        case SOF15:        case JPG:            av_log(avctx, AV_LOG_ERROR,                   \"mjpeg: unsupported coding type (%x)\\n\", start_code);            break;        }        /* eof process start code */        buf_ptr += (get_bits_count(&s->gb) + 7) / 8;        av_log(avctx, AV_LOG_DEBUG,               \"marker parser used %d bytes (%d bits)\\n\",               (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));    }    if (s->got_picture && s->cur_scan) {        av_log(avctx, AV_LOG_WARNING, \"EOI missing, emulating\\n\");        goto eoi_parser;    }    av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");    return AVERROR_INVALIDDATA;fail:    s->got_picture = 0;    return ret;the_end:    if (s->upscale_h) {        uint8_t *line = s->picture_ptr->data[s->upscale_h];        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||                   avctx->pix_fmt == AV_PIX_FMT_YUVJ440P ||                   avctx->pix_fmt == AV_PIX_FMT_YUV440P);        for (i = 0; i < s->chroma_height; i++) {            for (index = s->width - 1; index; index--)                line[index] = (line[index / 2] + line[(index + 1) / 2]) >> 1;            line += s->linesize[s->upscale_h];        }    }    if (s->upscale_v) {        uint8_t *dst = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(s->height - 1) * s->linesize[s->upscale_v]];        int w;        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);        w = s->width >> hshift;        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||                   avctx->pix_fmt == AV_PIX_FMT_YUVJ422P ||                   avctx->pix_fmt == AV_PIX_FMT_YUV422P);        for (i = s->height - 1; i; i--) {            uint8_t *src1 = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[i / 2 * s->linesize[s->upscale_v]];            uint8_t *src2 = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(i + 1) / 2 * s->linesize[s->upscale_v]];            if (src1 == src2) {                memcpy(dst, src1, w);            } else {                for (index = 0; index < w; index++)                    dst[index] = (src1[index] + src2[index]) >> 1;            }            dst -= s->linesize[s->upscale_v];        }    }    if (s->flipped) {        int j;        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);        for (index=0; index<4; index++) {            uint8_t *dst = s->picture_ptr->data[index];            int w = s->picture_ptr->width;            int h = s->picture_ptr->height;            if(index && index<3){                w = FF_CEIL_RSHIFT(w, hshift);                h = FF_CEIL_RSHIFT(h, vshift);            }            if(dst){                uint8_t *dst2 = dst + s->linesize[index]*(h-1);                for (i=0; i<h/2; i++) {                    for (j=0; j<w; j++)                        FFSWAP(int, dst[j], dst2[j]);                    dst  += s->linesize[index];                    dst2 -= s->linesize[index];                }            }        }    }    if (s->stereo3d) {        AVStereo3D *stereo = av_stereo3d_create_side_data(data);        if (stereo) {            stereo->type  = s->stereo3d->type;            stereo->flags = s->stereo3d->flags;        }        av_freep(&s->stereo3d);    }    av_dict_copy(avpriv_frame_get_metadatap(data), s->exif_metadata, 0);    av_dict_free(&s->exif_metadata);    av_log(avctx, AV_LOG_DEBUG, \"decode frame unused %td bytes\\n\",           buf_end - buf_ptr);//  return buf_end - buf_ptr;    return buf_ptr - buf;}", "idx": 12374}
{"project": "qemu", "commit_id": "3936161f1fd72d1dfa577aaba910819c5e873260", "target": 1, "function": "static void pci_qdev_unrealize(DeviceState *dev, Error **errp){    PCIDevice *pci_dev = PCI_DEVICE(dev);    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);    pci_unregister_io_regions(pci_dev);    pci_del_option_rom(pci_dev);    if (pc->exit) {        pc->exit(pci_dev);    }    do_pci_unregister_device(pci_dev);}", "idx": 12593}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "function": "void ff_biweight_h264_pixels8_8_msa(uint8_t *dst, uint8_t *src,                                    int stride, int height,                                    int log2_denom, int weight_dst,                                    int weight_src, int offset){    avc_biwgt_8width_msa(src, stride,                         dst, stride,                         height, log2_denom,                         weight_src, weight_dst, offset);}", "idx": 12729}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "function": "int float32_lt( float32 a, float32 b STATUS_PARAM ){    flag aSign, bSign;    if (    ( ( extractFloat32Exp( a ) == 0xFF ) && extractFloat32Frac( a ) )         || ( ( extractFloat32Exp( b ) == 0xFF ) && extractFloat32Frac( b ) )       ) {        float_raise( float_flag_invalid STATUS_VAR);        return 0;    }    aSign = extractFloat32Sign( a );    bSign = extractFloat32Sign( b );    if ( aSign != bSign ) return aSign && ( (bits32) ( ( a | b )<<1 ) != 0 );    return ( a != b ) && ( aSign ^ ( a < b ) );}", "idx": 12735}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "function": "static SocketAddressLegacy *sd_server_config(QDict *options, Error **errp){    QDict *server = NULL;    QObject *crumpled_server = NULL;    Visitor *iv = NULL;    SocketAddress *saddr_flat = NULL;    SocketAddressLegacy *saddr = NULL;    Error *local_err = NULL;    qdict_extract_subqdict(options, &server, \"server.\");    crumpled_server = qdict_crumple(server, errp);    if (!crumpled_server) {        goto done;    }    /*     * FIXME .numeric, .to, .ipv4 or .ipv6 don't work with -drive     * server.type=inet.  .to doesn't matter, it's ignored anyway.     * That's because when @options come from -blockdev or     * blockdev_add, members are typed according to the QAPI schema,     * but when they come from -drive, they're all QString.  The     * visitor expects the former.     */    iv = qobject_input_visitor_new(crumpled_server);    visit_type_SocketAddress(iv, NULL, &saddr_flat, &local_err);    if (local_err) {        error_propagate(errp, local_err);        goto done;    }    saddr = socket_address_crumple(saddr_flat);done:    qapi_free_SocketAddress(saddr_flat);    visit_free(iv);    qobject_decref(crumpled_server);    QDECREF(server);    return saddr;}", "idx": 12737}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "function": "static int scsi_block_initfn(SCSIDevice *dev){    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);    int sg_version;    int rc;    if (!s->qdev.conf.bs) {        error_report(\"drive property not set\");        return -1;    }    /* check we are using a driver managing SG_IO (version 3 and after) */    rc = bdrv_ioctl(s->qdev.conf.bs, SG_GET_VERSION_NUM, &sg_version);    if (rc < 0) {        error_report(\"cannot get SG_IO version number: %s.  \"                     \"Is this a SCSI device?\",                     strerror(-rc));        return -1;    }    if (sg_version < 30000) {        error_report(\"scsi generic interface too old\");        return -1;    }    /* get device type from INQUIRY data */    rc = get_device_type(s);    if (rc < 0) {        error_report(\"INQUIRY failed\");        return -1;    }    /* Make a guess for the block size, we'll fix it when the guest sends.     * READ CAPACITY.  If they don't, they likely would assume these sizes     * anyway. (TODO: check in /sys).     */    if (s->qdev.type == TYPE_ROM || s->qdev.type == TYPE_WORM) {        s->qdev.blocksize = 2048;    } else {        s->qdev.blocksize = 512;    }    /* Makes the scsi-block device not removable by using HMP and QMP eject     * command.     */    s->features |= (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS);    return scsi_initfn(&s->qdev);}", "idx": 12746}
{"project": "qemu", "commit_id": "c11e80e299e57c64934c164b231fa0d4279db445", "target": 0, "function": "static void OPLWriteReg(FM_OPL *OPL, int r, int v){\tOPL_CH *CH;\tint slot;\tint block_fnum;\tswitch(r&0xe0)\t{\tcase 0x00: /* 00-1f:control */\t\tswitch(r&0x1f)\t\t{\t\tcase 0x01:\t\t\t/* wave selector enable */\t\t\tif(OPL->type&OPL_TYPE_WAVESEL)\t\t\t{\t\t\t\tOPL->wavesel = v&0x20;\t\t\t\tif(!OPL->wavesel)\t\t\t\t{\t\t\t\t\t/* preset compatible mode */\t\t\t\t\tint c;\t\t\t\t\tfor(c=0;c<OPL->max_ch;c++)\t\t\t\t\t{\t\t\t\t\t\tOPL->P_CH[c].SLOT[SLOT1].wavetable = &SIN_TABLE[0];\t\t\t\t\t\tOPL->P_CH[c].SLOT[SLOT2].wavetable = &SIN_TABLE[0];\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\treturn;\t\tcase 0x02:\t/* Timer 1 */\t\t\tOPL->T[0] = (256-v)*4;\t\t\tbreak;\t\tcase 0x03:\t/* Timer 2 */\t\t\tOPL->T[1] = (256-v)*16;\t\t\treturn;\t\tcase 0x04:\t/* IRQ clear / mask and Timer enable */\t\t\tif(v&0x80)\t\t\t{\t/* IRQ flag clear */\t\t\t\tOPL_STATUS_RESET(OPL,0x7f);\t\t\t}\t\t\telse\t\t\t{\t/* set IRQ mask ,timer enable*/\t\t\t\tUINT8 st1 = v&1;\t\t\t\tUINT8 st2 = (v>>1)&1;\t\t\t\t/* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */\t\t\t\tOPL_STATUS_RESET(OPL,v&0x78);\t\t\t\tOPL_STATUSMASK_SET(OPL,((~v)&0x78)|0x01);\t\t\t\t/* timer 2 */\t\t\t\tif(OPL->st[1] != st2)\t\t\t\t{\t\t\t\t\tdouble interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;\t\t\t\t\tOPL->st[1] = st2;\t\t\t\t\tif (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);\t\t\t\t}\t\t\t\t/* timer 1 */\t\t\t\tif(OPL->st[0] != st1)\t\t\t\t{\t\t\t\t\tdouble interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;\t\t\t\t\tOPL->st[0] = st1;\t\t\t\t\tif (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);\t\t\t\t}\t\t\t}\t\t\treturn;#if BUILD_Y8950\t\tcase 0x06:\t\t/* Key Board OUT */\t\t\tif(OPL->type&OPL_TYPE_KEYBOARD)\t\t\t{\t\t\t\tif(OPL->keyboardhandler_w)\t\t\t\t\tOPL->keyboardhandler_w(OPL->keyboard_param,v);\t\t\t\telse\t\t\t\t\tLOG(LOG_WAR,(\"OPL:write unmapped KEYBOARD port\\n\"));\t\t\t}\t\t\treturn;\t\tcase 0x07:\t/* DELTA-T control : START,REC,MEMDATA,REPT,SPOFF,x,x,RST */\t\t\tif(OPL->type&OPL_TYPE_ADPCM)\t\t\t\tYM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\t\t\treturn;\t\tcase 0x08:\t/* MODE,DELTA-T : CSM,NOTESEL,x,x,smpl,da/ad,64k,rom */\t\t\tOPL->mode = v;\t\t\tv&=0x1f;\t/* for DELTA-T unit */\t\tcase 0x09:\t\t/* START ADD */\t\tcase 0x0a:\t\tcase 0x0b:\t\t/* STOP ADD  */\t\tcase 0x0c:\t\tcase 0x0d:\t\t/* PRESCALE   */\t\tcase 0x0e:\t\tcase 0x0f:\t\t/* ADPCM data */\t\tcase 0x10: \t\t/* DELTA-N    */\t\tcase 0x11: \t\t/* DELTA-N    */\t\tcase 0x12: \t\t/* EG-CTRL    */\t\t\tif(OPL->type&OPL_TYPE_ADPCM)\t\t\t\tYM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\t\t\treturn;#if 0\t\tcase 0x15:\t\t/* DAC data    */\t\tcase 0x16:\t\tcase 0x17:\t\t/* SHIFT    */\t\t\treturn;\t\tcase 0x18:\t\t/* I/O CTRL (Direction) */\t\t\tif(OPL->type&OPL_TYPE_IO)\t\t\t\tOPL->portDirection = v&0x0f;\t\t\treturn;\t\tcase 0x19:\t\t/* I/O DATA */\t\t\tif(OPL->type&OPL_TYPE_IO)\t\t\t{\t\t\t\tOPL->portLatch = v;\t\t\t\tif(OPL->porthandler_w)\t\t\t\t\tOPL->porthandler_w(OPL->port_param,v&OPL->portDirection);\t\t\t}\t\t\treturn;\t\tcase 0x1a:\t\t/* PCM data */\t\t\treturn;#endif#endif\t\t}\t\tbreak;\tcase 0x20:\t/* am,vib,ksr,eg type,mul */\t\tslot = slot_array[r&0x1f];\t\tif(slot == -1) return;\t\tset_mul(OPL,slot,v);\t\treturn;\tcase 0x40:\t\tslot = slot_array[r&0x1f];\t\tif(slot == -1) return;\t\tset_ksl_tl(OPL,slot,v);\t\treturn;\tcase 0x60:\t\tslot = slot_array[r&0x1f];\t\tif(slot == -1) return;\t\tset_ar_dr(OPL,slot,v);\t\treturn;\tcase 0x80:\t\tslot = slot_array[r&0x1f];\t\tif(slot == -1) return;\t\tset_sl_rr(OPL,slot,v);\t\treturn;\tcase 0xa0:\t\tswitch(r)\t\t{\t\tcase 0xbd:\t\t\t/* amsep,vibdep,r,bd,sd,tom,tc,hh */\t\t\t{\t\t\tUINT8 rkey = OPL->rythm^v;\t\t\tOPL->ams_table = &AMS_TABLE[v&0x80 ? AMS_ENT : 0];\t\t\tOPL->vib_table = &VIB_TABLE[v&0x40 ? VIB_ENT : 0];\t\t\tOPL->rythm  = v&0x3f;\t\t\tif(OPL->rythm&0x20)\t\t\t{#if 0\t\t\t\tusrintf_showmessage(\"OPL Rythm mode select\");#endif\t\t\t\t/* BD key on/off */\t\t\t\tif(rkey&0x10)\t\t\t\t{\t\t\t\t\tif(v&0x10)\t\t\t\t\t{\t\t\t\t\t\tOPL->P_CH[6].op1_out[0] = OPL->P_CH[6].op1_out[1] = 0;\t\t\t\t\t\tOPL_KEYON(&OPL->P_CH[6].SLOT[SLOT1]);\t\t\t\t\t\tOPL_KEYON(&OPL->P_CH[6].SLOT[SLOT2]);\t\t\t\t\t}\t\t\t\t\telse\t\t\t\t\t{\t\t\t\t\t\tOPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1]);\t\t\t\t\t\tOPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2]);\t\t\t\t\t}\t\t\t\t}\t\t\t\t/* SD key on/off */\t\t\t\tif(rkey&0x08)\t\t\t\t{\t\t\t\t\tif(v&0x08) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT2]);\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2]);\t\t\t\t}/* TAM key on/off */\t\t\t\tif(rkey&0x04)\t\t\t\t{\t\t\t\t\tif(v&0x04) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT1]);\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1]);\t\t\t\t}\t\t\t\t/* TOP-CY key on/off */\t\t\t\tif(rkey&0x02)\t\t\t\t{\t\t\t\t\tif(v&0x02) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT2]);\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2]);\t\t\t\t}\t\t\t\t/* HH key on/off */\t\t\t\tif(rkey&0x01)\t\t\t\t{\t\t\t\t\tif(v&0x01) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT1]);\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1]);\t\t\t\t}\t\t\t}\t\t\t}\t\t\treturn;\t\t}\t\t/* keyon,block,fnum */\t\tif( (r&0x0f) > 8) return;\t\tCH = &OPL->P_CH[r&0x0f];\t\tif(!(r&0x10))\t\t{\t/* a0-a8 */\t\t\tblock_fnum  = (CH->block_fnum&0x1f00) | v;\t\t}\t\telse\t\t{\t/* b0-b8 */\t\t\tint keyon = (v>>5)&1;\t\t\tblock_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);\t\t\tif(CH->keyon != keyon)\t\t\t{\t\t\t\tif( (CH->keyon=keyon) )\t\t\t\t{\t\t\t\t\tCH->op1_out[0] = CH->op1_out[1] = 0;\t\t\t\t\tOPL_KEYON(&CH->SLOT[SLOT1]);\t\t\t\t\tOPL_KEYON(&CH->SLOT[SLOT2]);\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tOPL_KEYOFF(&CH->SLOT[SLOT1]);\t\t\t\t\tOPL_KEYOFF(&CH->SLOT[SLOT2]);\t\t\t\t}\t\t\t}\t\t}\t\t/* update */\t\tif(CH->block_fnum != block_fnum)\t\t{\t\t\tint blockRv = 7-(block_fnum>>10);\t\t\tint fnum   = block_fnum&0x3ff;\t\t\tCH->block_fnum = block_fnum;\t\t\tCH->ksl_base = KSL_TABLE[block_fnum>>6];\t\t\tCH->fc = OPL->FN_TABLE[fnum]>>blockRv;\t\t\tCH->kcode = CH->block_fnum>>9;\t\t\tif( (OPL->mode&0x40) && CH->block_fnum&0x100) CH->kcode |=1;\t\t\tCALC_FCSLOT(CH,&CH->SLOT[SLOT1]);\t\t\tCALC_FCSLOT(CH,&CH->SLOT[SLOT2]);\t\t}\t\treturn;\tcase 0xc0:\t\t/* FB,C */\t\tif( (r&0x0f) > 8) return;\t\tCH = &OPL->P_CH[r&0x0f];\t\t{\t\tint feedback = (v>>1)&7;\t\tCH->FB   = feedback ? (8+1) - feedback : 0;\t\tCH->CON = v&1;\t\tset_algorythm(CH);\t\t}\t\treturn;\tcase 0xe0: /* wave type */\t\tslot = slot_array[r&0x1f];\t\tif(slot == -1) return;\t\tCH = &OPL->P_CH[slot/2];\t\tif(OPL->wavesel)\t\t{\t\t\t/* LOG(LOG_INF,(\"OPL SLOT %d wave select %d\\n\",slot,v&3)); */\t\t\tCH->SLOT[slot&1].wavetable = &SIN_TABLE[(v&0x03)*SIN_ENT];\t\t}\t\treturn;\t}}", "idx": 12762}
{"project": "qemu", "commit_id": "8e84865e54cb66fd7b57bb18c312ad3d56b6e276", "target": 1, "function": "static int do_cont(Monitor *mon, const QDict *qdict, QObject **ret_data){    struct bdrv_iterate_context context = { mon, 0 };    bdrv_iterate(encrypted_bdrv_it, &context);    /* only resume the vm if all keys are set and valid */    if (!context.err) {        vm_start();        return 0;    } else {", "idx": 12821}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "function": "static void slavio_set_timer_irq_cpu(void *opaque, int cpu, int level){    SLAVIO_INTCTLState *s = opaque;    DPRINTF(\"Set cpu %d local level %d\\n\", cpu, level);    if (!s->cpu_envs[cpu])        return;    if (level) {        s->intreg_pending[cpu] |= s->cputimer_bit;    } else {        s->intreg_pending[cpu] &= ~s->cputimer_bit;    }    slavio_check_interrupts(s);}", "idx": 12848}
{"project": "qemu", "commit_id": "f74e27bf0f07425aba6cb812aa7f5aa98bb68542", "target": 0, "function": "static void coroutine_fn pdu_complete(V9fsPDU *pdu, ssize_t len){    int8_t id = pdu->id + 1; /* Response */    V9fsState *s = pdu->s;    if (len < 0) {        int err = -len;        len = 7;        if (s->proto_version != V9FS_PROTO_2000L) {            V9fsString str;            str.data = strerror(err);            str.size = strlen(str.data);            len += pdu_marshal(pdu, len, \"s\", &str);            id = P9_RERROR;        }        len += pdu_marshal(pdu, len, \"d\", err);        if (s->proto_version == V9FS_PROTO_2000L) {            id = P9_RLERROR;        }        trace_v9fs_rerror(pdu->tag, pdu->id, err); /* Trace ERROR */    }    /* fill out the header */    pdu_marshal(pdu, 0, \"dbw\", (int32_t)len, id, pdu->tag);    /* keep these in sync */    pdu->size = len;    pdu->id = id;    pdu_push_and_notify(pdu);    /* Now wakeup anybody waiting in flush for this request */    qemu_co_queue_next(&pdu->complete);    pdu_free(pdu);}", "idx": 12855}
{"project": "qemu", "commit_id": "d57e4e482e3997b1382625c84149ad0b69155fc0", "target": 0, "function": "static BlockBackend *img_open(const char *id, const char *filename,                              const char *fmt, int flags,                              bool require_io, bool quiet){    BlockBackend *blk;    BlockDriverState *bs;    char password[256];    Error *local_err = NULL;    QDict *options = NULL;    if (fmt) {        options = qdict_new();        qdict_put(options, \"driver\", qstring_from_str(fmt));    }    blk = blk_new_open(id, filename, NULL, options, flags, &local_err);    if (!blk) {        error_report(\"Could not open '%s': %s\", filename,                     error_get_pretty(local_err));        error_free(local_err);        goto fail;    }    bs = blk_bs(blk);    if (bdrv_is_encrypted(bs) && require_io) {        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);        if (read_password(password, sizeof(password)) < 0) {            error_report(\"No password given\");            goto fail;        }        if (bdrv_set_key(bs, password) < 0) {            error_report(\"invalid password\");            goto fail;        }    }    return blk;fail:    blk_unref(blk);    return NULL;}", "idx": 12866}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void channel_load_d(struct fs_dma_ctrl *ctrl, int c){\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_SAVED_DATA);\t/* Load and decode. FIXME: handle endianness.  */\tD(printf(\"%s ch=%d addr=\" TARGET_FMT_plx \"\\n\", __func__, c, addr));\tcpu_physical_memory_read (addr,\t\t\t\t  (void *) &ctrl->channels[c].current_d, \t\t\t\t  sizeof ctrl->channels[c].current_d);\tD(dump_d(c, &ctrl->channels[c].current_d));\tctrl->channels[c].regs[RW_DATA] = addr;}", "idx": 12876}
{"project": "FFmpeg", "commit_id": "cac8de2da5c4935773128335c11b806faa73e19d", "target": 1, "function": "int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src){    const AVCodec *orig_codec = dest->codec;    uint8_t *orig_priv_data = dest->priv_data;    if (avcodec_is_open(dest)) { // check that the dest context is uninitialized        av_log(dest, AV_LOG_ERROR,               \"Tried to copy AVCodecContext %p into already-initialized %p\\n\",               src, dest);        return AVERROR(EINVAL);    }    copy_context_reset(dest);    memcpy(dest, src, sizeof(*dest));    av_opt_copy(dest, src);    dest->priv_data       = orig_priv_data;    dest->codec           = orig_codec;    if (orig_priv_data && src->codec && src->codec->priv_class &&        dest->codec && dest->codec->priv_class)        av_opt_copy(orig_priv_data, src->priv_data);    /* set values specific to opened codecs back to their default state */    dest->slice_offset    = NULL;    dest->hwaccel         = NULL;    dest->internal        = NULL;#if FF_API_CODED_FRAMEFF_DISABLE_DEPRECATION_WARNINGS    dest->coded_frame     = NULL;FF_ENABLE_DEPRECATION_WARNINGS#endif    /* reallocate values that should be allocated separately */    dest->extradata       = NULL;    dest->intra_matrix    = NULL;    dest->inter_matrix    = NULL;    dest->rc_override     = NULL;    dest->subtitle_header = NULL;    dest->hw_frames_ctx   = NULL;#define alloc_and_copy_or_fail(obj, size, pad) \\    if (src->obj && size > 0) { \\        dest->obj = av_malloc(size + pad); \\        if (!dest->obj) \\            goto fail; \\        memcpy(dest->obj, src->obj, size); \\        if (pad) \\            memset(((uint8_t *) dest->obj) + size, 0, pad); \\    }    alloc_and_copy_or_fail(extradata,    src->extradata_size,                           AV_INPUT_BUFFER_PADDING_SIZE);    dest->extradata_size  = src->extradata_size;    alloc_and_copy_or_fail(intra_matrix, 64 * sizeof(int16_t), 0);    alloc_and_copy_or_fail(inter_matrix, 64 * sizeof(int16_t), 0);    alloc_and_copy_or_fail(rc_override,  src->rc_override_count * sizeof(*src->rc_override), 0);    alloc_and_copy_or_fail(subtitle_header, src->subtitle_header_size, 1);    av_assert0(dest->subtitle_header_size == src->subtitle_header_size);#undef alloc_and_copy_or_fail    if (src->hw_frames_ctx) {        dest->hw_frames_ctx = av_buffer_ref(src->hw_frames_ctx);        if (!dest->hw_frames_ctx)            goto fail;    }    return 0;fail:    copy_context_reset(dest);    return AVERROR(ENOMEM);}", "idx": 12926}
{"project": "FFmpeg", "commit_id": "473f0f75a16b4d37bdaa943f75e4ae249212c1ba", "target": 1, "function": "static int thread_execute(AVFilterContext *ctx, avfilter_action_func *func,                          void *arg, int *ret, int nb_jobs){    ThreadContext *c = ctx->graph->internal->thread;    int dummy_ret;    if (nb_jobs <= 0)        return 0;    pthread_mutex_lock(&c->current_job_lock);    c->current_job = c->nb_threads;    c->nb_jobs     = nb_jobs;    c->ctx         = ctx;    c->arg         = arg;    c->func        = func;    if (ret) {        c->rets    = ret;        c->nb_rets = nb_jobs;    } else {        c->rets    = &dummy_ret;        c->nb_rets = 1;    }    c->current_execute++;    pthread_cond_broadcast(&c->current_job_cond);    slice_thread_park_workers(c);    return 0;}", "idx": 12930}
{"project": "FFmpeg", "commit_id": "0ad5ef674b65fe87bb948e1c200f0c320db2f869", "target": 1, "function": "static void calc_diffs(const DecimateContext *dm, struct qitem *q,                       const AVFrame *f1, const AVFrame *f2){    int64_t maxdiff = -1;    int64_t *bdiffs = dm->bdiffs;    int plane, i, j;    memset(bdiffs, 0, dm->bdiffsize * sizeof(*bdiffs));    for (plane = 0; plane < (dm->chroma ? 3 : 1); plane++) {        int x, y, xl;        const int linesize1 = f1->linesize[plane];        const int linesize2 = f2->linesize[plane];        const uint8_t *f1p = f1->data[plane];        const uint8_t *f2p = f2->data[plane];        int width    = plane ? FF_CEIL_RSHIFT(f1->width,  dm->hsub) : f1->width;        int height   = plane ? FF_CEIL_RSHIFT(f1->height, dm->vsub) : f1->height;        int hblockx  = dm->blockx / 2;        int hblocky  = dm->blocky / 2;        if (plane) {            hblockx >>= dm->hsub;            hblocky >>= dm->vsub;        }        for (y = 0; y < height; y++) {            int ydest = y / hblocky;            int xdest = 0;#define CALC_DIFF(nbits) do {                               \\    for (x = 0; x < width; x += hblockx) {                  \\        int64_t acc = 0;                                    \\        int m = FFMIN(width, x + hblockx);                  \\        for (xl = x; xl < m; xl++)                          \\            acc += abs(((const uint##nbits##_t *)f1p)[xl] - \\                       ((const uint##nbits##_t *)f2p)[xl]); \\        bdiffs[ydest * dm->nxblocks + xdest] += acc;        \\        xdest++;                                            \\    }                                                       \\} while (0)            if (dm->depth == 8) CALC_DIFF(8);            else                CALC_DIFF(16);            f1p += linesize1;            f2p += linesize2;        }    }    for (i = 0; i < dm->nyblocks - 1; i++) {        for (j = 0; j < dm->nxblocks - 1; j++) {            int64_t tmp = bdiffs[      i * dm->nxblocks + j    ]                        + bdiffs[      i * dm->nxblocks + j + 1]                        + bdiffs[(i + 1) * dm->nxblocks + j    ]                        + bdiffs[(i + 1) * dm->nxblocks + j + 1];            if (tmp > maxdiff)                maxdiff = tmp;        }    }    q->totdiff = 0;    for (i = 0; i < dm->bdiffsize; i++)        q->totdiff += bdiffs[i];    q->maxbdiff = maxdiff;}", "idx": 12938}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "function": "int ffio_read_indirect(AVIOContext *s, unsigned char *buf, int size, unsigned char **data){    if (s->buf_end - s->buf_ptr >= size && !s->write_flag) {        *data = s->buf_ptr;        s->buf_ptr += size;        return size;    } else {        *data = buf;        return avio_read(s, buf, size);    }}", "idx": 12947}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static inline void t_gen_swapr(TCGv d, TCGv s){\tstruct {\t\tint shift; /* LSL when positive, LSR when negative.  */\t\tuint32_t mask;\t} bitrev [] = {\t\t{7, 0x80808080},\t\t{5, 0x40404040},\t\t{3, 0x20202020},\t\t{1, 0x10101010},\t\t{-1, 0x08080808},\t\t{-3, 0x04040404},\t\t{-5, 0x02020202},\t\t{-7, 0x01010101}\t};\tint i;\tTCGv t, org_s;\t/* d and s refer the same object.  */\tt = tcg_temp_new(TCG_TYPE_TL);\torg_s = tcg_temp_new(TCG_TYPE_TL);\ttcg_gen_mov_tl(org_s, s);\ttcg_gen_shli_tl(t, org_s,  bitrev[0].shift);\ttcg_gen_andi_tl(d, t,  bitrev[0].mask);\tfor (i = 1; i < sizeof bitrev / sizeof bitrev[0]; i++) {\t\tif (bitrev[i].shift >= 0) {\t\t\ttcg_gen_shli_tl(t, org_s,  bitrev[i].shift);\t\t} else {\t\t\ttcg_gen_shri_tl(t, org_s,  -bitrev[i].shift);\t\t}\t\ttcg_gen_andi_tl(t, t,  bitrev[i].mask);\t\ttcg_gen_or_tl(d, d, t);\t}\ttcg_temp_free(t);\ttcg_temp_free(org_s);}", "idx": 13008}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint32_t slow_bar_readw(void *opaque, target_phys_addr_t addr){    AssignedDevRegion *d = opaque;    uint16_t *in = (uint16_t *)(d->u.r_virtbase + addr);    uint32_t r;    r = *in;    DEBUG(\"slow_bar_readl addr=0x\" TARGET_FMT_plx \" val=0x%08x\\n\", addr, r);    return r;}", "idx": 13018}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "function": "static av_always_inline void idct(uint8_t *dst, int stride, int16_t *input, int type){    int16_t *ip = input;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    int A, B, C, D, Ad, Bd, Cd, Dd, E, F, G, H;    int Ed, Gd, Add, Bdd, Fd, Hd;    int i;    /* Inverse DCT on the rows now */    for (i = 0; i < 8; i++) {        /* Check for non-zero values */        if ( ip[0] | ip[1] | ip[2] | ip[3] | ip[4] | ip[5] | ip[6] | ip[7] ) {            A = M(xC1S7, ip[1]) + M(xC7S1, ip[7]);            B = M(xC7S1, ip[1]) - M(xC1S7, ip[7]);            C = M(xC3S5, ip[3]) + M(xC5S3, ip[5]);            D = M(xC3S5, ip[5]) - M(xC5S3, ip[3]);            Ad = M(xC4S4, (A - C));            Bd = M(xC4S4, (B - D));            Cd = A + C;            Dd = B + D;            E = M(xC4S4, (ip[0] + ip[4]));            F = M(xC4S4, (ip[0] - ip[4]));            G = M(xC2S6, ip[2]) + M(xC6S2, ip[6]);            H = M(xC6S2, ip[2]) - M(xC2S6, ip[6]);            Ed = E - G;            Gd = E + G;            Add = F + Ad;            Bdd = Bd - H;            Fd = F - Ad;            Hd = Bd + H;            /*  Final sequence of operations over-write original inputs. */            ip[0] = Gd + Cd ;            ip[7] = Gd - Cd ;            ip[1] = Add + Hd;            ip[2] = Add - Hd;            ip[3] = Ed + Dd ;            ip[4] = Ed - Dd ;            ip[5] = Fd + Bdd;            ip[6] = Fd - Bdd;        }        ip += 8;            /* next row */    }    ip = input;    for ( i = 0; i < 8; i++) {        /* Check for non-zero values (bitwise or faster than ||) */        if ( ip[1 * 8] | ip[2 * 8] | ip[3 * 8] |             ip[4 * 8] | ip[5 * 8] | ip[6 * 8] | ip[7 * 8] ) {            A = M(xC1S7, ip[1*8]) + M(xC7S1, ip[7*8]);            B = M(xC7S1, ip[1*8]) - M(xC1S7, ip[7*8]);            C = M(xC3S5, ip[3*8]) + M(xC5S3, ip[5*8]);            D = M(xC3S5, ip[5*8]) - M(xC5S3, ip[3*8]);            Ad = M(xC4S4, (A - C));            Bd = M(xC4S4, (B - D));            Cd = A + C;            Dd = B + D;            E = M(xC4S4, (ip[0*8] + ip[4*8])) + 8;            F = M(xC4S4, (ip[0*8] - ip[4*8])) + 8;            if(type==1){  //HACK                E += 16*128;                F += 16*128;            }            G = M(xC2S6, ip[2*8]) + M(xC6S2, ip[6*8]);            H = M(xC6S2, ip[2*8]) - M(xC2S6, ip[6*8]);            Ed = E - G;            Gd = E + G;            Add = F + Ad;            Bdd = Bd - H;            Fd = F - Ad;            Hd = Bd + H;            /* Final sequence of operations over-write original inputs. */            if(type==0){                ip[0*8] = (Gd + Cd )  >> 4;                ip[7*8] = (Gd - Cd )  >> 4;                ip[1*8] = (Add + Hd ) >> 4;                ip[2*8] = (Add - Hd ) >> 4;                ip[3*8] = (Ed + Dd )  >> 4;                ip[4*8] = (Ed - Dd )  >> 4;                ip[5*8] = (Fd + Bdd ) >> 4;                ip[6*8] = (Fd - Bdd ) >> 4;            }else if(type==1){                dst[0*stride] = cm[(Gd + Cd )  >> 4];                dst[7*stride] = cm[(Gd - Cd )  >> 4];                dst[1*stride] = cm[(Add + Hd ) >> 4];                dst[2*stride] = cm[(Add - Hd ) >> 4];                dst[3*stride] = cm[(Ed + Dd )  >> 4];                dst[4*stride] = cm[(Ed - Dd )  >> 4];                dst[5*stride] = cm[(Fd + Bdd ) >> 4];                dst[6*stride] = cm[(Fd - Bdd ) >> 4];            }else{                dst[0*stride] = cm[dst[0*stride] + ((Gd + Cd )  >> 4)];                dst[7*stride] = cm[dst[7*stride] + ((Gd - Cd )  >> 4)];                dst[1*stride] = cm[dst[1*stride] + ((Add + Hd ) >> 4)];                dst[2*stride] = cm[dst[2*stride] + ((Add - Hd ) >> 4)];                dst[3*stride] = cm[dst[3*stride] + ((Ed + Dd )  >> 4)];                dst[4*stride] = cm[dst[4*stride] + ((Ed - Dd )  >> 4)];                dst[5*stride] = cm[dst[5*stride] + ((Fd + Bdd ) >> 4)];                dst[6*stride] = cm[dst[6*stride] + ((Fd - Bdd ) >> 4)];            }        } else {            if(type==0){                ip[0*8] =                ip[1*8] =                ip[2*8] =                ip[3*8] =                ip[4*8] =                ip[5*8] =                ip[6*8] =                ip[7*8] = ((xC4S4 * ip[0*8] + (IdctAdjustBeforeShift<<16))>>20);            }else if(type==1){                dst[0*stride]=                dst[1*stride]=                dst[2*stride]=                dst[3*stride]=                dst[4*stride]=                dst[5*stride]=                dst[6*stride]=                dst[7*stride]= cm[128 + ((xC4S4 * ip[0*8] + (IdctAdjustBeforeShift<<16))>>20)];            }else{                if(ip[0*8]){                    int v= ((xC4S4 * ip[0*8] + (IdctAdjustBeforeShift<<16))>>20);                    dst[0*stride] = cm[dst[0*stride] + v];                    dst[1*stride] = cm[dst[1*stride] + v];                    dst[2*stride] = cm[dst[2*stride] + v];                    dst[3*stride] = cm[dst[3*stride] + v];                    dst[4*stride] = cm[dst[4*stride] + v];                    dst[5*stride] = cm[dst[5*stride] + v];                    dst[6*stride] = cm[dst[6*stride] + v];                    dst[7*stride] = cm[dst[7*stride] + v];                }            }        }        ip++;            /* next column */        dst++;    }}", "idx": 13020}
{"project": "qemu", "commit_id": "f689d2811a36894618087e1e2cc3ade78e758e94", "target": 1, "function": "static uint64_t ivshmem_io_read(void *opaque, hwaddr addr,                                unsigned size){    IVShmemState *s = opaque;    uint32_t ret;    switch (addr)    {        case INTRMASK:            ret = ivshmem_IntrMask_read(s);            break;        case INTRSTATUS:            ret = ivshmem_IntrStatus_read(s);            break;        case IVPOSITION:            /* return my VM ID if the memory is mapped */            if (s->shm_fd >= 0) {                ret = s->vm_id;            } else {                ret = -1;            }            break;        default:            IVSHMEM_DPRINTF(\"why are we reading \" TARGET_FMT_plx \"\\n\", addr);            ret = 0;    }    return ret;}", "idx": 13029}
{"project": "qemu", "commit_id": "ff1d2ac949dc94d8a0e71fd46939fb69c2ef075b", "target": 1, "function": "static void mcf_fec_enable_rx(mcf_fec_state *s){    mcf_fec_bd bd;    mcf_fec_read_bd(&bd, s->rx_descriptor);    s->rx_enabled = ((bd.flags & FEC_BD_E) != 0);    if (!s->rx_enabled)        DPRINTF(\"RX buffer full\\n\");}", "idx": 13030}
{"project": "qemu", "commit_id": "75e347d66ab81944b5b657d17cc90ef92af3f016", "target": 1, "function": "static int enable_write_target(BDRVVVFATState *s, Error **errp){    BlockDriver *bdrv_qcow;    QEMUOptionParameter *options;    int ret;    int size = sector2cluster(s, s->sector_count);    s->used_clusters = calloc(size, 1);    array_init(&(s->commits), sizeof(commit_t));    s->qcow_filename = g_malloc(1024);    ret = get_tmp_filename(s->qcow_filename, 1024);    if (ret < 0) {        error_setg_errno(errp, -ret, \"can't create temporary file\");        goto err;    }    bdrv_qcow = bdrv_find_format(\"qcow\");    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");    ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, errp);    if (ret < 0) {        goto err;    }    s->qcow = NULL;    ret = bdrv_open(&s->qcow, s->qcow_filename, NULL, NULL,                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH,                    bdrv_qcow, errp);    if (ret < 0) {        goto err;    }#ifndef _WIN32    unlink(s->qcow_filename);#endif    bdrv_set_backing_hd(s->bs, bdrv_new(\"\", &error_abort));    s->bs->backing_hd->drv = &vvfat_write_target;    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));    *(void**)s->bs->backing_hd->opaque = s;    return 0;err:    g_free(s->qcow_filename);    s->qcow_filename = NULL;    return ret;}", "idx": 13036}
{"project": "qemu", "commit_id": "ba9bc59e1f5dc91caf35e0ef08da137b3a5e7386", "target": 0, "function": "int kvm_arch_init_vcpu(CPUState *env){    struct {        struct kvm_cpuid2 cpuid;        struct kvm_cpuid_entry2 entries[100];    } __attribute__((packed)) cpuid_data;    uint32_t limit, i, j, cpuid_i;    uint32_t unused;    struct kvm_cpuid_entry2 *c;    uint32_t signature[3];    env->cpuid_features &= kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);    i = env->cpuid_ext_features & CPUID_EXT_HYPERVISOR;    env->cpuid_ext_features &= kvm_arch_get_supported_cpuid(env, 1, 0, R_ECX);    env->cpuid_ext_features |= i;    env->cpuid_ext2_features &= kvm_arch_get_supported_cpuid(env, 0x80000001,                                                             0, R_EDX);    env->cpuid_ext3_features &= kvm_arch_get_supported_cpuid(env, 0x80000001,                                                             0, R_ECX);    env->cpuid_svm_features  &= kvm_arch_get_supported_cpuid(env, 0x8000000A,                                                             0, R_EDX);    cpuid_i = 0;    /* Paravirtualization CPUIDs */    memcpy(signature, \"KVMKVMKVM\\0\\0\\0\", 12);    c = &cpuid_data.entries[cpuid_i++];    memset(c, 0, sizeof(*c));    c->function = KVM_CPUID_SIGNATURE;    c->eax = 0;    c->ebx = signature[0];    c->ecx = signature[1];    c->edx = signature[2];    c = &cpuid_data.entries[cpuid_i++];    memset(c, 0, sizeof(*c));    c->function = KVM_CPUID_FEATURES;    c->eax = env->cpuid_kvm_features & kvm_arch_get_supported_cpuid(env,                                                KVM_CPUID_FEATURES, 0, R_EAX);    has_msr_async_pf_en = c->eax & (1 << KVM_FEATURE_ASYNC_PF);    cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);    for (i = 0; i <= limit; i++) {        c = &cpuid_data.entries[cpuid_i++];        switch (i) {        case 2: {            /* Keep reading function 2 till all the input is received */            int times;            c->function = i;            c->flags = KVM_CPUID_FLAG_STATEFUL_FUNC |                       KVM_CPUID_FLAG_STATE_READ_NEXT;            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);            times = c->eax & 0xff;            for (j = 1; j < times; ++j) {                c = &cpuid_data.entries[cpuid_i++];                c->function = i;                c->flags = KVM_CPUID_FLAG_STATEFUL_FUNC;                cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);            }            break;        }        case 4:        case 0xb:        case 0xd:            for (j = 0; ; j++) {                c->function = i;                c->flags = KVM_CPUID_FLAG_SIGNIFCANT_INDEX;                c->index = j;                cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);                if (i == 4 && c->eax == 0) {                    break;                }                if (i == 0xb && !(c->ecx & 0xff00)) {                    break;                }                if (i == 0xd && c->eax == 0) {                    break;                }                c = &cpuid_data.entries[cpuid_i++];            }            break;        default:            c->function = i;            c->flags = 0;            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);            break;        }    }    cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);    for (i = 0x80000000; i <= limit; i++) {        c = &cpuid_data.entries[cpuid_i++];        c->function = i;        c->flags = 0;        cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);    }    /* Call Centaur's CPUID instructions they are supported. */    if (env->cpuid_xlevel2 > 0) {        env->cpuid_ext4_features &=            kvm_arch_get_supported_cpuid(env, 0xC0000001, 0, R_EDX);        cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);        for (i = 0xC0000000; i <= limit; i++) {            c = &cpuid_data.entries[cpuid_i++];            c->function = i;            c->flags = 0;            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);        }    }    cpuid_data.cpuid.nent = cpuid_i;    if (((env->cpuid_version >> 8)&0xF) >= 6        && (env->cpuid_features&(CPUID_MCE|CPUID_MCA)) == (CPUID_MCE|CPUID_MCA)        && kvm_check_extension(env->kvm_state, KVM_CAP_MCE) > 0) {        uint64_t mcg_cap;        int banks;        int ret;        ret = kvm_get_mce_cap_supported(env->kvm_state, &mcg_cap, &banks);        if (ret < 0) {            fprintf(stderr, \"kvm_get_mce_cap_supported: %s\", strerror(-ret));            return ret;        }        if (banks > MCE_BANKS_DEF) {            banks = MCE_BANKS_DEF;        }        mcg_cap &= MCE_CAP_DEF;        mcg_cap |= banks;        ret = kvm_vcpu_ioctl(env, KVM_X86_SETUP_MCE, &mcg_cap);        if (ret < 0) {            fprintf(stderr, \"KVM_X86_SETUP_MCE: %s\", strerror(-ret));            return ret;        }        env->mcg_cap = mcg_cap;    }    qemu_add_vm_change_state_handler(cpu_update_state, env);    return kvm_vcpu_ioctl(env, KVM_SET_CPUID2, &cpuid_data);}", "idx": 13168}
{"project": "qemu", "commit_id": "1687a089f103f9b7a1b4a1555068054cb46ee9e9", "target": 0, "function": "VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_RET_CORUPT)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_BUF_END_BEFORE_LE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_INVALID_FILE_SELECTED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_FCI_FORMAT_INVALID)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_CHANGE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_WARNING_FILE_FILLED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_EXC_ERROR)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_EXC_ERROR_CHANGE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_WRONG_LENGTH)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_CLA_NOT_SUPPORTED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_CHANNEL_NOT_SUPPORTED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED)VCARD_RESPONSE_NEW_STATIC_STATUS(                    VCARD7816_STATUS_ERROR_COMMAND_INCOMPATIBLE_WITH_FILE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_SECURITY_NOT_SATISFIED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_AUTHENTICATION_BLOCKED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_DATA_INVALID)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_CONDITION_NOT_SATISFIED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_DATA_NO_EF)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_SM_OBJECT_MISSING)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_SM_OBJECT_INCORRECT)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_WRONG_PARAMETERS)VCARD_RESPONSE_NEW_STATIC_STATUS(                            VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_IN_DATA)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_FILE_NOT_FOUND)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_RECORD_NOT_FOUND)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_NO_SPACE_FOR_FILE)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_LC_TLV_INCONSISTENT)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_P1_P2_INCORRECT)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_LC_P1_P2_INCONSISTENT)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_DATA_NOT_FOUND)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_2)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_INS_CODE_INVALID)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_CLA_INVALID)VCARD_RESPONSE_NEW_STATIC_STATUS(VCARD7816_STATUS_ERROR_GENERAL)/* * return a single response code. This function cannot fail. It will always * return a response. */VCardResponse *vcard_make_response(vcard_7816_status_t status){    VCardResponse *response = NULL;    switch (status) {    /* known 7816 response codes */    case VCARD7816_STATUS_SUCCESS:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_SUCCESS);    case VCARD7816_STATUS_WARNING:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING);    case VCARD7816_STATUS_WARNING_RET_CORUPT:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_RET_CORUPT);    case VCARD7816_STATUS_WARNING_BUF_END_BEFORE_LE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_BUF_END_BEFORE_LE);    case VCARD7816_STATUS_WARNING_INVALID_FILE_SELECTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_INVALID_FILE_SELECTED);    case VCARD7816_STATUS_WARNING_FCI_FORMAT_INVALID:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_FCI_FORMAT_INVALID);    case VCARD7816_STATUS_WARNING_CHANGE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_CHANGE);    case VCARD7816_STATUS_WARNING_FILE_FILLED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_WARNING_FILE_FILLED);    case VCARD7816_STATUS_EXC_ERROR:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_EXC_ERROR);    case VCARD7816_STATUS_EXC_ERROR_CHANGE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_EXC_ERROR_CHANGE);    case VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);    case VCARD7816_STATUS_ERROR_WRONG_LENGTH:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_WRONG_LENGTH);    case VCARD7816_STATUS_ERROR_CLA_NOT_SUPPORTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_CLA_NOT_SUPPORTED);    case VCARD7816_STATUS_ERROR_CHANNEL_NOT_SUPPORTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_CHANNEL_NOT_SUPPORTED);    case VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_SECURE_NOT_SUPPORTED);    case VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_COMMAND_NOT_SUPPORTED);    case VCARD7816_STATUS_ERROR_COMMAND_INCOMPATIBLE_WITH_FILE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_COMMAND_INCOMPATIBLE_WITH_FILE);    case VCARD7816_STATUS_ERROR_SECURITY_NOT_SATISFIED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_SECURITY_NOT_SATISFIED);    case VCARD7816_STATUS_ERROR_AUTHENTICATION_BLOCKED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_AUTHENTICATION_BLOCKED);    case VCARD7816_STATUS_ERROR_DATA_INVALID:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_DATA_INVALID);    case VCARD7816_STATUS_ERROR_CONDITION_NOT_SATISFIED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_CONDITION_NOT_SATISFIED);    case VCARD7816_STATUS_ERROR_DATA_NO_EF:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_DATA_NO_EF);    case VCARD7816_STATUS_ERROR_SM_OBJECT_MISSING:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_SM_OBJECT_MISSING);    case VCARD7816_STATUS_ERROR_SM_OBJECT_INCORRECT:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_SM_OBJECT_INCORRECT);    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS);    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_IN_DATA:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_IN_DATA);    case VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_FUNCTION_NOT_SUPPORTED);    case VCARD7816_STATUS_ERROR_FILE_NOT_FOUND:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_FILE_NOT_FOUND);    case VCARD7816_STATUS_ERROR_RECORD_NOT_FOUND:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_RECORD_NOT_FOUND);    case VCARD7816_STATUS_ERROR_NO_SPACE_FOR_FILE:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_NO_SPACE_FOR_FILE);    case VCARD7816_STATUS_ERROR_LC_TLV_INCONSISTENT:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_LC_TLV_INCONSISTENT);    case VCARD7816_STATUS_ERROR_P1_P2_INCORRECT:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_P1_P2_INCORRECT);    case VCARD7816_STATUS_ERROR_LC_P1_P2_INCONSISTENT:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_LC_P1_P2_INCONSISTENT);    case VCARD7816_STATUS_ERROR_DATA_NOT_FOUND:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_DATA_NOT_FOUND);    case VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_2:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_WRONG_PARAMETERS_2);    case VCARD7816_STATUS_ERROR_INS_CODE_INVALID:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_INS_CODE_INVALID);    case VCARD7816_STATUS_ERROR_CLA_INVALID:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_CLA_INVALID);    case VCARD7816_STATUS_ERROR_GENERAL:        return VCARD_RESPONSE_GET_STATIC(                    VCARD7816_STATUS_ERROR_GENERAL);    default:        /* we don't know this status code, create a response buffer to         * hold it */        response = vcard_response_new_status(status);        if (response == NULL) {            /* couldn't allocate the buffer, return memmory error */            return VCARD_RESPONSE_GET_STATIC(                        VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE);        }    }    assert(response);    return response;}", "idx": 13173}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "function": "void qemu_map_cache_init(void){    unsigned long size;    struct rlimit rlimit_as;    mapcache = qemu_mallocz(sizeof (MapCache));    QTAILQ_INIT(&mapcache->locked_entries);    mapcache->last_address_index = -1;    getrlimit(RLIMIT_AS, &rlimit_as);    rlimit_as.rlim_cur = rlimit_as.rlim_max;    setrlimit(RLIMIT_AS, &rlimit_as);    mapcache->max_mcache_size = rlimit_as.rlim_max;    mapcache->nr_buckets =        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));    size = mapcache->nr_buckets * sizeof (MapCacheEntry);    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);    DPRINTF(\"qemu_map_cache_init, nr_buckets = %lx size %lu\\n\", mapcache->nr_buckets, size);    mapcache->entry = qemu_mallocz(size);}", "idx": 13183}
{"project": "FFmpeg", "commit_id": "81230e2612a9c88e5b35ed2f67d828450cc50abf", "target": 0, "function": "static int msmpeg4_decode_dc(MpegEncContext * s, int n, int *dir_ptr){    int level, pred;    if(s->msmpeg4_version<=2){        if (n < 4) {            level = get_vlc2(&s->gb, v2_dc_lum_vlc.table, DC_VLC_BITS, 3);        } else {            level = get_vlc2(&s->gb, v2_dc_chroma_vlc.table, DC_VLC_BITS, 3);        }        if (level < 0)            return -1;        level-=256;    }else{  //FIXME optimize use unified tables & index        if (n < 4) {            level = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);        } else {            level = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3);        }        if (level < 0){            av_log(s->avctx, AV_LOG_ERROR, \"illegal dc vlc\\n\");            return -1;        }        if (level == DC_MAX) {            level = get_bits(&s->gb, 8);            if (get_bits1(&s->gb))                level = -level;        } else if (level != 0) {            if (get_bits1(&s->gb))                level = -level;        }    }    if(s->msmpeg4_version==1){        int32_t *dc_val;        pred = msmpeg4v1_pred_dc(s, n, &dc_val);        level += pred;        /* update predictor */        *dc_val= level;    }else{        int16_t *dc_val;        pred   = ff_msmpeg4_pred_dc(s, n, &dc_val, dir_ptr);        level += pred;        /* update predictor */        if (n < 4) {            *dc_val = level * s->y_dc_scale;        } else {            *dc_val = level * s->c_dc_scale;        }    }    return level;}", "idx": 13196}
{"project": "qemu", "commit_id": "f7c40aa1e7feb50bc4d4bc171fa811bdd9a93e51", "target": 1, "function": "void s390_pci_iommu_enable(S390PCIBusDevice *pbdev){    uint64_t size = pbdev->pal - pbdev->pba + 1;    memory_region_init_iommu(&pbdev->iommu_mr, OBJECT(&pbdev->mr),                             &s390_iommu_ops, \"iommu-s390\", size);    memory_region_add_subregion(&pbdev->mr, pbdev->pba, &pbdev->iommu_mr);    pbdev->iommu_enabled = true;}", "idx": 13233}
{"project": "qemu", "commit_id": "d510c5cf343eabd4d3a301f5730af724747b7055", "target": 1, "function": "QemuOpts *qemu_opts_parse(QemuOptsList *list, const char *params,                          int permit_abbrev){    const char *firstname;    char value[1024], *id = NULL;    const char *p;    QemuOpts *opts;    assert(!permit_abbrev || list->implied_opt_name);    firstname = permit_abbrev ? list->implied_opt_name : NULL;    if (strncmp(params, \"id=\", 3) == 0) {        get_opt_value(value, sizeof(value), params+3);        id = qemu_strdup(value);    } else if ((p = strstr(params, \",id=\")) != NULL) {        get_opt_value(value, sizeof(value), p+4);        id = qemu_strdup(value);    }    opts = qemu_opts_create(list, id, 1);    if (opts == NULL)        return NULL;    if (qemu_opts_do_parse(opts, params, firstname) != 0) {        qemu_opts_del(opts);        return NULL;    }    return opts;}", "idx": 13237}
{"project": "qemu", "commit_id": "6516367fc0803d079384e0ad370856ac328bef30", "target": 1, "function": "static void generic_loader_realize(DeviceState *dev, Error **errp){    GenericLoaderState *s = GENERIC_LOADER(dev);    hwaddr entry;    int big_endian;    int size = 0;    s->set_pc = false;    /* Perform some error checking on the user's options */    if (s->data || s->data_len  || s->data_be) {        /* User is loading memory values */        if (s->file) {            error_setg(errp, \"Specifying a file is not supported when loading \"                       \"memory values\");            return;        } else if (s->force_raw) {            error_setg(errp, \"Specifying force-raw is not supported when \"                       \"loading memory values\");            return;        } else if (!s->data_len) {            /* We can't check for !data here as a value of 0 is still valid. */            error_setg(errp, \"Both data and data-len must be specified\");            return;        } else if (s->data_len > 8) {            error_setg(errp, \"data-len cannot be greater then 8 bytes\");            return;        }    } else if (s->file || s->force_raw)  {        /* User is loading an image */        if (s->data || s->data_len || s->data_be) {            error_setg(errp, \"data can not be specified when loading an \"                       \"image\");            return;        }        /* The user specified a file, only set the PC if they also specified         * a CPU to use.         */        if (s->cpu_num != CPU_NONE) {            s->set_pc = true;        }    } else if (s->addr) {        /* User is setting the PC */        if (s->data || s->data_len || s->data_be) {            error_setg(errp, \"data can not be specified when setting a \"                       \"program counter\");            return;        } else if (!s->cpu_num) {            error_setg(errp, \"cpu_num must be specified when setting a \"                       \"program counter\");            return;        }        s->set_pc = true;    } else {        /* Did the user specify anything? */        error_setg(errp, \"please include valid arguments\");        return;    }    qemu_register_reset(generic_loader_reset, dev);    if (s->cpu_num != CPU_NONE) {        s->cpu = qemu_get_cpu(s->cpu_num);        if (!s->cpu) {            error_setg(errp, \"Specified boot CPU#%d is nonexistent\",                       s->cpu_num);            return;        }    } else {        s->cpu = first_cpu;    }#ifdef TARGET_WORDS_BIGENDIAN    big_endian = 1;#else    big_endian = 0;#endif    if (s->file) {        if (!s->force_raw) {            size = load_elf_as(s->file, NULL, NULL, &entry, NULL, NULL,                               big_endian, 0, 0, 0, s->cpu->as);            if (size < 0) {                size = load_uimage_as(s->file, &entry, NULL, NULL, NULL, NULL,                                      s->cpu->as);            }        }        if (size < 0 || s->force_raw) {            /* Default to the maximum size being the machine's ram size */            size = load_image_targphys_as(s->file, s->addr, ram_size,                                          s->cpu->as);        } else {            s->addr = entry;        }        if (size < 0) {            error_setg(errp, \"Cannot load specified image %s\", s->file);            return;        }    }    /* Convert the data endiannes */    if (s->data_be) {        s->data = cpu_to_be64(s->data);    } else {        s->data = cpu_to_le64(s->data);    }}", "idx": 13296}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "function": "static void gen_mfsrin(DisasContext *ctx){#if defined(CONFIG_USER_ONLY)    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);#else    TCGv t0;    if (unlikely(ctx->pr)) {        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);        return;    }    t0 = tcg_temp_new();    tcg_gen_shri_tl(t0, cpu_gpr[rB(ctx->opcode)], 28);    tcg_gen_andi_tl(t0, t0, 0xF);    gen_helper_load_sr(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);    tcg_temp_free(t0);#endif}", "idx": 13301}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "function": "opts_check_struct(Visitor *v, Error **errp){    OptsVisitor *ov = to_ov(v);    GHashTableIter iter;    GQueue *any;    if (ov->depth > 0) {        return;    }    /* we should have processed all (distinct) QemuOpt instances */    g_hash_table_iter_init(&iter, ov->unprocessed_opts);    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {        const QemuOpt *first;        first = g_queue_peek_head(any);        error_setg(errp, QERR_INVALID_PARAMETER, first->name);    }}", "idx": 13337}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "function": "static void vaapi_encode_h264_write_sei(PutBitContext *pbc,                                        VAAPIEncodeContext *ctx,                                        VAAPIEncodePicture *pic){    VAAPIEncodeH264Context *priv = ctx->priv_data;    PutBitContext payload_bits;    char payload[256];    int payload_type, payload_size, i;    void (*write_payload)(PutBitContext *pbc,                          VAAPIEncodeContext *ctx,                          VAAPIEncodePicture *pic) = NULL;    vaapi_encode_h264_write_nal_header(pbc, NAL_SEI, 0);    for (payload_type = 0; payload_type < 64; payload_type++) {        switch (payload_type) {        case SEI_TYPE_BUFFERING_PERIOD:            if (!priv->send_timing_sei ||                pic->type != PICTURE_TYPE_IDR)                continue;            write_payload = &vaapi_encode_h264_write_buffering_period;            break;        case SEI_TYPE_PIC_TIMING:            if (!priv->send_timing_sei)                continue;            write_payload = &vaapi_encode_h264_write_pic_timing;            break;        case SEI_TYPE_USER_DATA_UNREGISTERED:            if (pic->encode_order != 0)                continue;            write_payload = &vaapi_encode_h264_write_identifier;            break;        default:            continue;        }        init_put_bits(&payload_bits, payload, sizeof(payload));        write_payload(&payload_bits, ctx, pic);        if (put_bits_count(&payload_bits) & 7) {            write_u(&payload_bits, 1, 1, bit_equal_to_one);            while (put_bits_count(&payload_bits) & 7)                write_u(&payload_bits, 1, 0, bit_equal_to_zero);        }        payload_size = put_bits_count(&payload_bits) / 8;        flush_put_bits(&payload_bits);        u(8, payload_type, last_payload_type_byte);        u(8, payload_size, last_payload_size_byte);        for (i = 0; i < payload_size; i++)            u(8, payload[i] & 0xff, sei_payload);    }    vaapi_encode_h264_write_trailing_rbsp(pbc);}", "idx": 13391}
{"project": "FFmpeg", "commit_id": "92ea249d7db4baf64680f412c6bd99ff85860723", "target": 0, "function": "static inline int round_sample(int64_t *sum){    int sum1;    sum1 = (int)((*sum) >> OUT_SHIFT);    *sum &= (1<<OUT_SHIFT)-1;    return av_clip(sum1, OUT_MIN, OUT_MAX);}", "idx": 13403}
{"project": "FFmpeg", "commit_id": "5e885275f1eda3f0281747d9c78d072adb8bc940", "target": 1, "function": "int ff_MPV_lowest_referenced_row(MpegEncContext *s, int dir){    int my_max = INT_MIN, my_min = INT_MAX, qpel_shift = !s->quarter_sample;    int my, off, i, mvs;    if (s->picture_structure != PICT_FRAME) goto unhandled;    switch (s->mv_type) {        case MV_TYPE_16X16:            mvs = 1;            break;        case MV_TYPE_16X8:            mvs = 2;            break;        case MV_TYPE_8X8:            mvs = 4;            break;        default:            goto unhandled;    }    for (i = 0; i < mvs; i++) {        my = s->mv[dir][i][1]<<qpel_shift;        my_max = FFMAX(my_max, my);        my_min = FFMIN(my_min, my);    }    off = (FFMAX(-my_min, my_max) + 63) >> 6;    return FFMIN(FFMAX(s->mb_y + off, 0), s->mb_height-1);unhandled:    return s->mb_height-1;}", "idx": 13451}
{"project": "qemu", "commit_id": "27c3f2cb9bf2112b82edac898094e0a39e6efca1", "target": 1, "function": "int main_loop(void *opaque){    struct pollfd ufds[2], *pf, *serial_ufd, *net_ufd, *gdb_ufd;    int ret, n, timeout;    uint8_t ch;    CPUState *env = global_env;    if (!term_inited) {        /* initialize terminal only there so that the user has a           chance to stop QEMU with Ctrl-C before the gdb connection           is launched */        term_inited = 1;        term_init();    }    for(;;) {        ret = cpu_x86_exec(env);        if (reset_requested)            break;        if (ret == EXCP_DEBUG)            return EXCP_DEBUG;        /* if hlt instruction, we wait until the next IRQ */        if (ret == EXCP_HLT)             timeout = 10;        else            timeout = 0;        /* poll any events */        serial_ufd = NULL;        pf = ufds;        if (!(serial_ports[0].lsr & UART_LSR_DR)) {            serial_ufd = pf;            pf->fd = 0;            pf->events = POLLIN;            pf++;        }        net_ufd = NULL;        if (net_fd > 0 && ne2000_can_receive(&ne2000_state)) {            net_ufd = pf;            pf->fd = net_fd;            pf->events = POLLIN;            pf++;        }        gdb_ufd = NULL;        if (gdbstub_fd > 0) {            gdb_ufd = pf;            pf->fd = gdbstub_fd;            pf->events = POLLIN;            pf++;        }        ret = poll(ufds, pf - ufds, timeout);        if (ret > 0) {            if (serial_ufd && (serial_ufd->revents & POLLIN)) {                n = read(0, &ch, 1);                if (n == 1) {                    serial_received_byte(&serial_ports[0], ch);                }            }            if (net_ufd && (net_ufd->revents & POLLIN)) {                uint8_t buf[MAX_ETH_FRAME_SIZE];                n = read(net_fd, buf, MAX_ETH_FRAME_SIZE);                if (n > 0) {                    if (n < 60) {                        memset(buf + n, 0, 60 - n);                        n = 60;                    }                    ne2000_receive(&ne2000_state, buf, n);                }            }            if (gdb_ufd && (gdb_ufd->revents & POLLIN)) {                uint8_t buf[1];                /* stop emulation if requested by gdb */                n = read(gdbstub_fd, buf, 1);                if (n == 1)                    break;            }        }        /* timer IRQ */        if (timer_irq_pending) {            pic_set_irq(0, 1);            pic_set_irq(0, 0);            timer_irq_pending = 0;        }        /* VGA */        if (gui_refresh_pending) {            display_state.dpy_refresh(&display_state);            gui_refresh_pending = 0;        }    }    return EXCP_INTERRUPT;}", "idx": 13608}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "function": "yuv2yuvX_altivec_real(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\t\t      int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\t\t      uint8_t *dest, uint8_t *uDest, uint8_t *vDest, int dstW, int chrDstW){  const vector signed int vini = {(1 << 18), (1 << 18), (1 << 18), (1 << 18)};  register int i, j;  {    int __attribute__ ((aligned (16))) val[dstW];    for (i = 0; i < (dstW -7); i+=4) {      vec_st(vini, i << 2, val);    }    for (; i < dstW; i++) {      val[i] = (1 << 18);    }    for (j = 0; j < lumFilterSize; j++) {      vector signed short l1, vLumFilter = vec_ld(j << 1, lumFilter);      vector unsigned char perm, perm0 = vec_lvsl(j << 1, lumFilter);      vLumFilter = vec_perm(vLumFilter, vLumFilter, perm0);      vLumFilter = vec_splat(vLumFilter, 0); // lumFilter[j] is loaded 8 times in vLumFilter      perm = vec_lvsl(0, lumSrc[j]);      l1 = vec_ld(0, lumSrc[j]);      for (i = 0; i < (dstW - 7); i+=8) {\tint offset = i << 2;\tvector signed short l2 = vec_ld((i << 1) + 16, lumSrc[j]);\tvector signed int v1 = vec_ld(offset, val);\tvector signed int v2 = vec_ld(offset + 16, val);\tvector signed short ls = vec_perm(l1, l2, perm); // lumSrc[j][i] ... lumSrc[j][i+7]\tvector signed int i1 = vec_mule(vLumFilter, ls);\tvector signed int i2 = vec_mulo(vLumFilter, ls);\tvector signed int vf1 = vec_mergeh(i1, i2);\tvector signed int vf2 = vec_mergel(i1, i2); // lumSrc[j][i] * lumFilter[j] ... lumSrc[j][i+7] * lumFilter[j]\tvector signed int vo1 = vec_add(v1, vf1);\tvector signed int vo2 = vec_add(v2, vf2);\tvec_st(vo1, offset, val);\tvec_st(vo2, offset + 16, val);\tl1 = l2;      }      for ( ; i < dstW; i++) {\tval[i] += lumSrc[j][i] * lumFilter[j];      }    }    altivec_packIntArrayToCharArray(val,dest,dstW);  }  if (uDest != 0) {    int  __attribute__ ((aligned (16))) u[chrDstW];    int  __attribute__ ((aligned (16))) v[chrDstW];    for (i = 0; i < (chrDstW -7); i+=4) {      vec_st(vini, i << 2, u);      vec_st(vini, i << 2, v);    }    for (; i < chrDstW; i++) {      u[i] = (1 << 18);      v[i] = (1 << 18);    }    for (j = 0; j < chrFilterSize; j++) {      vector signed short l1, l1_V, vChrFilter = vec_ld(j << 1, chrFilter);      vector unsigned char perm, perm0 = vec_lvsl(j << 1, chrFilter);      vChrFilter = vec_perm(vChrFilter, vChrFilter, perm0);      vChrFilter = vec_splat(vChrFilter, 0); // chrFilter[j] is loaded 8 times in vChrFilter      perm = vec_lvsl(0, chrSrc[j]);      l1 = vec_ld(0, chrSrc[j]);      l1_V = vec_ld(2048 << 1, chrSrc[j]);      for (i = 0; i < (chrDstW - 7); i+=8) {\tint offset = i << 2;\tvector signed short l2 = vec_ld((i << 1) + 16, chrSrc[j]);\tvector signed short l2_V = vec_ld(((i + 2048) << 1) + 16, chrSrc[j]);\tvector signed int v1 = vec_ld(offset, u);\tvector signed int v2 = vec_ld(offset + 16, u);\tvector signed int v1_V = vec_ld(offset, v);\tvector signed int v2_V = vec_ld(offset + 16, v);\tvector signed short ls = vec_perm(l1, l2, perm); // chrSrc[j][i] ... chrSrc[j][i+7]\tvector signed short ls_V = vec_perm(l1_V, l2_V, perm); // chrSrc[j][i+2048] ... chrSrc[j][i+2055]\tvector signed int i1 = vec_mule(vChrFilter, ls);\tvector signed int i2 = vec_mulo(vChrFilter, ls);\tvector signed int i1_V = vec_mule(vChrFilter, ls_V);\tvector signed int i2_V = vec_mulo(vChrFilter, ls_V);\tvector signed int vf1 = vec_mergeh(i1, i2);\tvector signed int vf2 = vec_mergel(i1, i2); // chrSrc[j][i] * chrFilter[j] ... chrSrc[j][i+7] * chrFilter[j]\tvector signed int vf1_V = vec_mergeh(i1_V, i2_V);\tvector signed int vf2_V = vec_mergel(i1_V, i2_V); // chrSrc[j][i] * chrFilter[j] ... chrSrc[j][i+7] * chrFilter[j]\tvector signed int vo1 = vec_add(v1, vf1);\tvector signed int vo2 = vec_add(v2, vf2);\tvector signed int vo1_V = vec_add(v1_V, vf1_V);\tvector signed int vo2_V = vec_add(v2_V, vf2_V);\tvec_st(vo1, offset, u);\tvec_st(vo2, offset + 16, u);\tvec_st(vo1_V, offset, v);\tvec_st(vo2_V, offset + 16, v);\tl1 = l2;\tl1_V = l2_V;      }      for ( ; i < chrDstW; i++) {\tu[i] += chrSrc[j][i] * chrFilter[j];\tv[i] += chrSrc[j][i + 2048] * chrFilter[j];      }    }    altivec_packIntArrayToCharArray(u,uDest,chrDstW);    altivec_packIntArrayToCharArray(v,vDest,chrDstW);  }}", "idx": 13669}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "function": "void vnc_write(VncState *vs, const void *data, size_t len){    buffer_reserve(&vs->output, len);    if (buffer_empty(&vs->output)) {        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);    }    buffer_append(&vs->output, data, len);}", "idx": 13710}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "function": "void HELPER(srst)(CPUS390XState *env, uint32_t r1, uint32_t r2){    uintptr_t ra = GETPC();    uint64_t end, str;    uint32_t len;    uint8_t v, c = env->regs[0];    /* Bits 32-55 must contain all 0.  */    if (env->regs[0] & 0xffffff00u) {        cpu_restore_state(ENV_GET_CPU(env), ra);        program_interrupt(env, PGM_SPECIFICATION, 6);    }    str = get_address(env, r2);    end = get_address(env, r1);    /* Lest we fail to service interrupts in a timely manner, limit the       amount of work we're willing to do.  For now, let's cap at 8k.  */    for (len = 0; len < 0x2000; ++len) {        if (str + len == end) {            /* Character not found.  R1 & R2 are unmodified.  */            env->cc_op = 2;            return;        }        v = cpu_ldub_data_ra(env, str + len, ra);        if (v == c) {            /* Character found.  Set R1 to the location; R2 is unmodified.  */            env->cc_op = 1;            set_address(env, r1, str + len);            return;        }    }    /* CPU-determined bytes processed.  Advance R2 to next byte to process.  */    env->cc_op = 3;    set_address(env, r2, str + len);}", "idx": 13799}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "function": "void do_POWER_dozo (void){    if (Ts1 > Ts0) {        T2 = T0;        T0 = T1 - T0;        if (((~T2) ^ T1 ^ (-1)) & ((~T2) ^ T0) & (1 << 31)) {            xer_so = 1;            xer_ov = 1;        } else {            xer_ov = 0;        }    } else {        T0 = 0;        xer_ov = 0;    }}", "idx": 13837}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "function": "void OPPROTO op_srli_T0 (void){    T0 = T0 >> PARAM1;    RETURN();}", "idx": 13928}
{"project": "qemu", "commit_id": "8be656b87c6bb1b9f8af3ff78094413d71e4443a", "target": 1, "function": "void syscall_init(void){    IOCTLEntry *ie;    const argtype *arg_type;    int size;    int i;#define STRUCT(name, ...) thunk_register_struct(STRUCT_ ## name, #name, struct_ ## name ## _def);#define STRUCT_SPECIAL(name) thunk_register_struct_direct(STRUCT_ ## name, #name, &struct_ ## name ## _def);#include \"syscall_types.h\"#undef STRUCT#undef STRUCT_SPECIAL    /* Build target_to_host_errno_table[] table from     * host_to_target_errno_table[]. */    for (i = 0; i < ERRNO_TABLE_SIZE; i++) {        target_to_host_errno_table[host_to_target_errno_table[i]] = i;    }    /* we patch the ioctl size if necessary. We rely on the fact that       no ioctl has all the bits at '1' in the size field */    ie = ioctl_entries;    while (ie->target_cmd != 0) {        if (((ie->target_cmd >> TARGET_IOC_SIZESHIFT) & TARGET_IOC_SIZEMASK) ==            TARGET_IOC_SIZEMASK) {            arg_type = ie->arg_type;            if (arg_type[0] != TYPE_PTR) {                fprintf(stderr, \"cannot patch size for ioctl 0x%x\\n\",                        ie->target_cmd);                exit(1);            }            arg_type++;            size = thunk_type_size(arg_type, 0);            ie->target_cmd = (ie->target_cmd &                              ~(TARGET_IOC_SIZEMASK << TARGET_IOC_SIZESHIFT)) |                (size << TARGET_IOC_SIZESHIFT);        }        /* automatic consistency check if same arch */#if (defined(__i386__) && defined(TARGET_I386) && defined(TARGET_ABI32)) || \\    (defined(__x86_64__) && defined(TARGET_X86_64))        if (unlikely(ie->target_cmd != ie->host_cmd)) {            fprintf(stderr, \"ERROR: ioctl(%s): target=0x%x host=0x%x\\n\",                    ie->name, ie->target_cmd, ie->host_cmd);        }#endif        ie++;    }}", "idx": 13930}
{"project": "FFmpeg", "commit_id": "b9c8388710a06544812739eedc0a40d3451491dc", "target": 1, "function": "static void *av_mallocz_static(unsigned int size){    void *ptr = av_mallocz(size);    if(ptr){        array_static =av_fast_realloc(array_static, &allocated_static, sizeof(void*)*(last_static+1));        if(!array_static)            return NULL;        array_static[last_static++] = ptr;    }    return ptr;}", "idx": 14042}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "function": "static int v4l2_receive_frame(AVCodecContext *avctx, AVFrame *frame){    V4L2m2mContext *s = avctx->priv_data;    V4L2Context *const capture = &s->capture;    V4L2Context *const output = &s->output;    AVPacket avpkt = {0};    int ret;    ret = ff_decode_get_packet(avctx, &avpkt);    if (ret < 0 && ret != AVERROR_EOF)        return ret;    if (s->draining)        goto dequeue;    ret = ff_v4l2_context_enqueue_packet(output, &avpkt);    if (ret < 0) {        if (ret != AVERROR(ENOMEM))           return ret;        /* no input buffers available, continue dequeing */    }    if (avpkt.size) {        ret = v4l2_try_start(avctx);        if (ret)            return 0;    }dequeue:    return ff_v4l2_context_dequeue_frame(capture, frame);}", "idx": 14057}
{"project": "FFmpeg", "commit_id": "95a57d26d8653d21f0dab1aff3558ee944853dbf", "target": 1, "function": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,                                AVFrame *picture){    int compno, reslevelno, bandno;    int x, y;    uint8_t *line;    Jpeg2000T1Context t1;    /* Loop on tile components */    for (compno = 0; compno < s->ncomponents; compno++) {        Jpeg2000Component *comp     = tile->comp + compno;        Jpeg2000CodingStyle *codsty = tile->codsty + compno;        /* Loop on resolution levels */        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;            /* Loop on bands */            for (bandno = 0; bandno < rlevel->nbands; bandno++) {                uint16_t nb_precincts, precno;                Jpeg2000Band *band = rlevel->band + bandno;                int cblkno = 0, bandpos;                bandpos = bandno + (reslevelno > 0);                if (band->coord[0][0] == band->coord[0][1] ||                    band->coord[1][0] == band->coord[1][1])                    continue;                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;                /* Loop on precincts */                for (precno = 0; precno < nb_precincts; precno++) {                    Jpeg2000Prec *prec = band->prec + precno;                    /* Loop on codeblocks */                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {                        int x, y;                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;                        decode_cblk(s, codsty, &t1, cblk,                                    cblk->coord[0][1] - cblk->coord[0][0],                                    cblk->coord[1][1] - cblk->coord[1][0],                                    bandpos);                        x = cblk->coord[0][0];                        y = cblk->coord[1][0];                        if (codsty->transform == FF_DWT97)                            dequantization_float(x, y, cblk, comp, &t1, band);                        else                            dequantization_int(x, y, cblk, comp, &t1, band);                   } /* end cblk */                } /*end prec */            } /* end band */        } /* end reslevel */        /* inverse DWT */        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);    } /*end comp */    /* inverse MCT transformation */    if (tile->codsty[0].mct)        mct_decode(s, tile);    if (s->precision <= 8) {        for (compno = 0; compno < s->ncomponents; compno++) {            Jpeg2000Component *comp = tile->comp + compno;            float *datap = comp->f_data;            int32_t *i_datap = comp->i_data;            int cbps = s->cbps[compno];            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;            line = picture->data[0] + y * picture->linesize[0];            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {                uint8_t *dst;                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;                dst = line + x * s->ncomponents + compno;                if (tile->codsty->transform == FF_DWT97) {                    for (; x < w; x += s->cdx[compno]) {                        int val = lrintf(*datap) + (1 << (cbps - 1));                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */                        val = av_clip(val, 0, (1 << cbps) - 1);                        *dst = val << (8 - cbps);                        datap++;                        dst += s->ncomponents;                    }                } else {                    for (; x < w; x += s->cdx[compno]) {                        int val = *i_datap + (1 << (cbps - 1));                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */                        val = av_clip(val, 0, (1 << cbps) - 1);                        *dst = val << (8 - cbps);                        i_datap++;                        dst += s->ncomponents;                    }                }                line += picture->linesize[0];            }        }    } else {        for (compno = 0; compno < s->ncomponents; compno++) {            Jpeg2000Component *comp = tile->comp + compno;            float *datap = comp->f_data;            int32_t *i_datap = comp->i_data;            uint16_t *linel;            int cbps = s->cbps[compno];            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;            linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {                uint16_t *dst;                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;                dst = linel + (x * s->ncomponents + compno);                if (tile->codsty->transform == FF_DWT97) {                    for (; x < w; x += s-> cdx[compno]) {                        int  val = lrintf(*datap) + (1 << (cbps - 1));                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */                        val = av_clip(val, 0, (1 << cbps) - 1);                        /* align 12 bit values in little-endian mode */                        *dst = val << (16 - cbps);                        datap++;                        dst += s->ncomponents;                    }                } else {                    for (; x < w; x += s-> cdx[compno]) {                        int val = *i_datap + (1 << (cbps - 1));                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */                        val = av_clip(val, 0, (1 << cbps) - 1);                        /* align 12 bit values in little-endian mode */                        *dst = val << (16 - cbps);                        i_datap++;                        dst += s->ncomponents;                    }                }                linel += picture->linesize[0] >> 1;            }        }    }    return 0;}", "idx": 14058}
{"project": "qemu", "commit_id": "339064d5063924e5176842abbf6c8089f3479c5b", "target": 1, "function": "bool bdrv_qiov_is_aligned(BlockDriverState *bs, QEMUIOVector *qiov){    int i;    for (i = 0; i < qiov->niov; i++) {        if ((uintptr_t) qiov->iov[i].iov_base % bs->buffer_alignment) {            return false;        }        if (qiov->iov[i].iov_len % bs->buffer_alignment) {            return false;        }    }    return true;}", "idx": 14073}
{"project": "qemu", "commit_id": "0fa758c3a069bc59a0d903d69028971c46d1a119", "target": 0, "function": "void i2c_end_transfer(I2CBus *bus){    I2CSlaveClass *sc;    I2CNode *node, *next;    if (QLIST_EMPTY(&bus->current_devs)) {        return;    }    QLIST_FOREACH_SAFE(node, &bus->current_devs, next, next) {        sc = I2C_SLAVE_GET_CLASS(node->elt);        if (sc->event) {            sc->event(node->elt, I2C_FINISH);        }        QLIST_REMOVE(node, next);        g_free(node);    }    bus->broadcast = false;}", "idx": 14083}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "function": "void *qemu_mallocz(size_t size){    void *ptr;    ptr = qemu_malloc(size);    if (!ptr)        return NULL;    memset(ptr, 0, size);    return ptr;}", "idx": 14132}
{"project": "FFmpeg", "commit_id": "5da42be1921604a97e6180f242c78c484a179314", "target": 0, "function": "static int dvvideo_init(AVCodecContext *avctx){    DVVideoContext *s = avctx->priv_data;    DSPContext dsp;    static int done=0;    int i, j;    if (!done) {        VLC dv_vlc;        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];        uint8_t new_dv_vlc_len[NB_DV_VLC*2];        uint8_t new_dv_vlc_run[NB_DV_VLC*2];        int16_t new_dv_vlc_level[NB_DV_VLC*2];        done = 1;        dv_vlc_map = av_mallocz(DV_VLC_MAP_LEV_SIZE*DV_VLC_MAP_RUN_SIZE*sizeof(struct dv_vlc_pair));\tif (!dv_vlc_map)\t    return -ENOMEM;\t/* dv_anchor lets each thread know its Id */\tdv_anchor = av_malloc(12*27*sizeof(void*));\tif (!dv_anchor) {\t    av_free(dv_vlc_map);\t    return -ENOMEM;\t}\tfor (i=0; i<12*27; i++)\t    dv_anchor[i] = (void*)(size_t)i;\t/* it's faster to include sign bit in a generic VLC parsing scheme */\tfor (i=0, j=0; i<NB_DV_VLC; i++, j++) {\t    new_dv_vlc_bits[j] = dv_vlc_bits[i];\t    new_dv_vlc_len[j] = dv_vlc_len[i];\t    new_dv_vlc_run[j] = dv_vlc_run[i];\t    new_dv_vlc_level[j] = dv_vlc_level[i];\t    \t    if (dv_vlc_level[i]) {\t        new_dv_vlc_bits[j] <<= 1;\t\tnew_dv_vlc_len[j]++;\t\tj++;\t\tnew_dv_vlc_bits[j] = (dv_vlc_bits[i] << 1) | 1;\t\tnew_dv_vlc_len[j] = dv_vlc_len[i] + 1;\t\tnew_dv_vlc_run[j] = dv_vlc_run[i];\t\tnew_dv_vlc_level[j] = -dv_vlc_level[i];\t    }\t}                     /* NOTE: as a trick, we use the fact the no codes are unused           to accelerate the parsing of partial codes */        init_vlc(&dv_vlc, TEX_VLC_BITS, j,                  new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2);        dv_rl_vlc = av_malloc(dv_vlc.table_size * sizeof(RL_VLC_ELEM));\tif (!dv_rl_vlc) {\t    av_free(dv_anchor);\t    av_free(dv_vlc_map);\t    return -ENOMEM;\t}        for(i = 0; i < dv_vlc.table_size; i++){            int code= dv_vlc.table[i][0];            int len = dv_vlc.table[i][1];            int level, run;                    if(len<0){ //more bits needed                run= 0;                level= code;            } else {                run=   new_dv_vlc_run[code] + 1;                level= new_dv_vlc_level[code];            }            dv_rl_vlc[i].len = len;            dv_rl_vlc[i].level = level;            dv_rl_vlc[i].run = run;        }\tfree_vlc(&dv_vlc);\tfor (i = 0; i < NB_DV_VLC - 1; i++) {           if (dv_vlc_run[i] >= DV_VLC_MAP_RUN_SIZE || dv_vlc_level[i] >= DV_VLC_MAP_LEV_SIZE)\t       continue;\t   \t   if (dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].size != 0)\t       continue;\t       \t   dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].vlc = dv_vlc_bits[i] << \t                                                    (!!dv_vlc_level[i]);\t   dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].size = dv_vlc_len[i] + \t                                                     (!!dv_vlc_level[i]);\t}\tfor (i = 0; i < DV_VLC_MAP_RUN_SIZE; i++) {#ifdef DV_CODEC_TINY_TARGET\t   for (j = 1; j < DV_VLC_MAP_LEV_SIZE; j++) {\t      if (dv_vlc_map[i][j].size == 0) {\t          dv_vlc_map[i][j].vlc = dv_vlc_map[0][j].vlc |\t\t            (dv_vlc_map[i-1][0].vlc << (dv_vlc_map[0][j].size));\t          dv_vlc_map[i][j].size = dv_vlc_map[i-1][0].size + \t\t                          dv_vlc_map[0][j].size;\t      }\t   }#else\t   for (j = 1; j < DV_VLC_MAP_LEV_SIZE/2; j++) {\t      if (dv_vlc_map[i][j].size == 0) {\t          dv_vlc_map[i][j].vlc = dv_vlc_map[0][j].vlc |\t\t            (dv_vlc_map[i-1][0].vlc << (dv_vlc_map[0][j].size));\t          dv_vlc_map[i][j].size = dv_vlc_map[i-1][0].size + \t\t                          dv_vlc_map[0][j].size;\t      }\t      dv_vlc_map[i][((uint16_t)(-j))&0x1ff].vlc = \t                                    dv_vlc_map[i][j].vlc | 1;\t      dv_vlc_map[i][((uint16_t)(-j))&0x1ff].size = \t                                    dv_vlc_map[i][j].size;\t   }#endif\t}    }    /* Generic DSP setup */    dsputil_init(&dsp, avctx);    s->get_pixels = dsp.get_pixels;    /* 88DCT setup */    s->fdct[0] = dsp.fdct;    s->idct_put[0] = dsp.idct_put;    for (i=0; i<64; i++)       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];    /* 248DCT setup */    s->fdct[1] = dsp.fdct248;    s->idct_put[1] = simple_idct248_put;  // FIXME: need to add it to DSP    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);    /* XXX: do it only for constant case */    dv_build_unquantize_tables(s, dsp.idct_permutation);    /* FIXME: I really don't think this should be here */    if (dv_codec_profile(avctx))\tavctx->pix_fmt = dv_codec_profile(avctx)->pix_fmt;     avctx->coded_frame = &s->picture;        return 0;}", "idx": 14135}
{"project": "FFmpeg", "commit_id": "3735b5c616770429572f86aabdaec39c6ebb8818", "target": 0, "function": "static int config_input(AVFilterLink *inlink){    AVFilterContext *ctx = inlink->dst;    PadContext *s = ctx->priv;    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);    uint8_t rgba_color[4];    int ret, is_packed_rgba;    double var_values[VARS_NB], res;    char *expr;    s->hsub = pix_desc->log2_chroma_w;    s->vsub = pix_desc->log2_chroma_h;    var_values[VAR_PI]    = M_PI;    var_values[VAR_PHI]   = M_PHI;    var_values[VAR_E]     = M_E;    var_values[VAR_IN_W]  = var_values[VAR_IW] = inlink->w;    var_values[VAR_IN_H]  = var_values[VAR_IH] = inlink->h;    var_values[VAR_OUT_W] = var_values[VAR_OW] = NAN;    var_values[VAR_OUT_H] = var_values[VAR_OH] = NAN;    var_values[VAR_A]     = (double) inlink->w / inlink->h;    var_values[VAR_HSUB]  = 1<<s->hsub;    var_values[VAR_VSUB]  = 1<<s->vsub;    /* evaluate width and height */    if ((ret = av_expr_parse_and_eval(&res, (expr = s->w_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->w = var_values[VAR_OUT_W] = var_values[VAR_OW] = res;    if ((ret = av_expr_parse_and_eval(&res, (expr = s->h_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->h = var_values[VAR_OUT_H] = var_values[VAR_OH] = res;    /* evaluate the width again, as it may depend on the evaluated output height */    if ((ret = av_expr_parse_and_eval(&res, (expr = s->w_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->w = var_values[VAR_OUT_W] = var_values[VAR_OW] = res;    /* evaluate x and y */    if ((ret = av_expr_parse_and_eval(&res, (expr = s->x_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->x = var_values[VAR_X] = res;    if ((ret = av_expr_parse_and_eval(&res, (expr = s->y_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->y = var_values[VAR_Y] = res;    /* evaluate x again, as it may depend on the evaluated y value */    if ((ret = av_expr_parse_and_eval(&res, (expr = s->x_expr),                                      var_names, var_values,                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)        goto eval_fail;    s->x = var_values[VAR_X] = res;    /* sanity check params */    if (s->w < 0 || s->h < 0 || s->x < 0 || s->y < 0) {        av_log(ctx, AV_LOG_ERROR, \"Negative values are not acceptable.\\n\");        return AVERROR(EINVAL);    }    if (!s->w)        s->w = inlink->w;    if (!s->h)        s->h = inlink->h;    s->w &= ~((1 << s->hsub) - 1);    s->h &= ~((1 << s->vsub) - 1);    s->x &= ~((1 << s->hsub) - 1);    s->y &= ~((1 << s->vsub) - 1);    s->in_w = inlink->w & ~((1 << s->hsub) - 1);    s->in_h = inlink->h & ~((1 << s->vsub) - 1);    memcpy(rgba_color, s->color, sizeof(rgba_color));    ff_fill_line_with_color(s->line, s->line_step, s->w, s->color,                            inlink->format, rgba_color, &is_packed_rgba, NULL);    av_log(ctx, AV_LOG_VERBOSE, \"w:%d h:%d -> w:%d h:%d x:%d y:%d color:0x%02X%02X%02X%02X[%s]\\n\",           inlink->w, inlink->h, s->w, s->h, s->x, s->y,           s->color[0], s->color[1], s->color[2], s->color[3],           is_packed_rgba ? \"rgba\" : \"yuva\");    if (s->x <  0 || s->y <  0                      ||        s->w <= 0 || s->h <= 0                      ||        (unsigned)s->x + (unsigned)inlink->w > s->w ||        (unsigned)s->y + (unsigned)inlink->h > s->h) {        av_log(ctx, AV_LOG_ERROR,               \"Input area %d:%d:%d:%d not within the padded area 0:0:%d:%d or zero-sized\\n\",               s->x, s->y, s->x + inlink->w, s->y + inlink->h, s->w, s->h);        return AVERROR(EINVAL);    }    return 0;eval_fail:    av_log(NULL, AV_LOG_ERROR,           \"Error when evaluating the expression '%s'\\n\", expr);    return ret;}", "idx": 14172}
{"project": "qemu", "commit_id": "c3adb5b9168a57790b5074489b6f0275ac3cc8b5", "target": 1, "function": "BlockDriverAIOCB *dma_bdrv_io(    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,    DMAIOFunc *io_func, BlockDriverCompletionFunc *cb,    void *opaque, bool to_dev){    DMAAIOCB *dbs = qemu_aio_get(&dma_aio_pool, bs, cb, opaque);    dbs->acb = NULL;    dbs->bs = bs;    dbs->sg = sg;    dbs->sector_num = sector_num;    dbs->sg_cur_index = 0;    dbs->sg_cur_byte = 0;    dbs->to_dev = to_dev;    dbs->io_func = io_func;    dbs->bh = NULL;    qemu_iovec_init(&dbs->iov, sg->nsg);    dma_bdrv_cb(dbs, 0);    if (!dbs->acb) {        qemu_aio_release(dbs);        return NULL;    }    return &dbs->common;}", "idx": 14201}
{"project": "qemu", "commit_id": "3a31cff11203bf62ebafa6d74b1fcf2aba345eed", "target": 1, "function": "static void ivshmem_read(void *opaque, const uint8_t *buf, int size){    IVShmemState *s = opaque;    int incoming_fd, tmp_fd;    int guest_max_eventfd;    long incoming_posn;    if (fifo8_is_empty(&s->incoming_fifo) && size == sizeof(incoming_posn)) {        memcpy(&incoming_posn, buf, size);    } else {        const uint8_t *p;        uint32_t num;        IVSHMEM_DPRINTF(\"short read of %d bytes\\n\", size);        num = MAX(size, sizeof(long) - fifo8_num_used(&s->incoming_fifo));        fifo8_push_all(&s->incoming_fifo, buf, num);        if (fifo8_num_used(&s->incoming_fifo) < sizeof(incoming_posn)) {            return;        }        size -= num;        buf += num;        p = fifo8_pop_buf(&s->incoming_fifo, sizeof(incoming_posn), &num);        g_assert(num == sizeof(incoming_posn));        memcpy(&incoming_posn, p, sizeof(incoming_posn));        if (size > 0) {            fifo8_push_all(&s->incoming_fifo, buf, size);        }    }    if (incoming_posn < -1) {        IVSHMEM_DPRINTF(\"invalid incoming_posn %ld\\n\", incoming_posn);        return;    }    /* pick off s->server_chr->msgfd and store it, posn should accompany msg */    tmp_fd = qemu_chr_fe_get_msgfd(s->server_chr);    IVSHMEM_DPRINTF(\"posn is %ld, fd is %d\\n\", incoming_posn, tmp_fd);    /* make sure we have enough space for this guest */    if (incoming_posn >= s->nb_peers) {        if (increase_dynamic_storage(s, incoming_posn) < 0) {            error_report(\"increase_dynamic_storage() failed\");            if (tmp_fd != -1) {            }            return;        }    }    if (tmp_fd == -1) {        /* if posn is positive and unseen before then this is our posn*/        if ((incoming_posn >= 0) &&                            (s->peers[incoming_posn].eventfds == NULL)) {            /* receive our posn */            s->vm_id = incoming_posn;            return;        } else {            /* otherwise an fd == -1 means an existing guest has gone away */            IVSHMEM_DPRINTF(\"posn %ld has gone away\\n\", incoming_posn);            close_guest_eventfds(s, incoming_posn);            return;        }    }    /* because of the implementation of get_msgfd, we need a dup */    incoming_fd = dup(tmp_fd);    if (incoming_fd == -1) {        fprintf(stderr, \"could not allocate file descriptor %s\\n\",                                                            strerror(errno));        return;    }    /* if the position is -1, then it's shared memory region fd */    if (incoming_posn == -1) {        void * map_ptr;        s->max_peer = 0;        if (check_shm_size(s, incoming_fd) == -1) {            exit(-1);        }        /* mmap the region and map into the BAR2 */        map_ptr = mmap(0, s->ivshmem_size, PROT_READ|PROT_WRITE, MAP_SHARED,                                                            incoming_fd, 0);        memory_region_init_ram_ptr(&s->ivshmem, OBJECT(s),                                   \"ivshmem.bar2\", s->ivshmem_size, map_ptr);        vmstate_register_ram(&s->ivshmem, DEVICE(s));        IVSHMEM_DPRINTF(\"guest h/w addr = %p, size = %\" PRIu64 \"\\n\",                         map_ptr, s->ivshmem_size);        memory_region_add_subregion(&s->bar, 0, &s->ivshmem);        /* only store the fd if it is successfully mapped */        s->shm_fd = incoming_fd;        return;    }    /* each guest has an array of eventfds, and we keep track of how many     * guests for each VM */    guest_max_eventfd = s->peers[incoming_posn].nb_eventfds;    if (guest_max_eventfd == 0) {        /* one eventfd per MSI vector */        s->peers[incoming_posn].eventfds = g_new(EventNotifier, s->vectors);    }    /* this is an eventfd for a particular guest VM */    IVSHMEM_DPRINTF(\"eventfds[%ld][%d] = %d\\n\", incoming_posn,                                            guest_max_eventfd, incoming_fd);    event_notifier_init_fd(&s->peers[incoming_posn].eventfds[guest_max_eventfd],                           incoming_fd);    /* increment count for particular guest */    s->peers[incoming_posn].nb_eventfds++;    /* keep track of the maximum VM ID */    if (incoming_posn > s->max_peer) {        s->max_peer = incoming_posn;    }    if (incoming_posn == s->vm_id) {        s->eventfd_chr[guest_max_eventfd] = create_eventfd_chr_device(s,                   &s->peers[s->vm_id].eventfds[guest_max_eventfd],                   guest_max_eventfd);    }    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD)) {        ivshmem_add_eventfd(s, incoming_posn, guest_max_eventfd);    }}", "idx": 14210}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "function": "static void gen_cas_asi(DisasContext *dc, TCGv addr, TCGv val2,                        int insn, int rd){    TCGv val1 = gen_load_gpr(dc, rd);    TCGv dst = gen_dest_gpr(dc, rd);    TCGv_i32 r_asi = gen_get_asi(dc, insn);    gen_helper_cas_asi(dst, cpu_env, addr, val1, val2, r_asi);    tcg_temp_free_i32(r_asi);    gen_store_gpr(dc, rd, dst);}", "idx": 14215}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "function": "QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id, int fail_if_exists){    QemuOpts *opts = NULL;    if (id) {        if (!id_wellformed(id)) {            qerror_report(QERR_INVALID_PARAMETER_VALUE, \"id\", \"an identifier\");            error_printf_unless_qmp(\"Identifiers consist of letters, digits, '-', '.', '_', starting with a letter.\\n\");            return NULL;        }        opts = qemu_opts_find(list, id);        if (opts != NULL) {            if (fail_if_exists && !list->merge_lists) {                qerror_report(QERR_DUPLICATE_ID, id, list->name);                return NULL;            } else {                return opts;            }        }    } else if (list->merge_lists) {        opts = qemu_opts_find(list, NULL);        if (opts) {            return opts;        }    }    opts = g_malloc0(sizeof(*opts));    if (id) {        opts->id = g_strdup(id);    }    opts->list = list;    loc_save(&opts->loc);    QTAILQ_INIT(&opts->head);    QTAILQ_INSERT_TAIL(&list->head, opts, next);    return opts;}", "idx": 14243}
{"project": "FFmpeg", "commit_id": "fe2d6fe2359b153eee827906140e62f710496a37", "target": 0, "function": "int av_write_trailer(AVFormatContext *s){    int ret;        while(s->packet_buffer){        int ret;        AVPacketList *pktl= s->packet_buffer;//av_log(s, AV_LOG_DEBUG, \"write_trailer st:%d dts:%lld\\n\", pktl->pkt.stream_index, pktl->pkt.dts);        truncate_ts(s->streams[pktl->pkt.stream_index], &pktl->pkt);        ret= s->oformat->write_packet(s, &pktl->pkt);                s->packet_buffer= pktl->next;                av_free_packet(&pktl->pkt);        av_freep(&pktl);                if(ret<0)            return ret;    }    ret = s->oformat->write_trailer(s);    av_freep(&s->priv_data);    return ret;}", "idx": 14252}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "function": "static int mov_read_colr(MOVContext *c, AVIOContext *pb, MOVAtom atom){    AVStream *st;    char color_parameter_type[5] = { 0 };    int color_primaries, color_trc, color_matrix;    if (c->fc->nb_streams < 1)        return 0;    st = c->fc->streams[c->fc->nb_streams - 1];    avio_read(pb, color_parameter_type, 4);    if (strncmp(color_parameter_type, \"nclx\", 4) &&        strncmp(color_parameter_type, \"nclc\", 4)) {        av_log(c->fc, AV_LOG_WARNING, \"unsupported color_parameter_type %s\\n\",               color_parameter_type);        return 0;    }    color_primaries = avio_rb16(pb);    color_trc = avio_rb16(pb);    color_matrix = avio_rb16(pb);    av_log(c->fc, AV_LOG_TRACE,           \"%s: pri %\"PRIu16\" trc %\"PRIu16\" matrix %\"PRIu16\"\",           color_parameter_type, color_primaries, color_trc, color_matrix);    if (!strncmp(color_parameter_type, \"nclx\", 4)) {        uint8_t color_range = avio_r8(pb) >> 7;        av_log(c->fc, AV_LOG_TRACE, \" full %\"PRIu8\"\", color_range);        if (color_range)            st->codec->color_range = AVCOL_RANGE_JPEG;        else            st->codec->color_range = AVCOL_RANGE_MPEG;        /* 14496-12 references JPEG XR specs (rather than the more complete         * 23001-8) so some adjusting is required */        if (color_primaries >= AVCOL_PRI_FILM)            color_primaries = AVCOL_PRI_UNSPECIFIED;        if ((color_trc >= AVCOL_TRC_LINEAR &&             color_trc <= AVCOL_TRC_LOG_SQRT) ||            color_trc >= AVCOL_TRC_BT2020_10)            color_trc = AVCOL_TRC_UNSPECIFIED;        if (color_matrix >= AVCOL_SPC_BT2020_NCL)            color_matrix = AVCOL_SPC_UNSPECIFIED;        st->codec->color_primaries = color_primaries;        st->codec->color_trc = color_trc;        st->codec->colorspace = color_matrix;    } else if (!strncmp(color_parameter_type, \"nclc\", 4)) {        /* color primaries, Table 4-4 */        switch (color_primaries) {        case 1: st->codec->color_primaries = AVCOL_PRI_BT709; break;        case 5: st->codec->color_primaries = AVCOL_PRI_SMPTE170M; break;        case 6: st->codec->color_primaries = AVCOL_PRI_SMPTE240M; break;        }        /* color transfer, Table 4-5 */        switch (color_trc) {        case 1: st->codec->color_trc = AVCOL_TRC_BT709; break;        case 7: st->codec->color_trc = AVCOL_TRC_SMPTE240M; break;        }        /* color matrix, Table 4-6 */        switch (color_matrix) {        case 1: st->codec->colorspace = AVCOL_SPC_BT709; break;        case 6: st->codec->colorspace = AVCOL_SPC_BT470BG; break;        case 7: st->codec->colorspace = AVCOL_SPC_SMPTE240M; break;        }    }    av_log(c->fc, AV_LOG_TRACE, \"\\n\");    return 0;}", "idx": 14321}
{"project": "FFmpeg", "commit_id": "b6eaa3928e198554a3934dd5ad6eac4d16f27df2", "target": 1, "function": "static int videotoolbox_common_end_frame(AVCodecContext *avctx, AVFrame *frame){    int status;    AVVideotoolboxContext *videotoolbox = avctx->hwaccel_context;    VTContext *vtctx = avctx->internal->hwaccel_priv_data;    av_buffer_unref(&frame->buf[0]);    if (!videotoolbox->session || !vtctx->bitstream)        return AVERROR_INVALIDDATA;    status = videotoolbox_session_decode_frame(avctx);    if (status) {        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);        return AVERROR_UNKNOWN;    }    if (!vtctx->frame)        return AVERROR_UNKNOWN;    return ff_videotoolbox_buffer_create(vtctx, frame);}", "idx": 14323}
{"project": "FFmpeg", "commit_id": "d597655f771979c70c08f8f8ed84c1319da121e8", "target": 0, "function": "static void put_ebml_uint(ByteIOContext *pb, unsigned int elementid, uint64_t val){    int i, bytes = 1;    while (val >> bytes*8) bytes++;    put_ebml_id(pb, elementid);    put_ebml_num(pb, bytes, 0);    for (i = bytes - 1; i >= 0; i--)        put_byte(pb, val >> i*8);}", "idx": 14331}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "function": "static void gen_compute_eflags_p(DisasContext *s, TCGv reg){    gen_compute_eflags(s);    tcg_gen_shri_tl(reg, cpu_cc_src, 2);    tcg_gen_andi_tl(reg, reg, 1);}", "idx": 14392}
{"project": "qemu", "commit_id": "1d3323de5fe5656844ea57a16eb432f09a366140", "target": 0, "function": "static void vnc_dpy_setdata(DisplayState *ds){    /* We don't have to do anything */}", "idx": 14402}
{"project": "FFmpeg", "commit_id": "6e8fe448154e1aa0928cb0d2e1aecb7255c751cc", "target": 1, "function": "static av_cold int wmv2_encode_init(AVCodecContext *avctx){    Wmv2Context * const w= avctx->priv_data;    if(ff_MPV_encode_init(avctx) < 0)        return -1;    ff_wmv2_common_init(w);    avctx->extradata_size= 4;    avctx->extradata= av_mallocz(avctx->extradata_size + 10);    encode_ext_header(w);    return 0;}", "idx": 14451}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "function": "uint64_t migrate_max_downtime(void){    return max_downtime;}", "idx": 14479}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "function": "int64_t bdrv_get_allocated_file_size(BlockDriverState *bs){    BlockDriver *drv = bs->drv;    if (!drv) {        return -ENOMEDIUM;    }    if (drv->bdrv_get_allocated_file_size) {        return drv->bdrv_get_allocated_file_size(bs);    }    if (bs->file) {        return bdrv_get_allocated_file_size(bs->file);    }    return -ENOTSUP;}", "idx": 14582}
{"project": "FFmpeg", "commit_id": "422e3a74b9d783571bec775af64f75e4915c40cc", "target": 1, "function": "static int raw_decode(AVCodecContext *avctx,                            void *data, int *data_size,                            AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    int linesize_align = 4;    RawVideoContext *context = avctx->priv_data;    AVFrame * frame = (AVFrame *) data;    AVPicture * picture = (AVPicture *) data;    frame->pict_type        = avctx->coded_frame->pict_type;    frame->interlaced_frame = avctx->coded_frame->interlaced_frame;    frame->top_field_first = avctx->coded_frame->top_field_first;    frame->reordered_opaque = avctx->reordered_opaque;    frame->pkt_pts          = avctx->pkt->pts;    frame->pkt_pos          = avctx->pkt->pos;    if(context->tff>=0){        frame->interlaced_frame = 1;        frame->top_field_first  = context->tff;    }    //2bpp and 4bpp raw in avi and mov (yes this is ugly ...)    if (context->buffer) {        int i;        uint8_t *dst = context->buffer;        buf_size = context->length - 256*4;        if (avctx->bits_per_coded_sample == 4){            for(i=0; 2*i+1 < buf_size; i++){                dst[2*i+0]= buf[i]>>4;                dst[2*i+1]= buf[i]&15;            }            linesize_align = 8;        } else {            for(i=0; 4*i+3 < buf_size; i++){                dst[4*i+0]= buf[i]>>6;                dst[4*i+1]= buf[i]>>4&3;                dst[4*i+2]= buf[i]>>2&3;                dst[4*i+3]= buf[i]   &3;            }            linesize_align = 16;        }        buf= dst;    }    if(avctx->codec_tag == MKTAG('A', 'V', '1', 'x') ||       avctx->codec_tag == MKTAG('A', 'V', 'u', 'p'))        buf += buf_size - context->length;    if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0))        return -1;    avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height);    if((avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length) ||       (av_pix_fmt_descriptors[avctx->pix_fmt].flags & PIX_FMT_PSEUDOPAL)) {        frame->data[1]= context->palette;    }    if (avctx->pix_fmt == PIX_FMT_PAL8) {        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);        if (pal) {            memcpy(frame->data[1], pal, AVPALETTE_SIZE);            frame->palette_has_changed = 1;        }    }    if((avctx->pix_fmt==PIX_FMT_BGR24    ||        avctx->pix_fmt==PIX_FMT_GRAY8    ||        avctx->pix_fmt==PIX_FMT_RGB555LE ||        avctx->pix_fmt==PIX_FMT_RGB555BE ||        avctx->pix_fmt==PIX_FMT_RGB565LE ||        avctx->pix_fmt==PIX_FMT_MONOWHITE ||        avctx->pix_fmt==PIX_FMT_PAL8) &&        FFALIGN(frame->linesize[0], linesize_align)*avctx->height <= buf_size)        frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align);    if(context->flip)        flip(avctx, picture);    if (   avctx->codec_tag == MKTAG('Y', 'V', '1', '2')        || avctx->codec_tag == MKTAG('Y', 'V', '1', '6')        || avctx->codec_tag == MKTAG('Y', 'V', '2', '4')        || avctx->codec_tag == MKTAG('Y', 'V', 'U', '9'))        FFSWAP(uint8_t *, picture->data[1], picture->data[2]);    if(avctx->codec_tag == AV_RL32(\"yuv2\") &&       avctx->pix_fmt   == PIX_FMT_YUYV422) {        int x, y;        uint8_t *line = picture->data[0];        for(y = 0; y < avctx->height; y++) {            for(x = 0; x < avctx->width; x++)                line[2*x + 1] ^= 0x80;            line += picture->linesize[0];        }    }    *data_size = sizeof(AVPicture);    return buf_size;}", "idx": 14600}
{"project": "FFmpeg", "commit_id": "796012af6c780b5b13ebca39a491f215515a18fe", "target": 0, "function": "static uint8_t *advance_line(uint8_t *start, uint8_t *line,                             int stride, int *y, int h, int interleave){    *y += interleave;    if (*y < h) {        return line + interleave * stride;    } else {        *y = (*y + 1) & (interleave - 1);        if (*y) {            return start + *y * stride;        } else {            return NULL;        }    }}", "idx": 14609}
{"project": "qemu", "commit_id": "302a0d3ed721e4c30c6a2a37f64c60b50ffd33b9", "target": 1, "function": "static size_t pdu_unmarshal(V9fsPDU *pdu, size_t offset, const char *fmt, ...){    size_t old_offset = offset;    va_list ap;    int i;    va_start(ap, fmt);    for (i = 0; fmt[i]; i++) {        switch (fmt[i]) {        case 'b': {            uint8_t *valp = va_arg(ap, uint8_t *);            offset += pdu_unpack(valp, pdu, offset, sizeof(*valp));            break;        }        case 'w': {            uint16_t val, *valp;            valp = va_arg(ap, uint16_t *);            offset += pdu_unpack(&val, pdu, offset, sizeof(val));            *valp = le16_to_cpu(val);            break;        }        case 'd': {            uint32_t val, *valp;            valp = va_arg(ap, uint32_t *);            offset += pdu_unpack(&val, pdu, offset, sizeof(val));            *valp = le32_to_cpu(val);            break;        }        case 'q': {            uint64_t val, *valp;            valp = va_arg(ap, uint64_t *);            offset += pdu_unpack(&val, pdu, offset, sizeof(val));            *valp = le64_to_cpu(val);            break;        }        case 'v': {            struct iovec *iov = va_arg(ap, struct iovec *);            int *iovcnt = va_arg(ap, int *);            *iovcnt = pdu_copy_sg(pdu, offset, 0, iov);            break;        }        case 's': {            V9fsString *str = va_arg(ap, V9fsString *);            offset += pdu_unmarshal(pdu, offset, \"w\", &str->size);            /* FIXME: sanity check str->size */            str->data = g_malloc(str->size + 1);            offset += pdu_unpack(str->data, pdu, offset, str->size);            str->data[str->size] = 0;            break;        }        case 'Q': {            V9fsQID *qidp = va_arg(ap, V9fsQID *);            offset += pdu_unmarshal(pdu, offset, \"bdq\",                        &qidp->type, &qidp->version, &qidp->path);            break;        }        case 'S': {            V9fsStat *statp = va_arg(ap, V9fsStat *);            offset += pdu_unmarshal(pdu, offset, \"wwdQdddqsssssddd\",                        &statp->size, &statp->type, &statp->dev,                        &statp->qid, &statp->mode, &statp->atime,                        &statp->mtime, &statp->length,                        &statp->name, &statp->uid, &statp->gid,                        &statp->muid, &statp->extension,                        &statp->n_uid, &statp->n_gid,                        &statp->n_muid);            break;        }        case 'I': {            V9fsIattr *iattr = va_arg(ap, V9fsIattr *);            offset += pdu_unmarshal(pdu, offset, \"ddddqqqqq\",                        &iattr->valid, &iattr->mode,                        &iattr->uid, &iattr->gid, &iattr->size,                        &iattr->atime_sec, &iattr->atime_nsec,                        &iattr->mtime_sec, &iattr->mtime_nsec);            break;        }        default:            break;        }    }    va_end(ap);    return offset - old_offset;}", "idx": 14628}
{"project": "FFmpeg", "commit_id": "ecff5acb5a738fcb4f9e206a12070dac4bf259b3", "target": 1, "function": "static int svq1_decode_delta_block(AVCodecContext *avctx, DSPContext *dsp,                                   GetBitContext *bitbuf,                                   uint8_t *current, uint8_t *previous,                                   int pitch, svq1_pmv *motion, int x, int y){    uint32_t block_type;    int result = 0;    /* get block type */    block_type = get_vlc2(bitbuf, svq1_block_type.table, 2, 2);    /* reset motion vectors */    if (block_type == SVQ1_BLOCK_SKIP || block_type == SVQ1_BLOCK_INTRA) {        motion[0].x         =        motion[0].y         =        motion[x / 8 + 2].x =        motion[x / 8 + 2].y =        motion[x / 8 + 3].x =        motion[x / 8 + 3].y = 0;    }    switch (block_type) {    case SVQ1_BLOCK_SKIP:        svq1_skip_block(current, previous, pitch, x, y);        break;    case SVQ1_BLOCK_INTER:        result = svq1_motion_inter_block(dsp, bitbuf, current, previous,                                         pitch, motion, x, y);        if (result != 0) {            av_dlog(avctx, \"Error in svq1_motion_inter_block %i\\n\", result);            break;        }        result = svq1_decode_block_non_intra(bitbuf, current, pitch);        break;    case SVQ1_BLOCK_INTER_4V:        result = svq1_motion_inter_4v_block(dsp, bitbuf, current, previous,                                            pitch, motion, x, y);        if (result != 0) {            av_dlog(avctx, \"Error in svq1_motion_inter_4v_block %i\\n\", result);            break;        }        result = svq1_decode_block_non_intra(bitbuf, current, pitch);        break;    case SVQ1_BLOCK_INTRA:        result = svq1_decode_block_intra(bitbuf, current, pitch);        break;    }    return result;}", "idx": 14678}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "function": "static void hid_pointer_event(DeviceState *dev, QemuConsole *src,                              InputEvent *evt){    static const int bmap[INPUT_BUTTON__MAX] = {        [INPUT_BUTTON_LEFT]   = 0x01,        [INPUT_BUTTON_RIGHT]  = 0x02,        [INPUT_BUTTON_MIDDLE] = 0x04,    };    HIDState *hs = (HIDState *)dev;    HIDPointerEvent *e;    InputMoveEvent *move;    InputBtnEvent *btn;    assert(hs->n < QUEUE_LENGTH);    e = &hs->ptr.queue[(hs->head + hs->n) & QUEUE_MASK];    switch (evt->type) {    case INPUT_EVENT_KIND_REL:        move = evt->u.rel;        if (move->axis == INPUT_AXIS_X) {            e->xdx += move->value;        } else if (move->axis == INPUT_AXIS_Y) {            e->ydy += move->value;        }        break;    case INPUT_EVENT_KIND_ABS:        move = evt->u.abs;        if (move->axis == INPUT_AXIS_X) {            e->xdx = move->value;        } else if (move->axis == INPUT_AXIS_Y) {            e->ydy = move->value;        }        break;    case INPUT_EVENT_KIND_BTN:        btn = evt->u.btn;        if (btn->down) {            e->buttons_state |= bmap[btn->button];            if (btn->button == INPUT_BUTTON_WHEEL_UP) {                e->dz--;            } else if (btn->button == INPUT_BUTTON_WHEEL_DOWN) {                e->dz++;            }        } else {            e->buttons_state &= ~bmap[btn->button];        }        break;    default:        /* keep gcc happy */        break;    }}", "idx": 14729}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "function": "static void arm_cpu_class_init(ObjectClass *oc, void *data){    ARMCPUClass *acc = ARM_CPU_CLASS(oc);    CPUClass *cc = CPU_CLASS(acc);    DeviceClass *dc = DEVICE_CLASS(oc);    acc->parent_realize = dc->realize;    dc->realize = arm_cpu_realizefn;    dc->props = arm_cpu_properties;    acc->parent_reset = cc->reset;    cc->reset = arm_cpu_reset;    cc->class_by_name = arm_cpu_class_by_name;    cc->has_work = arm_cpu_has_work;    cc->cpu_exec_interrupt = arm_cpu_exec_interrupt;    cc->dump_state = arm_cpu_dump_state;    cc->set_pc = arm_cpu_set_pc;    cc->gdb_read_register = arm_cpu_gdb_read_register;    cc->gdb_write_register = arm_cpu_gdb_write_register;#ifdef CONFIG_USER_ONLY    cc->handle_mmu_fault = arm_cpu_handle_mmu_fault;#else    cc->do_interrupt = arm_cpu_do_interrupt;    cc->get_phys_page_debug = arm_cpu_get_phys_page_debug;    cc->vmsd = &vmstate_arm_cpu;    cc->virtio_is_big_endian = arm_cpu_is_big_endian;#endif    cc->gdb_num_core_regs = 26;    cc->gdb_core_xml_file = \"arm-core.xml\";    cc->gdb_stop_before_watchpoint = true;    cc->debug_excp_handler = arm_debug_excp_handler;    cc->disas_set_info = arm_disas_set_info;}", "idx": 14738}
{"project": "FFmpeg", "commit_id": "3c8c94b403977eb7c65a07081b55cc9bc5005ced", "target": 1, "function": "static int flic_decode_frame(AVCodecContext *avctx,                             void *data, int *data_size,                             uint8_t *buf, int buf_size){    FlicDecodeContext *s = (FlicDecodeContext *)avctx->priv_data;    int stream_ptr = 0;    int stream_ptr_after_color_chunk;    int pixel_ptr;    int palette_ptr;    unsigned char palette_idx1;    unsigned char palette_idx2;    unsigned int frame_size;    int num_chunks;    unsigned int chunk_size;    int chunk_type;    int i, j;    int color_packets;    int color_changes;    int color_shift;    unsigned char r, g, b;    int lines;    int compressed_lines;    int starting_line;    signed short line_packets;    int y_ptr;    signed char byte_run;    int pixel_skip;    int pixel_countdown;    unsigned char *pixels;    int pixel_limit;    s->frame.reference = 1;    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;    if (avctx->reget_buffer(avctx, &s->frame) < 0) {        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");        return -1;    }    pixels = s->frame.data[0];    pixel_limit = s->avctx->height * s->frame.linesize[0];    frame_size = LE_32(&buf[stream_ptr]);    stream_ptr += 6;  /* skip the magic number */    num_chunks = LE_16(&buf[stream_ptr]);    stream_ptr += 10;  /* skip padding */    frame_size -= 16;    /* iterate through the chunks */    while ((frame_size > 0) && (num_chunks > 0)) {        chunk_size = LE_32(&buf[stream_ptr]);        stream_ptr += 4;        chunk_type = LE_16(&buf[stream_ptr]);        stream_ptr += 2;        switch (chunk_type) {        case FLI_256_COLOR:        case FLI_COLOR:            stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6;            s->new_palette = 1;            /* check special case: If this file is from the Magic Carpet              * game and uses 6-bit colors even though it reports 256-color              * chunks in a 0xAF12-type file (fli_type is set to 0xAF13 during             * initialization) */            if ((chunk_type == FLI_256_COLOR) && (s->fli_type != 0xAF13))                color_shift = 0;            else                color_shift = 2;            /* set up the palette */            color_packets = LE_16(&buf[stream_ptr]);            stream_ptr += 2;            palette_ptr = 0;            for (i = 0; i < color_packets; i++) {                /* first byte is how many colors to skip */                palette_ptr += buf[stream_ptr++];                /* next byte indicates how many entries to change */                color_changes = buf[stream_ptr++];                /* if there are 0 color changes, there are actually 256 */                if (color_changes == 0)                    color_changes = 256;                for (j = 0; j < color_changes; j++) {                    /* wrap around, for good measure */                    if ((unsigned)palette_ptr >= 256)                        palette_ptr = 0;                    r = buf[stream_ptr++] << color_shift;                    g = buf[stream_ptr++] << color_shift;                    b = buf[stream_ptr++] << color_shift;                    s->palette[palette_ptr++] = (r << 16) | (g << 8) | b;                }            }            /* color chunks sometimes have weird 16-bit alignment issues;             * therefore, take the hardline approach and set the stream_ptr             * to the value calculated w.r.t. the size specified by the color             * chunk header */            stream_ptr = stream_ptr_after_color_chunk;            break;        case FLI_DELTA:            y_ptr = 0;            compressed_lines = LE_16(&buf[stream_ptr]);            stream_ptr += 2;            while (compressed_lines > 0) {                line_packets = LE_16(&buf[stream_ptr]);                stream_ptr += 2;                if (line_packets < 0) {                    line_packets = -line_packets;                    y_ptr += line_packets * s->frame.linesize[0];                } else {                    compressed_lines--;                    pixel_ptr = y_ptr;                    pixel_countdown = s->avctx->width;                    for (i = 0; i < line_packets; i++) {                        /* account for the skip bytes */                        pixel_skip = buf[stream_ptr++];                        pixel_ptr += pixel_skip;                        pixel_countdown -= pixel_skip;                        byte_run = buf[stream_ptr++];                        if (byte_run < 0) {                            byte_run = -byte_run;                            palette_idx1 = buf[stream_ptr++];                            palette_idx2 = buf[stream_ptr++];                            for (j = 0; j < byte_run; j++, pixel_countdown -= 2) {                                pixels[pixel_ptr++] = palette_idx1;                                pixels[pixel_ptr++] = palette_idx2;                            }                        } else {                            for (j = 0; j < byte_run * 2; j++, pixel_countdown--) {                                palette_idx1 = buf[stream_ptr++];                                pixels[pixel_ptr++] = palette_idx1;                            }                        }                    }                    y_ptr += s->frame.linesize[0];                }            }            break;        case FLI_LC:            /* line compressed */            starting_line = LE_16(&buf[stream_ptr]);            stream_ptr += 2;            y_ptr = 0;            y_ptr += starting_line * s->frame.linesize[0];            compressed_lines = LE_16(&buf[stream_ptr]);            stream_ptr += 2;            while (compressed_lines > 0) {                pixel_ptr = y_ptr;                pixel_countdown = s->avctx->width;                line_packets = buf[stream_ptr++];                if (line_packets > 0) {                    for (i = 0; i < line_packets; i++) {                        /* account for the skip bytes */                        pixel_skip = buf[stream_ptr++];                        pixel_ptr += pixel_skip;                        pixel_countdown -= pixel_skip;                        byte_run = buf[stream_ptr++];                        if (byte_run > 0) {                            for (j = 0; j < byte_run; j++, pixel_countdown--) {                                palette_idx1 = buf[stream_ptr++];                                pixels[pixel_ptr++] = palette_idx1;                            }                        } else {                            byte_run = -byte_run;                            palette_idx1 = buf[stream_ptr++];                            for (j = 0; j < byte_run; j++, pixel_countdown--) {                                pixels[pixel_ptr++] = palette_idx1;                            }                        }                    }                }                y_ptr += s->frame.linesize[0];                compressed_lines--;            }            break;        case FLI_BLACK:            /* set the whole frame to color 0 (which is usually black) */            memset(pixels, 0,                s->frame.linesize[0] * s->avctx->height);            break;        case FLI_BRUN:            /* Byte run compression: This chunk type only occurs in the first             * FLI frame and it will update the entire frame. */            y_ptr = 0;            for (lines = 0; lines < s->avctx->height; lines++) {                pixel_ptr = y_ptr;                /* disregard the line packets; instead, iterate through all                 * pixels on a row */                stream_ptr++;                pixel_countdown = s->avctx->width;                while (pixel_countdown > 0) {                    byte_run = buf[stream_ptr++];                    if (byte_run > 0) {                        palette_idx1 = buf[stream_ptr++];                        for (j = 0; j < byte_run; j++) {                            pixels[pixel_ptr++] = palette_idx1;                            pixel_countdown--;                            if (pixel_countdown < 0)                                av_log(avctx, AV_LOG_ERROR, \"pixel_countdown < 0 (%d)\\n\",                                       pixel_countdown);                        }                    } else {  /* copy bytes if byte_run < 0 */                        byte_run = -byte_run;                        for (j = 0; j < byte_run; j++) {                            palette_idx1 = buf[stream_ptr++];                            pixels[pixel_ptr++] = palette_idx1;                            pixel_countdown--;                            if (pixel_countdown < 0)                                av_log(avctx, AV_LOG_ERROR, \"pixel_countdown < 0 (%d)\\n\",                                       pixel_countdown);                        }                    }                }                y_ptr += s->frame.linesize[0];            }            break;        case FLI_COPY:            /* copy the chunk (uncompressed frame) */            if (chunk_size - 6 > s->avctx->width * s->avctx->height) {                av_log(avctx, AV_LOG_ERROR, \"In chunk FLI_COPY : source data (%d bytes) \" \\                       \"bigger than image, skipping chunk\\n\", chunk_size - 6);                stream_ptr += chunk_size - 6;            } else {                for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;                     y_ptr += s->frame.linesize[0]) {                    memcpy(&pixels[y_ptr], &buf[stream_ptr],                        s->avctx->width);                    stream_ptr += s->avctx->width;                }            }            break;        case FLI_MINI:            /* some sort of a thumbnail? disregard this chunk... */            stream_ptr += chunk_size - 6;            break;        default:            av_log(avctx, AV_LOG_ERROR, \"Unrecognized chunk type: %d\\n\", chunk_type);            break;        }        frame_size -= chunk_size;        num_chunks--;    }    /* by the end of the chunk, the stream ptr should equal the frame     * size (minus 1, possibly); if it doesn't, issue a warning */    if ((stream_ptr != buf_size) && (stream_ptr != buf_size - 1))        av_log(avctx, AV_LOG_ERROR, \"Processed FLI chunk where chunk size = %d \" \\               \"and final chunk ptr = %d\\n\", buf_size, stream_ptr);    /* make the palette available on the way out *///    if (s->new_palette) {    if (1) {        memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);        s->frame.palette_has_changed = 1;        s->new_palette = 0;    }    *data_size=sizeof(AVFrame);    *(AVFrame*)data = s->frame;    return buf_size;}", "idx": 14740}
{"project": "FFmpeg", "commit_id": "a860adb49c4cd9c1271778cb7c2930c25efb2a97", "target": 0, "function": "static void check_mc(void){    LOCAL_ALIGNED_32(uint8_t, buf, [72 * 72 * 2]);    LOCAL_ALIGNED_32(uint8_t, dst0, [64 * 64 * 2]);    LOCAL_ALIGNED_32(uint8_t, dst1, [64 * 64 * 2]);    VP9DSPContext dsp;    int op, hsize, bit_depth, filter, dx, dy;    declare_func(void, uint8_t *dst, ptrdiff_t dst_stride,                 const uint8_t *ref, ptrdiff_t ref_stride,                 int h, int mx, int my);    static const char *const filter_names[4] = {        \"8tap_smooth\", \"8tap_regular\", \"8tap_sharp\", \"bilin\"    };    static const char *const subpel_names[2][2] = { { \"\", \"h\" }, { \"v\", \"hv\" } };    static const char *const op_names[2] = { \"put\", \"avg\" };    char str[256];    for (op = 0; op < 2; op++) {        for (bit_depth = 8; bit_depth <= 12; bit_depth += 2) {            ff_vp9dsp_init(&dsp, bit_depth, 0);            for (hsize = 0; hsize < 5; hsize++) {                int size = 64 >> hsize;                for (filter = 0; filter < 4; filter++) {                    for (dx = 0; dx < 2; dx++) {                        for (dy = 0; dy < 2; dy++) {                            if (dx || dy) {                                sprintf(str, \"%s_%s_%d%s\", op_names[op],                                        filter_names[filter], size,                                        subpel_names[dy][dx]);                            } else {                                sprintf(str, \"%s%d\", op_names[op], size);                            }                            if (check_func(dsp.mc[hsize][filter][op][dx][dy],                                           \"vp9_%s_%dbpp\", str, bit_depth)) {                                int mx = dx ? 1 + (rnd() % 14) : 0;                                int my = dy ? 1 + (rnd() % 14) : 0;                                randomize_buffers();                                call_ref(dst0, size * SIZEOF_PIXEL,                                         src, SRC_BUF_STRIDE * SIZEOF_PIXEL,                                         size, mx, my);                                call_new(dst1, size * SIZEOF_PIXEL,                                         src, SRC_BUF_STRIDE * SIZEOF_PIXEL,                                         size, mx, my);                                if (memcmp(dst0, dst1, DST_BUF_SIZE))                                    fail();                                // simd implementations for each filter of subpel                                // functions are identical                                if (filter >= 1 && filter <= 2) continue;                                // 10/12 bpp for bilin are identical                                if (bit_depth == 12 && filter == 3) continue;                                bench_new(dst1, size * SIZEOF_PIXEL,                                          src, SRC_BUF_STRIDE * SIZEOF_PIXEL,                                          size, mx, my);                            }                        }                    }                }            }        }    }    report(\"mc\");}", "idx": 14748}
{"project": "FFmpeg", "commit_id": "991ef6e5b9a6a9d95e274ff6bff52db1c82b3808", "target": 1, "function": "static int decode_nal_sei_message(GetBitContext *gb, void *logctx, HEVCSEI *s,                                  const HEVCParamSets *ps, int nal_unit_type){    int payload_type = 0;    int payload_size = 0;    int byte = 0xFF;    av_log(logctx, AV_LOG_DEBUG, \"Decoding SEI\\n\");    while (byte == 0xFF) {        byte          = get_bits(gb, 8);        payload_type += byte;    }    byte = 0xFF;    while (byte == 0xFF) {        byte          = get_bits(gb, 8);        payload_size += byte;    }    if (nal_unit_type == HEVC_NAL_SEI_PREFIX) {        return decode_nal_sei_prefix(gb, logctx, s, ps, payload_type, payload_size);    } else { /* nal_unit_type == NAL_SEI_SUFFIX */        return decode_nal_sei_suffix(gb, logctx, s, payload_type, payload_size);    }}", "idx": 14759}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "function": "void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,                         Error **errp){    MachineState *machine = MACHINE(OBJECT(hotplug_dev));    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(OBJECT(hotplug_dev));    sPAPRMachineState *spapr = SPAPR_MACHINE(OBJECT(hotplug_dev));    int spapr_max_cores = max_cpus / smp_threads;    int index;    Error *local_err = NULL;    CPUCore *cc = CPU_CORE(dev);    char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);    const char *type = object_get_typename(OBJECT(dev));    if (!smc->dr_cpu_enabled) {        error_setg(&local_err, \"CPU hotplug not supported for this machine\");        goto out;    }    if (strcmp(base_core_type, type)) {        error_setg(&local_err, \"CPU core type should be %s\", base_core_type);        goto out;    }    if (cc->nr_threads != smp_threads) {        error_setg(&local_err, \"threads must be %d\", smp_threads);        goto out;    }    if (cc->core_id % smp_threads) {        error_setg(&local_err, \"invalid core id %d\\n\", cc->core_id);        goto out;    }    index = cc->core_id / smp_threads;    if (index < 0 || index >= spapr_max_cores) {        error_setg(&local_err, \"core id %d out of range\", cc->core_id);        goto out;    }    if (spapr->cores[index]) {        error_setg(&local_err, \"core %d already populated\", cc->core_id);        goto out;    }out:    g_free(base_core_type);    error_propagate(errp, local_err);}", "idx": 14796}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "function": "static void vhost_scsi_stop(VHostSCSI *s){    VirtIODevice *vdev = VIRTIO_DEVICE(s);    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    int ret = 0;    if (!k->set_guest_notifiers) {        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);        if (ret < 0) {                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);        }    }    assert(ret >= 0);    vhost_scsi_clear_endpoint(s);    vhost_dev_stop(&s->dev, vdev);    vhost_dev_disable_notifiers(&s->dev, vdev);}", "idx": 14822}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static unsigned int dec_move_rs(DisasContext *dc){\tDIS(fprintf (logfile, \"move $r%u, $s%u\\n\", dc->op1, dc->op2));\tcris_cc_mask(dc, 0);\ttcg_gen_helper_0_2(helper_movl_sreg_reg, \t\t\t   tcg_const_tl(dc->op2), tcg_const_tl(dc->op1));\treturn 2;}", "idx": 14941}
{"project": "FFmpeg", "commit_id": "b5da07d4340a8e8e40dcd1900977a76ff31fbb84", "target": 0, "function": "void ff_put_h264_qpel4_mc10_msa(uint8_t *dst, const uint8_t *src,                                ptrdiff_t stride){    avc_luma_hz_qrt_4w_msa(src - 2, stride, dst, stride, 4, 0);}", "idx": 15008}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "function": "static void do_bit_allocation1(AC3DecodeContext *ctx, int chnl){    ac3_audio_block *ab = &ctx->audio_block;    int sdecay, fdecay, sgain, dbknee, floor;    int lowcomp = 0, fgain = 0, snroffset = 0, fastleak = 0, slowleak = 0;    int psd[256], bndpsd[50], excite[50], mask[50], delta;    int start = 0, end = 0, bin = 0, i = 0, j = 0, k = 0, lastbin = 0, bndstrt = 0;    int bndend = 0, begin = 0, deltnseg = 0, band = 0, seg = 0, address = 0;    int fscod = ctx->sync_info.fscod;    uint8_t *exps, *deltoffst = 0, *deltlen = 0, *deltba = 0;    uint8_t *baps;    int do_delta = 0;    /* initialization */    sdecay = sdecaytab[ab->sdcycod];    fdecay = fdecaytab[ab->fdcycod];    sgain = sgaintab[ab->sgaincod];    dbknee = dbkneetab[ab->dbpbcod];    floor = floortab[ab->floorcod];    if (chnl == 5) {        start = ab->cplstrtmant;        end = ab->cplendmant;        fgain = fgaintab[ab->cplfgaincod];        snroffset = (((ab->csnroffst - 15) << 4) + ab->cplfsnroffst) << 2;        fastleak = (ab->cplfleak << 8) + 768;        slowleak = (ab->cplsleak << 8) + 768;        exps = ab->dcplexps;        baps = ab->cplbap;        if (ab->cpldeltbae == AC3_DBASTR_NEW || ab->cpldeltbae == AC3_DBASTR_REUSE) {            do_delta = 1;            deltnseg = ab->cpldeltnseg;            deltoffst = ab->cpldeltoffst;            deltlen = ab->cpldeltlen;            deltba = ab->cpldeltba;        }    }    else if (chnl == 6) {        start = 0;        end = 7;        lowcomp = 0;        fastleak = 0;        slowleak = 0;        fgain = fgaintab[ab->lfefgaincod];        snroffset = (((ab->csnroffst - 15) << 4) + ab->lfefsnroffst) << 2;        exps = ab->dlfeexps;        baps = ab->lfebap;    }    else {        start = 0;        end = ab->endmant[chnl];        lowcomp = 0;        fastleak = 0;        slowleak = 0;        fgain = fgaintab[ab->fgaincod[chnl]];        snroffset = (((ab->csnroffst - 15) << 4) + ab->fsnroffst[chnl]) << 2;        exps = ab->dexps[chnl];        baps = ab->bap[chnl];        if (ab->deltbae[chnl] == AC3_DBASTR_NEW || ab->deltbae[chnl] == AC3_DBASTR_REUSE) {            do_delta = 1;            deltnseg = ab->deltnseg[chnl];            deltoffst = ab->deltoffst[chnl];            deltlen = ab->deltlen[chnl];            deltba = ab->deltba[chnl];        }    }    for (bin = start; bin < end; bin++) /* exponent mapping into psd */        psd[bin] = (3072 - ((int)(exps[bin]) << 7));    /* psd integration */    j = start;    k = masktab[start];    do {        lastbin = FFMIN(bndtab[k] + bndsz[k], end);        bndpsd[k] = psd[j];        j++;        for (i = j; i < lastbin; i++) {            bndpsd[k] = logadd(bndpsd[k], psd[j]);            j++;        }        k++;    } while (end > lastbin);    /* compute the excite function */    bndstrt = masktab[start];    bndend = masktab[end - 1] + 1;    if (bndstrt == 0) {        lowcomp = calc_lowcomp(lowcomp, bndpsd[0], bndpsd[1], 0);        excite[0] = bndpsd[0] - fgain - lowcomp;        lowcomp = calc_lowcomp(lowcomp, bndpsd[1], bndpsd[2], 1);        excite[1] = bndpsd[1] - fgain - lowcomp;        begin = 7;        for (bin = 2; bin < 7; bin++) {            if (bndend != 7 || bin != 6)                lowcomp = calc_lowcomp(lowcomp, bndpsd[bin], bndpsd[bin + 1], bin);            fastleak = bndpsd[bin] - fgain;            slowleak = bndpsd[bin] - sgain;            excite[bin] = fastleak - lowcomp;            if (bndend != 7 || bin != 6)                if (bndpsd[bin] <= bndpsd[bin + 1]) {                    begin = bin + 1;                    break;                }        }        for (bin = begin; bin < FFMIN(bndend, 22); bin++) {            if (bndend != 7 || bin != 6)                lowcomp = calc_lowcomp(lowcomp, bndpsd[bin], bndpsd[bin + 1], bin);            fastleak -= fdecay;            fastleak = FFMAX(fastleak, bndpsd[bin] - fgain);            slowleak -= sdecay;            slowleak = FFMAX(slowleak, bndpsd[bin] - sgain);            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);        }        begin = 22;    }    else {        begin = bndstrt;    }    for (bin = begin; bin < bndend; bin++) {        fastleak -= fdecay;        fastleak = FFMAX(fastleak, bndpsd[bin] - fgain);        slowleak -= sdecay;        slowleak = FFMAX(slowleak, bndpsd[bin] - sgain);        excite[bin] = FFMAX(fastleak, slowleak);    }    /* compute the masking curve */    for (bin = bndstrt; bin < bndend; bin++) {        if (bndpsd[bin] < dbknee)            excite[bin] += ((dbknee - bndpsd[bin]) >> 2);        mask[bin] = FFMAX(excite[bin], hth[bin][fscod]);    }    /* apply the delta bit allocation */    if (do_delta) {        band = 0;        for (seg = 0; seg < deltnseg + 1; seg++) {            band += (int)(deltoffst[seg]);            if ((int)(deltba[seg]) >= 4)                delta = ((int)(deltba[seg]) - 3) << 7;            else                delta = ((int)(deltba[seg]) - 4) << 7;            for (k = 0; k < (int)(deltlen[seg]); k++) {                mask[band] += delta;                band++;            }        }    }    /*compute the bit allocation */    i = start;    j = masktab[start];    do {        lastbin = FFMIN(bndtab[j] + bndsz[j], end);        mask[j] -= snroffset;        mask[j] -= floor;        if (mask[j] < 0)            mask[j] = 0;        mask[j] &= 0x1fe0;        mask[j] += floor;        for (k = i; k < lastbin; k++) {            address = (psd[i] - mask[j]) >> 5;            address = FFMIN(63, FFMAX(0, address));            baps[i] = baptab[address];            i++;        }        j++;    } while (end > lastbin);}", "idx": 15044}
{"project": "qemu", "commit_id": "92f9a4f13ea29de4644bd0b077643e1dff96ab29", "target": 0, "function": "static int apb_pci_bridge_initfn(PCIDevice *dev){    int rc;    rc = pci_bridge_initfn(dev);    if (rc < 0) {        return rc;    }    pci_config_set_vendor_id(dev->config, PCI_VENDOR_ID_SUN);    pci_config_set_device_id(dev->config, PCI_DEVICE_ID_SUN_SIMBA);    /*     * command register:     * According to PCI bridge spec, after reset     *   bus master bit is off     *   memory space enable bit is off     * According to manual (805-1251.pdf).     *   the reset value should be zero unless the boot pin is tied high     *   (which is true) and thus it should be PCI_COMMAND_MEMORY.     */    pci_set_word(dev->config + PCI_COMMAND,                 PCI_COMMAND_MEMORY);    pci_set_word(dev->config + PCI_STATUS,                 PCI_STATUS_FAST_BACK | PCI_STATUS_66MHZ |                 PCI_STATUS_DEVSEL_MEDIUM);    pci_set_byte(dev->config + PCI_REVISION_ID, 0x11);    return 0;}", "idx": 15076}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "function": "void OPPROTO op_divw_AX_T0(void){    unsigned int num, den, q, r;    num = (EAX & 0xffff) | ((EDX & 0xffff) << 16);    den = (T0 & 0xffff);    if (den == 0) {        raise_exception(EXCP00_DIVZ);    }    q = (num / den) & 0xffff;    r = (num % den) & 0xffff;    EAX = (EAX & ~0xffff) | q;    EDX = (EDX & ~0xffff) | r;}", "idx": 15138}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "function": "void axisdev88_init(MachineState *machine){    ram_addr_t ram_size = machine->ram_size;    const char *cpu_model = machine->cpu_model;    const char *kernel_filename = machine->kernel_filename;    const char *kernel_cmdline = machine->kernel_cmdline;    CRISCPU *cpu;    CPUCRISState *env;    DeviceState *dev;    SysBusDevice *s;    DriveInfo *nand;    qemu_irq irq[30], nmi[2];    void *etraxfs_dmac;    struct etraxfs_dma_client *dma_eth;    int i;    MemoryRegion *address_space_mem = get_system_memory();    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);    MemoryRegion *phys_intmem = g_new(MemoryRegion, 1);    /* init CPUs */    if (cpu_model == NULL) {        cpu_model = \"crisv32\";    }    cpu = cpu_cris_init(cpu_model);    env = &cpu->env;    /* allocate RAM */    memory_region_allocate_system_memory(phys_ram, NULL, \"axisdev88.ram\",                                         ram_size);    memory_region_add_subregion(address_space_mem, 0x40000000, phys_ram);    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the        internal memory.  */    memory_region_init_ram(phys_intmem, NULL, \"axisdev88.chipram\", INTMEM_SIZE,                           &error_abort);    vmstate_register_ram_global(phys_intmem);    memory_region_add_subregion(address_space_mem, 0x38000000, phys_intmem);      /* Attach a NAND flash to CS1.  */    nand = drive_get(IF_MTD, 0, 0);    nand_state.nand = nand_init(nand ? blk_by_legacy_dinfo(nand) : NULL,                                NAND_MFR_STMICRO, 0x39);    memory_region_init_io(&nand_state.iomem, NULL, &nand_ops, &nand_state,                          \"nand\", 0x05000000);    memory_region_add_subregion(address_space_mem, 0x10000000,                                &nand_state.iomem);    gpio_state.nand = &nand_state;    memory_region_init_io(&gpio_state.iomem, NULL, &gpio_ops, &gpio_state,                          \"gpio\", 0x5c);    memory_region_add_subregion(address_space_mem, 0x3001a000,                                &gpio_state.iomem);    dev = qdev_create(NULL, \"etraxfs,pic\");    /* FIXME: Is there a proper way to signal vectors to the CPU core?  */    qdev_prop_set_ptr(dev, \"interrupt_vector\", &env->interrupt_vector);    qdev_init_nofail(dev);    s = SYS_BUS_DEVICE(dev);    sysbus_mmio_map(s, 0, 0x3001c000);    sysbus_connect_irq(s, 0, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_IRQ));    sysbus_connect_irq(s, 1, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_NMI));    for (i = 0; i < 30; i++) {        irq[i] = qdev_get_gpio_in(dev, i);    }    nmi[0] = qdev_get_gpio_in(dev, 30);    nmi[1] = qdev_get_gpio_in(dev, 31);    etraxfs_dmac = etraxfs_dmac_init(0x30000000, 10);    for (i = 0; i < 10; i++) {        /* On ETRAX, odd numbered channels are inputs.  */        etraxfs_dmac_connect(etraxfs_dmac, i, irq + 7 + i, i & 1);    }    /* Add the two ethernet blocks.  */    dma_eth = g_malloc0(sizeof dma_eth[0] * 4); /* Allocate 4 channels.  */    etraxfs_eth_init(&nd_table[0], 0x30034000, 1, &dma_eth[0], &dma_eth[1]);    if (nb_nics > 1) {        etraxfs_eth_init(&nd_table[1], 0x30036000, 2, &dma_eth[2], &dma_eth[3]);    }    /* The DMA Connector block is missing, hardwire things for now.  */    etraxfs_dmac_connect_client(etraxfs_dmac, 0, &dma_eth[0]);    etraxfs_dmac_connect_client(etraxfs_dmac, 1, &dma_eth[1]);    if (nb_nics > 1) {        etraxfs_dmac_connect_client(etraxfs_dmac, 6, &dma_eth[2]);        etraxfs_dmac_connect_client(etraxfs_dmac, 7, &dma_eth[3]);    }    /* 2 timers.  */    sysbus_create_varargs(\"etraxfs,timer\", 0x3001e000, irq[0x1b], nmi[1], NULL);    sysbus_create_varargs(\"etraxfs,timer\", 0x3005e000, irq[0x1b], nmi[1], NULL);    for (i = 0; i < 4; i++) {        sysbus_create_simple(\"etraxfs,serial\", 0x30026000 + i * 0x2000,                             irq[0x14 + i]);    }    if (kernel_filename) {        li.image_filename = kernel_filename;        li.cmdline = kernel_cmdline;        cris_load_image(cpu, &li);    } else if (!qtest_enabled()) {        fprintf(stderr, \"Kernel image must be specified\\n\");        exit(1);    }}", "idx": 15146}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "function": "static inline bool media_is_dvd(SCSIDiskState *s){    uint64_t nb_sectors;    if (s->qdev.type != TYPE_ROM) {        return false;    }    if (!bdrv_is_inserted(s->qdev.conf.bs)) {        return false;    }    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);    return nb_sectors > CD_MAX_SECTORS;}", "idx": 15171}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "function": "static char *json_escape_str(const char *s){    static const char json_escape[] = {'\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t', 0};    static const char json_subst[]  = {'\"', '\\\\',  'b',  'f',  'n',  'r',  't', 0};    char *ret, *p;    int i, len = 0;    // compute the length of the escaped string    for (i = 0; s[i]; i++) {        if (strchr(json_escape, s[i]))     len += 2; // simple escape        else if ((unsigned char)s[i] < 32) len += 6; // handle non-printable chars        else                               len += 1; // char copy    }    p = ret = av_malloc(len + 1);    if (!p)        return NULL;    for (i = 0; s[i]; i++) {        char *q = strchr(json_escape, s[i]);        if (q) {            *p++ = '\\\\';            *p++ = json_subst[q - json_escape];        } else if ((unsigned char)s[i] < 32) {            snprintf(p, 7, \"\\\\u00%02x\", s[i] & 0xff);            p += 6;        } else {            *p++ = s[i];        }    }    *p = 0;    return ret;}", "idx": 15216}
{"project": "FFmpeg", "commit_id": "5b4da8a38a5ed211df9504c85ce401c30af86b97", "target": 0, "function": "static int estimate_motion_b(MpegEncContext *s, int mb_x, int mb_y,                             int16_t (*mv_table)[2], int ref_index, int f_code){    MotionEstContext * const c= &s->me;    int mx = 0, my = 0, dmin = 0;    int P[10][2];    const int shift= 1+s->quarter_sample;    const int mot_stride = s->mb_stride;    const int mot_xy = mb_y*mot_stride + mb_x;    uint8_t * const mv_penalty= c->mv_penalty[f_code] + MAX_MV;    int mv_scale;    c->penalty_factor    = get_penalty_factor(s->lambda, s->lambda2, c->avctx->me_cmp);    c->sub_penalty_factor= get_penalty_factor(s->lambda, s->lambda2, c->avctx->me_sub_cmp);    c->mb_penalty_factor = get_penalty_factor(s->lambda, s->lambda2, c->avctx->mb_cmp);    c->current_mv_penalty= mv_penalty;    get_limits(s, 16*mb_x, 16*mb_y);    if (s->motion_est != FF_ME_ZERO) {        P_LEFT[0] = mv_table[mot_xy - 1][0];        P_LEFT[1] = mv_table[mot_xy - 1][1];        if (P_LEFT[0] > (c->xmax << shift)) P_LEFT[0] = (c->xmax << shift);        /* special case for first line */        if (!s->first_slice_line) {            P_TOP[0]      = mv_table[mot_xy - mot_stride    ][0];            P_TOP[1]      = mv_table[mot_xy - mot_stride    ][1];            P_TOPRIGHT[0] = mv_table[mot_xy - mot_stride + 1][0];            P_TOPRIGHT[1] = mv_table[mot_xy - mot_stride + 1][1];            if (P_TOP[1] > (c->ymax << shift)) P_TOP[1] = (c->ymax << shift);            if (P_TOPRIGHT[0] < (c->xmin << shift)) P_TOPRIGHT[0] = (c->xmin << shift);            if (P_TOPRIGHT[1] > (c->ymax << shift)) P_TOPRIGHT[1] = (c->ymax << shift);            P_MEDIAN[0] = mid_pred(P_LEFT[0], P_TOP[0], P_TOPRIGHT[0]);            P_MEDIAN[1] = mid_pred(P_LEFT[1], P_TOP[1], P_TOPRIGHT[1]);        }        c->pred_x = P_LEFT[0];        c->pred_y = P_LEFT[1];        if(mv_table == s->b_forw_mv_table){            mv_scale= (s->pb_time<<16) / (s->pp_time<<shift);        }else{            mv_scale= ((s->pb_time - s->pp_time)<<16) / (s->pp_time<<shift);        }        dmin = ff_epzs_motion_search(s, &mx, &my, P, 0, ref_index, s->p_mv_table, mv_scale, 0, 16);    }    dmin= c->sub_motion_search(s, &mx, &my, dmin, 0, ref_index, 0, 16);    if(c->avctx->me_sub_cmp != c->avctx->mb_cmp && !c->skip)        dmin= get_mb_score(s, mx, my, 0, ref_index, 0, 16, 1);//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;    mv_table[mot_xy][0]= mx;    mv_table[mot_xy][1]= my;    return dmin;}", "idx": 15294}
{"project": "qemu", "commit_id": "3c2daac0b98952a858277878cb11294256b39e43", "target": 1, "function": "static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,                                     uint64_t sector, size_t size){    if (sector & dev->sector_mask) {    if (size % dev->conf->logical_block_size) {    return true;", "idx": 15384}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "function": "BlockAIOCB *thread_pool_submit_aio(ThreadPool *pool,        ThreadPoolFunc *func, void *arg,        BlockCompletionFunc *cb, void *opaque){    ThreadPoolElement *req;    req = qemu_aio_get(&thread_pool_aiocb_info, NULL, cb, opaque);    req->func = func;    req->arg = arg;    req->state = THREAD_QUEUED;    req->pool = pool;    QLIST_INSERT_HEAD(&pool->head, req, all);    trace_thread_pool_submit(pool, req, arg);    qemu_mutex_lock(&pool->lock);    if (pool->idle_threads == 0 && pool->cur_threads < pool->max_threads) {        spawn_thread(pool);    }    QTAILQ_INSERT_TAIL(&pool->request_list, req, reqs);    qemu_mutex_unlock(&pool->lock);    qemu_sem_post(&pool->sem);    return &req->common;}", "idx": 15425}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "function": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,                                           struct XenDevOps *ops){    struct XenDevice *xendev;    xendev = xen_be_find_xendev(type, dom, dev);    if (xendev) {        return xendev;    }    /* init new xendev */    xendev = g_malloc0(ops->size);    xendev->type  = type;    xendev->dom   = dom;    xendev->dev   = dev;    xendev->ops   = ops;    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",             xendev->type, xendev->dom, xendev->dev);    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",             xendev->type, xendev->dev);    xendev->debug      = debug;    xendev->local_port = -1;    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");        g_free(xendev);        return NULL;    }    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");            xc_evtchn_close(xendev->evtchndev);            g_free(xendev);            return NULL;        }    } else {        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;    }    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);    if (xendev->ops->alloc) {        xendev->ops->alloc(xendev);    }    return xendev;}", "idx": 15449}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "function": "static int usb_audio_handle_data(USBDevice *dev, USBPacket *p){    USBAudioState *s = (USBAudioState *) dev;    int ret = 0;    switch (p->pid) {    case USB_TOKEN_OUT:        switch (p->devep) {        case 1:            ret = usb_audio_handle_dataout(s, p);            break;        default:            goto fail;        }        break;    default:fail:        ret = USB_RET_STALL;        break;    }    if (ret == USB_RET_STALL && s->debug) {        fprintf(stderr, \"usb-audio: failed data transaction: \"                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",                        p->pid, p->devep, p->iov.size);    }    return ret;}", "idx": 15484}
{"project": "FFmpeg", "commit_id": "6c7f1155bb648eced8e5aa08b1fd490df2f8b325", "target": 0, "function": "static void mp3_parse_info_tag(AVFormatContext *s, AVStream *st,                               MPADecodeHeader *c, uint32_t spf){#define LAST_BITS(k, n) ((k) & ((1 << (n)) - 1))#define MIDDLE_BITS(k, m, n) LAST_BITS((k) >> (m), ((n) - (m)))    uint16_t crc;    uint32_t v;    char version[10];    uint32_t peak   = 0;    int32_t  r_gain = INT32_MIN, a_gain = INT32_MIN;    MP3DecContext *mp3 = s->priv_data;    static const int64_t xing_offtbl[2][2] = {{32, 17}, {17,9}};    uint64_t fsize = avio_size(s->pb);    /* Check for Xing / Info tag */    avio_skip(s->pb, xing_offtbl[c->lsf == 1][c->nb_channels == 1]);    v = avio_rb32(s->pb);    mp3->is_cbr = v == MKBETAG('I', 'n', 'f', 'o');    if (v != MKBETAG('X', 'i', 'n', 'g') && !mp3->is_cbr)        return;    v = avio_rb32(s->pb);    if (v & XING_FLAG_FRAMES)        mp3->frames = avio_rb32(s->pb);    if (v & XING_FLAG_SIZE)        mp3->header_filesize = avio_rb32(s->pb);    if (fsize && mp3->header_filesize) {        uint64_t min, delta;        min = FFMIN(fsize, mp3->header_filesize);        delta = FFMAX(fsize, mp3->header_filesize) - min;        if (fsize > mp3->header_filesize && delta > min >> 4) {            mp3->frames = 0;        } else if (delta > min >> 4) {            av_log(s, AV_LOG_WARNING,                   \"filesize and duration do not match (growing file?)\\n\");        }    }    if (v & XING_FLAG_TOC)        read_xing_toc(s, mp3->header_filesize, av_rescale_q(mp3->frames,                                       (AVRational){spf, c->sample_rate},                                       st->time_base));    /* VBR quality */    if(v & 8)        avio_skip(s->pb, 4);    /* Encoder short version string */    memset(version, 0, sizeof(version));    avio_read(s->pb, version, 9);    /* Info Tag revision + VBR method */    avio_r8(s->pb);    /* Lowpass filter value */    avio_r8(s->pb);    /* ReplayGain peak */    v    = avio_rb32(s->pb);    peak = av_rescale(v, 100000, 1 << 23);    /* Radio ReplayGain */    v = avio_rb16(s->pb);    if (MIDDLE_BITS(v, 13, 15) == 1) {        r_gain = MIDDLE_BITS(v, 0, 8) * 10000;        if (v & (1 << 9))            r_gain *= -1;    }    /* Audiophile ReplayGain */    v = avio_rb16(s->pb);    if (MIDDLE_BITS(v, 13, 15) == 2) {        a_gain = MIDDLE_BITS(v, 0, 8) * 10000;        if (v & (1 << 9))            a_gain *= -1;    }    /* Encoding flags + ATH Type */    avio_r8(s->pb);    /* if ABR {specified bitrate} else {minimal bitrate} */    avio_r8(s->pb);    /* Encoder delays */    v= avio_rb24(s->pb);    if(AV_RB32(version) == MKBETAG('L', 'A', 'M', 'E')        || AV_RB32(version) == MKBETAG('L', 'a', 'v', 'f')) {        mp3->start_pad = v>>12;        mp3->  end_pad = v&4095;        st->skip_samples = mp3->start_pad + 528 + 1;        if (mp3->frames)            st->end_discard_sample = -mp3->end_pad + 528 + 1 + mp3->frames * (int64_t)spf;        if (!st->start_time)            st->start_time = av_rescale_q(st->skip_samples,                                            (AVRational){1, c->sample_rate},                                            st->time_base);        av_log(s, AV_LOG_DEBUG, \"pad %d %d\\n\", mp3->start_pad, mp3->  end_pad);    }    /* Misc */    avio_r8(s->pb);    /* MP3 gain */    avio_r8(s->pb);    /* Preset and surround info */    avio_rb16(s->pb);    /* Music length */    avio_rb32(s->pb);    /* Music CRC */    avio_rb16(s->pb);    /* Info Tag CRC */    crc = ffio_get_checksum(s->pb);    v   = avio_rb16(s->pb);    if (v == crc) {        ff_replaygain_export_raw(st, r_gain, peak, a_gain, 0);        av_dict_set(&st->metadata, \"encoder\", version, 0);    }}", "idx": 15531}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "function": "static void add_codec(FFServerStream *stream, AVCodecContext *av,                      FFServerConfig *config){    AVStream *st;    AVDictionary **opts, *recommended = NULL;    char *enc_config;    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))        return;    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?           &config->audio_opts : &config->video_opts;    av_dict_copy(&recommended, *opts, 0);    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);    if (av_dict_count(*opts))        av_log(NULL, AV_LOG_WARNING,               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));    if (config->stream_use_defaults) {    //TODO: reident    /* compute default parameters */    switch(av->codec_type) {    case AVMEDIA_TYPE_AUDIO:        if (av->bit_rate == 0) {            av->bit_rate = 64000;            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);        }        if (av->sample_rate == 0) {            av->sample_rate = 22050;            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);        }        if (av->channels == 0) {            av->channels = 1;            av_dict_set_int(&recommended, \"ac\", av->channels, 0);        }        break;    case AVMEDIA_TYPE_VIDEO:        if (av->bit_rate == 0) {            av->bit_rate = 64000;            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);        }        if (av->time_base.num == 0){            av->time_base.den = 5;            av->time_base.num = 1;            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);        }        if (av->width == 0 || av->height == 0) {            av->width = 160;            av->height = 128;            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);        }        /* Bitrate tolerance is less for streaming */        if (av->bit_rate_tolerance == 0) {            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);        }        if (!av->rc_eq) {            av->rc_eq = av_strdup(\"tex^qComp\");            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);        }        if (!av->rc_max_rate) {            av->rc_max_rate = av->bit_rate * 2;            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);        }        if (av->rc_max_rate && !av->rc_buffer_size) {            av->rc_buffer_size = av->rc_max_rate;            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);        }        break;    default:        abort();    }    } else {        switch(av->codec_type) {        case AVMEDIA_TYPE_AUDIO:            if (av->bit_rate == 0)                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,                                    &config->errors, \"audio bit rate is not set\\n\");            if (av->sample_rate == 0)                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,                                    &config->errors, \"audio sample rate is not set\\n\");            break;        case AVMEDIA_TYPE_VIDEO:            if (av->width == 0 || av->height == 0)                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,                                    &config->errors, \"video size is not set\\n\");            break;        default:            av_assert0(0);        }    }    st = av_mallocz(sizeof(AVStream));    if (!st)        return;    av_dict_get_string(recommended, &enc_config, '=', ',');    av_dict_free(&recommended);    av_stream_set_recommended_encoder_configuration(st, enc_config);    st->codec = av;    stream->streams[stream->nb_streams++] = st;}", "idx": 15555}
{"project": "qemu", "commit_id": "eba2af633fb8fa3b20ad578184d79e1f0eabcefe", "target": 1, "function": "int bdrv_open(BlockDriverState *bs, const char *filename, int snapshot){    int fd;    int64_t size;    struct cow_header_v2 cow_header;#ifndef _WIN32    char template[] = \"/tmp/vl.XXXXXX\";    int cow_fd;    struct stat st;#endif    bs->read_only = 0;    bs->fd = -1;    bs->cow_fd = -1;    bs->cow_bitmap = NULL;    strcpy(bs->filename, filename);    /* open standard HD image */#ifdef _WIN32    fd = open(filename, O_RDWR | O_BINARY);#else    fd = open(filename, O_RDWR | O_LARGEFILE);#endif    if (fd < 0) {        /* read only image on disk */#ifdef _WIN32        fd = open(filename, O_RDONLY | O_BINARY);#else        fd = open(filename, O_RDONLY | O_LARGEFILE);#endif        if (fd < 0) {            perror(filename);            goto fail;        }        if (!snapshot)            bs->read_only = 1;    }    bs->fd = fd;    /* see if it is a cow image */    if (read(fd, &cow_header, sizeof(cow_header)) != sizeof(cow_header)) {        fprintf(stderr, \"%s: could not read header\\n\", filename);        goto fail;    }#ifndef _WIN32    if (be32_to_cpu(cow_header.magic) == COW_MAGIC &&        be32_to_cpu(cow_header.version) == COW_VERSION) {        /* cow image found */        size = cow_header.size;#ifndef WORDS_BIGENDIAN        size = bswap64(size);#endif            bs->total_sectors = size / 512;        bs->cow_fd = fd;        bs->fd = -1;        if (cow_header.backing_file[0] != '\\0') {            if (stat(cow_header.backing_file, &st) != 0) {                fprintf(stderr, \"%s: could not find original disk image '%s'\\n\", filename, cow_header.backing_file);                goto fail;            }            if (st.st_mtime != be32_to_cpu(cow_header.mtime)) {                fprintf(stderr, \"%s: original raw disk image '%s' does not match saved timestamp\\n\", filename, cow_header.backing_file);                goto fail;            }            fd = open(cow_header.backing_file, O_RDONLY | O_LARGEFILE);            if (fd < 0)                goto fail;            bs->fd = fd;        }        /* mmap the bitmap */        bs->cow_bitmap_size = ((bs->total_sectors + 7) >> 3) + sizeof(cow_header);        bs->cow_bitmap_addr = mmap(get_mmap_addr(bs->cow_bitmap_size),                                    bs->cow_bitmap_size,                                    PROT_READ | PROT_WRITE,                                   MAP_SHARED, bs->cow_fd, 0);        if (bs->cow_bitmap_addr == MAP_FAILED)            goto fail;        bs->cow_bitmap = bs->cow_bitmap_addr + sizeof(cow_header);        bs->cow_sectors_offset = (bs->cow_bitmap_size + 511) & ~511;        snapshot = 0;    } else #endif    {        /* standard raw image */        size = lseek64(fd, 0, SEEK_END);        bs->total_sectors = size / 512;        bs->fd = fd;    }#ifndef _WIN32    if (snapshot) {        /* create a temporary COW file */        cow_fd = mkstemp64(template);        if (cow_fd < 0)            goto fail;        bs->cow_fd = cow_fd;\tunlink(template);                /* just need to allocate bitmap */        bs->cow_bitmap_size = (bs->total_sectors + 7) >> 3;        bs->cow_bitmap_addr = mmap(get_mmap_addr(bs->cow_bitmap_size),                                    bs->cow_bitmap_size,                                    PROT_READ | PROT_WRITE,                                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (bs->cow_bitmap_addr == MAP_FAILED)            goto fail;        bs->cow_bitmap = bs->cow_bitmap_addr;        bs->cow_sectors_offset = 0;    }#endif        bs->inserted = 1;    /* call the change callback */    if (bs->change_cb)        bs->change_cb(bs->change_opaque);    return 0; fail:    bdrv_close(bs);    return -1;}", "idx": 15563}
{"project": "FFmpeg", "commit_id": "1795fed7bc7a8b8109757cb5f27198c5b05698b5", "target": 1, "function": "static int film_read_packet(AVFormatContext *s,                            AVPacket *pkt){    FilmDemuxContext *film = s->priv_data;    AVIOContext *pb = s->pb;    film_sample *sample;    int ret = 0;    int i;    int left, right;    if (film->current_sample >= film->sample_count)    sample = &film->sample_table[film->current_sample];    /* position the stream (will probably be there anyway) */    avio_seek(pb, sample->sample_offset, SEEK_SET);    /* do a special song and dance when loading FILM Cinepak chunks */    if ((sample->stream == film->video_stream_index) &&        (film->video_type == CODEC_ID_CINEPAK)) {        pkt->pos= avio_tell(pb);        if (av_new_packet(pkt, sample->sample_size))            return AVERROR(ENOMEM);        avio_read(pb, pkt->data, sample->sample_size);    } else if ((sample->stream == film->audio_stream_index) &&        (film->audio_channels == 2) &&        (film->audio_type != CODEC_ID_ADPCM_ADX)) {        /* stereo PCM needs to be interleaved */        if (av_new_packet(pkt, sample->sample_size))            return AVERROR(ENOMEM);        /* make sure the interleave buffer is large enough */        if (sample->sample_size > film->stereo_buffer_size) {            av_free(film->stereo_buffer);            film->stereo_buffer_size = sample->sample_size;            film->stereo_buffer = av_malloc(film->stereo_buffer_size);            if (!film->stereo_buffer) {                film->stereo_buffer_size = 0;                return AVERROR(ENOMEM);            }        }        pkt->pos= avio_tell(pb);        ret = avio_read(pb, film->stereo_buffer, sample->sample_size);        if (ret != sample->sample_size)            ret = AVERROR(EIO);        left = 0;        right = sample->sample_size / 2;        for (i = 0; i < sample->sample_size; ) {            if (film->audio_bits == 8) {                pkt->data[i++] = film->stereo_buffer[left++];                pkt->data[i++] = film->stereo_buffer[right++];            } else {                pkt->data[i++] = film->stereo_buffer[left++];                pkt->data[i++] = film->stereo_buffer[left++];                pkt->data[i++] = film->stereo_buffer[right++];                pkt->data[i++] = film->stereo_buffer[right++];            }        }    } else {        ret= av_get_packet(pb, pkt, sample->sample_size);        if (ret != sample->sample_size)            ret = AVERROR(EIO);    }    pkt->stream_index = sample->stream;    pkt->pts = sample->pts;    film->current_sample++;    return ret;}", "idx": 15584}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "function": "static void spapr_phb_remove_pci_device_cb(DeviceState *dev, void *opaque){    /* some version guests do not wait for completion of a device     * cleanup (generally done asynchronously by the kernel) before     * signaling to QEMU that the device is safe, but instead sleep     * for some 'safe' period of time. unfortunately on a busy host     * this sleep isn't guaranteed to be long enough, resulting in     * bad things like IRQ lines being left asserted during final     * device removal. to deal with this we call reset just prior     * to finalizing the device, which will put the device back into     * an 'idle' state, as the device cleanup code expects.     */    pci_device_reset(PCI_DEVICE(dev));    object_unparent(OBJECT(dev));}", "idx": 15642}
{"project": "FFmpeg", "commit_id": "0af48e29f55a4e5824e6f7157ac94cf8b210aa84", "target": 1, "function": "static void decode_q_branch(SnowContext *s, int level, int x, int y){    const int w= s->b_width << s->block_max_depth;    const int rem_depth= s->block_max_depth - level;    const int index= (x + y*w) << rem_depth;    int trx= (x+1)<<rem_depth;    const BlockNode *left  = x ? &s->block[index-1] : &null_block;    const BlockNode *top   = y ? &s->block[index-w] : &null_block;    const BlockNode *tl    = y && x ? &s->block[index-w-1] : left;    const BlockNode *tr    = y && trx<w && ((x&1)==0 || level==0) ? &s->block[index-w+(1<<rem_depth)] : tl; //FIXME use lt    int s_context= 2*left->level + 2*top->level + tl->level + tr->level;    if(s->keyframe){        set_blocks(s, level, x, y, null_block.color[0], null_block.color[1], null_block.color[2], null_block.mx, null_block.my, null_block.ref, BLOCK_INTRA);        return;    }    if(level==s->block_max_depth || get_rac(&s->c, &s->block_state[4 + s_context])){        int type, mx, my;        int l = left->color[0];        int cb= left->color[1];        int cr= left->color[2];        int ref = 0;        int ref_context= av_log2(2*left->ref) + av_log2(2*top->ref);        int mx_context= av_log2(2*FFABS(left->mx - top->mx)) + 0*av_log2(2*FFABS(tr->mx - top->mx));        int my_context= av_log2(2*FFABS(left->my - top->my)) + 0*av_log2(2*FFABS(tr->my - top->my));        type= get_rac(&s->c, &s->block_state[1 + left->type + top->type]) ? BLOCK_INTRA : 0;        if(type){            pred_mv(s, &mx, &my, 0, left, top, tr);            l += get_symbol(&s->c, &s->block_state[32], 1);            cb+= get_symbol(&s->c, &s->block_state[64], 1);            cr+= get_symbol(&s->c, &s->block_state[96], 1);        }else{            if(s->ref_frames > 1)                ref= get_symbol(&s->c, &s->block_state[128 + 1024 + 32*ref_context], 0);            pred_mv(s, &mx, &my, ref, left, top, tr);            mx+= get_symbol(&s->c, &s->block_state[128 + 32*(mx_context + 16*!!ref)], 1);            my+= get_symbol(&s->c, &s->block_state[128 + 32*(my_context + 16*!!ref)], 1);        }        set_blocks(s, level, x, y, l, cb, cr, mx, my, ref, type);    }else{        decode_q_branch(s, level+1, 2*x+0, 2*y+0);        decode_q_branch(s, level+1, 2*x+1, 2*y+0);        decode_q_branch(s, level+1, 2*x+0, 2*y+1);        decode_q_branch(s, level+1, 2*x+1, 2*y+1);    }}", "idx": 15667}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val){    IntelHDAState *d = opaque;    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);    intel_hda_reg_write(d, reg, val, 0xff);}", "idx": 15728}
{"project": "FFmpeg", "commit_id": "473147bed01c0c6c82d85fd79d3e1c1d65542663", "target": 0, "function": "int ff_cmap_read_palette(AVCodecContext *avctx, uint32_t *pal){    int count, i;    if (avctx->bits_per_coded_sample > 8) {        av_log(avctx, AV_LOG_ERROR, \"bit_per_coded_sample > 8 not supported\\n\");        return AVERROR_INVALIDDATA;    }    count = 1 << avctx->bits_per_coded_sample;    if (avctx->extradata_size < count * 3) {        av_log(avctx, AV_LOG_ERROR, \"palette data underflow\\n\");        return AVERROR_INVALIDDATA;    }    for (i=0; i < count; i++) {        pal[i] = 0xFF000000 | AV_RB24( avctx->extradata + i*3 );    }    return 0;}", "idx": 15736}
{"project": "FFmpeg", "commit_id": "7207dd8f829baee58b4df6c97c19ffde77039e8d", "target": 0, "function": "ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,                      AVStream *st, RMStream *ast, AVPacket *pkt){    RMDemuxContext *rm = s->priv_data;    assert (rm->audio_pkt_cnt > 0);    if (ast->deint_id == DEINT_ID_VBRF ||        ast->deint_id == DEINT_ID_VBRS)        av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);    else {        av_new_packet(pkt, st->codec->block_align);        memcpy(pkt->data, ast->pkt.data + st->codec->block_align * //FIXME avoid this               (ast->sub_packet_h * ast->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt),               st->codec->block_align);    }    rm->audio_pkt_cnt--;    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {        ast->audiotimestamp = AV_NOPTS_VALUE;        pkt->flags = AV_PKT_FLAG_KEY;    } else        pkt->flags = 0;    pkt->stream_index = st->index;    return rm->audio_pkt_cnt;}", "idx": 15746}
{"project": "FFmpeg", "commit_id": "b1563d0cf99a6ac1dd66d8baabe60b1c859a735a", "target": 1, "function": "int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile){    int         mbn, blk, num_blocks, num_coeffs, blk_size, scan_pos, run, val,                pos, is_intra, mc_type, mv_x, mv_y, col_mask;    uint8_t     col_flags[8];    int32_t     prev_dc, trvec[64];    uint32_t    cbp, sym, lo, hi, quant, buf_offs, q;    IVIMbInfo   *mb;    RVMapDesc   *rvmap = band->rv_map;    void (*mc_with_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);    void (*mc_no_delta_func)  (int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);    const uint16_t  *base_tab;    const uint8_t   *scale_tab;    prev_dc = 0; /* init intra prediction for the DC coefficient */    blk_size   = band->blk_size;    col_mask   = blk_size - 1; /* column mask for tracking non-zero coeffs */    num_blocks = (band->mb_size != blk_size) ? 4 : 1; /* number of blocks per mb */    num_coeffs = blk_size * blk_size;    if (blk_size == 8) {        mc_with_delta_func = ff_ivi_mc_8x8_delta;        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;    } else {        mc_with_delta_func = ff_ivi_mc_4x4_delta;        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;    }    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {        is_intra = !mb->type;        cbp      = mb->cbp;        buf_offs = mb->buf_offs;        quant = av_clip(band->glob_quant + mb->q_delta, 0, 23);        base_tab  = is_intra ? band->intra_base  : band->inter_base;        scale_tab = is_intra ? band->intra_scale : band->inter_scale;        if (scale_tab)            quant = scale_tab[quant];        if (!is_intra) {            mv_x = mb->mv_x;            mv_y = mb->mv_y;            if (!band->is_halfpel) {                mc_type = 0; /* we have only fullpel vectors */            } else {                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);                mv_x >>= 1;                mv_y >>= 1; /* convert halfpel vectors into fullpel ones */            }        }        for (blk = 0; blk < num_blocks; blk++) {            /* adjust block position in the buffer according to its number */            if (blk & 1) {                buf_offs += blk_size;            } else if (blk == 2) {                buf_offs -= blk_size;                buf_offs += blk_size * band->pitch;            }            if (cbp & 1) { /* block coded ? */                scan_pos = -1;                memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */                memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */                while (scan_pos <= num_coeffs) {                    sym = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);                    if (sym == rvmap->eob_sym)                        break; /* End of block */                    if (sym == rvmap->esc_sym) { /* Escape - run/val explicitly coded using 3 vlc codes */                        run = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1) + 1;                        lo  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);                        hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);                        val = IVI_TOSIGNED((hi << 6) | lo); /* merge them and convert into signed val */                    } else {                        if (sym >= 256U) {                            av_log(NULL, AV_LOG_ERROR, \"Invalid sym encountered: %d.\\n\", sym);                            return -1;                        }                        run = rvmap->runtab[sym];                        val = rvmap->valtab[sym];                    }                    /* de-zigzag and dequantize */                    scan_pos += run;                    if (scan_pos >= num_coeffs)                        break;                    pos = band->scan[scan_pos];                    if (!val)                        av_dlog(NULL, \"Val = 0 encountered!\\n\");                    q = (base_tab[pos] * quant) >> 9;                    if (q > 1)                        val = val * q + FFSIGN(val) * (((q ^ 1) - 1) >> 1);                    trvec[pos] = val;                    col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */                }// while                if (scan_pos >= num_coeffs && sym != rvmap->eob_sym)                    return -1; /* corrupt block data */                /* undoing DC coeff prediction for intra-blocks */                if (is_intra && band->is_2d_trans) {                    prev_dc      += trvec[0];                    trvec[0]      = prev_dc;                    col_flags[0] |= !!prev_dc;                }                /* apply inverse transform */                band->inv_transform(trvec, band->buf + buf_offs,                                    band->pitch, col_flags);                /* apply motion compensation */                if (!is_intra)                    mc_with_delta_func(band->buf + buf_offs,                                       band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,                                       band->pitch, mc_type);            } else {                /* block not coded */                /* for intra blocks apply the dc slant transform */                /* for inter - perform the motion compensation without delta */                if (is_intra && band->dc_transform) {                    band->dc_transform(&prev_dc, band->buf + buf_offs,                                       band->pitch, blk_size);                } else                    mc_no_delta_func(band->buf + buf_offs,                                     band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,                                     band->pitch, mc_type);            }            cbp >>= 1;        }// for blk    }// for mbn    align_get_bits(gb);    return 0;}", "idx": 15755}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "function": "static CharDriverState *qemu_chr_open_pipe(QemuOpts *opts){    int fd_in, fd_out;    char filename_in[256], filename_out[256];    const char *filename = qemu_opt_get(opts, \"path\");    if (filename == NULL) {        fprintf(stderr, \"chardev: pipe: no filename given\\n\");        return NULL;    }    snprintf(filename_in, 256, \"%s.in\", filename);    snprintf(filename_out, 256, \"%s.out\", filename);    TFR(fd_in = open(filename_in, O_RDWR | O_BINARY));    TFR(fd_out = open(filename_out, O_RDWR | O_BINARY));    if (fd_in < 0 || fd_out < 0) {\tif (fd_in >= 0)\t    close(fd_in);\tif (fd_out >= 0)\t    close(fd_out);        TFR(fd_in = fd_out = open(filename, O_RDWR | O_BINARY));        if (fd_in < 0)            return NULL;    }    return qemu_chr_open_fd(fd_in, fd_out);}", "idx": 15770}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "function": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc){    switch (drc->state) {    case SPAPR_DRC_STATE_PHYSICAL_POWERON:        return RTAS_OUT_SUCCESS; /* Nothing to do */    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:        break; /* see below */    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:        return RTAS_OUT_PARAM_ERROR; /* not allowed */    default:        g_assert_not_reached();    }    /* if the guest is configuring a device attached to this DRC, we     * should reset the configuration state at this point since it may     * no longer be reliable (guest released device and needs to start     * over, or unplug occurred so the FDT is no longer valid)     */    g_free(drc->ccs);    drc->ccs = NULL;    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;    if (drc->unplug_requested) {        uint32_t drc_index = spapr_drc_index(drc);        trace_spapr_drc_set_isolation_state_finalizing(drc_index);        spapr_drc_detach(drc);    }    return RTAS_OUT_SUCCESS;}", "idx": 15818}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "function": "static void decode_scaling_list(H264Context *h, uint8_t *factors, int size,                                const uint8_t *jvt_list,                                const uint8_t *fallback_list){    int i, last = 8, next = 8;    const uint8_t *scan = size == 16 ? ff_zigzag_scan : ff_zigzag_direct;    if (!get_bits1(&h->gb)) /* matrix not written, we use the predicted one */        memcpy(factors, fallback_list, size * sizeof(uint8_t));    else        for (i = 0; i < size; i++) {            if (next)                next = (last + get_se_golomb(&h->gb)) & 0xff;            if (!i && !next) { /* matrix not written, we use the preset one */                memcpy(factors, jvt_list, size * sizeof(uint8_t));                break;            }            last = factors[scan[i]] = next ? next : last;        }}", "idx": 15843}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "function": "void bdrv_iterate_format(void (*it)(void *opaque, const char *name),                         void *opaque){    BlockDriver *drv;    int count = 0;    int i;    const char **formats = NULL;    QLIST_FOREACH(drv, &bdrv_drivers, list) {        if (drv->format_name) {            bool found = false;            int i = count;            while (formats && i && !found) {                found = !strcmp(formats[--i], drv->format_name);            }            if (!found) {                formats = g_renew(const char *, formats, count + 1);                formats[count++] = drv->format_name;            }        }    }    qsort(formats, count, sizeof(formats[0]), qsort_strcmp);    for (i = 0; i < count; i++) {        it(opaque, formats[i]);    }    g_free(formats);}", "idx": 15893}
{"project": "FFmpeg", "commit_id": "c4be288fdbe1993110f1abd28ea57587cb2bc221", "target": 0, "function": "static void write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost){    AVFormatContext *s = of->ctx;    AVStream *st = ost->st;    int ret;    if (!of->header_written) {        AVPacket tmp_pkt = {0};        /* the muxer is not initialized yet, buffer the packet */        if (!av_fifo_space(ost->muxing_queue)) {            int new_size = FFMIN(2 * av_fifo_size(ost->muxing_queue),                                 ost->max_muxing_queue_size);            if (new_size <= av_fifo_size(ost->muxing_queue)) {                av_log(NULL, AV_LOG_ERROR,                       \"Too many packets buffered for output stream %d:%d.\\n\",                       ost->file_index, ost->st->index);                exit_program(1);            }            ret = av_fifo_realloc2(ost->muxing_queue, new_size);            if (ret < 0)                exit_program(1);        }        ret = av_packet_ref(&tmp_pkt, pkt);        if (ret < 0)            exit_program(1);        av_fifo_generic_write(ost->muxing_queue, &tmp_pkt, sizeof(tmp_pkt), NULL);        av_packet_unref(pkt);        return;    }    if ((st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||        (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))        pkt->pts = pkt->dts = AV_NOPTS_VALUE;    /*     * Audio encoders may split the packets --  #frames in != #packets out.     * But there is no reordering, so we can limit the number of output packets     * by simply dropping them here.     * Counting encoded video frames needs to be done separately because of     * reordering, see do_video_out()     */    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) {        if (ost->frame_number >= ost->max_frames) {            av_packet_unref(pkt);            return;        }        ost->frame_number++;    }    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {        int i;        uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_STATS,                                              NULL);        ost->quality = sd ? AV_RL32(sd) : -1;        ost->pict_type = sd ? sd[4] : AV_PICTURE_TYPE_NONE;        for (i = 0; i<FF_ARRAY_ELEMS(ost->error); i++) {            if (sd && i < sd[5])                ost->error[i] = AV_RL64(sd + 8 + 8*i);            else                ost->error[i] = -1;        }        if (ost->frame_rate.num && ost->is_cfr) {            if (pkt->duration > 0)                av_log(NULL, AV_LOG_WARNING, \"Overriding packet duration by frame rate, this should not happen\\n\");            pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate),                                         ost->mux_timebase);        }    }    av_packet_rescale_ts(pkt, ost->mux_timebase, ost->st->time_base);    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS)) {        if (pkt->dts != AV_NOPTS_VALUE &&            pkt->pts != AV_NOPTS_VALUE &&            pkt->dts > pkt->pts) {            av_log(s, AV_LOG_WARNING, \"Invalid DTS: %\"PRId64\" PTS: %\"PRId64\" in output stream %d:%d, replacing by guess\\n\",                   pkt->dts, pkt->pts,                   ost->file_index, ost->st->index);            pkt->pts =            pkt->dts = pkt->pts + pkt->dts + ost->last_mux_dts + 1                     - FFMIN3(pkt->pts, pkt->dts, ost->last_mux_dts + 1)                     - FFMAX3(pkt->pts, pkt->dts, ost->last_mux_dts + 1);        }        if ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) &&            pkt->dts != AV_NOPTS_VALUE &&            !(st->codecpar->codec_id == AV_CODEC_ID_VP9 && ost->stream_copy) &&            ost->last_mux_dts != AV_NOPTS_VALUE) {            int64_t max = ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);            if (pkt->dts < max) {                int loglevel = max - pkt->dts > 2 || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ? AV_LOG_WARNING : AV_LOG_DEBUG;                av_log(s, loglevel, \"Non-monotonous DTS in output stream \"                       \"%d:%d; previous: %\"PRId64\", current: %\"PRId64\"; \",                       ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);                if (exit_on_error) {                    av_log(NULL, AV_LOG_FATAL, \"aborting.\\n\");                    exit_program(1);                }                av_log(s, loglevel, \"changing to %\"PRId64\". This may result \"                       \"in incorrect timestamps in the output file.\\n\",                       max);                if (pkt->pts >= pkt->dts)                    pkt->pts = FFMAX(pkt->pts, max);                pkt->dts = max;            }        }    }    ost->last_mux_dts = pkt->dts;    ost->data_size += pkt->size;    ost->packets_written++;    pkt->stream_index = ost->index;    if (debug_ts) {        av_log(NULL, AV_LOG_INFO, \"muxer <- type:%s \"                \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",                av_get_media_type_string(ost->enc_ctx->codec_type),                av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &ost->st->time_base),                av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &ost->st->time_base),                pkt->size              );    }    ret = av_interleaved_write_frame(s, pkt);    if (ret < 0) {        print_error(\"av_interleaved_write_frame()\", ret);        main_return_code = 1;        close_all_output_streams(ost, MUXER_FINISHED | ENCODER_FINISHED, ENCODER_FINISHED);    }    av_packet_unref(pkt);}", "idx": 15919}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "function": "void sparc64_set_context(CPUSPARCState *env){    abi_ulong ucp_addr;    struct target_ucontext *ucp;    target_mc_gregset_t *grp;    abi_ulong pc, npc, tstate;    abi_ulong fp, i7, w_addr;    int err;    unsigned int i;    ucp_addr = env->regwptr[UREG_I0];    if (!lock_user_struct(VERIFY_READ, ucp, ucp_addr, 1))        goto do_sigsegv;    grp  = &ucp->tuc_mcontext.mc_gregs;    err  = __get_user(pc, &((*grp)[MC_PC]));    err |= __get_user(npc, &((*grp)[MC_NPC]));    if (err || ((pc | npc) & 3))        goto do_sigsegv;    if (env->regwptr[UREG_I1]) {        target_sigset_t target_set;        sigset_t set;        if (TARGET_NSIG_WORDS == 1) {            if (__get_user(target_set.sig[0], &ucp->tuc_sigmask.sig[0]))                goto do_sigsegv;        } else {            abi_ulong *src, *dst;            src = ucp->tuc_sigmask.sig;            dst = target_set.sig;            for (i = 0; i < TARGET_NSIG_WORDS; i++, dst++, src++) {                err |= __get_user(*dst, src);            }            if (err)                goto do_sigsegv;        }        target_to_host_sigset_internal(&set, &target_set);        sigprocmask(SIG_SETMASK, &set, NULL);    }    env->pc = pc;    env->npc = npc;    err |= __get_user(env->y, &((*grp)[MC_Y]));    err |= __get_user(tstate, &((*grp)[MC_TSTATE]));    env->asi = (tstate >> 24) & 0xff;    cpu_put_ccr(env, tstate >> 32);    cpu_put_cwp64(env, tstate & 0x1f);    err |= __get_user(env->gregs[1], (&(*grp)[MC_G1]));    err |= __get_user(env->gregs[2], (&(*grp)[MC_G2]));    err |= __get_user(env->gregs[3], (&(*grp)[MC_G3]));    err |= __get_user(env->gregs[4], (&(*grp)[MC_G4]));    err |= __get_user(env->gregs[5], (&(*grp)[MC_G5]));    err |= __get_user(env->gregs[6], (&(*grp)[MC_G6]));    err |= __get_user(env->gregs[7], (&(*grp)[MC_G7]));    err |= __get_user(env->regwptr[UREG_I0], (&(*grp)[MC_O0]));    err |= __get_user(env->regwptr[UREG_I1], (&(*grp)[MC_O1]));    err |= __get_user(env->regwptr[UREG_I2], (&(*grp)[MC_O2]));    err |= __get_user(env->regwptr[UREG_I3], (&(*grp)[MC_O3]));    err |= __get_user(env->regwptr[UREG_I4], (&(*grp)[MC_O4]));    err |= __get_user(env->regwptr[UREG_I5], (&(*grp)[MC_O5]));    err |= __get_user(env->regwptr[UREG_I6], (&(*grp)[MC_O6]));    err |= __get_user(env->regwptr[UREG_I7], (&(*grp)[MC_O7]));    err |= __get_user(fp, &(ucp->tuc_mcontext.mc_fp));    err |= __get_user(i7, &(ucp->tuc_mcontext.mc_i7));    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];    if (put_user(fp, w_addr + offsetof(struct target_reg_window, ins[6]),                  abi_ulong) != 0)        goto do_sigsegv;    if (put_user(i7, w_addr + offsetof(struct target_reg_window, ins[7]),                  abi_ulong) != 0)        goto do_sigsegv;    /* FIXME this does not match how the kernel handles the FPU in     * its sparc64_set_context implementation. In particular the FPU     * is only restored if fenab is non-zero in:     *   __get_user(fenab, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_enab));     */    err |= __get_user(env->fprs, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fprs));    {        uint32_t *src = ucp->tuc_mcontext.mc_fpregs.mcfpu_fregs.sregs;        for (i = 0; i < 64; i++, src++) {            if (i & 1) {                err |= __get_user(env->fpr[i/2].l.lower, src);            } else {                err |= __get_user(env->fpr[i/2].l.upper, src);            }        }    }    err |= __get_user(env->fsr,                      &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fsr));    err |= __get_user(env->gsr,                      &(ucp->tuc_mcontext.mc_fpregs.mcfpu_gsr));    if (err)        goto do_sigsegv;    unlock_user_struct(ucp, ucp_addr, 0);    return; do_sigsegv:    unlock_user_struct(ucp, ucp_addr, 0);    force_sig(TARGET_SIGSEGV);}", "idx": 15926}
{"project": "FFmpeg", "commit_id": "937cfebd72d30e617591c666ea4854a3898a64b2", "target": 0, "function": "static int init(AVFilterContext *ctx){    EvalContext *eval = ctx->priv;    char *args1 = av_strdup(eval->exprs);    char *expr, *buf;    int ret, i;    if (!args1) {        av_log(ctx, AV_LOG_ERROR, \"Channels expressions list is empty\\n\");        ret = eval->exprs ? AVERROR(ENOMEM) : AVERROR(EINVAL);        goto end;    }    /* parse expressions */    buf = args1;    i = 0;    while (i < FF_ARRAY_ELEMS(eval->expr) && (expr = av_strtok(buf, \"|\", &buf))) {        ret = av_expr_parse(&eval->expr[i], expr, var_names,                            NULL, NULL, NULL, NULL, 0, ctx);        if (ret < 0)            goto end;        i++;    }    eval->nb_channels = i;    if (eval->chlayout_str) {        int n;        ret = ff_parse_channel_layout(&eval->chlayout, eval->chlayout_str, ctx);        if (ret < 0)            goto end;        n = av_get_channel_layout_nb_channels(eval->chlayout);        if (n != eval->nb_channels) {            av_log(ctx, AV_LOG_ERROR,                   \"Mismatch between the specified number of channels '%d' \"                   \"and the number of channels '%d' in the specified channel layout '%s'\\n\",                   eval->nb_channels, n, eval->chlayout_str);            ret = AVERROR(EINVAL);            goto end;        }    } else {        /* guess channel layout from nb expressions/channels */        eval->chlayout = av_get_default_channel_layout(eval->nb_channels);        if (!eval->chlayout) {            av_log(ctx, AV_LOG_ERROR, \"Invalid number of channels '%d' provided\\n\",                   eval->nb_channels);            ret = AVERROR(EINVAL);            goto end;        }    }    if ((ret = ff_parse_sample_rate(&eval->sample_rate, eval->sample_rate_str, ctx)))        goto end;    eval->n = 0;end:    av_free(args1);    return ret;}", "idx": 15979}
{"project": "FFmpeg", "commit_id": "57d24225595af78b0fd836d4d145f5d181e320a2", "target": 0, "function": "static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *pkt){    OutputFile *of = output_files[ost->file_index];    int64_t ost_tb_start_time = av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);    AVPacket opkt;    av_init_packet(&opkt);    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) &&        !ost->copy_initial_nonkeyframes)        return;    if (of->recording_time != INT64_MAX &&        ist->last_dts >= of->recording_time + of->start_time) {        ost->is_past_recording_time = 1;        return;    }    /* force the input stream PTS */    if (ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)        audio_size += pkt->size;    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {        video_size += pkt->size;        ost->sync_opts++;    }    if (pkt->pts != AV_NOPTS_VALUE)        opkt.pts = av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;    else        opkt.pts = AV_NOPTS_VALUE;    if (pkt->dts == AV_NOPTS_VALUE)        opkt.dts = av_rescale_q(ist->last_dts, AV_TIME_BASE_Q, ost->st->time_base);    else        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);    opkt.dts -= ost_tb_start_time;    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);    opkt.flags    = pkt->flags;    // FIXME remove the following 2 lines they shall be replaced by the bitstream filters    if (  ost->st->codec->codec_id != AV_CODEC_ID_H264       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG1VIDEO       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG2VIDEO       && ost->st->codec->codec_id != AV_CODEC_ID_VC1       ) {        if (av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY))            opkt.destruct = av_destruct_packet;    } else {        opkt.data = pkt->data;        opkt.size = pkt->size;    }    write_frame(of->ctx, &opkt, ost);    ost->st->codec->frame_number++;    av_free_packet(&opkt);}", "idx": 15995}
{"project": "FFmpeg", "commit_id": "898276c16b1683ac77723e97574a3bfdb29507fd", "target": 0, "function": "static int r3d_read_reda(AVFormatContext *s, AVPacket *pkt, Atom *atom){    AVStream *st = s->streams[1];    int av_unused tmp, tmp2;    int samples, size;    uint64_t pos = avio_tell(s->pb);    unsigned dts;    int ret;    dts = avio_rb32(s->pb);    st->codec->sample_rate = avio_rb32(s->pb);    if (st->codec->sample_rate <= 0) {        av_log(s, AV_LOG_ERROR, \"Bad sample rate\\n\");        return AVERROR_INVALIDDATA;    }    samples = avio_rb32(s->pb);    tmp = avio_rb32(s->pb);    av_dlog(s, \"packet num %d\\n\", tmp);    tmp = avio_rb16(s->pb); // unknown    av_dlog(s, \"unknown %d\\n\", tmp);    tmp  = avio_r8(s->pb); // major version    tmp2 = avio_r8(s->pb); // minor version    av_dlog(s, \"version %d.%d\\n\", tmp, tmp2);    tmp = avio_rb32(s->pb); // unknown    av_dlog(s, \"unknown %d\\n\", tmp);    size = atom->size - 8 - (avio_tell(s->pb) - pos);    if (size < 0)        return -1;    ret = av_get_packet(s->pb, pkt, size);    if (ret < 0) {        av_log(s, AV_LOG_ERROR, \"error reading audio packet\\n\");        return ret;    }    pkt->stream_index = 1;    pkt->dts = dts;    pkt->duration = av_rescale(samples, st->time_base.den, st->codec->sample_rate);    av_dlog(s, \"pkt dts %\"PRId64\" duration %d samples %d sample rate %d\\n\",            pkt->dts, pkt->duration, samples, st->codec->sample_rate);    return 0;}", "idx": 15998}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "function": "void hmp_hostfwd_add(Monitor *mon, const QDict *qdict){    const char *redir_str;    SlirpState *s;    const char *arg1 = qdict_get_str(qdict, \"arg1\");    const char *arg2 = qdict_get_try_str(qdict, \"arg2\");    const char *arg3 = qdict_get_try_str(qdict, \"arg3\");    if (arg2) {        s = slirp_lookup(mon, arg1, arg2);        redir_str = arg3;    } else {        s = slirp_lookup(mon, NULL, NULL);        redir_str = arg1;    }    if (s) {        slirp_hostfwd(s, redir_str, 0);    }}", "idx": 16000}
{"project": "qemu", "commit_id": "a1bb73849fbd7d992b6ac2cf30c034244fb2299d", "target": 1, "function": "void helper_rfci(CPUPPCState *env){    do_rfi(env, env->spr[SPR_BOOKE_CSRR0], SPR_BOOKE_CSRR1,           ~((target_ulong)0x3FFF0000), 0);}", "idx": 16011}
{"project": "qemu", "commit_id": "b7079df4100069959f4e9d90d5cb5ba7d4ebbf1a", "target": 0, "function": "static int curl_find_buf(BDRVCURLState *s, size_t start, size_t len,                         CURLAIOCB *acb){    int i;    size_t end = start + len;    for (i=0; i<CURL_NUM_STATES; i++) {        CURLState *state = &s->states[i];        size_t buf_end = (state->buf_start + state->buf_off);        size_t buf_fend = (state->buf_start + state->buf_len);        if (!state->orig_buf)            continue;        if (!state->buf_off)            continue;        // Does the existing buffer cover our section?        if ((start >= state->buf_start) &&            (start <= buf_end) &&            (end >= state->buf_start) &&            (end <= buf_end))        {            char *buf = state->orig_buf + (start - state->buf_start);            qemu_iovec_from_buf(acb->qiov, 0, buf, len);            acb->common.cb(acb->common.opaque, 0);            return FIND_RET_OK;        }        // Wait for unfinished chunks        if ((start >= state->buf_start) &&            (start <= buf_fend) &&            (end >= state->buf_start) &&            (end <= buf_fend))        {            int j;            acb->start = start - state->buf_start;            acb->end = acb->start + len;            for (j=0; j<CURL_NUM_ACB; j++) {                if (!state->acb[j]) {                    state->acb[j] = acb;                    return FIND_RET_WAIT;                }            }        }    }    return FIND_RET_NONE;}", "idx": 16040}
{"project": "FFmpeg", "commit_id": "fee7c42bf45f72d457fafaee536f054ce59e4ec5", "target": 1, "function": "static int aac_decode_er_frame(AVCodecContext *avctx, void *data,                               int *got_frame_ptr, GetBitContext *gb){    AACContext *ac = avctx->priv_data;    const MPEG4AudioConfig *const m4ac = &ac->oc[1].m4ac;    ChannelElement *che;    int err, i;    int samples = m4ac->frame_length_short ? 960 : 1024;    int chan_config = m4ac->chan_config;    int aot = m4ac->object_type;    if (aot == AOT_ER_AAC_LD || aot == AOT_ER_AAC_ELD)        samples >>= 1;    ac->frame = data;    if ((err = frame_configure_elements(avctx)) < 0)        return err;    // The FF_PROFILE_AAC_* defines are all object_type - 1    // This may lead to an undefined profile being signaled    ac->avctx->profile = aot - 1;    ac->tags_mapped = 0;    if (chan_config < 0 || (chan_config >= 8 && chan_config < 11) || chan_config >= 13) {        avpriv_request_sample(avctx, \"Unknown ER channel configuration %d\",                              chan_config);        return AVERROR_INVALIDDATA;    }    for (i = 0; i < tags_per_config[chan_config]; i++) {        const int elem_type = aac_channel_layout_map[chan_config-1][i][0];        const int elem_id   = aac_channel_layout_map[chan_config-1][i][1];        if (!(che=get_che(ac, elem_type, elem_id))) {            av_log(ac->avctx, AV_LOG_ERROR,                   \"channel element %d.%d is not allocated\\n\",                   elem_type, elem_id);            return AVERROR_INVALIDDATA;        }        che->present = 1;        if (aot != AOT_ER_AAC_ELD)            skip_bits(gb, 4);        switch (elem_type) {        case TYPE_SCE:            err = decode_ics(ac, &che->ch[0], gb, 0, 0);            break;        case TYPE_CPE:            err = decode_cpe(ac, gb, che);            break;        case TYPE_LFE:            err = decode_ics(ac, &che->ch[0], gb, 0, 0);            break;        }        if (err < 0)            return err;    }    spectral_to_sample(ac);    ac->frame->nb_samples = samples;    ac->frame->sample_rate = avctx->sample_rate;    *got_frame_ptr = 1;    skip_bits_long(gb, get_bits_left(gb));    return 0;}", "idx": 16097}
{"project": "FFmpeg", "commit_id": "d42ec8433c687fcbccefa51a7716d81920218e4f", "target": 1, "function": "static int decode_frame(AVCodecContext *avctx,                            void *data, int *got_frame,                            AVPacket *avpkt){    AnsiContext *s = avctx->priv_data;    uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    const uint8_t *buf_end   = buf+buf_size;    int ret, i, count;    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)        return ret;    if (!avctx->frame_number) {        for (i=0; i<avctx->height; i++)            memset(s->frame->data[0]+ i*s->frame->linesize[0], 0, avctx->width);        memset(s->frame->data[1], 0, AVPALETTE_SIZE);    }    s->frame->pict_type           = AV_PICTURE_TYPE_I;    s->frame->palette_has_changed = 1;    set_palette((uint32_t *)s->frame->data[1]);    if (!s->first_frame) {        erase_screen(avctx);        s->first_frame = 1;    }    while(buf < buf_end) {        switch(s->state) {        case STATE_NORMAL:            switch (buf[0]) {            case 0x00: //NUL            case 0x07: //BEL            case 0x1A: //SUB                /* ignore */                break;            case 0x08: //BS                s->x = FFMAX(s->x - 1, 0);                break;            case 0x09: //HT                i = s->x / FONT_WIDTH;                count = ((i + 8) & ~7) - i;                for (i = 0; i < count; i++)                    draw_char(avctx, ' ');                break;            case 0x0A: //LF                hscroll(avctx);            case 0x0D: //CR                s->x = 0;                break;            case 0x0C: //FF                erase_screen(avctx);                break;            case 0x1B: //ESC                s->state = STATE_ESCAPE;                break;            default:                draw_char(avctx, buf[0]);            }            break;        case STATE_ESCAPE:            if (buf[0] == '[') {                s->state   = STATE_CODE;                s->nb_args = 0;                s->args[0] = -1;            } else {                s->state = STATE_NORMAL;                draw_char(avctx, 0x1B);                continue;            }            break;        case STATE_CODE:            switch(buf[0]) {            case '0': case '1': case '2': case '3': case '4':            case '5': case '6': case '7': case '8': case '9':                if (s->nb_args < MAX_NB_ARGS)                    s->args[s->nb_args] = FFMAX(s->args[s->nb_args], 0) * 10 + buf[0] - '0';                break;            case ';':                s->nb_args++;                if (s->nb_args < MAX_NB_ARGS)                    s->args[s->nb_args] = 0;                break;            case 'M':                s->state = STATE_MUSIC_PREAMBLE;                break;            case '=': case '?':                /* ignore */                break;            default:                if (s->nb_args > MAX_NB_ARGS)                    av_log(avctx, AV_LOG_WARNING, \"args overflow (%i)\\n\", s->nb_args);                if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] >= 0)                    s->nb_args++;                if ((ret = execute_code(avctx, buf[0])) < 0)                    return ret;                s->state = STATE_NORMAL;            }            break;        case STATE_MUSIC_PREAMBLE:            if (buf[0] == 0x0E || buf[0] == 0x1B)                s->state = STATE_NORMAL;            /* ignore music data */            break;        }        buf++;    }    *got_frame = 1;    if ((ret = av_frame_ref(data, s->frame)) < 0)        return ret;    return buf_size;}", "idx": 16120}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "function": "static int64_t coroutine_fn qcow_co_get_block_status(BlockDriverState *bs,        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file){    BDRVQcowState *s = bs->opaque;    int index_in_cluster, n;    uint64_t cluster_offset;    qemu_co_mutex_lock(&s->lock);    cluster_offset = get_cluster_offset(bs, sector_num << 9, 0, 0, 0, 0);    qemu_co_mutex_unlock(&s->lock);    index_in_cluster = sector_num & (s->cluster_sectors - 1);    n = s->cluster_sectors - index_in_cluster;    if (n > nb_sectors)        n = nb_sectors;    *pnum = n;    if (!cluster_offset) {        return 0;    }    if ((cluster_offset & QCOW_OFLAG_COMPRESSED) || s->cipher) {        return BDRV_BLOCK_DATA;    }    cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);    *file = bs->file->bs;    return BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID | cluster_offset;}", "idx": 16158}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "function": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,                                 ptrdiff_t stride){    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,                                           stride, dst, stride, 16, 0);}", "idx": 16255}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "function": "static int coroutine_fn bdrv_co_do_copy_on_readv(BlockDriverState *bs,        int64_t sector_num, int nb_sectors, QEMUIOVector *qiov){    /* Perform I/O through a temporary buffer so that users who scribble over     * their read buffer while the operation is in progress do not end up     * modifying the image file.  This is critical for zero-copy guest I/O     * where anything might happen inside guest memory.     */    void *bounce_buffer;    BlockDriver *drv = bs->drv;    struct iovec iov;    QEMUIOVector bounce_qiov;    int64_t cluster_sector_num;    int cluster_nb_sectors;    size_t skip_bytes;    int ret;    /* Cover entire cluster so no additional backing file I/O is required when     * allocating cluster in the image file.     */    bdrv_round_to_clusters(bs, sector_num, nb_sectors,                           &cluster_sector_num, &cluster_nb_sectors);    trace_bdrv_co_do_copy_on_readv(bs, sector_num, nb_sectors,                                   cluster_sector_num, cluster_nb_sectors);    iov.iov_len = cluster_nb_sectors * BDRV_SECTOR_SIZE;    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);    if (bounce_buffer == NULL) {        ret = -ENOMEM;        goto err;    }    qemu_iovec_init_external(&bounce_qiov, &iov, 1);    ret = drv->bdrv_co_readv(bs, cluster_sector_num, cluster_nb_sectors,                             &bounce_qiov);    if (ret < 0) {        goto err;    }    if (drv->bdrv_co_write_zeroes &&        buffer_is_zero(bounce_buffer, iov.iov_len)) {        ret = bdrv_co_do_write_zeroes(bs, cluster_sector_num,                                      cluster_nb_sectors, 0);    } else {        /* This does not change the data on the disk, it is not necessary         * to flush even in cache=writethrough mode.         */        ret = drv->bdrv_co_writev(bs, cluster_sector_num, cluster_nb_sectors,                                  &bounce_qiov);    }    if (ret < 0) {        /* It might be okay to ignore write errors for guest requests.  If this         * is a deliberate copy-on-read then we don't want to ignore the error.         * Simply report it in all cases.         */        goto err;    }    skip_bytes = (sector_num - cluster_sector_num) * BDRV_SECTOR_SIZE;    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes,                        nb_sectors * BDRV_SECTOR_SIZE);err:    qemu_vfree(bounce_buffer);    return ret;}", "idx": 16270}
{"project": "qemu", "commit_id": "b11e20fb6c658bc13b2e4dfc1b86c2eb8731e374", "target": 1, "function": "static void cleanup_infolist(CommandLineParameterInfoList *head){    CommandLineParameterInfoList *pre_entry, *cur, *del_entry;    cur = head;    while (cur->next) {        pre_entry = head;        while (pre_entry != cur->next) {            if (!strcmp(pre_entry->value->name, cur->next->value->name)) {                del_entry = cur->next;                cur->next = cur->next->next;                g_free(del_entry);                break;            }            pre_entry = pre_entry->next;        }        cur = cur->next;    }}", "idx": 16294}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "function": "static void omap_mcbsp_source_tick(void *opaque){    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *) opaque;    static const int bps[8] = { 0, 1, 1, 2, 2, 2, -255, -255 };    if (!s->rx_rate)        return;    if (s->rx_req)        printf(\"%s: Rx FIFO overrun\\n\", __FUNCTION__);    s->rx_req = s->rx_rate << bps[(s->rcr[0] >> 5) & 7];    omap_mcbsp_rx_newdata(s);    timer_mod(s->source_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +                   NANOSECONDS_PER_SECOND);}", "idx": 16314}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "function": "int64_t bdrv_nb_sectors(BlockDriverState *bs){    BlockDriver *drv = bs->drv;    if (!drv)        return -ENOMEDIUM;    if (drv->has_variable_length) {        int ret = refresh_total_sectors(bs, bs->total_sectors);        if (ret < 0) {            return ret;        }    }    return bs->total_sectors;}", "idx": 16319}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "function": "static void udp_chr_update_read_handler(CharDriverState *chr){    NetCharDriver *s = chr->opaque;    if (s->tag) {        g_source_remove(s->tag);        s->tag = 0;    }    if (s->chan) {        s->tag = io_add_watch_poll(s->chan, udp_chr_read_poll, udp_chr_read, chr);    }}", "idx": 16339}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "function": "static int dvvideo_encode_close(AVCodecContext *avctx){    av_frame_free(&avctx->coded_frame);    return 0;}", "idx": 16401}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "function": "static void nbd_detach_aio_context(BlockDriverState *bs){    BDRVNBDState *s = bs->opaque;    nbd_client_session_detach_aio_context(&s->client);}", "idx": 16404}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "function": "static void *iothread_run(void *opaque){    IOThread *iothread = opaque;    qemu_mutex_lock(&iothread->init_done_lock);    iothread->thread_id = qemu_get_thread_id();    qemu_cond_signal(&iothread->init_done_cond);    qemu_mutex_unlock(&iothread->init_done_lock);    while (!iothread->stopping) {        aio_context_acquire(iothread->ctx);        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {            /* Progress was made, keep going */        }        aio_context_release(iothread->ctx);    }    return NULL;}", "idx": 16410}
{"project": "qemu", "commit_id": "e8dd1d9c396104f0fac4b39a701143df49df2a74", "target": 0, "function": "static void netmap_send(void *opaque){    NetmapState *s = opaque;    struct netmap_ring *ring = s->me.rx;    /* Keep sending while there are available packets into the netmap       RX ring and the forwarding path towards the peer is open. */    while (!nm_ring_empty(ring) && qemu_can_send_packet(&s->nc)) {        uint32_t i;        uint32_t idx;        bool morefrag;        int iovcnt = 0;        int iovsize;        do {            i = ring->cur;            idx = ring->slot[i].buf_idx;            morefrag = (ring->slot[i].flags & NS_MOREFRAG);            s->iov[iovcnt].iov_base = (u_char *)NETMAP_BUF(ring, idx);            s->iov[iovcnt].iov_len = ring->slot[i].len;            iovcnt++;            ring->cur = ring->head = nm_ring_next(ring, i);        } while (!nm_ring_empty(ring) && morefrag);        if (unlikely(nm_ring_empty(ring) && morefrag)) {            RD(5, \"[netmap_send] ran out of slots, with a pending\"                   \"incomplete packet\\n\");        }        iovsize = qemu_sendv_packet_async(&s->nc, s->iov, iovcnt,                                            netmap_send_completed);        if (iovsize == 0) {            /* The peer does not receive anymore. Packet is queued, stop             * reading from the backend until netmap_send_completed()             */            netmap_read_poll(s, false);            break;        }    }}", "idx": 16417}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "function": "void do_delvm(Monitor *mon, const QDict *qdict){    BlockDriverState *bs, *bs1;    Error *err = NULL;    const char *name = qdict_get_str(qdict, \"name\");    bs = find_vmstate_bs();    if (!bs) {        monitor_printf(mon, \"No block device supports snapshots\\n\");        return;    }    bs1 = NULL;    while ((bs1 = bdrv_next(bs1))) {        if (bdrv_can_snapshot(bs1)) {            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);            if (err) {                monitor_printf(mon,                               \"Error while deleting snapshot on device '%s':\"                               \" %s\\n\",                               bdrv_get_device_name(bs),                               error_get_pretty(err));                error_free(err);            }        }    }}", "idx": 16507}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "function": "static AHCIQState *ahci_boot_and_enable(void){    AHCIQState *ahci;    ahci = ahci_boot();    ahci_pci_enable(ahci);    ahci_hba_enable(ahci);    return ahci;}", "idx": 16548}
{"project": "FFmpeg", "commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "target": 1, "function": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code){    uint32_t opcode_size, offset;    uint8_t *dst, *dend, mask = 0, color = 0;    const uint8_t *src, *send, *opcodes;    int i, j, op = 0;    i = bytestream2_get_byte(&c->gb);    if (i) {        if (code & 0x10) {            int align;            align = bytestream2_tell(&c->gb) & 3;            if (align)                bytestream2_skip(&c->gb, 4 - align);        }        do {            int page, val, x, y;            val    = bytestream2_get_be16(&c->gb);            page   = val >> 14;            x      = (val & 0x7F) * 2;            y      = ((val >> 7) & 0x7F) * 2;            dst    = c->frame[page] + x + y * c->width;            dend   = c->frame[page] + c->frame_size;            offset = (x & 0x7F) * 2;            j      = bytestream2_get_le16(&c->gb) + offset;            do {                offset++;                if (dst + 3 * c->width + 4 > dend)                    return AVERROR_INVALIDDATA;                read4x4block(c, dst, c->width);                if ((offset & 0x3F) == 0)                    dst += c->width * 3;                dst += 4;            } while (offset < j);        } while (--i);    }    dst  = c->frame[c->current_frame];    dend = c->frame[c->current_frame] + c->frame_size;    do {        set_src_position(c, &src, &send);        if ((src + 3 * c->width + 4 > send) ||            (dst + 3 * c->width + 4 > dend))            return AVERROR_INVALIDDATA;        copy_block4(dst, src, c->width, c->width, 4);        i++;        if ((i & 0x3F) == 0)            dst += c->width * 3;        dst += 4;    } while (i < c->video_size / 16);    opcode_size = bytestream2_get_le16(&c->gb);    bytestream2_skip(&c->gb, 2);    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)        return AVERROR_INVALIDDATA;    opcodes = pkt + bytestream2_tell(&c->gb);    bytestream2_skipu(&c->gb, opcode_size);    dst = c->frame[c->current_frame];    for (i = 0; i < c->height; i += 4, dst += c->width * 3)        for (j = 0; j < c->width; j += 4, dst += 4) {            int opcode, k = 0;            if (op > opcode_size)                return AVERROR_INVALIDDATA;            if (j & 4) {                opcode = opcodes[op] & 15;                op++;            } else {                opcode = opcodes[op] >> 4;            }            while (block_sequences[opcode][k]) {                offset = c->width * 2;                code   = block_sequences[opcode][k++];                switch (code) {                case 2:                    offset = 0;                case 3:                    color = bytestream2_get_byte(&c->gb);                case 4:                    mask = bytestream2_get_byte(&c->gb);                    copy_color_mask(dst + offset, c->width, mask, color);                    break;                case 5:                    offset = 0;                case 6:                    set_src_position(c, &src, &send);                case 7:                    if (src + offset + c->width + 4 > send)                        return AVERROR_INVALIDDATA;                    mask = bytestream2_get_byte(&c->gb);                    copy_src_mask(dst + offset, c->width, mask, src + offset);                    break;                }            }        }    return 0;}", "idx": 16614}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "function": "void  helper_evaluate_flags_mcp(void){\tuint32_t src;\tuint32_t dst;\tuint32_t res;\tuint32_t flags = 0;\tsrc = env->cc_src;\tdst = env->cc_dest;\tres = env->cc_result;\tif ((res & 0x80000000L) != 0L)\t{\t\tflags |= N_FLAG;\t\tif (((src & 0x80000000L) == 0L)\t\t    && ((dst & 0x80000000L) == 0L))\t\t{\t\t\tflags |= V_FLAG;\t\t}\t\telse if (((src & 0x80000000L) != 0L) &&\t\t\t ((dst & 0x80000000L) != 0L))\t\t{\t\t\tflags |= R_FLAG;\t\t}\t}\telse\t{\t\tif (res == 0L)\t\t\tflags |= Z_FLAG;\t\tif (((src & 0x80000000L) != 0L)\t\t    && ((dst & 0x80000000L) != 0L))\t\t\tflags |= V_FLAG;\t\tif ((dst & 0x80000000L) != 0L\t\t    || (src & 0x80000000L) != 0L)\t\t\tflags |= R_FLAG;\t}\tevaluate_flags_writeback(flags);}", "idx": 16624}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void lsi_mmio_write(void *opaque, target_phys_addr_t addr,                           uint64_t val, unsigned size){    LSIState *s = opaque;    lsi_reg_writeb(s, addr & 0xff, val);}", "idx": 16645}
{"project": "FFmpeg", "commit_id": "78e9852a2e3b198ecd69ffa0deab3fa22a8e5378", "target": 1, "function": "static void rpza_decode_stream(RpzaContext *s){    int width = s->avctx->width;    int stride = s->frame.linesize[0] / 2;    int row_inc = stride - 4;    int stream_ptr = 0;    int chunk_size;    unsigned char opcode;    int n_blocks;    unsigned short colorA = 0, colorB;    unsigned short color4[4];    unsigned char index, idx;    unsigned short ta, tb;    unsigned short *pixels = (unsigned short *)s->frame.data[0];    int row_ptr = 0;    int pixel_ptr = 0;    int block_ptr;    int pixel_x, pixel_y;    int total_blocks;    /* First byte is always 0xe1. Warn if it's different */    if (s->buf[stream_ptr] != 0xe1)        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",            s->buf[stream_ptr]);    /* Get chunk size, ingnoring first byte */    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;    stream_ptr += 4;    /* If length mismatch use size from MOV file and try to decode anyway */    if (chunk_size != s->size)        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");    chunk_size = s->size;    /* Number of 4x4 blocks in frame. */    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);    /* Process chunk data */    while (stream_ptr < chunk_size) {        opcode = s->buf[stream_ptr++]; /* Get opcode */        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */        /* If opcode MSbit is 0, we need more data to decide what to do */        if ((opcode & 0x80) == 0) {            colorA = (opcode << 8) | (s->buf[stream_ptr++]);            opcode = 0;            if ((s->buf[stream_ptr] & 0x80) != 0) {                /* Must behave as opcode 110xxxxx, using colorA computed                 * above. Use fake opcode 0x20 to enter switch block at                 * the right place */                opcode = 0x20;                n_blocks = 1;            }        }        switch (opcode & 0xe0) {        /* Skip blocks */        case 0x80:            while (n_blocks--) {              ADVANCE_BLOCK();            }            break;        /* Fill blocks with one color */        case 0xa0:            colorA = AV_RB16 (&s->buf[stream_ptr]);            stream_ptr += 2;            while (n_blocks--) {                block_ptr = row_ptr + pixel_ptr;                for (pixel_y = 0; pixel_y < 4; pixel_y++) {                    for (pixel_x = 0; pixel_x < 4; pixel_x++){                        pixels[block_ptr] = colorA;                        block_ptr++;                    }                    block_ptr += row_inc;                }                ADVANCE_BLOCK();            }            break;        /* Fill blocks with 4 colors */        case 0xc0:            colorA = AV_RB16 (&s->buf[stream_ptr]);            stream_ptr += 2;        case 0x20:            colorB = AV_RB16 (&s->buf[stream_ptr]);            stream_ptr += 2;            /* sort out the colors */            color4[0] = colorB;            color4[1] = 0;            color4[2] = 0;            color4[3] = colorA;            /* red components */            ta = (colorA >> 10) & 0x1F;            tb = (colorB >> 10) & 0x1F;            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;            /* green components */            ta = (colorA >> 5) & 0x1F;            tb = (colorB >> 5) & 0x1F;            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;            /* blue components */            ta = colorA & 0x1F;            tb = colorB & 0x1F;            color4[1] |= ((11 * ta + 21 * tb) >> 5);            color4[2] |= ((21 * ta + 11 * tb) >> 5);            while (n_blocks--) {                block_ptr = row_ptr + pixel_ptr;                for (pixel_y = 0; pixel_y < 4; pixel_y++) {                    index = s->buf[stream_ptr++];                    for (pixel_x = 0; pixel_x < 4; pixel_x++){                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;                        pixels[block_ptr] = color4[idx];                        block_ptr++;                    }                    block_ptr += row_inc;                }                ADVANCE_BLOCK();            }            break;        /* Fill block with 16 colors */        case 0x00:            if (s->size - stream_ptr < 16)            block_ptr = row_ptr + pixel_ptr;            for (pixel_y = 0; pixel_y < 4; pixel_y++) {                for (pixel_x = 0; pixel_x < 4; pixel_x++){                    /* We already have color of upper left pixel */                    if ((pixel_y != 0) || (pixel_x !=0)) {                        colorA = AV_RB16 (&s->buf[stream_ptr]);                        stream_ptr += 2;                    }                    pixels[block_ptr] = colorA;                    block_ptr++;                }                block_ptr += row_inc;            }            ADVANCE_BLOCK();            break;        /* Unknown opcode */        default:            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,                 chunk_size - stream_ptr);        } /* Opcode switch */    }}", "idx": 16703}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "function": "uint64_t ldq_tce(VIOsPAPRDevice *dev, uint64_t taddr){    uint64_t val;    spapr_tce_dma_read(dev, taddr, &val, sizeof(val));    return tswap64(val);}", "idx": 16706}
{"project": "qemu", "commit_id": "79c18be7dfe660ab48f9f535e6cabd38c9f1d73b", "target": 0, "function": "uint32_t HELPER(neon_abd_f32)(uint32_t a, uint32_t b){    float32 f0 = make_float32(a);    float32 f1 = make_float32(b);    return float32_val((float32_compare_quiet(f0, f1, NFS) == 1)                    ? float32_sub(f0, f1, NFS)                    : float32_sub(f1, f0, NFS));}", "idx": 16875}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "function": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize){    const uint8_t *src_end = src + src_size;    int x = 0, y = 0;#define INC_XY(n) \\    x += n; \\    if (x >= width) { \\        y++; \\        if (y >= height) \\            return 0; \\        x = 0; \\    }    while (src_end - src >= 2) {        uint8_t v = *src++;        if (v > 0 && v < 0xC0) {            do {                int length = FFMIN(v, width - x);                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);                INC_XY(length);                v   -= length;            } while (v > 0);            src++;        } else if (v >= 0xC1) {            v -= 0xC0;            do {                int length = FFMIN3(v, width - x, src_end - src);                if (src_end - src < length)                    break;                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);                INC_XY(length);                src += length;                v   -= length;            } while (v > 0);        } else {            avpriv_request_sample(avctx, \"opcode %d\", v);            return AVERROR_PATCHWELCOME;        }    }    return 0;}", "idx": 16984}
{"project": "FFmpeg", "commit_id": "cb5469462d427ea38625e255306f07b37d75280f", "target": 0, "function": "static int fill_filter_caches(H264Context *h, int mb_type){    MpegEncContext * const s = &h->s;    const int mb_xy= h->mb_xy;    int top_xy, left_xy[2];    int top_type, left_type[2];    top_xy     = mb_xy  - (s->mb_stride << MB_FIELD);    //FIXME deblocking could skip the intra and nnz parts.    /* Wow, what a mess, why didn't they simplify the interlacing & intra     * stuff, I can't imagine that these complex rules are worth it. */    left_xy[1] = left_xy[0] = mb_xy-1;    if(FRAME_MBAFF){        const int left_mb_field_flag     = IS_INTERLACED(s->current_picture.mb_type[mb_xy-1]);        const int curr_mb_field_flag     = IS_INTERLACED(mb_type);        if(s->mb_y&1){            if (left_mb_field_flag != curr_mb_field_flag) {                left_xy[0] -= s->mb_stride;            }        }else{            if(curr_mb_field_flag){                top_xy      += s->mb_stride & (((s->current_picture.mb_type[top_xy    ]>>7)&1)-1);            }            if (left_mb_field_flag != curr_mb_field_flag) {                left_xy[1] += s->mb_stride;            }        }    }    h->top_mb_xy = top_xy;    h->left_mb_xy[0] = left_xy[0];    h->left_mb_xy[1] = left_xy[1];    {        //for sufficiently low qp, filtering wouldn't do anything        //this is a conservative estimate: could also check beta_offset and more accurate chroma_qp        int qp_thresh = h->qp_thresh; //FIXME strictly we should store qp_thresh for each mb of a slice        int qp = s->current_picture.qscale_table[mb_xy];        if(qp <= qp_thresh           && (left_xy[0]<0 || ((qp + s->current_picture.qscale_table[left_xy[0]] + 1)>>1) <= qp_thresh)           && (top_xy   < 0 || ((qp + s->current_picture.qscale_table[top_xy    ] + 1)>>1) <= qp_thresh)){            if(!FRAME_MBAFF)                return 1;            if(   (left_xy[0]< 0            || ((qp + s->current_picture.qscale_table[left_xy[1]             ] + 1)>>1) <= qp_thresh)               && (top_xy    < s->mb_stride || ((qp + s->current_picture.qscale_table[top_xy    -s->mb_stride] + 1)>>1) <= qp_thresh))                return 1;        }    }    top_type     = s->current_picture.mb_type[top_xy]    ;    left_type[0] = s->current_picture.mb_type[left_xy[0]];    left_type[1] = s->current_picture.mb_type[left_xy[1]];    if(h->deblocking_filter == 2){        if(h->slice_table[top_xy     ] != h->slice_num) top_type= 0;        if(h->slice_table[left_xy[0] ] != h->slice_num) left_type[0]= left_type[1]= 0;    }else{        if(h->slice_table[top_xy     ] == 0xFFFF) top_type= 0;        if(h->slice_table[left_xy[0] ] == 0xFFFF) left_type[0]= left_type[1] =0;    }    h->top_type    = top_type    ;    h->left_type[0]= left_type[0];    h->left_type[1]= left_type[1];    if(IS_INTRA(mb_type))        return 0;    AV_COPY32(&h->non_zero_count_cache[4+8* 1], &h->non_zero_count[mb_xy][ 0]);    AV_COPY32(&h->non_zero_count_cache[4+8* 2], &h->non_zero_count[mb_xy][ 4]);    AV_COPY32(&h->non_zero_count_cache[4+8* 3], &h->non_zero_count[mb_xy][ 8]);    AV_COPY32(&h->non_zero_count_cache[4+8* 4], &h->non_zero_count[mb_xy][12]);    h->cbp= h->cbp_table[mb_xy];    {        int list;        for(list=0; list<h->list_count; list++){            int8_t *ref;            int y, b_stride;            int16_t (*mv_dst)[2];            int16_t (*mv_src)[2];            if(!USES_LIST(mb_type, list)){                fill_rectangle(  h->mv_cache[list][scan8[0]], 4, 4, 8, pack16to32(0,0), 4);                AV_WN32A(&h->ref_cache[list][scan8[ 0]], ((LIST_NOT_USED)&0xFF)*0x01010101u);                AV_WN32A(&h->ref_cache[list][scan8[ 2]], ((LIST_NOT_USED)&0xFF)*0x01010101u);                AV_WN32A(&h->ref_cache[list][scan8[ 8]], ((LIST_NOT_USED)&0xFF)*0x01010101u);                AV_WN32A(&h->ref_cache[list][scan8[10]], ((LIST_NOT_USED)&0xFF)*0x01010101u);                continue;            }            ref = &s->current_picture.ref_index[list][4*mb_xy];            {                int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);                AV_WN32A(&h->ref_cache[list][scan8[ 0]], (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101);                AV_WN32A(&h->ref_cache[list][scan8[ 2]], (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101);                ref += 2;                AV_WN32A(&h->ref_cache[list][scan8[ 8]], (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101);                AV_WN32A(&h->ref_cache[list][scan8[10]], (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101);            }            b_stride = h->b_stride;            mv_dst   = &h->mv_cache[list][scan8[0]];            mv_src   = &s->current_picture.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride];            for(y=0; y<4; y++){                AV_COPY128(mv_dst + 8*y, mv_src + y*b_stride);            }        }    }/*0 . T T. T T T T1 L . .L . . . .2 L . .L . . . .3 . T TL . . . .4 L . .L . . . .5 L . .. . . . .*///FIXME constraint_intra_pred & partitioning & nnz (let us hope this is just a typo in the spec)    if(top_type){        AV_COPY32(&h->non_zero_count_cache[4+8*0], &h->non_zero_count[top_xy][3*4]);    }    if(left_type[0]){        h->non_zero_count_cache[3+8*1]= h->non_zero_count[left_xy[0]][3+0*4];        h->non_zero_count_cache[3+8*2]= h->non_zero_count[left_xy[0]][3+1*4];        h->non_zero_count_cache[3+8*3]= h->non_zero_count[left_xy[0]][3+2*4];        h->non_zero_count_cache[3+8*4]= h->non_zero_count[left_xy[0]][3+3*4];    }    // CAVLC 8x8dct requires NNZ values for residual decoding that differ from what the loop filter needs    if(!CABAC && h->pps.transform_8x8_mode){        if(IS_8x8DCT(top_type)){            h->non_zero_count_cache[4+8*0]=            h->non_zero_count_cache[5+8*0]= (h->cbp_table[top_xy] & 0x4000) >> 12;            h->non_zero_count_cache[6+8*0]=            h->non_zero_count_cache[7+8*0]= (h->cbp_table[top_xy] & 0x8000) >> 12;        }        if(IS_8x8DCT(left_type[0])){            h->non_zero_count_cache[3+8*1]=            h->non_zero_count_cache[3+8*2]= (h->cbp_table[left_xy[0]]&0x2000) >> 12; //FIXME check MBAFF        }        if(IS_8x8DCT(left_type[1])){            h->non_zero_count_cache[3+8*3]=            h->non_zero_count_cache[3+8*4]= (h->cbp_table[left_xy[1]]&0x8000) >> 12; //FIXME check MBAFF        }        if(IS_8x8DCT(mb_type)){            h->non_zero_count_cache[scan8[0   ]]= h->non_zero_count_cache[scan8[1   ]]=            h->non_zero_count_cache[scan8[2   ]]= h->non_zero_count_cache[scan8[3   ]]= (h->cbp & 0x1000) >> 12;            h->non_zero_count_cache[scan8[0+ 4]]= h->non_zero_count_cache[scan8[1+ 4]]=            h->non_zero_count_cache[scan8[2+ 4]]= h->non_zero_count_cache[scan8[3+ 4]]= (h->cbp & 0x2000) >> 12;            h->non_zero_count_cache[scan8[0+ 8]]= h->non_zero_count_cache[scan8[1+ 8]]=            h->non_zero_count_cache[scan8[2+ 8]]= h->non_zero_count_cache[scan8[3+ 8]]= (h->cbp & 0x4000) >> 12;            h->non_zero_count_cache[scan8[0+12]]= h->non_zero_count_cache[scan8[1+12]]=            h->non_zero_count_cache[scan8[2+12]]= h->non_zero_count_cache[scan8[3+12]]= (h->cbp & 0x8000) >> 12;        }    }    if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){        int list;        for(list=0; list<h->list_count; list++){            if(USES_LIST(top_type, list)){                const int b_xy= h->mb2b_xy[top_xy] + 3*h->b_stride;                const int b8_xy= 4*top_xy + 2;                int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);                AV_COPY128(h->mv_cache[list][scan8[0] + 0 - 1*8], s->current_picture.motion_val[list][b_xy + 0]);                h->ref_cache[list][scan8[0] + 0 - 1*8]=                h->ref_cache[list][scan8[0] + 1 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 0]];                h->ref_cache[list][scan8[0] + 2 - 1*8]=                h->ref_cache[list][scan8[0] + 3 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 1]];            }else{                AV_ZERO128(h->mv_cache[list][scan8[0] + 0 - 1*8]);                AV_WN32A(&h->ref_cache[list][scan8[0] + 0 - 1*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);            }            if(!IS_INTERLACED(mb_type^left_type[0])){                if(USES_LIST(left_type[0], list)){                    const int b_xy= h->mb2b_xy[left_xy[0]] + 3;                    const int b8_xy= 4*left_xy[0] + 1;                    int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);                    AV_COPY32(h->mv_cache[list][scan8[0] - 1 + 0 ], s->current_picture.motion_val[list][b_xy + h->b_stride*0]);                    AV_COPY32(h->mv_cache[list][scan8[0] - 1 + 8 ], s->current_picture.motion_val[list][b_xy + h->b_stride*1]);                    AV_COPY32(h->mv_cache[list][scan8[0] - 1 +16 ], s->current_picture.motion_val[list][b_xy + h->b_stride*2]);                    AV_COPY32(h->mv_cache[list][scan8[0] - 1 +24 ], s->current_picture.motion_val[list][b_xy + h->b_stride*3]);                    h->ref_cache[list][scan8[0] - 1 + 0 ]=                    h->ref_cache[list][scan8[0] - 1 + 8 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 2*0]];                    h->ref_cache[list][scan8[0] - 1 +16 ]=                    h->ref_cache[list][scan8[0] - 1 +24 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 2*1]];                }else{                    AV_ZERO32(h->mv_cache [list][scan8[0] - 1 + 0 ]);                    AV_ZERO32(h->mv_cache [list][scan8[0] - 1 + 8 ]);                    AV_ZERO32(h->mv_cache [list][scan8[0] - 1 +16 ]);                    AV_ZERO32(h->mv_cache [list][scan8[0] - 1 +24 ]);                    h->ref_cache[list][scan8[0] - 1 + 0  ]=                    h->ref_cache[list][scan8[0] - 1 + 8  ]=                    h->ref_cache[list][scan8[0] - 1 + 16 ]=                    h->ref_cache[list][scan8[0] - 1 + 24 ]= LIST_NOT_USED;                }            }        }    }    return 0;}", "idx": 17065}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "function": "static void host_signal_handler(int host_signum, siginfo_t *info,                                void *puc){    int sig;    target_siginfo_t tinfo;    /* the CPU emulator uses some host signals to detect exceptions,       we forward to it some signals */    if ((host_signum == SIGSEGV || host_signum == SIGBUS)        && info->si_code > 0) {        if (cpu_signal_handler(host_signum, info, puc))            return;    }    /* get target signal number */    sig = host_to_target_signal(host_signum);    if (sig < 1 || sig > TARGET_NSIG)        return;#if defined(DEBUG_SIGNAL)    fprintf(stderr, \"qemu: got signal %d\\n\", sig);#endif    host_to_target_siginfo_noswap(&tinfo, info);    if (queue_signal(thread_env, sig, &tinfo) == 1) {        /* interrupt the virtual CPU as soon as possible */        cpu_interrupt(thread_env, CPU_INTERRUPT_EXIT);    }}", "idx": 17071}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint32_t pmac_ide_readl (void *opaque,target_phys_addr_t addr){    uint32_t retval;    MACIOIDEState *d = opaque;    addr = (addr & 0xFFF) >> 4;    if (addr == 0) {        retval = ide_data_readl(&d->bus, 0);    } else {        retval = 0xFFFFFFFF;    }    retval = bswap32(retval);    return retval;}", "idx": 17243}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "function": "static void ac97_map (PCIDevice *pci_dev, int region_num,                      uint32_t addr, uint32_t size, int type){    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;    AC97LinkState *s = &d->ac97;    if (!region_num) {        s->base[0] = addr;        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);    }    else {        s->base[1] = addr;        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);    }}", "idx": 17266}
{"project": "FFmpeg", "commit_id": "2d15554850799346472683b4a2df05878dcfad48", "target": 0, "function": "static int mlp_parse(AVCodecParserContext *s,                     AVCodecContext *avctx,                     const uint8_t **poutbuf, int *poutbuf_size,                     const uint8_t *buf, int buf_size){    MLPParseContext *mp = s->priv_data;    int sync_present;    uint8_t parity_bits;    int next;    int i, p = 0;    *poutbuf_size = 0;    if (buf_size == 0)        return 0;    if (!mp->in_sync) {        // Not in sync - find a major sync header        for (i = 0; i < buf_size; i++) {            mp->pc.state = (mp->pc.state << 8) | buf[i];            if ((mp->pc.state & 0xfffffffe) == 0xf8726fba &&                // ignore if we do not have the data for the start of header                mp->pc.index + i >= 7) {                mp->in_sync = 1;                mp->bytes_left = 0;                break;            }        }        if (!mp->in_sync) {            if (ff_combine_frame(&mp->pc, END_NOT_FOUND, &buf, &buf_size) != -1)                av_log(avctx, AV_LOG_WARNING, \"ff_combine_frame failed\\n\");            return buf_size;        }        ff_combine_frame(&mp->pc, i - 7, &buf, &buf_size);        return i - 7;    }    if (mp->bytes_left == 0) {        // Find length of this packet        /* Copy overread bytes from last frame into buffer. */        for(; mp->pc.overread>0; mp->pc.overread--) {            mp->pc.buffer[mp->pc.index++]= mp->pc.buffer[mp->pc.overread_index++];        }        if (mp->pc.index + buf_size < 2) {            if (ff_combine_frame(&mp->pc, END_NOT_FOUND, &buf, &buf_size) != -1)                av_log(avctx, AV_LOG_WARNING, \"ff_combine_frame failed\\n\");            return buf_size;        }        mp->bytes_left = ((mp->pc.index > 0 ? mp->pc.buffer[0] : buf[0]) << 8)                       |  (mp->pc.index > 1 ? mp->pc.buffer[1] : buf[1-mp->pc.index]);        mp->bytes_left = (mp->bytes_left & 0xfff) * 2;        if (mp->bytes_left <= 0) { // prevent infinite loop            goto lost_sync;        }        mp->bytes_left -= mp->pc.index;    }    next = (mp->bytes_left > buf_size) ? END_NOT_FOUND : mp->bytes_left;    if (ff_combine_frame(&mp->pc, next, &buf, &buf_size) < 0) {        mp->bytes_left -= buf_size;        return buf_size;    }    mp->bytes_left = 0;    sync_present = (AV_RB32(buf + 4) & 0xfffffffe) == 0xf8726fba;    if (!sync_present) {        /* The first nibble of a frame is a parity check of the 4-byte         * access unit header and all the 2- or 4-byte substream headers. */        // Only check when this isn't a sync frame - syncs have a checksum.        parity_bits = 0;        for (i = -1; i < mp->num_substreams; i++) {            parity_bits ^= buf[p++];            parity_bits ^= buf[p++];            if (i < 0 || buf[p-2] & 0x80) {                parity_bits ^= buf[p++];                parity_bits ^= buf[p++];            }        }        if ((((parity_bits >> 4) ^ parity_bits) & 0xF) != 0xF) {            av_log(avctx, AV_LOG_INFO, \"mlpparse: Parity check failed.\\n\");            goto lost_sync;        }    } else {        GetBitContext gb;        MLPHeaderInfo mh;        init_get_bits(&gb, buf + 4, (buf_size - 4) << 3);        if (ff_mlp_read_major_sync(avctx, &mh, &gb) < 0)            goto lost_sync;        avctx->bits_per_raw_sample = mh.group1_bits;        if (avctx->bits_per_raw_sample > 16)            avctx->sample_fmt = AV_SAMPLE_FMT_S32;        else            avctx->sample_fmt = AV_SAMPLE_FMT_S16;        avctx->sample_rate = mh.group1_samplerate;        s->duration = mh.access_unit_size;        if(!avctx->channels || !avctx->channel_layout) {        if (mh.stream_type == 0xbb) {            /* MLP stream */#if FF_API_REQUEST_CHANNELSFF_DISABLE_DEPRECATION_WARNINGS            if (avctx->request_channels > 0 && avctx->request_channels <= 2 &&                mh.num_substreams > 1) {                avctx->channels       = 2;                avctx->channel_layout = AV_CH_LAYOUT_STEREO;FF_ENABLE_DEPRECATION_WARNINGS            } else#endif            if (avctx->request_channel_layout &&                (avctx->request_channel_layout & AV_CH_LAYOUT_STEREO) ==                avctx->request_channel_layout &&                mh.num_substreams > 1) {                avctx->channels       = 2;                avctx->channel_layout = AV_CH_LAYOUT_STEREO;            } else {                avctx->channels       = mh.channels_mlp;                avctx->channel_layout = mh.channel_layout_mlp;            }        } else { /* mh.stream_type == 0xba */            /* TrueHD stream */#if FF_API_REQUEST_CHANNELSFF_DISABLE_DEPRECATION_WARNINGS            if (avctx->request_channels > 0 && avctx->request_channels <= 2 &&                mh.num_substreams > 1) {                avctx->channels       = 2;                avctx->channel_layout = AV_CH_LAYOUT_STEREO;            } else if (avctx->request_channels > 0 &&                       avctx->request_channels <= mh.channels_thd_stream1) {                avctx->channels       = mh.channels_thd_stream1;                avctx->channel_layout = mh.channel_layout_thd_stream1;FF_ENABLE_DEPRECATION_WARNINGS            } else#endif                if (avctx->request_channel_layout &&                    (avctx->request_channel_layout & AV_CH_LAYOUT_STEREO) ==                    avctx->request_channel_layout &&                    mh.num_substreams > 1) {                avctx->channels       = 2;                avctx->channel_layout = AV_CH_LAYOUT_STEREO;            } else if (!mh.channels_thd_stream2 ||                       (avctx->request_channel_layout &&                        (avctx->request_channel_layout & mh.channel_layout_thd_stream1) ==                        avctx->request_channel_layout)) {                avctx->channels       = mh.channels_thd_stream1;                avctx->channel_layout = mh.channel_layout_thd_stream1;            } else {                avctx->channels       = mh.channels_thd_stream2;                avctx->channel_layout = mh.channel_layout_thd_stream2;            }        }        }        if (!mh.is_vbr) /* Stream is CBR */            avctx->bit_rate = mh.peak_bitrate;        mp->num_substreams = mh.num_substreams;    }    *poutbuf = buf;    *poutbuf_size = buf_size;    return next;lost_sync:    mp->in_sync = 0;    return 1;}", "idx": 17270}
{"project": "FFmpeg", "commit_id": "435535e41159fbe7423a12078d684329a554776d", "target": 1, "function": "static int read_header(AVFormatContext *s,                       AVFormatParameters *ap){    JVDemuxContext *jv = s->priv_data;    AVIOContext *pb = s->pb;    AVStream *vst, *ast;    int64_t audio_pts = 0;    int64_t offset;    int i;    avio_skip(pb, 80);    ast = av_new_stream(s, 0);    vst = av_new_stream(s, 1);    if (!ast || !vst)        return AVERROR(ENOMEM);    vst->codec->codec_type  = CODEC_TYPE_VIDEO;    vst->codec->codec_id    = CODEC_ID_JV;    vst->codec->codec_tag   = 0; /* no fourcc */    vst->codec->width       = avio_rl16(pb);    vst->codec->height      = avio_rl16(pb);    vst->nb_frames          =    ast->nb_index_entries   = avio_rl16(pb);    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);    avio_skip(pb, 4);    ast->codec->codec_type  = CODEC_TYPE_AUDIO;    ast->codec->codec_id    = CODEC_ID_PCM_U8;    ast->codec->codec_tag   = 0; /* no fourcc */    ast->codec->sample_rate = avio_rl16(pb);    ast->codec->channels    = 1;    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);    avio_skip(pb, 10);    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));    if (!ast->index_entries)        return AVERROR(ENOMEM);    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));    if (!jv->frames)        return AVERROR(ENOMEM);    offset = 0x68 + ast->nb_index_entries * 16;    for(i = 0; i < ast->nb_index_entries; i++) {        AVIndexEntry *e   = ast->index_entries + i;        JVFrame      *jvf = jv->frames + i;        /* total frame size including audio, video, palette data and padding */        e->size         = avio_rl32(pb);        e->timestamp    = i;        e->pos          = offset;        offset         += e->size;        jvf->audio_size = avio_rl32(pb);        jvf->video_size = avio_rl32(pb);        jvf->palette_size = avio_r8(pb) ? 768 : 0;        if (avio_r8(pb))             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");        jvf->video_type = avio_r8(pb);        avio_skip(pb, 1);        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;        audio_pts += jvf->audio_size;        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;    }    jv->state = JV_AUDIO;    return 0;}", "idx": 17280}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "function": "SchroVideoFormatEnum ff_get_schro_video_format_preset(AVCodecContext *avctx){    unsigned int num_formats = sizeof(ff_schro_video_formats) /                               sizeof(ff_schro_video_formats[0]);    unsigned int idx = get_video_format_idx(avctx);    return (idx < num_formats) ? ff_schro_video_formats[idx] :                                 SCHRO_VIDEO_FORMAT_CUSTOM;}", "idx": 17352}
{"project": "qemu", "commit_id": "83cc6f8c2f134ccff1a41ed86bbe3bc305e0c334", "target": 1, "function": "static void gen_spr_970_pmu_sup(CPUPPCState *env){    spr_register(env, SPR_970_PMC7, \"PMC7\",                 SPR_NOACCESS, SPR_NOACCESS,                 &spr_read_generic, &spr_write_generic,                 0x00000000);    spr_register(env, SPR_970_PMC8, \"PMC8\",                 SPR_NOACCESS, SPR_NOACCESS,                 &spr_read_generic, &spr_write_generic,                 0x00000000);}", "idx": 17385}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "function": "static int block_save_complete(QEMUFile *f, void *opaque){    int ret;    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",            block_mig_state.submitted, block_mig_state.transferred);    ret = flush_blks(f);    if (ret) {        return ret;    }    blk_mig_reset_dirty_cursor();    /* we know for sure that save bulk is completed and       all async read completed */    blk_mig_lock();    assert(block_mig_state.submitted == 0);    blk_mig_unlock();    do {        ret = blk_mig_save_dirty_block(f, 0);        if (ret < 0) {            return ret;        }    } while (ret == 0);    /* report completion */    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);    DPRINTF(\"Block migration completed\\n\");    qemu_put_be64(f, BLK_MIG_FLAG_EOS);    blk_mig_cleanup();    return 0;}", "idx": 17411}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "function": "static inline void RENAME(rgb24ToY)(uint8_t *dst, uint8_t *src, int width){\tint i;\tfor(i=0; i<width; i++)\t{\t\tint r= src[i*3+0];\t\tint g= src[i*3+1];\t\tint b= src[i*3+2];\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\t}}", "idx": 17434}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "function": "static ram_addr_t get_start_block(DumpState *s){    RAMBlock *block;    if (!s->has_filter) {        s->block = QTAILQ_FIRST(&ram_list.blocks);        return 0;    }    QTAILQ_FOREACH(block, &ram_list.blocks, next) {        if (block->offset >= s->begin + s->length ||            block->offset + block->length <= s->begin) {            /* This block is out of the range */            continue;        }        s->block = block;        if (s->begin > block->offset) {            s->start = s->begin - block->offset;        } else {            s->start = 0;        }        return s->start;    }    return -1;}", "idx": 17440}
{"project": "FFmpeg", "commit_id": "e936c8d176efd1a0a41e22df24564b1178c79ea9", "target": 1, "function": "int ff_read_packet(AVFormatContext *s, AVPacket *pkt){    int ret, i, err;    AVStream *st;    for (;;) {        AVPacketList *pktl = s->internal->raw_packet_buffer;        if (pktl) {            *pkt = pktl->pkt;            st   = s->streams[pkt->stream_index];            if (s->internal->raw_packet_buffer_remaining_size <= 0)                if ((err = probe_codec(s, st, NULL)) < 0)                    return err;            if (st->request_probe <= 0) {                s->internal->raw_packet_buffer                 = pktl->next;                s->internal->raw_packet_buffer_remaining_size += pkt->size;                av_free(pktl);                return 0;        pkt->data = NULL;        pkt->size = 0;        av_init_packet(pkt);        ret = s->iformat->read_packet(s, pkt);        if (ret < 0) {            /* Some demuxers return FFERROR_REDO when they consume               data and discard it (ignored streams, junk, extradata).               We must re-call the demuxer to get the real packet. */            if (ret == FFERROR_REDO)                continue;            if (!pktl || ret == AVERROR(EAGAIN))                return ret;            for (i = 0; i < s->nb_streams; i++) {                st = s->streams[i];                if (st->probe_packets || st->request_probe > 0)                    if ((err = probe_codec(s, st, NULL)) < 0)                        return err;                av_assert0(st->request_probe <= 0);            continue;        if (!pkt->buf) {            AVPacket tmp = { 0 };            ret = av_packet_ref(&tmp, pkt);            if (ret < 0)                return ret;            *pkt = tmp;        if ((s->flags & AVFMT_FLAG_DISCARD_CORRUPT) &&            (pkt->flags & AV_PKT_FLAG_CORRUPT)) {            av_log(s, AV_LOG_WARNING,                   \"Dropped corrupted packet (stream = %d)\\n\",                   pkt->stream_index);            av_packet_unref(pkt);            continue;        if (pkt->stream_index >= (unsigned)s->nb_streams) {            av_log(s, AV_LOG_ERROR, \"Invalid stream index %d\\n\", pkt->stream_index);            continue;        st = s->streams[pkt->stream_index];        if (update_wrap_reference(s, st, pkt->stream_index, pkt) && st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET) {            // correct first time stamps to negative values            if (!is_relative(st->first_dts))                st->first_dts = wrap_timestamp(st, st->first_dts);            if (!is_relative(st->start_time))                st->start_time = wrap_timestamp(st, st->start_time);            if (!is_relative(st->cur_dts))                st->cur_dts = wrap_timestamp(st, st->cur_dts);        pkt->dts = wrap_timestamp(st, pkt->dts);        pkt->pts = wrap_timestamp(st, pkt->pts);        force_codec_ids(s, st);        /* TODO: audio: time filter; video: frame reordering (pts != dts) */        if (s->use_wallclock_as_timestamps)            pkt->dts = pkt->pts = av_rescale_q(av_gettime(), AV_TIME_BASE_Q, st->time_base);        if (!pktl && st->request_probe <= 0)            return ret;        err = add_to_pktbuf(&s->internal->raw_packet_buffer, pkt,                            &s->internal->raw_packet_buffer_end, 0);        if (err)            return err;        s->internal->raw_packet_buffer_remaining_size -= pkt->size;        if ((err = probe_codec(s, st, pkt)) < 0)            return err;", "idx": 17487}
{"project": "qemu", "commit_id": "345ce423dd58b3ddc3cfbcbb1ca2eee25546e8be", "target": 1, "function": "print_insn_sparc (bfd_vma memaddr, disassemble_info *info){  FILE *stream = info->stream;  bfd_byte buffer[4];  unsigned long insn;  sparc_opcode_hash *op;  /* Nonzero of opcode table has been initialized.  */  static int opcodes_initialized = 0;  /* bfd mach number of last call.  */  static unsigned long current_mach = 0;  bfd_vma (*getword) (const unsigned char *);  if (!opcodes_initialized      || info->mach != current_mach)    {      int i;      current_arch_mask = compute_arch_mask (info->mach);      if (!opcodes_initialized)        sorted_opcodes =          malloc (sparc_num_opcodes * sizeof (sparc_opcode *));      /* Reset the sorted table so we can resort it.  */      for (i = 0; i < sparc_num_opcodes; ++i)        sorted_opcodes[i] = &sparc_opcodes[i];      qsort ((char *) sorted_opcodes, sparc_num_opcodes,             sizeof (sorted_opcodes[0]), compare_opcodes);      build_hash_table (sorted_opcodes, opcode_hash_table, sparc_num_opcodes);      current_mach = info->mach;      opcodes_initialized = 1;    }  {    int status =      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);    if (status != 0)      {        (*info->memory_error_func) (status, memaddr, info);        return -1;      }  }  /* On SPARClite variants such as DANlite (sparc86x), instructions     are always big-endian even when the machine is in little-endian mode.  */  if (info->endian == BFD_ENDIAN_BIG || info->mach == bfd_mach_sparc_sparclite)    getword = bfd_getb32;  else    getword = bfd_getl32;  insn = getword (buffer);  info->insn_info_valid = 1;                    /* We do return this info.  */  info->insn_type = dis_nonbranch;              /* Assume non branch insn.  */  info->branch_delay_insns = 0;                 /* Assume no delay.  */  info->target = 0;                             /* Assume no target known.  */  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)    {      const sparc_opcode *opcode = op->opcode;      /* If the insn isn't supported by the current architecture, skip it.  */      if (! (opcode->architecture & current_arch_mask))        continue;      if ((opcode->match & insn) == opcode->match          && (opcode->lose & insn) == 0)        {          /* Nonzero means that we have found an instruction which has             the effect of adding or or'ing the imm13 field to rs1.  */          int imm_added_to_rs1 = 0;          int imm_ored_to_rs1 = 0;          /* Nonzero means that we have found a plus sign in the args             field of the opcode table.  */          int found_plus = 0;          /* Nonzero means we have an annulled branch.  */          /* int is_annulled = 0; */ /* see FIXME below */          /* Do we have an `add' or `or' instruction combining an             immediate with rs1?  */          if (opcode->match == 0x80102000) /* or */            imm_ored_to_rs1 = 1;          if (opcode->match == 0x80002000) /* add */            imm_added_to_rs1 = 1;          if (X_RS1 (insn) != X_RD (insn)              && strchr (opcode->args, 'r') != NULL)              /* Can't do simple format if source and dest are different.  */              continue;          if (X_RS2 (insn) != X_RD (insn)              && strchr (opcode->args, 'O') != NULL)              /* Can't do simple format if source and dest are different.  */              continue;          (*info->fprintf_func) (stream, \"%s\", opcode->name);          {            const char *s;            if (opcode->args[0] != ',')              (*info->fprintf_func) (stream, \" \");            for (s = opcode->args; *s != '\\0'; ++s)              {                while (*s == ',')                  {                    (*info->fprintf_func) (stream, \",\");                    ++s;                    switch (*s)                      {                      case 'a':                        (*info->fprintf_func) (stream, \"a\");                        /* is_annulled = 1; */ /* see FIXME below */                        ++s;                        continue;                      case 'N':                        (*info->fprintf_func) (stream, \"pn\");                        ++s;                        continue;                      case 'T':                        (*info->fprintf_func) (stream, \"pt\");                        ++s;                        continue;                      default:                        break;                      }                  }                (*info->fprintf_func) (stream, \" \");                switch (*s)                  {                  case '+':                    found_plus = 1;                    /* Fall through.  */                  default:                    (*info->fprintf_func) (stream, \"%c\", *s);                    break;                  case '#':                    (*info->fprintf_func) (stream, \"0\");                    break;#define reg(n)  (*info->fprintf_func) (stream, \"%%%s\", reg_names[n])                  case '1':                  case 'r':                    reg (X_RS1 (insn));                    break;                  case '2':                  case 'O':                    reg (X_RS2 (insn));                    break;                  case 'd':                    reg (X_RD (insn));                    break;#undef  reg#define freg(n)         (*info->fprintf_func) (stream, \"%%%s\", freg_names[n])#define fregx(n)        (*info->fprintf_func) (stream, \"%%%s\", freg_names[((n) & ~1) | (((n) & 1) << 5)])                  case 'e':                    freg (X_RS1 (insn));                    break;                  case 'v':     /* Double/even.  */                  case 'V':     /* Quad/multiple of 4.  */                    fregx (X_RS1 (insn));                    break;                  case 'f':                    freg (X_RS2 (insn));                    break;                  case 'B':     /* Double/even.  */                  case 'R':     /* Quad/multiple of 4.  */                    fregx (X_RS2 (insn));                    break;                  case 'g':                    freg (X_RD (insn));                    break;                  case 'H':     /* Double/even.  */                  case 'J':     /* Quad/multiple of 4.  */                    fregx (X_RD (insn));                    break;#undef  freg#undef  fregx#define creg(n) (*info->fprintf_func) (stream, \"%%c%u\", (unsigned int) (n))                  case 'b':                    creg (X_RS1 (insn));                    break;                  case 'c':                    creg (X_RS2 (insn));                    break;                  case 'D':                    creg (X_RD (insn));                    break;#undef  creg                  case 'h':                    (*info->fprintf_func) (stream, \"%%hi(%#x)\",                                           ((unsigned) 0xFFFFFFFF                                            & ((int) X_IMM22 (insn) << 10)));                    break;                  case 'i':     /* 13 bit immediate.  */                  case 'I':     /* 11 bit immediate.  */                  case 'j':     /* 10 bit immediate.  */                    {                      int imm;                      if (*s == 'i')                        imm = X_SIMM (insn, 13);                      else if (*s == 'I')                        imm = X_SIMM (insn, 11);                      else                        imm = X_SIMM (insn, 10);                      /* Check to see whether we have a 1+i, and take                         note of that fact.                         Note: because of the way we sort the table,                         we will be matching 1+i rather than i+1,                         so it is OK to assume that i is after +,                         not before it.  */                      if (found_plus)                        imm_added_to_rs1 = 1;                      if (imm <= 9)                        (*info->fprintf_func) (stream, \"%d\", imm);                      else                        (*info->fprintf_func) (stream, \"%#x\", imm);                    }                    break;                  case 'X':     /* 5 bit unsigned immediate.  */                  case 'Y':     /* 6 bit unsigned immediate.  */                    {                      int imm = X_IMM (insn, *s == 'X' ? 5 : 6);                      if (imm <= 9)                        (info->fprintf_func) (stream, \"%d\", imm);                      else                        (info->fprintf_func) (stream, \"%#x\", (unsigned) imm);                    }                    break;                  case '3':                    (info->fprintf_func) (stream, \"%ld\", X_IMM (insn, 3));                    break;                  case 'K':                    {                      int mask = X_MEMBAR (insn);                      int bit = 0x40, printed_one = 0;                      const char *name;                      if (mask == 0)                        (info->fprintf_func) (stream, \"0\");                      else                        while (bit)                          {                            if (mask & bit)                              {                                if (printed_one)                                  (info->fprintf_func) (stream, \"|\");                                name = sparc_decode_membar (bit);                                (info->fprintf_func) (stream, \"%s\", name);                                printed_one = 1;                              }                            bit >>= 1;                          }                      break;                    }                  case 'k':                    info->target = memaddr + SEX (X_DISP16 (insn), 16) * 4;                    (*info->print_address_func) (info->target, info);                    break;                  case 'G':                    info->target = memaddr + SEX (X_DISP19 (insn), 19) * 4;                    (*info->print_address_func) (info->target, info);                    break;                  case '6':                  case '7':                  case '8':                  case '9':                    (*info->fprintf_func) (stream, \"%%fcc%c\", *s - '6' + '0');                    break;                  case 'z':                    (*info->fprintf_func) (stream, \"%%icc\");                    break;                  case 'Z':                    (*info->fprintf_func) (stream, \"%%xcc\");                    break;                  case 'E':                    (*info->fprintf_func) (stream, \"%%ccr\");                    break;                  case 's':                    (*info->fprintf_func) (stream, \"%%fprs\");                    break;                  case 'o':                    (*info->fprintf_func) (stream, \"%%asi\");                    break;                  case 'W':                    (*info->fprintf_func) (stream, \"%%tick\");                    break;                  case 'P':                    (*info->fprintf_func) (stream, \"%%pc\");                    break;                  case '?':                    if (X_RS1 (insn) == 31)                      (*info->fprintf_func) (stream, \"%%ver\");                    else if ((unsigned) X_RS1 (insn) < 17)                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9_priv_reg_names[X_RS1 (insn)]);                    else                      (*info->fprintf_func) (stream, \"%%reserved\");                    break;                  case '!':                    if ((unsigned) X_RD (insn) < 17)                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9_priv_reg_names[X_RD (insn)]);                    else                      (*info->fprintf_func) (stream, \"%%reserved\");                    break;                  case '$':                    if ((unsigned) X_RS1 (insn) < 32)                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9_hpriv_reg_names[X_RS1 (insn)]);                    else                      (*info->fprintf_func) (stream, \"%%reserved\");                    break;                  case '%':                    if ((unsigned) X_RD (insn) < 32)                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9_hpriv_reg_names[X_RD (insn)]);                    else                      (*info->fprintf_func) (stream, \"%%reserved\");                    break;                  case '/':                    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 25)                      (*info->fprintf_func) (stream, \"%%reserved\");                    else                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9a_asr_reg_names[X_RS1 (insn)-16]);                    break;                  case '_':                    if (X_RD (insn) < 16 || X_RD (insn) > 25)                      (*info->fprintf_func) (stream, \"%%reserved\");                    else                      (*info->fprintf_func) (stream, \"%%%s\",                                             v9a_asr_reg_names[X_RD (insn)-16]);                    break;                  case '*':                    {                      const char *name = sparc_decode_prefetch (X_RD (insn));                      if (name)                        (*info->fprintf_func) (stream, \"%s\", name);                      else                        (*info->fprintf_func) (stream, \"%ld\", X_RD (insn));                      break;                    }                  case 'M':                    (*info->fprintf_func) (stream, \"%%asr%ld\", X_RS1 (insn));                    break;                  case 'm':                    (*info->fprintf_func) (stream, \"%%asr%ld\", X_RD (insn));                    break;                  case 'L':                    info->target = memaddr + SEX (X_DISP30 (insn), 30) * 4;                    (*info->print_address_func) (info->target, info);                    break;                  case 'n':                    (*info->fprintf_func)                      (stream, \"%#x\", SEX (X_DISP22 (insn), 22));                    break;                  case 'l':                    info->target = memaddr + SEX (X_DISP22 (insn), 22) * 4;                    (*info->print_address_func) (info->target, info);                    break;                  case 'A':                    {                      const char *name;                      if ((info->mach == bfd_mach_sparc_v8plusa) ||                          ((info->mach >= bfd_mach_sparc_v9) &&                           (info->mach <= bfd_mach_sparc_v9b)))                        name = sparc_decode_asi_v9 (X_ASI (insn));                      else                        name = sparc_decode_asi_v8 (X_ASI (insn));                      if (name)                        (*info->fprintf_func) (stream, \"%s\", name);                      else                        (*info->fprintf_func) (stream, \"(%ld)\", X_ASI (insn));                      break;                    }                  case 'C':                    (*info->fprintf_func) (stream, \"%%csr\");                    break;                  case 'F':                    (*info->fprintf_func) (stream, \"%%fsr\");                    break;                  case 'p':                    (*info->fprintf_func) (stream, \"%%psr\");                    break;                  case 'q':                    (*info->fprintf_func) (stream, \"%%fq\");                    break;                  case 'Q':                    (*info->fprintf_func) (stream, \"%%cq\");                    break;                  case 't':                    (*info->fprintf_func) (stream, \"%%tbr\");                    break;                  case 'w':                    (*info->fprintf_func) (stream, \"%%wim\");                    break;                  case 'x':                    (*info->fprintf_func) (stream, \"%ld\",                                           ((X_LDST_I (insn) << 8)                                            + X_ASI (insn)));                    break;                  case 'y':                    (*info->fprintf_func) (stream, \"%%y\");                    break;                  case 'u':                  case 'U':                    {                      int val = *s == 'U' ? X_RS1 (insn) : X_RD (insn);                      const char *name = sparc_decode_sparclet_cpreg (val);                      if (name)                        (*info->fprintf_func) (stream, \"%s\", name);                      else                        (*info->fprintf_func) (stream, \"%%cpreg(%d)\", val);                      break;                    }                  }              }          }          /* If we are adding or or'ing something to rs1, then             check to see whether the previous instruction was             a sethi to the same register as in the sethi.             If so, attempt to print the result of the add or             or (in this context add and or do the same thing)             and its symbolic value.  */          if (imm_ored_to_rs1 || imm_added_to_rs1)            {              unsigned long prev_insn;              int errcode;              if (memaddr >= 4)                errcode =                  (*info->read_memory_func)                  (memaddr - 4, buffer, sizeof (buffer), info);              else                errcode = 1;              prev_insn = getword (buffer);              if (errcode == 0)                {                  /* If it is a delayed branch, we need to look at the                     instruction before the delayed branch.  This handles                     sequences such as:                     sethi %o1, %hi(_foo), %o1                     call _printf                     or %o1, %lo(_foo), %o1  */                  if (is_delayed_branch (prev_insn))                    {                      if (memaddr >= 8)                        errcode = (*info->read_memory_func)                          (memaddr - 8, buffer, sizeof (buffer), info);                      else                        errcode = 1;                      prev_insn = getword (buffer);                    }                }              /* If there was a problem reading memory, then assume                 the previous instruction was not sethi.  */              if (errcode == 0)                {                  /* Is it sethi to the same register?  */                  if ((prev_insn & 0xc1c00000) == 0x01000000                      && X_RD (prev_insn) == X_RS1 (insn))                    {                      (*info->fprintf_func) (stream, \"\\t! \");                      info->target =                        ((unsigned) 0xFFFFFFFF                         & ((int) X_IMM22 (prev_insn) << 10));                      if (imm_added_to_rs1)                        info->target += X_SIMM (insn, 13);                      else                        info->target |= X_SIMM (insn, 13);                      (*info->print_address_func) (info->target, info);                      info->insn_type = dis_dref;                      info->data_size = 4;  /* FIXME!!! */                    }                }            }          if (opcode->flags & (F_UNBR|F_CONDBR|F_JSR))            {                /* FIXME -- check is_annulled flag.  */              if (opcode->flags & F_UNBR)                info->insn_type = dis_branch;              if (opcode->flags & F_CONDBR)                info->insn_type = dis_condbranch;              if (opcode->flags & F_JSR)                info->insn_type = dis_jsr;              if (opcode->flags & F_DELAYED)                info->branch_delay_insns = 1;            }          return sizeof (buffer);        }    }  info->insn_type = dis_noninsn;        /* Mark as non-valid instruction.  */  (*info->fprintf_func) (stream, _(\"unknown\"));  return sizeof (buffer);}", "idx": 17489}
{"project": "FFmpeg", "commit_id": "5c22c90c1d5050f1206e46494b193320ac2397cb", "target": 1, "function": "static void vp9_superframe_close(AVBSFContext *ctx){    VP9BSFContext *s = ctx->priv_data;    int n;    // free cached data    for (n = 0; n < s->n_cache; n++)        av_packet_free(&s->cache[n]);}", "idx": 17496}
{"project": "FFmpeg", "commit_id": "bbcaf25d4d2130fa9c34c314628f9fd2f706b61b", "target": 0, "function": "static void sha512_transform(uint64_t *state, const uint8_t buffer[128]){    uint64_t a, b, c, d, e, f, g, h;    uint64_t block[80];    uint64_t T1;    int i;    a = state[0];    b = state[1];    c = state[2];    d = state[3];    e = state[4];    f = state[5];    g = state[6];    h = state[7];#if CONFIG_SMALL    for (i = 0; i < 80; i++) {        uint64_t T2;        if (i < 16)            T1 = blk0(i);        else            T1 = blk(i);        T1 += h + Sigma1_512(e) + Ch(e, f, g) + K512[i];        T2 = Sigma0_512(a) + Maj(a, b, c);        h = g;        g = f;        f = e;        e = d + T1;        d = c;        c = b;        b = a;        a = T1 + T2;    }#else    for (i = 0; i < 16 - 7;) {        ROUND512_0_TO_15(a, b, c, d, e, f, g, h);        ROUND512_0_TO_15(h, a, b, c, d, e, f, g);        ROUND512_0_TO_15(g, h, a, b, c, d, e, f);        ROUND512_0_TO_15(f, g, h, a, b, c, d, e);        ROUND512_0_TO_15(e, f, g, h, a, b, c, d);        ROUND512_0_TO_15(d, e, f, g, h, a, b, c);        ROUND512_0_TO_15(c, d, e, f, g, h, a, b);        ROUND512_0_TO_15(b, c, d, e, f, g, h, a);    }    for (; i < 80 - 7;) {        ROUND512_16_TO_80(a, b, c, d, e, f, g, h);        ROUND512_16_TO_80(h, a, b, c, d, e, f, g);        ROUND512_16_TO_80(g, h, a, b, c, d, e, f);        ROUND512_16_TO_80(f, g, h, a, b, c, d, e);        ROUND512_16_TO_80(e, f, g, h, a, b, c, d);        ROUND512_16_TO_80(d, e, f, g, h, a, b, c);        ROUND512_16_TO_80(c, d, e, f, g, h, a, b);        ROUND512_16_TO_80(b, c, d, e, f, g, h, a);    }#endif    state[0] += a;    state[1] += b;    state[2] += c;    state[3] += d;    state[4] += e;    state[5] += f;    state[6] += g;    state[7] += h;}", "idx": 17515}
{"project": "qemu", "commit_id": "2bf9febc95e5bcef8edb10ebc967325917b9c958", "target": 1, "function": "int qemu_fdt_setprop_sized_cells_from_array(void *fdt,                                            const char *node_path,                                            const char *property,                                            int numvalues,                                            uint64_t *values){    uint32_t *propcells;    uint64_t value;    int cellnum, vnum, ncells;    uint32_t hival;    propcells = g_new0(uint32_t, numvalues * 2);    cellnum = 0;    for (vnum = 0; vnum < numvalues; vnum++) {        ncells = values[vnum * 2];        if (ncells != 1 && ncells != 2) {            return -1;        }        value = values[vnum * 2 + 1];        hival = cpu_to_be32(value >> 32);        if (ncells > 1) {            propcells[cellnum++] = hival;        } else if (hival != 0) {            return -1;        }        propcells[cellnum++] = cpu_to_be32(value);    }    return qemu_fdt_setprop(fdt, node_path, property, propcells,                            cellnum * sizeof(uint32_t));}", "idx": 17521}
{"project": "FFmpeg", "commit_id": "42dd22c4a5c8463488d442eeb234b822bcc39625", "target": 0, "function": "static int decode_init(AVCodecContext *avctx){    HYuvContext *s = avctx->priv_data;    int width, height;    s->avctx= avctx;    s->flags= avctx->flags;            dsputil_init(&s->dsp, avctx);    memset(s->vlc, 0, 3*sizeof(VLC));        width= s->width= avctx->width;    height= s->height= avctx->height;    avctx->coded_frame= &s->picture;s->bgr32=1;    assert(width && height);//if(avctx->extradata)//  printf(\"extradata:%X, extradata_size:%d\\n\", *(uint32_t*)avctx->extradata, avctx->extradata_size);    if(avctx->extradata_size){        if((avctx->bits_per_sample&7) && avctx->bits_per_sample != 12)            s->version=1; // do such files exist at all?        else            s->version=2;    }else        s->version=0;        if(s->version==2){        int method;        method= ((uint8_t*)avctx->extradata)[0];        s->decorrelate= method&64 ? 1 : 0;        s->predictor= method&63;        s->bitstream_bpp= ((uint8_t*)avctx->extradata)[1];        if(s->bitstream_bpp==0)             s->bitstream_bpp= avctx->bits_per_sample&~7;        s->context= ((uint8_t*)avctx->extradata)[2] & 0x40 ? 1 : 0;                    if(read_huffman_tables(s, ((uint8_t*)avctx->extradata)+4, avctx->extradata_size) < 0)            return -1;    }else{        switch(avctx->bits_per_sample&7){        case 1:            s->predictor= LEFT;            s->decorrelate= 0;            break;        case 2:            s->predictor= LEFT;            s->decorrelate= 1;            break;        case 3:            s->predictor= PLANE;            s->decorrelate= avctx->bits_per_sample >= 24;            break;        case 4:            s->predictor= MEDIAN;            s->decorrelate= 0;            break;        default:            s->predictor= LEFT; //OLD            s->decorrelate= 0;            break;        }        s->bitstream_bpp= avctx->bits_per_sample & ~7;        s->context= 0;                if(read_old_huffman_tables(s) < 0)            return -1;    }        if(((uint8_t*)avctx->extradata)[2] & 0x20)\ts->interlaced= ((uint8_t*)avctx->extradata)[2] & 0x10 ? 1 : 0;    else\ts->interlaced= height > 288;        switch(s->bitstream_bpp){    case 12:        avctx->pix_fmt = PIX_FMT_YUV420P;        break;    case 16:        if(s->yuy2){            avctx->pix_fmt = PIX_FMT_YUV422;        }else{            avctx->pix_fmt = PIX_FMT_YUV422P;        }        break;    case 24:    case 32:        if(s->bgr32){            avctx->pix_fmt = PIX_FMT_RGBA32;        }else{            avctx->pix_fmt = PIX_FMT_BGR24;        }        break;    default:        assert(0);    }    //    av_log(NULL, AV_LOG_DEBUG, \"pred:%d bpp:%d hbpp:%d il:%d\\n\", s->predictor, s->bitstream_bpp, avctx->bits_per_sample, s->interlaced);    return 0;}", "idx": 17574}
{"project": "FFmpeg", "commit_id": "d574e22659bd51cdf16723a204fef65a9e783f1d", "target": 0, "function": "static int filter_frame(AVFilterLink *inlink, AVFrame *in){    AVFilterContext *ctx = inlink->dst;    HDCDContext *s = ctx->priv;    AVFilterLink *outlink = ctx->outputs[0];    AVFrame *out;    const int16_t *in_data;    int32_t *out_data;    int n, c;    int detect, packets, pe_packets;    out = ff_get_audio_buffer(outlink, in->nb_samples);    if (!out) {        av_frame_free(&in);        return AVERROR(ENOMEM);    }    av_frame_copy_props(out, in);    out->format = outlink->format;    in_data  = (int16_t*)in->data[0];    out_data = (int32_t*)out->data[0];    for (n = 0; n < in->nb_samples * in->channels; n++) {        out_data[n] = in_data[n];    }    detect = 0;    packets = 0;    pe_packets = 0;    s->det_errors = 0;    for (c = 0; c < inlink->channels; c++) {        hdcd_state_t *state = &s->state[c];        hdcd_process(s, state, out_data + c, in->nb_samples, out->channels);        if (state->sustain) detect++;        packets += state->code_counterA + state->code_counterB;        pe_packets += state->count_peak_extend;        s->uses_transient_filter |= !!state->count_transient_filter;        s->max_gain_adjustment = FFMIN(s->max_gain_adjustment, GAINTOFLOAT(state->max_gain));        s->det_errors += state->code_counterA_almost            + state->code_counterB_checkfails            + state->code_counterC_unmatched;    }    if (pe_packets) {        /* if every valid packet has used PE, call it permanent */        if (packets == pe_packets)            s->peak_extend = HDCD_PE_PERMANENT;        else            s->peak_extend = HDCD_PE_INTERMITTENT;    } else {        s->peak_extend = HDCD_PE_NEVER;    }    /* HDCD is detected if a valid packet is active in all (both)     * channels at the same time. */    if (detect == inlink->channels) s->hdcd_detected = 1;    s->sample_count += in->nb_samples * in->channels;    av_frame_free(&in);    return ff_filter_frame(outlink, out);}", "idx": 17620}
{"project": "qemu", "commit_id": "4a84214ebe1695405f58e5c6272d63d6084edfa5", "target": 0, "function": "void qmp_migrate_set_capabilities(MigrationCapabilityStatusList *params,                                  Error **errp){    MigrationState *s = migrate_get_current();    MigrationCapabilityStatusList *cap;    bool old_postcopy_cap = migrate_postcopy_ram();    if (migration_is_setup_or_active(s->state)) {        error_setg(errp, QERR_MIGRATION_ACTIVE);        return;    }    for (cap = params; cap; cap = cap->next) {#ifndef CONFIG_LIVE_BLOCK_MIGRATION        if (cap->value->capability == MIGRATION_CAPABILITY_BLOCK            && cap->value->state) {            error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"                       \"block migration\");            error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");            continue;        }#endif        s->enabled_capabilities[cap->value->capability] = cap->value->state;    }    if (migrate_postcopy_ram()) {        if (migrate_use_compression()) {            /* The decompression threads asynchronously write into RAM             * rather than use the atomic copies needed to avoid             * userfaulting.  It should be possible to fix the decompression             * threads for compatibility in future.             */            error_report(\"Postcopy is not currently compatible with \"                         \"compression\");            s->enabled_capabilities[MIGRATION_CAPABILITY_POSTCOPY_RAM] =                false;        }        /* This check is reasonably expensive, so only when it's being         * set the first time, also it's only the destination that needs         * special support.         */        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&            !postcopy_ram_supported_by_host()) {            /* postcopy_ram_supported_by_host will have emitted a more             * detailed message             */            error_report(\"Postcopy is not supported\");            s->enabled_capabilities[MIGRATION_CAPABILITY_POSTCOPY_RAM] =                false;        }    }}", "idx": 17706}
{"project": "FFmpeg", "commit_id": "30ba28fe8e5757ab4ee61b9c0e8a418bd7d54b50", "target": 1, "function": "static int write_adaptation_set(AVFormatContext *s, int as_index){    WebMDashMuxContext *w = s->priv_data;    AdaptationSet *as = &w->as[as_index];    AVCodecContext *codec = s->streams[as->streams[0]]->codec;    AVDictionaryEntry *lang;    int i;    static const char boolean[2][6] = { \"false\", \"true\" };    int subsegmentStartsWithSAP = 1;    // Width, Height and Sample Rate will go in the AdaptationSet tag if they    // are the same for all contained Representations. otherwise, they will go    // on their respective Representation tag. For live streams, they always go    // in the Representation tag.    int width_in_as = 1, height_in_as = 1, sample_rate_in_as = 1;    if (codec->codec_type == AVMEDIA_TYPE_VIDEO) {      width_in_as = !w->is_live && check_matching_width(s, as);      height_in_as = !w->is_live && check_matching_height(s, as);    } else {      sample_rate_in_as = !w->is_live && check_matching_sample_rate(s, as);    }    avio_printf(s->pb, \"<AdaptationSet id=\\\"%s\\\"\", as->id);    avio_printf(s->pb, \" mimeType=\\\"%s/webm\\\"\",                codec->codec_type == AVMEDIA_TYPE_VIDEO ? \"video\" : \"audio\");    avio_printf(s->pb, \" codecs=\\\"%s\\\"\", get_codec_name(codec->codec_id));    lang = av_dict_get(s->streams[as->streams[0]]->metadata, \"language\", NULL, 0);    if (lang) avio_printf(s->pb, \" lang=\\\"%s\\\"\", lang->value);    if (codec->codec_type == AVMEDIA_TYPE_VIDEO && width_in_as)        avio_printf(s->pb, \" width=\\\"%d\\\"\", codec->width);    if (codec->codec_type == AVMEDIA_TYPE_VIDEO && height_in_as)        avio_printf(s->pb, \" height=\\\"%d\\\"\", codec->height);    if (codec->codec_type == AVMEDIA_TYPE_AUDIO && sample_rate_in_as)        avio_printf(s->pb, \" audioSamplingRate=\\\"%d\\\"\", codec->sample_rate);    avio_printf(s->pb, \" bitstreamSwitching=\\\"%s\\\"\",                boolean[bitstream_switching(s, as)]);    avio_printf(s->pb, \" subsegmentAlignment=\\\"%s\\\"\",                boolean[w->is_live || subsegment_alignment(s, as)]);    for (i = 0; i < as->nb_streams; i++) {        AVDictionaryEntry *kf = av_dict_get(s->streams[as->streams[i]]->metadata,                                            CLUSTER_KEYFRAME, NULL, 0);        if (!w->is_live && (!kf || !strncmp(kf->value, \"0\", 1))) subsegmentStartsWithSAP = 0;    }    avio_printf(s->pb, \" subsegmentStartsWithSAP=\\\"%d\\\"\", subsegmentStartsWithSAP);    avio_printf(s->pb, \">\\n\");    if (w->is_live) {        AVDictionaryEntry *filename =            av_dict_get(s->streams[as->streams[0]]->metadata, FILENAME, NULL, 0);        char *initialization_pattern = NULL;        char *media_pattern = NULL;        int ret = parse_filename(filename->value, NULL, &initialization_pattern,                                 &media_pattern);        if (ret) return ret;        avio_printf(s->pb, \"<ContentComponent id=\\\"1\\\" type=\\\"%s\\\"/>\\n\",                    codec->codec_type == AVMEDIA_TYPE_VIDEO ? \"video\" : \"audio\");        avio_printf(s->pb, \"<SegmentTemplate\");        avio_printf(s->pb, \" timescale=\\\"1000\\\"\");        avio_printf(s->pb, \" duration=\\\"%d\\\"\", w->chunk_duration);        avio_printf(s->pb, \" media=\\\"%s\\\"\", media_pattern);        avio_printf(s->pb, \" startNumber=\\\"%d\\\"\", w->chunk_start_index);        avio_printf(s->pb, \" initialization=\\\"%s\\\"\", initialization_pattern);        avio_printf(s->pb, \"/>\\n\");        av_free(initialization_pattern);        av_free(media_pattern);    }    for (i = 0; i < as->nb_streams; i++) {        char *representation_id = NULL;        int ret;        if (w->is_live) {            AVDictionaryEntry *filename =                av_dict_get(s->streams[as->streams[i]]->metadata, FILENAME, NULL, 0);            if (!filename ||                (ret = parse_filename(filename->value, &representation_id, NULL, NULL))) {                return ret;            }        } else {            representation_id = av_asprintf(\"%d\", w->representation_id++);            if (!representation_id) return AVERROR(ENOMEM);        }        ret = write_representation(s, s->streams[as->streams[i]],                                   representation_id, !width_in_as,                                   !height_in_as, !sample_rate_in_as);        if (ret) return ret;        av_free(representation_id);    }    avio_printf(s->pb, \"</AdaptationSet>\\n\");    return 0;}", "idx": 17749}
{"project": "FFmpeg", "commit_id": "681868cbbe8a596860c454d34f259941e0c44d73", "target": 1, "function": "static void merge_context_after_encode(MpegEncContext *dst, MpegEncContext *src){    int i;    MERGE(dct_count[0]); //note, the other dct vars are not part of the context    MERGE(dct_count[1]);    MERGE(mv_bits);    MERGE(i_tex_bits);    MERGE(p_tex_bits);    MERGE(i_count);    MERGE(f_count);    MERGE(b_count);    MERGE(skip_count);    MERGE(misc_bits);    MERGE(er.error_count);    MERGE(padding_bug_score);    MERGE(current_picture.f->error[0]);    MERGE(current_picture.f->error[1]);    MERGE(current_picture.f->error[2]);    if(dst->avctx->noise_reduction){        for(i=0; i<64; i++){            MERGE(dct_error_sum[0][i]);            MERGE(dct_error_sum[1][i]);        }    }    assert(put_bits_count(&src->pb) % 8 ==0);    assert(put_bits_count(&dst->pb) % 8 ==0);    avpriv_copy_bits(&dst->pb, src->pb.buf, put_bits_count(&src->pb));    flush_put_bits(&dst->pb);}", "idx": 17785}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "function": "static int parse_fmtp(AVFormatContext *s,                      AVStream *stream, PayloadContext *data,                      const char *attr, const char *value){    AVCodecParameters *par = stream->codecpar;    int res, i;    if (!strcmp(attr, \"config\")) {        res = parse_fmtp_config(par, value);        if (res < 0)            return res;    }    if (par->codec_id == AV_CODEC_ID_AAC) {        /* Looking for a known attribute */        for (i = 0; attr_names[i].str; ++i) {            if (!av_strcasecmp(attr, attr_names[i].str)) {                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {                    *(int *)((char *)data+                        attr_names[i].offset) = atoi(value);                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)                    *(char **)((char *)data+                        attr_names[i].offset) = av_strdup(value);            }        }    }    return 0;}", "idx": 17786}
{"project": "qemu", "commit_id": "f61d82c2dfe02a60642a76e8f0034a0244eef2bf", "target": 1, "function": "static void isa_cirrus_vga_realizefn(DeviceState *dev, Error **errp){    ISADevice *isadev = ISA_DEVICE(dev);    ISACirrusVGAState *d = ISA_CIRRUS_VGA(dev);    VGACommonState *s = &d->cirrus_vga.vga;    vga_common_init(s, OBJECT(dev), true);    cirrus_init_common(&d->cirrus_vga, OBJECT(dev), CIRRUS_ID_CLGD5430, 0,                       isa_address_space(isadev),                       isa_address_space_io(isadev));    s->con = graphic_console_init(dev, 0, s->hw_ops, s);    rom_add_vga(VGABIOS_CIRRUS_FILENAME);    /* XXX ISA-LFB support */    /* FIXME not qdev yet */", "idx": 17804}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "function": "static uint8_t *read_huffman_tables(FourXContext *f, uint8_t * const buf){    int frequency[512];    uint8_t flag[512];    int up[512];    uint8_t len_tab[257];    int bits_tab[257];    int start, end;    uint8_t *ptr= buf;    int j;        memset(frequency, 0, sizeof(frequency));    memset(up, -1, sizeof(up));    start= *ptr++;    end= *ptr++;    for(;;){        int i;                for(i=start; i<=end; i++){            frequency[i]= *ptr++;//            printf(\"%d %d %d\\n\", start, end, frequency[i]);        }        start= *ptr++;        if(start==0) break;                end= *ptr++;    }    frequency[256]=1;    while((ptr - buf)&3) ptr++; // 4byte align //    for(j=0; j<16; j++)//        printf(\"%2X\", ptr[j]);        for(j=257; j<512; j++){        int min_freq[2]= {256*256, 256*256};        int smallest[2]= {0, 0};        int i;        for(i=0; i<j; i++){            if(frequency[i] == 0) continue;            if(frequency[i] < min_freq[1]){                if(frequency[i] < min_freq[0]){                    min_freq[1]= min_freq[0]; smallest[1]= smallest[0];                    min_freq[0]= frequency[i];smallest[0]= i;                }else{                    min_freq[1]= frequency[i];smallest[1]= i;                }            }        }        if(min_freq[1] == 256*256) break;                frequency[j]= min_freq[0] + min_freq[1];        flag[ smallest[0] ]= 0;        flag[ smallest[1] ]= 1;        up[ smallest[0] ]=         up[ smallest[1] ]= j;        frequency[ smallest[0] ]= frequency[ smallest[1] ]= 0;    }    for(j=0; j<257; j++){        int node;        int len=0;        int bits=0;        for(node= j; up[node] != -1; node= up[node]){            bits += flag[node]<<len;            len++;            if(len > 31) av_log(f->avctx, AV_LOG_ERROR, \"vlc length overflow\\n\"); //can this happen at all ?        }                bits_tab[j]= bits;        len_tab[j]= len;    }        init_vlc(&f->pre_vlc, ACDC_VLC_BITS, 257,              len_tab , 1, 1,             bits_tab, 4, 4);                 return ptr;}", "idx": 17846}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "function": "static inline void RENAME(rgb16to32)(const uint8_t *src, uint8_t *dst, long src_size){\tconst uint16_t *end;#ifdef HAVE_MMX\tconst uint16_t *mm_end;#endif\tuint8_t *d = (uint8_t *)dst;\tconst uint16_t *s = (uint16_t *)src;\tend = s + src_size/2;#ifdef HAVE_MMX\t__asm __volatile(PREFETCH\"\t%0\"::\"m\"(*s):\"memory\");\t__asm __volatile(\"pxor\t%%mm7,%%mm7\\n\\t\":::\"memory\");\tmm_end = end - 3;\twhile(s < mm_end)\t{\t    __asm __volatile(\t\tPREFETCH\" 32%1\\n\\t\"\t\t\"movq\t%1, %%mm0\\n\\t\"\t\t\"movq\t%1, %%mm1\\n\\t\"\t\t\"movq\t%1, %%mm2\\n\\t\"\t\t\"pand\t%2, %%mm0\\n\\t\"\t\t\"pand\t%3, %%mm1\\n\\t\"\t\t\"pand\t%4, %%mm2\\n\\t\"\t\t\"psllq\t$3, %%mm0\\n\\t\"\t\t\"psrlq\t$3, %%mm1\\n\\t\"\t\t\"psrlq\t$8, %%mm2\\n\\t\"\t\t\"movq\t%%mm0, %%mm3\\n\\t\"\t\t\"movq\t%%mm1, %%mm4\\n\\t\"\t\t\"movq\t%%mm2, %%mm5\\n\\t\"\t\t\"punpcklwd %%mm7, %%mm0\\n\\t\"\t\t\"punpcklwd %%mm7, %%mm1\\n\\t\"\t\t\"punpcklwd %%mm7, %%mm2\\n\\t\"\t\t\"punpckhwd %%mm7, %%mm3\\n\\t\"\t\t\"punpckhwd %%mm7, %%mm4\\n\\t\"\t\t\"punpckhwd %%mm7, %%mm5\\n\\t\"\t\t\"psllq\t$8, %%mm1\\n\\t\"\t\t\"psllq\t$16, %%mm2\\n\\t\"\t\t\"por\t%%mm1, %%mm0\\n\\t\"\t\t\"por\t%%mm2, %%mm0\\n\\t\"\t\t\"psllq\t$8, %%mm4\\n\\t\"\t\t\"psllq\t$16, %%mm5\\n\\t\"\t\t\"por\t%%mm4, %%mm3\\n\\t\"\t\t\"por\t%%mm5, %%mm3\\n\\t\"\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\t\tMOVNTQ\"\t%%mm3, 8%0\\n\\t\"\t\t:\"=m\"(*d)\t\t:\"m\"(*s),\"m\"(mask16b),\"m\"(mask16g),\"m\"(mask16r)\t\t:\"memory\");\t\td += 16;\t\ts += 4;\t}\t__asm __volatile(SFENCE:::\"memory\");\t__asm __volatile(EMMS:::\"memory\");#endif\twhile(s < end)\t{\t\tregister uint16_t bgr;\t\tbgr = *s++;#ifdef WORDS_BIGENDIAN\t\t*d++ = 0;\t\t*d++ = (bgr&0xF800)>>8;\t\t*d++ = (bgr&0x7E0)>>3;\t\t*d++ = (bgr&0x1F)<<3;#else\t\t*d++ = (bgr&0x1F)<<3;\t\t*d++ = (bgr&0x7E0)>>3;\t\t*d++ = (bgr&0xF800)>>8;\t\t*d++ = 0;#endif\t}}", "idx": 17894}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "function": "static int of_dpa_cmd_flow_add(OfDpa *of_dpa, uint64_t cookie,                               RockerTlv **flow_tlvs){    OfDpaFlow *flow = of_dpa_flow_find(of_dpa, cookie);    int err = ROCKER_OK;    if (flow) {        return -ROCKER_EEXIST;    }    flow = of_dpa_flow_alloc(cookie);    if (!flow) {        return -ROCKER_ENOMEM;    }    err = of_dpa_cmd_flow_add_mod(of_dpa, flow, flow_tlvs);    if (err) {        g_free(flow);        return err;    }    return of_dpa_flow_add(of_dpa, flow);}", "idx": 17935}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "function": "static int vmdk_parent_open(BlockDriverState *bs, const char * filename){    BDRVVmdkState *s = bs->opaque;    char *p_name;     char desc[DESC_SIZE];    char parent_img_name[1024];    /* the descriptor offset = 0x200 */    if (bdrv_pread(s->hd, 0x200, desc, DESC_SIZE) != DESC_SIZE)        return -1;    if ((p_name = strstr(desc,\"parentFileNameHint\")) != 0) {        char *end_name;        struct stat file_buf;        p_name += sizeof(\"parentFileNameHint\") + 1;        if ((end_name = strchr(p_name,'\\\"')) == 0)            return -1;                        strncpy(s->hd->backing_file, p_name, end_name - p_name);        if (stat(s->hd->backing_file, &file_buf) != 0) {            path_combine(parent_img_name, sizeof(parent_img_name),                         filename, s->hd->backing_file);        } else {            strcpy(parent_img_name, s->hd->backing_file);        }        s->hd->backing_hd = bdrv_new(\"\");        if (!s->hd->backing_hd) {            failure:            bdrv_close(s->hd);            return -1;        }        if (bdrv_open(s->hd->backing_hd, parent_img_name, 0) < 0)            goto failure;    }    return 0;}", "idx": 17947}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "function": "static void spapr_reallocate_hpt(sPAPRMachineState *spapr, int shift,                                 Error **errp){    long rc;    /* Clean up any HPT info from a previous boot */    g_free(spapr->htab);    spapr->htab = NULL;    spapr->htab_shift = 0;    close_htab_fd(spapr);    rc = kvmppc_reset_htab(shift);    if (rc < 0) {        /* kernel-side HPT needed, but couldn't allocate one */        error_setg_errno(errp, errno,                         \"Failed to allocate KVM HPT of order %d (try smaller maxmem?)\",                         shift);        /* This is almost certainly fatal, but if the caller really         * wants to carry on with shift == 0, it's welcome to try */    } else if (rc > 0) {        /* kernel-side HPT allocated */        if (rc != shift) {            error_setg(errp,                       \"Requested order %d HPT, but kernel allocated order %ld (try smaller maxmem?)\",                       shift, rc);        }        spapr->htab_shift = shift;        kvmppc_kern_htab = true;    } else {        /* kernel-side HPT not needed, allocate in userspace instead */        size_t size = 1ULL << shift;        int i;        spapr->htab = qemu_memalign(size, size);        if (!spapr->htab) {            error_setg_errno(errp, errno,                             \"Could not allocate HPT of order %d\", shift);            return;        }        memset(spapr->htab, 0, size);        spapr->htab_shift = shift;        kvmppc_kern_htab = false;        for (i = 0; i < size / HASH_PTE_SIZE_64; i++) {            DIRTY_HPTE(HPTE(spapr->htab, i));        }    }}", "idx": 18025}
{"project": "qemu", "commit_id": "dfad9ec4e9f15344f300996ad8c6f3eaf699d195", "target": 0, "function": "static void keyword_literal(void){    QObject *obj;    QBool *qbool;    QObject *null;    QString *str;    obj = qobject_from_json(\"true\");    g_assert(obj != NULL);    g_assert(qobject_type(obj) == QTYPE_QBOOL);    qbool = qobject_to_qbool(obj);    g_assert(qbool_get_bool(qbool) == true);    str = qobject_to_json(obj);    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);    QDECREF(str);    QDECREF(qbool);    obj = qobject_from_json(\"false\");    g_assert(obj != NULL);    g_assert(qobject_type(obj) == QTYPE_QBOOL);    qbool = qobject_to_qbool(obj);    g_assert(qbool_get_bool(qbool) == false);    str = qobject_to_json(obj);    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);    QDECREF(str);    QDECREF(qbool);    obj = qobject_from_jsonf(\"%i\", false);    g_assert(obj != NULL);    g_assert(qobject_type(obj) == QTYPE_QBOOL);    qbool = qobject_to_qbool(obj);    g_assert(qbool_get_bool(qbool) == false);    QDECREF(qbool);    /* Test that non-zero values other than 1 get collapsed to true */    obj = qobject_from_jsonf(\"%i\", 2);    g_assert(obj != NULL);    g_assert(qobject_type(obj) == QTYPE_QBOOL);    qbool = qobject_to_qbool(obj);    g_assert(qbool_get_bool(qbool) == true);    QDECREF(qbool);    obj = qobject_from_json(\"null\");    g_assert(obj != NULL);    g_assert(qobject_type(obj) == QTYPE_QNULL);    null = qnull();    g_assert(null == obj);    qobject_decref(obj);    qobject_decref(null);}", "idx": 18056}
{"project": "FFmpeg", "commit_id": "80469eafb747018cb9d9a2547f65def715d073b2", "target": 1, "function": "int MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx){    int i;    Picture *pic;    s->mb_skipped = 0;    assert(s->last_picture_ptr==NULL || s->out_format != FMT_H264 || s->codec_id == CODEC_ID_SVQ3);    /* mark&release old frames */    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr && s->last_picture_ptr != s->next_picture_ptr && s->last_picture_ptr->f.data[0]) {      if(s->out_format != FMT_H264 || s->codec_id == CODEC_ID_SVQ3){          free_frame_buffer(s, s->last_picture_ptr);        /* release forgotten pictures */        /* if(mpeg124/h263) */        if(!s->encoding){            for(i=0; i<s->picture_count; i++){                if (s->picture[i].f.data[0] && &s->picture[i] != s->next_picture_ptr && s->picture[i].f.reference) {                    av_log(avctx, AV_LOG_ERROR, \"releasing zombie picture\\n\");                    free_frame_buffer(s, &s->picture[i]);                }            }        }      }    }    if(!s->encoding){        ff_release_unused_pictures(s, 1);        if (s->current_picture_ptr && s->current_picture_ptr->f.data[0] == NULL)            pic= s->current_picture_ptr; //we already have a unused image (maybe it was set before reading the header)        else{            i= ff_find_unused_picture(s, 0);            pic= &s->picture[i];        }        pic->f.reference = 0;        if (!s->dropable){            if (s->codec_id == CODEC_ID_H264)                pic->f.reference = s->picture_structure;            else if (s->pict_type != AV_PICTURE_TYPE_B)                pic->f.reference = 3;        }        pic->f.coded_picture_number = s->coded_picture_number++;        if(ff_alloc_picture(s, pic, 0) < 0)            return -1;        s->current_picture_ptr= pic;        //FIXME use only the vars from current_pic        s->current_picture_ptr->f.top_field_first = s->top_field_first;        if(s->codec_id == CODEC_ID_MPEG1VIDEO || s->codec_id == CODEC_ID_MPEG2VIDEO) {            if(s->picture_structure != PICT_FRAME)                s->current_picture_ptr->f.top_field_first = (s->picture_structure == PICT_TOP_FIELD) == s->first_field;        }        s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame && !s->progressive_sequence;        s->current_picture_ptr->field_picture = s->picture_structure != PICT_FRAME;    }    s->current_picture_ptr->f.pict_type = s->pict_type;//    if(s->flags && CODEC_FLAG_QSCALE)  //      s->current_picture_ptr->quality= s->new_picture_ptr->quality;    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;    ff_copy_picture(&s->current_picture, s->current_picture_ptr);    if (s->pict_type != AV_PICTURE_TYPE_B) {        s->last_picture_ptr= s->next_picture_ptr;        if(!s->dropable)            s->next_picture_ptr= s->current_picture_ptr;    }/*    av_log(s->avctx, AV_LOG_DEBUG, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\", s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,        s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,        s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,        s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,        s->pict_type, s->dropable);*/    if(s->codec_id != CODEC_ID_H264){        if ((s->last_picture_ptr == NULL || s->last_picture_ptr->f.data[0] == NULL) &&           (s->pict_type!=AV_PICTURE_TYPE_I || s->picture_structure != PICT_FRAME)){            if (s->pict_type != AV_PICTURE_TYPE_I)                av_log(avctx, AV_LOG_ERROR, \"warning: first frame is no keyframe\\n\");            else if (s->picture_structure != PICT_FRAME)                av_log(avctx, AV_LOG_INFO, \"allocate dummy last picture for field based first keyframe\\n\");            /* Allocate a dummy frame */            i= ff_find_unused_picture(s, 0);            s->last_picture_ptr= &s->picture[i];            if(ff_alloc_picture(s, s->last_picture_ptr, 0) < 0)                return -1;            ff_thread_report_progress((AVFrame*)s->last_picture_ptr, INT_MAX, 0);            ff_thread_report_progress((AVFrame*)s->last_picture_ptr, INT_MAX, 1);        }        if ((s->next_picture_ptr == NULL || s->next_picture_ptr->f.data[0] == NULL) && s->pict_type == AV_PICTURE_TYPE_B) {            /* Allocate a dummy frame */            i= ff_find_unused_picture(s, 0);            s->next_picture_ptr= &s->picture[i];            if(ff_alloc_picture(s, s->next_picture_ptr, 0) < 0)                return -1;            ff_thread_report_progress((AVFrame*)s->next_picture_ptr, INT_MAX, 0);            ff_thread_report_progress((AVFrame*)s->next_picture_ptr, INT_MAX, 1);        }    }    if(s->last_picture_ptr) ff_copy_picture(&s->last_picture, s->last_picture_ptr);    if(s->next_picture_ptr) ff_copy_picture(&s->next_picture, s->next_picture_ptr);    assert(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr && s->last_picture_ptr->f.data[0]));    if(s->picture_structure!=PICT_FRAME && s->out_format != FMT_H264){        int i;        for(i=0; i<4; i++){            if(s->picture_structure == PICT_BOTTOM_FIELD){                 s->current_picture.f.data[i] += s->current_picture.f.linesize[i];            }            s->current_picture.f.linesize[i] *= 2;            s->last_picture.f.linesize[i]    *= 2;            s->next_picture.f.linesize[i]    *= 2;        }    }    s->error_recognition= avctx->error_recognition;    /* set dequantizer, we can't do it during init as it might change for mpeg4       and we can't do it in the header decode as init is not called for mpeg4 there yet */    if(s->mpeg_quant || s->codec_id == CODEC_ID_MPEG2VIDEO){        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;    }else if(s->out_format == FMT_H263 || s->out_format == FMT_H261){        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;    }else{        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;    }    if(s->dct_error_sum){        assert(s->avctx->noise_reduction && s->encoding);        update_noise_reduction(s);    }    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)        return ff_xvmc_field_start(s, avctx);    return 0;}", "idx": 18075}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "function": "static void gen_check_interrupts(DisasContext *dc){    if (dc->tb->cflags & CF_USE_ICOUNT) {        gen_io_start();    }    gen_helper_check_interrupts(cpu_env);    if (dc->tb->cflags & CF_USE_ICOUNT) {        gen_io_end();    }}", "idx": 18208}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "function": "void kqemu_record_dump(void){    PCRecord **pr, *r;    int i, h;    FILE *f;    int64_t total, sum;    pr = malloc(sizeof(PCRecord *) * nb_pc_records);    i = 0;    total = 0;    for(h = 0; h < PC_REC_HASH_SIZE; h++) {        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {            pr[i++] = r;            total += r->count;        }    }    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);    f = fopen(\"/tmp/kqemu.stats\", \"w\");    if (!f) {        perror(\"/tmp/kqemu.stats\");        exit(1);    }    fprintf(f, \"total: %\" PRId64 \"\\n\", total);    sum = 0;    for(i = 0; i < nb_pc_records; i++) {        r = pr[i];        sum += r->count;        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",                r->pc,                r->count,                (double)r->count / (double)total * 100.0,                (double)sum / (double)total * 100.0);    }    fclose(f);    free(pr);    kqemu_record_flush();}", "idx": 18231}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint64_t omap_sti_fifo_read(void *opaque, target_phys_addr_t addr,                                   unsigned size){    OMAP_BAD_REG(addr);    return 0;}", "idx": 18243}
{"project": "qemu", "commit_id": "fc1c4a5d32e15a4c40c47945da85ef9c1e0c1b54", "target": 0, "function": "void ram_handle_compressed(void *host, uint8_t ch, uint64_t size){    if (ch != 0 || !is_zero_range(host, size)) {        memset(host, ch, size);#ifndef _WIN32        if (ch == 0 && (!kvm_enabled() || kvm_has_sync_mmu())) {            size = size & ~(getpagesize() - 1);            if (size > 0) {                qemu_madvise(host, size, QEMU_MADV_DONTNEED);            }        }#endif    }}", "idx": 18278}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "function": "int qemu_savevm_state_iterate(QEMUFile *f){    SaveStateEntry *se;    int ret = 1;    trace_savevm_state_iterate();    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {        if (!se->ops || !se->ops->save_live_iterate) {            continue;        }        if (se->ops && se->ops->is_active) {            if (!se->ops->is_active(se->opaque)) {                continue;            }        }        if (qemu_file_rate_limit(f)) {            return 0;        }        trace_savevm_section_start(se->idstr, se->section_id);        save_section_header(f, se, QEMU_VM_SECTION_PART);        ret = se->ops->save_live_iterate(f, se->opaque);        trace_savevm_section_end(se->idstr, se->section_id, ret);        if (ret < 0) {            qemu_file_set_error(f, ret);        }        if (ret <= 0) {            /* Do not proceed to the next vmstate before this one reported               completion of the current stage. This serializes the migration               and reduces the probability that a faster changing state is               synchronized over and over again. */            break;        }    }    return ret;}", "idx": 18316}
{"project": "FFmpeg", "commit_id": "c988f97566cdf536ba0dcbc0d77d885456852060", "target": 0, "function": "int ff_h264_decode_mb_cabac(H264Context *h) {    MpegEncContext * const s = &h->s;    int mb_xy;    int mb_type, partition_count, cbp = 0;    int dct8x8_allowed= h->pps.transform_8x8_mode;    mb_xy = h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);    if( h->slice_type_nos != FF_I_TYPE ) {        int skip;        /* a skipped mb needs the aff flag from the following mb */        if( FRAME_MBAFF && s->mb_x==0 && (s->mb_y&1)==0 )            predict_field_decoding_flag(h);        if( FRAME_MBAFF && (s->mb_y&1)==1 && h->prev_mb_skipped )            skip = h->next_mb_skipped;        else            skip = decode_cabac_mb_skip( h, s->mb_x, s->mb_y );        /* read skip flags */        if( skip ) {            if( FRAME_MBAFF && (s->mb_y&1)==0 ){                s->current_picture.mb_type[mb_xy] = MB_TYPE_SKIP;                h->next_mb_skipped = decode_cabac_mb_skip( h, s->mb_x, s->mb_y+1 );                if(!h->next_mb_skipped)                    h->mb_mbaff = h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);            }            decode_mb_skip(h);            h->cbp_table[mb_xy] = 0;            h->chroma_pred_mode_table[mb_xy] = 0;            h->last_qscale_diff = 0;            return 0;        }    }    if(FRAME_MBAFF){        if( (s->mb_y&1) == 0 )            h->mb_mbaff =            h->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h);    }    h->prev_mb_skipped = 0;    compute_mb_neighbors(h);    if( h->slice_type_nos == FF_B_TYPE ) {        mb_type = decode_cabac_mb_type_b( h );        if( mb_type < 23 ){            partition_count= b_mb_type_info[mb_type].partition_count;            mb_type=         b_mb_type_info[mb_type].type;        }else{            mb_type -= 23;            goto decode_intra_mb;        }    } else if( h->slice_type_nos == FF_P_TYPE ) {        if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {            /* P-type */            if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {                /* P_L0_D16x16, P_8x8 */                mb_type= 3 * get_cabac_noinline( &h->cabac, &h->cabac_state[16] );            } else {                /* P_L0_D8x16, P_L0_D16x8 */                mb_type= 2 - get_cabac_noinline( &h->cabac, &h->cabac_state[17] );            }            partition_count= p_mb_type_info[mb_type].partition_count;            mb_type=         p_mb_type_info[mb_type].type;        } else {            mb_type= decode_cabac_intra_mb_type(h, 17, 0);            goto decode_intra_mb;        }    } else {        mb_type= decode_cabac_intra_mb_type(h, 3, 1);        if(h->slice_type == FF_SI_TYPE && mb_type)            mb_type--;        assert(h->slice_type_nos == FF_I_TYPE);decode_intra_mb:        partition_count = 0;        cbp= i_mb_type_info[mb_type].cbp;        h->intra16x16_pred_mode= i_mb_type_info[mb_type].pred_mode;        mb_type= i_mb_type_info[mb_type].type;    }    if(MB_FIELD)        mb_type |= MB_TYPE_INTERLACED;    h->slice_table[ mb_xy ]= h->slice_num;    if(IS_INTRA_PCM(mb_type)) {        const uint8_t *ptr;        // We assume these blocks are very rare so we do not optimize it.        // FIXME The two following lines get the bitstream position in the cabac        // decode, I think it should be done by a function in cabac.h (or cabac.c).        ptr= h->cabac.bytestream;        if(h->cabac.low&0x1) ptr--;        if(CABAC_BITS==16){            if(h->cabac.low&0x1FF) ptr--;        }        // The pixels are stored in the same order as levels in h->mb array.        memcpy(h->mb, ptr, 256); ptr+=256;        if(CHROMA){            memcpy(h->mb+128, ptr, 128); ptr+=128;        }        ff_init_cabac_decoder(&h->cabac, ptr, h->cabac.bytestream_end - ptr);        // All blocks are present        h->cbp_table[mb_xy] = 0x1ef;        h->chroma_pred_mode_table[mb_xy] = 0;        // In deblocking, the quantizer is 0        s->current_picture.qscale_table[mb_xy]= 0;        // All coeffs are present        memset(h->non_zero_count[mb_xy], 16, 16);        s->current_picture.mb_type[mb_xy]= mb_type;        h->last_qscale_diff = 0;        return 0;    }    if(MB_MBAFF){        h->ref_count[0] <<= 1;        h->ref_count[1] <<= 1;    }    fill_caches(h, mb_type, 0);    if( IS_INTRA( mb_type ) ) {        int i, pred_mode;        if( IS_INTRA4x4( mb_type ) ) {            if( dct8x8_allowed && decode_cabac_mb_transform_size( h ) ) {                mb_type |= MB_TYPE_8x8DCT;                for( i = 0; i < 16; i+=4 ) {                    int pred = pred_intra_mode( h, i );                    int mode = decode_cabac_mb_intra4x4_pred_mode( h, pred );                    fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );                }            } else {                for( i = 0; i < 16; i++ ) {                    int pred = pred_intra_mode( h, i );                    h->intra4x4_pred_mode_cache[ scan8[i] ] = decode_cabac_mb_intra4x4_pred_mode( h, pred );                //av_log( s->avctx, AV_LOG_ERROR, \"i4x4 pred=%d mode=%d\\n\", pred, h->intra4x4_pred_mode_cache[ scan8[i] ] );                }            }            ff_h264_write_back_intra_pred_mode(h);            if( ff_h264_check_intra4x4_pred_mode(h) < 0 ) return -1;        } else {            h->intra16x16_pred_mode= ff_h264_check_intra_pred_mode( h, h->intra16x16_pred_mode );            if( h->intra16x16_pred_mode < 0 ) return -1;        }        if(CHROMA){            h->chroma_pred_mode_table[mb_xy] =            pred_mode                        = decode_cabac_mb_chroma_pre_mode( h );            pred_mode= ff_h264_check_intra_pred_mode( h, pred_mode );            if( pred_mode < 0 ) return -1;            h->chroma_pred_mode= pred_mode;        }    } else if( partition_count == 4 ) {        int i, j, sub_partition_count[4], list, ref[2][4];        if( h->slice_type_nos == FF_B_TYPE ) {            for( i = 0; i < 4; i++ ) {                h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;                h->sub_mb_type[i]=      b_sub_mb_type_info[ h->sub_mb_type[i] ].type;            }            if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |                          h->sub_mb_type[2] | h->sub_mb_type[3]) ) {                ff_h264_pred_direct_motion(h, &mb_type);                h->ref_cache[0][scan8[4]] =                h->ref_cache[1][scan8[4]] =                h->ref_cache[0][scan8[12]] =                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;                if( h->ref_count[0] > 1 || h->ref_count[1] > 1 ) {                    for( i = 0; i < 4; i++ )                        if( IS_DIRECT(h->sub_mb_type[i]) )                            fill_rectangle( &h->direct_cache[scan8[4*i]], 2, 2, 8, 1, 1 );                }            }        } else {            for( i = 0; i < 4; i++ ) {                h->sub_mb_type[i] = decode_cabac_p_mb_sub_type( h );                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;            }        }        for( list = 0; list < h->list_count; list++ ) {                for( i = 0; i < 4; i++ ) {                    if(IS_DIRECT(h->sub_mb_type[i])) continue;                    if(IS_DIR(h->sub_mb_type[i], 0, list)){                        if( h->ref_count[list] > 1 ){                            ref[list][i] = decode_cabac_mb_ref( h, list, 4*i );                            if(ref[list][i] >= (unsigned)h->ref_count[list]){                                av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], h->ref_count[list]);                                return -1;                            }                        }else                            ref[list][i] = 0;                    } else {                        ref[list][i] = -1;                    }                                                       h->ref_cache[list][ scan8[4*i]+1 ]=                    h->ref_cache[list][ scan8[4*i]+8 ]=h->ref_cache[list][ scan8[4*i]+9 ]= ref[list][i];                }        }        if(dct8x8_allowed)            dct8x8_allowed = get_dct8x8_allowed(h);        for(list=0; list<h->list_count; list++){            for(i=0; i<4; i++){                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ];                if(IS_DIRECT(h->sub_mb_type[i])){                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4);                    continue;                }                if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){                    const int sub_mb_type= h->sub_mb_type[i];                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;                    for(j=0; j<sub_partition_count[i]; j++){                        int mpx, mpy;                        int mx, my;                        const int index= 4*i + block_width*j;                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];                        int16_t (* mvd_cache)[2]= &h->mvd_cache[list][ scan8[index] ];                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mpx, &mpy);                        mx = mpx + decode_cabac_mb_mvd( h, list, index, 0 );                        my = mpy + decode_cabac_mb_mvd( h, list, index, 1 );                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);                        if(IS_SUB_8X8(sub_mb_type)){                            mv_cache[ 1 ][0]=                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;                            mv_cache[ 1 ][1]=                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;                            mvd_cache[ 1 ][0]=                            mvd_cache[ 8 ][0]= mvd_cache[ 9 ][0]= mx - mpx;                            mvd_cache[ 1 ][1]=                            mvd_cache[ 8 ][1]= mvd_cache[ 9 ][1]= my - mpy;                        }else if(IS_SUB_8X4(sub_mb_type)){                            mv_cache[ 1 ][0]= mx;                            mv_cache[ 1 ][1]= my;                            mvd_cache[ 1 ][0]= mx - mpx;                            mvd_cache[ 1 ][1]= my - mpy;                        }else if(IS_SUB_4X8(sub_mb_type)){                            mv_cache[ 8 ][0]= mx;                            mv_cache[ 8 ][1]= my;                            mvd_cache[ 8 ][0]= mx - mpx;                            mvd_cache[ 8 ][1]= my - mpy;                        }                        mv_cache[ 0 ][0]= mx;                        mv_cache[ 0 ][1]= my;                        mvd_cache[ 0 ][0]= mx - mpx;                        mvd_cache[ 0 ][1]= my - mpy;                    }                }else{                    uint32_t *p= (uint32_t *)&h->mv_cache[list][ scan8[4*i] ][0];                    uint32_t *pd= (uint32_t *)&h->mvd_cache[list][ scan8[4*i] ][0];                    p[0] = p[1] = p[8] = p[9] = 0;                    pd[0]= pd[1]= pd[8]= pd[9]= 0;                }            }        }    } else if( IS_DIRECT(mb_type) ) {        ff_h264_pred_direct_motion(h, &mb_type);        fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 4);        fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 4);        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;    } else {        int list, mx, my, i, mpx, mpy;        if(IS_16X16(mb_type)){            for(list=0; list<h->list_count; list++){                if(IS_DIR(mb_type, 0, list)){                    int ref;                    if(h->ref_count[list] > 1){                        ref= decode_cabac_mb_ref(h, list, 0);                        if(ref >= (unsigned)h->ref_count[list]){                            av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);                            return -1;                        }                    }else                        ref=0;                        fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);                }else                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, (uint8_t)LIST_NOT_USED, 1); //FIXME factorize and the other fill_rect below too            }            for(list=0; list<h->list_count; list++){                if(IS_DIR(mb_type, 0, list)){                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mpx, &mpy);                    mx = mpx + decode_cabac_mb_mvd( h, list, 0, 0 );                    my = mpy + decode_cabac_mb_mvd( h, list, 0, 1 );                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx-mpx,my-mpy), 4);                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);                }else                    fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, 0, 4);            }        }        else if(IS_16X8(mb_type)){            for(list=0; list<h->list_count; list++){                    for(i=0; i<2; i++){                        if(IS_DIR(mb_type, i, list)){                            int ref;                            if(h->ref_count[list] > 1){                                ref= decode_cabac_mb_ref( h, list, 8*i );                                if(ref >= (unsigned)h->ref_count[list]){                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);                                    return -1;                                }                            }else                                ref=0;                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);                        }else                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);                    }            }            for(list=0; list<h->list_count; list++){                for(i=0; i<2; i++){                    if(IS_DIR(mb_type, i, list)){                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mpx, &mpy);                        mx = mpx + decode_cabac_mb_mvd( h, list, 8*i, 0 );                        my = mpy + decode_cabac_mb_mvd( h, list, 8*i, 1 );                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx-mpx,my-mpy), 4);                        fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);                    }else{                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);                    }                }            }        }else{            assert(IS_8X16(mb_type));            for(list=0; list<h->list_count; list++){                    for(i=0; i<2; i++){                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize                            int ref;                            if(h->ref_count[list] > 1){                                ref= decode_cabac_mb_ref( h, list, 4*i );                                if(ref >= (unsigned)h->ref_count[list]){                                    av_log(s->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, h->ref_count[list]);                                    return -1;                                }                            }else                                ref=0;                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);                        }else                            fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);                    }            }            for(list=0; list<h->list_count; list++){                for(i=0; i<2; i++){                    if(IS_DIR(mb_type, i, list)){                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mpx, &mpy);                        mx = mpx + decode_cabac_mb_mvd( h, list, 4*i, 0 );                        my = mpy + decode_cabac_mb_mvd( h, list, 4*i, 1 );                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx-mpx,my-mpy), 4);                        fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);                    }else{                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);                        fill_rectangle(h-> mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);                    }                }            }        }    }   if( IS_INTER( mb_type ) ) {        h->chroma_pred_mode_table[mb_xy] = 0;        write_back_motion( h, mb_type );   }    if( !IS_INTRA16x16( mb_type ) ) {        cbp  = decode_cabac_mb_cbp_luma( h );        if(CHROMA)            cbp |= decode_cabac_mb_cbp_chroma( h ) << 4;    }    h->cbp_table[mb_xy] = h->cbp = cbp;    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {        if( decode_cabac_mb_transform_size( h ) )            mb_type |= MB_TYPE_8x8DCT;    }    s->current_picture.mb_type[mb_xy]= mb_type;    if( cbp || IS_INTRA16x16( mb_type ) ) {        const uint8_t *scan, *scan8x8, *dc_scan;        const uint32_t *qmul;        int dqp;        if(IS_INTERLACED(mb_type)){            scan8x8= s->qscale ? h->field_scan8x8 : h->field_scan8x8_q0;            scan= s->qscale ? h->field_scan : h->field_scan_q0;            dc_scan= luma_dc_field_scan;        }else{            scan8x8= s->qscale ? h->zigzag_scan8x8 : h->zigzag_scan8x8_q0;            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;            dc_scan= luma_dc_zigzag_scan;        }        h->last_qscale_diff = dqp = decode_cabac_mb_dqp( h );        if( dqp == INT_MIN ){            av_log(h->s.avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", s->mb_x, s->mb_y);            return -1;        }        s->qscale += dqp;        if(((unsigned)s->qscale) > 51){            if(s->qscale<0) s->qscale+= 52;            else            s->qscale-= 52;        }        h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);        h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);        if( IS_INTRA16x16( mb_type ) ) {            int i;            //av_log( s->avctx, AV_LOG_ERROR, \"INTRA16x16 DC\\n\" );            decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16);            if( cbp&15 ) {                qmul = h->dequant4_coeff[0][s->qscale];                for( i = 0; i < 16; i++ ) {                    //av_log( s->avctx, AV_LOG_ERROR, \"INTRA16x16 AC:%d\\n\", i );                    decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15);                }            } else {                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);            }        } else {            int i8x8, i4x4;            for( i8x8 = 0; i8x8 < 4; i8x8++ ) {                if( cbp & (1<<i8x8) ) {                    if( IS_8x8DCT(mb_type) ) {                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);                    } else {                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];                        for( i4x4 = 0; i4x4 < 4; i4x4++ ) {                            const int index = 4*i8x8 + i4x4;                            //av_log( s->avctx, AV_LOG_ERROR, \"Luma4x4: %d\\n\", index );//START_TIMER                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);//STOP_TIMER(\"decode_residual\")                        }                    }                } else {                    uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;                }            }        }        if( cbp&0x30 ){            int c;            for( c = 0; c < 2; c++ ) {                //av_log( s->avctx, AV_LOG_ERROR, \"INTRA C%d-DC\\n\",c );                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);            }        }        if( cbp&0x20 ) {            int c, i;            for( c = 0; c < 2; c++ ) {                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];                for( i = 0; i < 4; i++ ) {                    const int index = 16 + 4 * c + i;                    //av_log( s->avctx, AV_LOG_ERROR, \"INTRA C%d-AC %d\\n\",c, index - 16 );                    decode_cabac_residual(h, h->mb + 16*index, 4, index, scan + 1, qmul, 15);                }            }        } else {            uint8_t * const nnz= &h->non_zero_count_cache[0];            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;        }    } else {        uint8_t * const nnz= &h->non_zero_count_cache[0];        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;        h->last_qscale_diff = 0;    }    s->current_picture.qscale_table[mb_xy]= s->qscale;    write_back_non_zero_count(h);    if(MB_MBAFF){        h->ref_count[0] >>= 1;        h->ref_count[1] >>= 1;    }    return 0;}", "idx": 18372}
{"project": "FFmpeg", "commit_id": "7fb4b0368de18fc150e72a9190a4c87827d2d9d2", "target": 1, "function": "static int parse_read_interval(const char *interval_spec,                               ReadInterval *interval){    int ret = 0;    char *next, *p, *spec = av_strdup(interval_spec);    if (!spec)        return AVERROR(ENOMEM);    if (!*spec) {        av_log(NULL, AV_LOG_ERROR, \"Invalid empty interval specification\\n\");        ret = AVERROR(EINVAL);        goto end;    }    p = spec;    next = strchr(spec, '%');    if (next)        *next++ = 0;    /* parse first part */    if (*p) {        interval->has_start = 1;        if (*p == '+') {            interval->start_is_offset = 1;            p++;        } else {            interval->start_is_offset = 0;        }        ret = av_parse_time(&interval->start, p, 1);        if (ret < 0) {            av_log(NULL, AV_LOG_ERROR, \"Invalid interval start specification '%s'\\n\", p);            goto end;        }    } else {        interval->has_start = 0;    }    /* parse second part */    p = next;    if (p && *p) {        int64_t us;        interval->has_end = 1;        if (*p == '+') {            interval->end_is_offset = 1;            p++;        } else {            interval->end_is_offset = 0;        }        if (interval->end_is_offset && *p == '#') {            long long int lli;            char *tail;            interval->duration_frames = 1;            p++;            lli = strtoll(p, &tail, 10);            if (*tail || lli < 0) {                av_log(NULL, AV_LOG_ERROR,                       \"Invalid or negative value '%s' for duration number of frames\\n\", p);                goto end;            }            interval->end = lli;        } else {            ret = av_parse_time(&us, p, 1);            if (ret < 0) {                av_log(NULL, AV_LOG_ERROR, \"Invalid interval end/duration specification '%s'\\n\", p);                goto end;            }            interval->end = us;        }    } else {        interval->has_end = 0;    }end:    av_free(spec);    return ret;}", "idx": 18373}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "function": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0, i = 0;    FsMountList mounts;    struct FsMount *mount;    Error *local_err = NULL;    int fd;    slog(\"guest-fsfreeze called\");    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    QTAILQ_INIT(&mounts);    build_fs_mount_list(&mounts, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    /* cannot risk guest agent blocking itself on a write in this state */    ga_set_frozen(ga_state);    QTAILQ_FOREACH(mount, &mounts, next) {        fd = qemu_open(mount->dirname, O_RDONLY);        if (fd == -1) {            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);            goto error;        }        /* we try to cull filesytems we know won't work in advance, but other         * filesytems may not implement fsfreeze for less obvious reasons.         * these will report EOPNOTSUPP. we simply ignore these when tallying         * the number of frozen filesystems.         *         * any other error means a failure to freeze a filesystem we         * expect to be freezable, so return an error in those cases         * and return system to thawed state.         */        ret = ioctl(fd, FIFREEZE);        if (ret == -1) {            if (errno != EOPNOTSUPP) {                error_setg_errno(err, errno, \"failed to freeze %s\",                                 mount->dirname);                close(fd);                goto error;            }        } else {            i++;        }        close(fd);    }    free_fs_mount_list(&mounts);    return i;error:    free_fs_mount_list(&mounts);    qmp_guest_fsfreeze_thaw(NULL);    return 0;}", "idx": 18409}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "function": "static void external_snapshot_commit(BlkActionState *common){    ExternalSnapshotState *state =                             DO_UPCAST(ExternalSnapshotState, common, common);    bdrv_set_aio_context(state->new_bs, state->aio_context);    /* This removes our old bs and adds the new bs */    bdrv_append(state->new_bs, state->old_bs);    /* We don't need (or want) to use the transactional     * bdrv_reopen_multiple() across all the entries at once, because we     * don't want to abort all of them if one of them fails the reopen */    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,                NULL);}", "idx": 18437}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "function": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,                                              VirtQueue *vq){    VirtIOSCSI *s = (VirtIOSCSI *)vdev;    assert(s->ctx && s->dataplane_started);    return virtio_scsi_handle_cmd_vq(s, vq);}", "idx": 18447}
{"project": "qemu", "commit_id": "fbb7b4e0804d2168f24142eebf7552adde1968dc", "target": 1, "function": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,                                   size_t size){    int64_t len;    if (!bdrv_is_inserted(bs))        return -ENOMEDIUM;    if (bs->growable)        return 0;    len = bdrv_getlength(bs);    if ((offset + size) > len)        return -EIO;    return 0;}", "idx": 18510}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "function": "static void gen_neon_dup_high16(TCGv var){    TCGv tmp = new_tmp();    tcg_gen_andi_i32(var, var, 0xffff0000);    tcg_gen_shri_i32(tmp, var, 16);    tcg_gen_or_i32(var, var, tmp);    dead_tmp(tmp);}", "idx": 18515}
{"project": "FFmpeg", "commit_id": "20da77449d4427a7152b80e4f9acce6a8c93ee7d", "target": 0, "function": "static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,             int srcSliceH, uint8_t* dst[], int dstStride[]){    int y, h_size;    if(c->srcFormat == PIX_FMT_YUV422P){\tsrcStride[1] *= 2;\tsrcStride[2] *= 2;    }    h_size= (c->dstW+7)&~7;    if(h_size*3 > dstStride[0]) h_size-=8;        __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );    for (y= 0; y<srcSliceH; y++ ) {\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\tuint8_t *_py = src[0] + y*srcStride[0];\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\tlong index= -h_size/2;\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\t       pixels in each iteration */\t    __asm__ __volatile__ (\t/* load data for start of next scan line */\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 *///\t\t    \".balign 16\t\t\t\\n\\t\"\t\t    \"1:\t\t\t\t\\n\\t\"YUV2RGB\t/* mm0=B, %%mm2=G, %%mm1=R */#ifdef HAVE_MMX2\t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\"\t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\"\t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2  B1 B0 B1 B0 */\t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2  G1 G0 G1 G0 */\t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0  R1 R0 R1 R0 */\t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /*    B2        B1       B0 */\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G2        G1       G0 */\t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /*       R1        R0       */\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2        G1       G0    */\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\"\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\"\t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5  G4 G3 G2 G1 */\t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4  B3 B2 B3 B2 */\t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3  G4 G3 G4 G3 */\t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4  R3 R2 R3 R2 */\t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5       B4        B3    */\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /*       G4        G3       */\t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /*    R4        R3       R2 */\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5    G4 B4     G3 B3    */\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6  B7 B6 B6 B7 */\t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7  G6 G5 G6 G5 */\t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6  R5 R4 R5 R4 */\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /*       B7        B6       */\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G7        G6       G5 */\t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7       R6        R5    */\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\\\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\"\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\"\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"#else\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */\t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */\t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */\t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */\t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */\t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */\t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */\t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */\t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */\t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */\t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */\t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */\t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */\t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */\t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */\t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */\t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */\t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */\t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */\t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */\t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */\t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */\t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\"\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"#endif\t\t     \t\t     \"add $24, %1\t\t\t\\n\\t\"\t\t     \"add $4, %0\t\t\t\\n\\t\"\t\t     \" js 1b\t\t\t\t\\n\\t\"\t\t     \t\t     : \"+r\" (index), \"+r\" (_image)\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\t\t     );    }    __asm__ __volatile__ (EMMS);    return srcSliceH;}", "idx": 18523}
{"project": "FFmpeg", "commit_id": "47b777ceed470104fb4e6325d5ac1bddbb4752c8", "target": 1, "function": "int ff_wma_init(AVCodecContext * avctx, int flags2){    WMACodecContext *s = avctx->priv_data;    int i;    float *window;    float bps1, high_freq;    volatile float bps;    int sample_rate1;    int coef_vlc_table;    s->sample_rate = avctx->sample_rate;    s->nb_channels = avctx->channels;    s->bit_rate = avctx->bit_rate;    s->block_align = avctx->block_align;    dsputil_init(&s->dsp, avctx);    if (avctx->codec->id == CODEC_ID_WMAV1) {        s->version = 1;    } else {        s->version = 2;    }    /* compute MDCT block size */    if (s->sample_rate <= 16000) {        s->frame_len_bits = 9;    } else if (s->sample_rate <= 22050 ||               (s->sample_rate <= 32000 && s->version == 1)) {        s->frame_len_bits = 10;    } else {        s->frame_len_bits = 11;    }    s->frame_len = 1 << s->frame_len_bits;    if (s->use_variable_block_len) {        int nb_max, nb;        nb = ((flags2 >> 3) & 3) + 1;        if ((s->bit_rate / s->nb_channels) >= 32000)            nb += 2;        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;        if (nb > nb_max)            nb = nb_max;        s->nb_block_sizes = nb + 1;    } else {        s->nb_block_sizes = 1;    }    /* init rate dependent parameters */    s->use_noise_coding = 1;    high_freq = s->sample_rate * 0.5;    /* if version 2, then the rates are normalized */    sample_rate1 = s->sample_rate;    if (s->version == 2) {        if (sample_rate1 >= 44100)            sample_rate1 = 44100;        else if (sample_rate1 >= 22050)            sample_rate1 = 22050;        else if (sample_rate1 >= 16000)            sample_rate1 = 16000;        else if (sample_rate1 >= 11025)            sample_rate1 = 11025;        else if (sample_rate1 >= 8000)            sample_rate1 = 8000;    }    bps = (float)s->bit_rate / (float)(s->nb_channels * s->sample_rate);    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;    /* compute high frequency value and choose if noise coding should       be activated */    bps1 = bps;    if (s->nb_channels == 2)        bps1 = bps * 1.6;    if (sample_rate1 == 44100) {        if (bps1 >= 0.61)            s->use_noise_coding = 0;        else            high_freq = high_freq * 0.4;    } else if (sample_rate1 == 22050) {        if (bps1 >= 1.16)            s->use_noise_coding = 0;        else if (bps1 >= 0.72)            high_freq = high_freq * 0.7;        else            high_freq = high_freq * 0.6;    } else if (sample_rate1 == 16000) {        if (bps > 0.5)            high_freq = high_freq * 0.5;        else            high_freq = high_freq * 0.3;    } else if (sample_rate1 == 11025) {        high_freq = high_freq * 0.7;    } else if (sample_rate1 == 8000) {        if (bps <= 0.625) {            high_freq = high_freq * 0.5;        } else if (bps > 0.75) {            s->use_noise_coding = 0;        } else {            high_freq = high_freq * 0.65;        }    } else {        if (bps >= 0.8) {            high_freq = high_freq * 0.75;        } else if (bps >= 0.6) {            high_freq = high_freq * 0.6;        } else {            high_freq = high_freq * 0.5;        }    }    dprintf(s->avctx, \"flags2=0x%x\\n\", flags2);    dprintf(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",           s->version, s->nb_channels, s->sample_rate, s->bit_rate,           s->block_align);    dprintf(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",           bps, bps1, high_freq, s->byte_offset_bits);    dprintf(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",           s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);    /* compute the scale factor band sizes for each MDCT block size */    {        int a, b, pos, lpos, k, block_len, i, j, n;        const uint8_t *table;        if (s->version == 1) {            s->coefs_start = 3;        } else {            s->coefs_start = 0;        }        for(k = 0; k < s->nb_block_sizes; k++) {            block_len = s->frame_len >> k;            if (s->version == 1) {                lpos = 0;                for(i=0;i<25;i++) {                    a = wma_critical_freqs[i];                    b = s->sample_rate;                    pos = ((block_len * 2 * a)  + (b >> 1)) / b;                    if (pos > block_len)                        pos = block_len;                    s->exponent_bands[0][i] = pos - lpos;                    if (pos >= block_len) {                        i++;                        break;                    }                    lpos = pos;                }                s->exponent_sizes[0] = i;            } else {                /* hardcoded tables */                table = NULL;                a = s->frame_len_bits - BLOCK_MIN_BITS - k;                if (a < 3) {                    if (s->sample_rate >= 44100)                        table = exponent_band_44100[a];                    else if (s->sample_rate >= 32000)                        table = exponent_band_32000[a];                    else if (s->sample_rate >= 22050)                        table = exponent_band_22050[a];                }                if (table) {                    n = *table++;                    for(i=0;i<n;i++)                        s->exponent_bands[k][i] = table[i];                    s->exponent_sizes[k] = n;                } else {                    j = 0;                    lpos = 0;                    for(i=0;i<25;i++) {                        a = wma_critical_freqs[i];                        b = s->sample_rate;                        pos = ((block_len * 2 * a)  + (b << 1)) / (4 * b);                        pos <<= 2;                        if (pos > block_len)                            pos = block_len;                        if (pos > lpos)                            s->exponent_bands[k][j++] = pos - lpos;                        if (pos >= block_len)                            break;                        lpos = pos;                    }                    s->exponent_sizes[k] = j;                }            }            /* max number of coefs */            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;            /* high freq computation */            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /                                          s->sample_rate + 0.5);            n = s->exponent_sizes[k];            j = 0;            pos = 0;            for(i=0;i<n;i++) {                int start, end;                start = pos;                pos += s->exponent_bands[k][i];                end = pos;                if (start < s->high_band_start[k])                    start = s->high_band_start[k];                if (end > s->coefs_end[k])                    end = s->coefs_end[k];                if (end > start)                    s->exponent_high_bands[k][j++] = end - start;            }            s->exponent_high_sizes[k] = j;#if 0            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",                  s->frame_len >> k,                  s->coefs_end[k],                  s->high_band_start[k],                  s->exponent_high_sizes[k]);            for(j=0;j<s->exponent_high_sizes[k];j++)                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);            tprintf(s->avctx, \"\\n\");#endif        }    }#ifdef TRACE    {        int i, j;        for(i = 0; i < s->nb_block_sizes; i++) {            tprintf(s->avctx, \"%5d: n=%2d:\",                   s->frame_len >> i,                   s->exponent_sizes[i]);            for(j=0;j<s->exponent_sizes[i];j++)                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);            tprintf(s->avctx, \"\\n\");        }    }#endif    /* init MDCT windows : simple sinus window */    for(i = 0; i < s->nb_block_sizes; i++) {        int n, j;        float alpha;        n = 1 << (s->frame_len_bits - i);        window = av_malloc(sizeof(float) * n);        alpha = M_PI / (2.0 * n);        for(j=0;j<n;j++) {            window[j] = sin((j + 0.5) * alpha);        }        s->windows[i] = window;    }    s->reset_block_lengths = 1;    if (s->use_noise_coding) {        /* init the noise generator */        if (s->use_exp_vlc)            s->noise_mult = 0.02;        else            s->noise_mult = 0.04;#ifdef TRACE        for(i=0;i<NOISE_TAB_SIZE;i++)            s->noise_table[i] = 1.0 * s->noise_mult;#else        {            unsigned int seed;            float norm;            seed = 1;            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;            for(i=0;i<NOISE_TAB_SIZE;i++) {                seed = seed * 314159 + 1;                s->noise_table[i] = (float)((int)seed) * norm;            }        }#endif    }    /* choose the VLC tables for the coefficients */    coef_vlc_table = 2;    if (s->sample_rate >= 32000) {        if (bps1 < 0.72)            coef_vlc_table = 0;        else if (bps1 < 1.16)            coef_vlc_table = 1;    }    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],                  s->coef_vlcs[0]);    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],                  s->coef_vlcs[1]);    return 0;}", "idx": 18525}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "function": "void do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn, Error **errp){    BlockDriverState *bs;    BlockDriverState *target_bs;    Error *local_err = NULL;    AioContext *aio_context;    if (!backup->has_speed) {        backup->speed = 0;    }    if (!backup->has_on_source_error) {        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;    }    if (!backup->has_on_target_error) {        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;    }    if (!backup->has_job_id) {        backup->job_id = NULL;    }    if (!backup->has_compress) {        backup->compress = false;    }    bs = qmp_get_root_bs(backup->device, errp);    if (!bs) {        return;    }    aio_context = bdrv_get_aio_context(bs);    aio_context_acquire(aio_context);    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);    if (!target_bs) {        goto out;    }    if (bdrv_get_aio_context(target_bs) != aio_context) {        if (!bdrv_has_blk(target_bs)) {            /* The target BDS is not attached, we can safely move it to another             * AioContext. */            bdrv_set_aio_context(target_bs, aio_context);        } else {            error_setg(errp, \"Target is attached to a different thread from \"                             \"source.\");            goto out;        }    }    backup_start(backup->job_id, bs, target_bs, backup->speed, backup->sync,                 NULL, backup->compress, backup->on_source_error,                 backup->on_target_error, BLOCK_JOB_DEFAULT,                 NULL, NULL, txn, &local_err);    if (local_err != NULL) {        error_propagate(errp, local_err);    }out:    aio_context_release(aio_context);}", "idx": 18526}
{"project": "qemu", "commit_id": "0f853a386739b22e541e6e65ed60a0cb37713340", "target": 1, "function": "void do_device_add(Monitor *mon, const QDict *qdict){    QemuOpts *opts;    opts = qemu_opts_parse(&qemu_device_opts,                           qdict_get_str(qdict, \"config\"), \"driver\");    if (opts && !qdev_device_help(opts))        qdev_device_add(opts);}", "idx": 18554}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "function": "void ram_control_load_hook(QEMUFile *f, uint64_t flags){    int ret = -EINVAL;    if (f->ops->hook_ram_load) {        ret = f->ops->hook_ram_load(f, f->opaque, flags);        if (ret < 0) {            qemu_file_set_error(f, ret);        }    } else {        qemu_file_set_error(f, ret);    }}", "idx": 18557}
{"project": "FFmpeg", "commit_id": "feeb8ca56dc08bda19174502a687ae262ea3ee21", "target": 0, "function": "int ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,                         AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    VP56Context *s = avctx->priv_data;    AVFrame *const p = s->frames[VP56_FRAME_CURRENT];    int remaining_buf_size = avpkt->size;    int av_uninit(alpha_offset);    int i, res;    if (s->has_alpha) {        if (remaining_buf_size < 3)            return -1;        alpha_offset = bytestream_get_be24(&buf);        remaining_buf_size -= 3;        if (remaining_buf_size < alpha_offset)            return -1;    }    res = s->parse_header(s, buf, remaining_buf_size);    if (res < 0)        return res;    if (res == VP56_SIZE_CHANGE) {        for (i = 0; i < 4; i++) {            av_frame_unref(s->frames[i]);            if (s->alpha_context)                av_frame_unref(s->alpha_context->frames[i]);        }    }    if (ff_get_buffer(avctx, p, AV_GET_BUFFER_FLAG_REF) < 0)        return -1;    if (s->has_alpha) {        av_frame_unref(s->alpha_context->frames[VP56_FRAME_CURRENT]);        av_frame_ref(s->alpha_context->frames[VP56_FRAME_CURRENT], p);    }    if (res == VP56_SIZE_CHANGE) {        if (vp56_size_changed(s)) {            av_frame_unref(p);            return -1;        }    }    if (s->has_alpha) {        int bak_w = avctx->width;        int bak_h = avctx->height;        int bak_cw = avctx->coded_width;        int bak_ch = avctx->coded_height;        buf += alpha_offset;        remaining_buf_size -= alpha_offset;        res = s->alpha_context->parse_header(s->alpha_context, buf, remaining_buf_size);        if (res != 0) {            if(res==VP56_SIZE_CHANGE) {                av_log(avctx, AV_LOG_ERROR, \"Alpha reconfiguration\\n\");                avctx->width  = bak_w;                avctx->height = bak_h;                avctx->coded_width  = bak_cw;                avctx->coded_height = bak_ch;            }            av_frame_unref(p);            return -1;        }    }    avctx->execute2(avctx, ff_vp56_decode_mbs, 0, 0, s->has_alpha + 1);    if ((res = av_frame_ref(data, p)) < 0)        return res;    *got_frame = 1;    return avpkt->size;}", "idx": 18585}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "function": "static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,                                unsigned int size){    S390PCIBusDevice *pbdev;    uint32_t io_int_word;    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;    uint32_t vec = data & ZPCI_MSI_VEC_MASK;    uint64_t ind_bit;    uint32_t sum_bit;    uint32_t e = 0;    DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid %d vec 0x%x\\n\", data, fid, vec);    pbdev = s390_pci_find_dev_by_fid(fid);    if (!pbdev) {        e |= (vec << ERR_EVENT_MVN_OFFSET);        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);        return;    }    if (!(pbdev->fh & FH_MASK_ENABLE)) {        return;    }    ind_bit = pbdev->routes.adapter.ind_offset;    sum_bit = pbdev->routes.adapter.summary_offset;    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) / 8,                   0x80 >> ((ind_bit + vec) % 8));    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit / 8,                                       0x80 >> (sum_bit % 8))) {        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;        s390_io_interrupt(0, 0, 0, io_int_word);    }}", "idx": 18605}
{"project": "qemu", "commit_id": "9807caccd605d09a72495637959568d690e10175", "target": 0, "function": "static uint64_t virtio_pci_config_read(void *opaque, hwaddr addr,                                       unsigned size){    VirtIOPCIProxy *proxy = opaque;    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);    uint64_t val = 0;    if (addr < config) {        return virtio_ioport_read(proxy, addr);    }    addr -= config;    switch (size) {    case 1:        val = virtio_config_readb(proxy->vdev, addr);        break;    case 2:        val = virtio_config_readw(proxy->vdev, addr);        if (virtio_is_big_endian()) {            val = bswap16(val);        }        break;    case 4:        val = virtio_config_readl(proxy->vdev, addr);        if (virtio_is_big_endian()) {            val = bswap32(val);        }        break;    }    return val;}", "idx": 18656}
{"project": "qemu", "commit_id": "b8e999673bd479eed7e71a5e8bc468bca4e31d7d", "target": 0, "function": "void spapr_cpu_parse_features(sPAPRMachineState *spapr){    /*     * Backwards compatibility hack:     *     *   CPUs had a \"compat=\" property which didn't make sense for     *   anything except pseries.  It was replaced by \"max-cpu-compat\"     *   machine option.  This supports old command lines like     *       -cpu POWER8,compat=power7     *   By stripping the compat option and applying it to the machine     *   before passing it on to the cpu level parser.     */    gchar **inpieces;    gchar *newprops;    int i, j;    gchar *compat_str = NULL;    inpieces = g_strsplit(MACHINE(spapr)->cpu_model, \",\", 0);    /* inpieces[0] is the actual model string */    i = 1;    j = 1;    while (inpieces[i]) {        if (g_str_has_prefix(inpieces[i], \"compat=\")) {            /* in case of multiple compat= options */            g_free(compat_str);            compat_str = inpieces[i];        } else {            j++;        }        i++;        /* Excise compat options from list */        inpieces[j] = inpieces[i];    }    if (compat_str) {        char *val = compat_str + strlen(\"compat=\");        object_property_set_str(OBJECT(spapr), val, \"max-cpu-compat\",                                &error_fatal);    }    newprops = g_strjoinv(\",\", inpieces);    cpu_parse_cpu_model(TYPE_POWERPC_CPU, newprops);    g_free(newprops);    g_strfreev(inpieces);}", "idx": 18657}
{"project": "qemu", "commit_id": "19a2223feaabc6c574af57c8c5f1c21a60e8d194", "target": 0, "function": "void apic_sipi(CPUState *env){    APICState *s = env->apic_state;    cpu_reset_interrupt(env, CPU_INTERRUPT_SIPI);    if (!s->wait_for_sipi)        return;    env->eip = 0;    cpu_x86_load_seg_cache(env, R_CS, s->sipi_vector << 8, s->sipi_vector << 12,                           0xffff, 0);    env->halted = 0;    s->wait_for_sipi = 0;}", "idx": 18666}
{"project": "FFmpeg", "commit_id": "391a1327bd076c25c2b2509ab7ae0081c443b94e", "target": 0, "function": "static void filter_line_c(uint8_t *dst,                          uint8_t *prev, uint8_t *cur, uint8_t *next,                          int w, int refs, int parity, int mode){    int x;    uint8_t *prev2 = parity ? prev : cur ;    uint8_t *next2 = parity ? cur  : next;    for (x = 0;  x < w; x++) {        int c = cur[-refs];        int d = (prev2[0] + next2[0])>>1;        int e = cur[+refs];        int temporal_diff0 = FFABS(prev2[0] - next2[0]);        int temporal_diff1 =(FFABS(prev[-refs] - c) + FFABS(prev[+refs] - e) )>>1;        int temporal_diff2 =(FFABS(next[-refs] - c) + FFABS(next[+refs] - e) )>>1;        int diff = FFMAX3(temporal_diff0>>1, temporal_diff1, temporal_diff2);        int spatial_pred = (c+e)>>1;        int spatial_score = FFABS(cur[-refs-1] - cur[+refs-1]) + FFABS(c-e)                          + FFABS(cur[-refs+1] - cur[+refs+1]) - 1;#define CHECK(j)\\    {   int score = FFABS(cur[-refs-1+j] - cur[+refs-1-j])\\                  + FFABS(cur[-refs  +j] - cur[+refs  -j])\\                  + FFABS(cur[-refs+1+j] - cur[+refs+1-j]);\\        if (score < spatial_score) {\\            spatial_score= score;\\            spatial_pred= (cur[-refs  +j] + cur[+refs  -j])>>1;\\        CHECK(-1) CHECK(-2) }} }}", "idx": 18750}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "function": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer){    AVFilterContext  *ctx = inlink->dst;    ATempoContext *atempo = ctx->priv;    AVFilterLink *outlink = ctx->outputs[0];    int ret = 0;    int n_in = src_buffer->nb_samples;    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);    const uint8_t *src = src_buffer->data[0];    const uint8_t *src_end = src + n_in * atempo->stride;    while (src < src_end) {        if (!atempo->dst_buffer) {            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);            if (!atempo->dst_buffer)                return AVERROR(ENOMEM);            av_frame_copy_props(atempo->dst_buffer, src_buffer);            atempo->dst = atempo->dst_buffer->data[0];            atempo->dst_end = atempo->dst + n_out * atempo->stride;        }        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);        if (atempo->dst == atempo->dst_end) {            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /                             atempo->stride);            ret = push_samples(atempo, outlink, n_samples);            if (ret < 0)                goto end;        }    }    atempo->nsamples_in += n_in;end:    av_frame_free(&src_buffer);    return ret;}", "idx": 18812}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "function": "static void FUNCC(pred4x4_dc)(uint8_t *_src, const uint8_t *topright, int _stride){    pixel *src = (pixel*)_src;    int stride = _stride/sizeof(pixel);    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) >>3;    ((pixel4*)(src+0*stride))[0]=    ((pixel4*)(src+1*stride))[0]=    ((pixel4*)(src+2*stride))[0]=    ((pixel4*)(src+3*stride))[0]= PIXEL_SPLAT_X4(dc);}", "idx": 18828}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "function": "void cpu_outb(pio_addr_t addr, uint8_t val){    LOG_IOPORT(\"outb: %04\"FMT_pioaddr\" %02\"PRIx8\"\\n\", addr, val);    trace_cpu_out(addr, val);    ioport_write(0, addr, val);}", "idx": 18873}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "function": "static void net_rx_packet(void *opaque, const uint8_t *buf, size_t size){    struct XenNetDev *netdev = opaque;    netif_rx_request_t rxreq;    RING_IDX rc, rp;    void *page;    if (netdev->xendev.be_state != XenbusStateConnected)\treturn;    rc = netdev->rx_ring.req_cons;    rp = netdev->rx_ring.sring->req_prod;    xen_rmb(); /* Ensure we see queued requests up to 'rp'. */    if (rc == rp || RING_REQUEST_CONS_OVERFLOW(&netdev->rx_ring, rc)) {\txen_be_printf(&netdev->xendev, 2, \"no buffer, drop packet\\n\");\treturn;    }    if (size > XC_PAGE_SIZE - NET_IP_ALIGN) {\txen_be_printf(&netdev->xendev, 0, \"packet too big (%lu > %ld)\",\t\t      (unsigned long)size, XC_PAGE_SIZE - NET_IP_ALIGN);\treturn;    }    memcpy(&rxreq, RING_GET_REQUEST(&netdev->rx_ring, rc), sizeof(rxreq));    netdev->rx_ring.req_cons = ++rc;    page = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\t\t\t\t   netdev->xendev.dom,\t\t\t\t   rxreq.gref, PROT_WRITE);    if (page == NULL) {\txen_be_printf(&netdev->xendev, 0, \"error: rx gref dereference failed (%d)\\n\",                      rxreq.gref);\tnet_rx_response(netdev, &rxreq, NETIF_RSP_ERROR, 0, 0, 0);\treturn;    }    memcpy(page + NET_IP_ALIGN, buf, size);    xc_gnttab_munmap(netdev->xendev.gnttabdev, page, 1);    net_rx_response(netdev, &rxreq, NETIF_RSP_OKAY, NET_IP_ALIGN, size, 0);}", "idx": 18875}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "function": "static void coroutine_fn bdrv_aio_discard_co_entry(void *opaque){    BlockDriverAIOCBCoroutine *acb = opaque;    BlockDriverState *bs = acb->common.bs;    acb->req.error = bdrv_co_discard(bs, acb->req.sector, acb->req.nb_sectors);    acb->bh = qemu_bh_new(bdrv_co_em_bh, acb);    qemu_bh_schedule(acb->bh);}", "idx": 18889}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "function": "static void stop(DBDMA_channel *ch){    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~(ACTIVE|DEAD|FLUSH));    /* the stop command does not increment command pointer */}", "idx": 18899}
{"project": "FFmpeg", "commit_id": "709c87109dc856abff9c905dfda3ca954453828a", "target": 1, "function": "static int mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s){    AVStream       *video_st    = s->streams[0];    AVCodecParameters *video_par = s->streams[0]->codecpar;    AVCodecParameters *audio_par = s->streams[1]->codecpar;    int audio_rate = audio_par->sample_rate;    int64_t frame_rate = (video_st->avg_frame_rate.num * 0x10000LL) / video_st->avg_frame_rate.den;    int audio_kbitrate = audio_par->bit_rate / 1000;    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);    if (frame_rate < 0 || frame_rate > INT32_MAX) {        av_log(s, AV_LOG_ERROR, \"Frame rate %f outside supported range\\n\", frame_rate / (double)0x10000);        return AVERROR(EINVAL);    }    avio_wb32(pb, 0x94); /* size */    ffio_wfourcc(pb, \"uuid\");    ffio_wfourcc(pb, \"PROF\");    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */    avio_wb32(pb, 0xbb88695c);    avio_wb32(pb, 0xfac9c740);    avio_wb32(pb, 0x0);  /* ? */    avio_wb32(pb, 0x3);  /* 3 sections ? */    avio_wb32(pb, 0x14); /* size */    ffio_wfourcc(pb, \"FPRF\");    avio_wb32(pb, 0x0);  /* ? */    avio_wb32(pb, 0x0);  /* ? */    avio_wb32(pb, 0x0);  /* ? */    avio_wb32(pb, 0x2c);  /* size */    ffio_wfourcc(pb, \"APRF\"); /* audio */    avio_wb32(pb, 0x0);    avio_wb32(pb, 0x2);   /* TrackID */    ffio_wfourcc(pb, \"mp4a\");    avio_wb32(pb, 0x20f);    avio_wb32(pb, 0x0);    avio_wb32(pb, audio_kbitrate);    avio_wb32(pb, audio_kbitrate);    avio_wb32(pb, audio_rate);    avio_wb32(pb, audio_par->channels);    avio_wb32(pb, 0x34);  /* size */    ffio_wfourcc(pb, \"VPRF\");   /* video */    avio_wb32(pb, 0x0);    avio_wb32(pb, 0x1);    /* TrackID */    if (video_par->codec_id == AV_CODEC_ID_H264) {        ffio_wfourcc(pb, \"avc1\");        avio_wb16(pb, 0x014D);        avio_wb16(pb, 0x0015);    } else {        ffio_wfourcc(pb, \"mp4v\");        avio_wb16(pb, 0x0000);        avio_wb16(pb, 0x0103);    }    avio_wb32(pb, 0x0);    avio_wb32(pb, video_kbitrate);    avio_wb32(pb, video_kbitrate);    avio_wb32(pb, frame_rate);    avio_wb32(pb, frame_rate);    avio_wb16(pb, video_par->width);    avio_wb16(pb, video_par->height);    avio_wb32(pb, 0x010001); /* ? */    return 0;}", "idx": 18958}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "function": "static void g364fb_screen_dump(void *opaque, const char *filename, bool cswitch,                               Error **errp){    G364State *s = opaque;    int ret, y, x;    uint8_t index;    uint8_t *data_buffer;    FILE *f;    qemu_flush_coalesced_mmio_buffer();    if (s->depth != 8) {        error_setg(errp, \"g364: unknown guest depth %d\", s->depth);        return;    }    f = fopen(filename, \"wb\");    if (!f) {        error_setg(errp, \"failed to open file '%s': %s\", filename,                   strerror(errno));        return;    }    if (s->ctla & CTLA_FORCE_BLANK) {        /* blank screen */        ret = fprintf(f, \"P4\\n%d %d\\n\", s->width, s->height);        if (ret < 0) {            goto write_err;        }        for (y = 0; y < s->height; y++)            for (x = 0; x < s->width; x++) {                ret = fputc(0, f);                if (ret == EOF) {                    goto write_err;                }            }    } else {        data_buffer = s->vram + s->top_of_screen;        ret = fprintf(f, \"P6\\n%d %d\\n%d\\n\", s->width, s->height, 255);        if (ret < 0) {            goto write_err;        }        for (y = 0; y < s->height; y++)            for (x = 0; x < s->width; x++, data_buffer++) {                index = *data_buffer;                ret = fputc(s->color_palette[index][0], f);                if (ret == EOF) {                    goto write_err;                }                ret = fputc(s->color_palette[index][1], f);                if (ret == EOF) {                    goto write_err;                }                ret = fputc(s->color_palette[index][2], f);                if (ret == EOF) {                    goto write_err;                }        }    }out:    fclose(f);    return;write_err:    error_setg(errp, \"failed to write to file '%s': %s\", filename,               strerror(errno));    unlink(filename);    goto out;}", "idx": 18997}
{"project": "qemu", "commit_id": "723aedd53281cfa0997457cb156a59909a75f5a8", "target": 1, "function": "static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,                                               USBPacket *p, uint8_t ep){    /* Output interrupt endpoint, normal async operation */    struct usb_redir_interrupt_packet_header interrupt_packet;    uint8_t buf[p->iov.size];    DPRINTF(\"interrupt-out ep %02X len %zd id %\"PRIu64\"\\n\", ep,            p->iov.size, p->id);    if (usbredir_already_in_flight(dev, p->id)) {        p->status = USB_RET_ASYNC;        return;    }    interrupt_packet.endpoint  = ep;    interrupt_packet.length    = p->iov.size;    usb_packet_copy(p, buf, p->iov.size);    usbredir_log_data(dev, \"interrupt data out:\", buf, p->iov.size);    usbredirparser_send_interrupt_packet(dev->parser, p->id,                                    &interrupt_packet, buf, p->iov.size);    usbredirparser_do_write(dev->parser);    p->status = USB_RET_ASYNC;}", "idx": 19061}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "function": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn){    if (use_icount) {        gen_io_start();    }    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);    if (use_icount) {        gen_io_end();        gen_stop_exception(ctx);    }}", "idx": 19108}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "function": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg){    uint8_t *old_code_ptr = s->code_ptr;    assert(ret != arg);#if TCG_TARGET_REG_BITS == 32    tcg_out_op_t(s, INDEX_op_mov_i32);#else    tcg_out_op_t(s, INDEX_op_mov_i64);#endif    tcg_out_r(s, ret);    tcg_out_r(s, arg);    old_code_ptr[1] = s->code_ptr - old_code_ptr;}", "idx": 19129}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static inline void cris_alu_m_alloc_temps(TCGv *t){\tt[0] = tcg_temp_new(TCG_TYPE_TL);\tt[1] = tcg_temp_new(TCG_TYPE_TL);}", "idx": 19132}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "function": "int kvm_s390_cpu_restart(S390CPU *cpu){    kvm_s390_interrupt(cpu, KVM_S390_RESTART, 0);    s390_add_running_cpu(cpu);    qemu_cpu_kick(CPU(cpu));    DPRINTF(\"DONE: KVM cpu restart: %p\\n\", &cpu->env);    return 0;}", "idx": 19188}
{"project": "FFmpeg", "commit_id": "dbe29db8cb09fb39bd8dc5b25934e92279d0aa8d", "target": 1, "function": "static int decode_band_types(AACContext *ac, enum BandType band_type[120],                             int band_type_run_end[120], GetBitContext *gb,                             IndividualChannelStream *ics){    int g, idx = 0;    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;    for (g = 0; g < ics->num_window_groups; g++) {        int k = 0;        while (k < ics->max_sfb) {            uint8_t sect_end = k;            int sect_len_incr;            int sect_band_type = get_bits(gb, 4);            if (sect_band_type == 12) {                av_log(ac->avctx, AV_LOG_ERROR, \"invalid band type\\n\");                return -1;            }            do {                sect_len_incr = get_bits(gb, bits);                sect_end += sect_len_incr;                if (get_bits_left(gb) < 0) {                    av_log(ac->avctx, AV_LOG_ERROR, overread_err);                    return -1;                }                if (sect_end > ics->max_sfb) {                    av_log(ac->avctx, AV_LOG_ERROR,                           \"Number of bands (%d) exceeds limit (%d).\\n\",                           sect_end, ics->max_sfb);                    return -1;                }            } while (sect_len_incr == (1 << bits) - 1);            for (; k < sect_end; k++) {                band_type        [idx]   = sect_band_type;                band_type_run_end[idx++] = sect_end;            }        }    }    return 0;}", "idx": 19230}
{"project": "FFmpeg", "commit_id": "c23a0e77dd492d6c794f89dbff3a438c95745e70", "target": 1, "function": "int ff_h264_decode_slice_header(H264Context *h, H264Context *h0){    unsigned int first_mb_in_slice;    unsigned int pps_id;    int ret;    unsigned int slice_type, tmp, i, j;    int last_pic_structure, last_pic_droppable;    int must_reinit;    int needs_reinit = 0;    int field_pic_flag, bottom_field_flag;    int first_slice = h == h0 && !h0->current_slice;    int frame_num, picture_structure, droppable;    PPS *pps;    h->qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;    h->qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;    first_mb_in_slice = get_ue_golomb_long(&h->gb);    if (first_mb_in_slice == 0) { // FIXME better field boundary detection        if (h0->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {            ff_h264_field_end(h, 1);        }        h0->current_slice = 0;        if (!h0->first_field) {            if (h->cur_pic_ptr && !h->droppable) {                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,                                          h->picture_structure == PICT_BOTTOM_FIELD);            }            h->cur_pic_ptr = NULL;        }    }    slice_type = get_ue_golomb_31(&h->gb);    if (slice_type > 9) {        av_log(h->avctx, AV_LOG_ERROR,               \"slice type %d too large at %d %d\\n\",               slice_type, h->mb_x, h->mb_y);        return AVERROR_INVALIDDATA;    }    if (slice_type > 4) {        slice_type -= 5;        h->slice_type_fixed = 1;    } else        h->slice_type_fixed = 0;    slice_type = golomb_to_pict_type[slice_type];    h->slice_type     = slice_type;    h->slice_type_nos = slice_type & 3;    if (h->nal_unit_type  == NAL_IDR_SLICE &&        h->slice_type_nos != AV_PICTURE_TYPE_I) {        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");        return AVERROR_INVALIDDATA;    }    if (        (h->avctx->skip_frame >= AVDISCARD_NONREF && !h->nal_ref_idc) ||        (h->avctx->skip_frame >= AVDISCARD_BIDIR  && h->slice_type_nos == AV_PICTURE_TYPE_B) ||        (h->avctx->skip_frame >= AVDISCARD_NONINTRA && h->slice_type_nos != AV_PICTURE_TYPE_I) ||        (h->avctx->skip_frame >= AVDISCARD_NONKEY && h->nal_unit_type != NAL_IDR_SLICE) ||         h->avctx->skip_frame >= AVDISCARD_ALL) {         return SLICE_SKIPED;     }    // to make a few old functions happy, it's wrong though    h->pict_type = h->slice_type;    pps_id = get_ue_golomb(&h->gb);    if (pps_id >= MAX_PPS_COUNT) {        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);        return AVERROR_INVALIDDATA;    }    if (!h0->pps_buffers[pps_id]) {        av_log(h->avctx, AV_LOG_ERROR,               \"non-existing PPS %u referenced\\n\",               pps_id);        return AVERROR_INVALIDDATA;    }    if (h0->au_pps_id >= 0 && pps_id != h0->au_pps_id) {        av_log(h->avctx, AV_LOG_ERROR,               \"PPS change from %d to %d forbidden\\n\",               h0->au_pps_id, pps_id);        return AVERROR_INVALIDDATA;    }    pps = h0->pps_buffers[pps_id];    if (!h0->sps_buffers[pps->sps_id]) {        av_log(h->avctx, AV_LOG_ERROR,               \"non-existing SPS %u referenced\\n\",               h->pps.sps_id);        return AVERROR_INVALIDDATA;    }    if (first_slice)        h->pps = *h0->pps_buffers[pps_id];    if (pps->sps_id != h->sps.sps_id ||        pps->sps_id != h->current_sps_id ||        h0->sps_buffers[pps->sps_id]->new) {        if (!first_slice) {            av_log(h->avctx, AV_LOG_ERROR,               \"SPS changed in the middle of the frame\\n\");            return AVERROR_INVALIDDATA;        }        h->sps = *h0->sps_buffers[h->pps.sps_id];        if (h->mb_width  != h->sps.mb_width ||            h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||            h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||            h->cur_chroma_format_idc != h->sps.chroma_format_idc        )            needs_reinit = 1;        if (h->bit_depth_luma    != h->sps.bit_depth_luma ||            h->chroma_format_idc != h->sps.chroma_format_idc) {            h->bit_depth_luma    = h->sps.bit_depth_luma;            h->chroma_format_idc = h->sps.chroma_format_idc;            needs_reinit         = 1;        }        if ((ret = ff_h264_set_parameter_from_sps(h)) < 0)            return ret;    }    h->avctx->profile = ff_h264_get_profile(&h->sps);    h->avctx->level   = h->sps.level_idc;    h->avctx->refs    = h->sps.ref_frame_count;    must_reinit = (h->context_initialized &&                    (   16*h->sps.mb_width != h->avctx->coded_width                     || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height                     || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma                     || h->cur_chroma_format_idc != h->sps.chroma_format_idc                     || h->mb_width  != h->sps.mb_width                     || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)                    ));    if (non_j_pixfmt(h0->avctx->pix_fmt) != non_j_pixfmt(get_pixel_format(h0, 0)))        must_reinit = 1;    if (first_slice && av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio))        must_reinit = 1;    h->mb_width  = h->sps.mb_width;    h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);    h->mb_num    = h->mb_width * h->mb_height;    h->mb_stride = h->mb_width + 1;    h->b_stride = h->mb_width * 4;    h->chroma_y_shift = h->sps.chroma_format_idc <= 1; // 400 uses yuv420p    h->width  = 16 * h->mb_width;    h->height = 16 * h->mb_height;    ret = init_dimensions(h);    if (ret < 0)        return ret;    if (h->sps.video_signal_type_present_flag) {        h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG                                                    : AVCOL_RANGE_MPEG;        if (h->sps.colour_description_present_flag) {            if (h->avctx->colorspace != h->sps.colorspace)                needs_reinit = 1;            h->avctx->color_primaries = h->sps.color_primaries;            h->avctx->color_trc       = h->sps.color_trc;            h->avctx->colorspace      = h->sps.colorspace;        }    }    if (h->context_initialized &&        (must_reinit || needs_reinit)) {        if (h != h0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"changing width %d -> %d / height %d -> %d on \"                   \"slice %d\\n\",                   h->width, h->avctx->coded_width,                   h->height, h->avctx->coded_height,                   h0->current_slice + 1);            return AVERROR_INVALIDDATA;        }        av_assert1(first_slice);        ff_h264_flush_change(h);        if ((ret = get_pixel_format(h, 1)) < 0)            return ret;        h->avctx->pix_fmt = ret;        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"               \"pix_fmt: %s\\n\", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));        if ((ret = h264_slice_header_init(h, 1)) < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"h264_slice_header_init() failed\\n\");            return ret;        }    }    if (!h->context_initialized) {        if (h != h0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"Cannot (re-)initialize context during parallel decoding.\\n\");            return AVERROR_PATCHWELCOME;        }        if ((ret = get_pixel_format(h, 1)) < 0)            return ret;        h->avctx->pix_fmt = ret;        if ((ret = h264_slice_header_init(h, 0)) < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"h264_slice_header_init() failed\\n\");            return ret;        }    }    if (h == h0 && h->dequant_coeff_pps != pps_id) {        h->dequant_coeff_pps = pps_id;        h264_init_dequant_tables(h);    }    frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);    if (!first_slice) {        if (h0->frame_num != frame_num) {            av_log(h->avctx, AV_LOG_ERROR, \"Frame num change from %d to %d\\n\",                   h0->frame_num, frame_num);            return AVERROR_INVALIDDATA;        }    }    h->mb_mbaff        = 0;    h->mb_aff_frame    = 0;    last_pic_structure = h0->picture_structure;    last_pic_droppable = h0->droppable;    droppable          = h->nal_ref_idc == 0;    if (h->sps.frame_mbs_only_flag) {        picture_structure = PICT_FRAME;    } else {        if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {            av_log(h->avctx, AV_LOG_ERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");            return -1;        }        field_pic_flag = get_bits1(&h->gb);        if (field_pic_flag) {            bottom_field_flag = get_bits1(&h->gb);            picture_structure = PICT_TOP_FIELD + bottom_field_flag;        } else {            picture_structure = PICT_FRAME;            h->mb_aff_frame      = h->sps.mb_aff;        }    }    if (h0->current_slice) {        if (last_pic_structure != picture_structure ||            last_pic_droppable != droppable) {            av_log(h->avctx, AV_LOG_ERROR,                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",                   last_pic_structure, h->picture_structure);            return AVERROR_INVALIDDATA;        } else if (!h0->cur_pic_ptr) {            av_log(h->avctx, AV_LOG_ERROR,                   \"unset cur_pic_ptr on slice %d\\n\",                   h0->current_slice + 1);            return AVERROR_INVALIDDATA;        }    }    h->picture_structure = picture_structure;    h->droppable         = droppable;    h->frame_num         = frame_num;    h->mb_field_decoding_flag = picture_structure != PICT_FRAME;    if (h0->current_slice == 0) {        /* Shorten frame num gaps so we don't have to allocate reference         * frames just to throw them away */        if (h->frame_num != h->prev_frame_num) {            int unwrap_prev_frame_num = h->prev_frame_num;            int max_frame_num         = 1 << h->sps.log2_max_frame_num;            if (unwrap_prev_frame_num > h->frame_num)                unwrap_prev_frame_num -= max_frame_num;            if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {                unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;                if (unwrap_prev_frame_num < 0)                    unwrap_prev_frame_num += max_frame_num;                h->prev_frame_num = unwrap_prev_frame_num;            }        }        /* See if we have a decoded first field looking for a pair...         * Here, we're using that to see if we should mark previously         * decode frames as \"finished\".         * We have to do that before the \"dummy\" in-between frame allocation,         * since that can modify h->cur_pic_ptr. */        if (h0->first_field) {            assert(h0->cur_pic_ptr);            assert(h0->cur_pic_ptr->f.buf[0]);            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);            /* Mark old field/frame as completed */            if (h0->cur_pic_ptr->tf.owner == h0->avctx) {                ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,                                          last_pic_structure == PICT_BOTTOM_FIELD);            }            /* figure out if we have a complementary field pair */            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {                /* Previous field is unmatched. Don't display it, but let it                 * remain for reference if marked as such. */                if (last_pic_structure != PICT_FRAME) {                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,                                              last_pic_structure == PICT_TOP_FIELD);                }            } else {                if (h0->cur_pic_ptr->frame_num != h->frame_num) {                    /* This and previous field were reference, but had                     * different frame_nums. Consider this field first in                     * pair. Throw away previous field except for reference                     * purposes. */                    if (last_pic_structure != PICT_FRAME) {                        ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,                                                  last_pic_structure == PICT_TOP_FIELD);                    }                } else {                    /* Second field in complementary pair */                    if (!((last_pic_structure   == PICT_TOP_FIELD &&                           h->picture_structure == PICT_BOTTOM_FIELD) ||                          (last_pic_structure   == PICT_BOTTOM_FIELD &&                           h->picture_structure == PICT_TOP_FIELD))) {                        av_log(h->avctx, AV_LOG_ERROR,                               \"Invalid field mode combination %d/%d\\n\",                               last_pic_structure, h->picture_structure);                        h->picture_structure = last_pic_structure;                        h->droppable         = last_pic_droppable;                        return AVERROR_INVALIDDATA;                    } else if (last_pic_droppable != h->droppable) {                        avpriv_request_sample(h->avctx,                                              \"Found reference and non-reference fields in the same frame, which\");                        h->picture_structure = last_pic_structure;                        h->droppable         = last_pic_droppable;                        return AVERROR_PATCHWELCOME;                    }                }            }        }        while (h->frame_num != h->prev_frame_num && !h0->first_field &&               h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",                   h->frame_num, h->prev_frame_num);            if (!h->sps.gaps_in_frame_num_allowed_flag)                for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)                    h->last_pocs[i] = INT_MIN;            ret = h264_frame_start(h);            if (ret < 0) {                h0->first_field = 0;                return ret;            }            h->prev_frame_num++;            h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;            h->cur_pic_ptr->frame_num = h->prev_frame_num;            h->cur_pic_ptr->invalid_gap = !h->sps.gaps_in_frame_num_allowed_flag;            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);            ret = ff_generate_sliding_window_mmcos(h, 1);            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))                return ret;            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))                return ret;            /* Error concealment: If a ref is missing, copy the previous ref             * in its place.             * FIXME: Avoiding a memcpy would be nice, but ref handling makes             * many assumptions about there being no actual duplicates.             * FIXME: This does not copy padding for out-of-frame motion             * vectors.  Given we are concealing a lost frame, this probably             * is not noticeable by comparison, but it should be fixed. */            if (h->short_ref_count) {                if (prev) {                    av_image_copy(h->short_ref[0]->f.data,                                  h->short_ref[0]->f.linesize,                                  (const uint8_t **)prev->f.data,                                  prev->f.linesize,                                  h->avctx->pix_fmt,                                  h->mb_width  * 16,                                  h->mb_height * 16);                    h->short_ref[0]->poc = prev->poc + 2;                }                h->short_ref[0]->frame_num = h->prev_frame_num;            }        }        /* See if we have a decoded first field looking for a pair...         * We're using that to see whether to continue decoding in that         * frame, or to allocate a new one. */        if (h0->first_field) {            assert(h0->cur_pic_ptr);            assert(h0->cur_pic_ptr->f.buf[0]);            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);            /* figure out if we have a complementary field pair */            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {                /* Previous field is unmatched. Don't display it, but let it                 * remain for reference if marked as such. */                h0->missing_fields ++;                h0->cur_pic_ptr = NULL;                h0->first_field = FIELD_PICTURE(h);            } else {                h0->missing_fields = 0;                if (h0->cur_pic_ptr->frame_num != h->frame_num) {                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,                                              h0->picture_structure==PICT_BOTTOM_FIELD);                    /* This and the previous field had different frame_nums.                     * Consider this field first in pair. Throw away previous                     * one except for reference purposes. */                    h0->first_field = 1;                    h0->cur_pic_ptr = NULL;                } else {                    /* Second field in complementary pair */                    h0->first_field = 0;                }            }        } else {            /* Frame or first field in a potentially complementary pair */            h0->first_field = FIELD_PICTURE(h);        }        if (!FIELD_PICTURE(h) || h0->first_field) {            if (h264_frame_start(h) < 0) {                h0->first_field = 0;                return AVERROR_INVALIDDATA;            }        } else {            release_unused_pictures(h, 0);        }        /* Some macroblocks can be accessed before they're available in case        * of lost slices, MBAFF or threading. */        if (FIELD_PICTURE(h)) {            for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)                memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));        } else {            memset(h->slice_table, -1,                (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));        }        h0->last_slice_type = -1;    }    if (h != h0 && (ret = clone_slice(h, h0)) < 0)        return ret;    /* can't be in alloc_tables because linesize isn't known there.     * FIXME: redo bipred weight to not require extra buffer? */    for (i = 0; i < h->slice_context_count; i++)        if (h->thread_context[i]) {            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);            if (ret < 0)                return ret;        }    h->cur_pic_ptr->frame_num = h->frame_num; // FIXME frame_num cleanup    av_assert1(h->mb_num == h->mb_width * h->mb_height);    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||        first_mb_in_slice >= h->mb_num) {        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");        return AVERROR_INVALIDDATA;    }    h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;    h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<                               FIELD_OR_MBAFF_PICTURE(h);    if (h->picture_structure == PICT_BOTTOM_FIELD)        h->resync_mb_y = h->mb_y = h->mb_y + 1;    av_assert1(h->mb_y < h->mb_height);    if (h->picture_structure == PICT_FRAME) {        h->curr_pic_num = h->frame_num;        h->max_pic_num  = 1 << h->sps.log2_max_frame_num;    } else {        h->curr_pic_num = 2 * h->frame_num + 1;        h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);    }    if (h->nal_unit_type == NAL_IDR_SLICE)        get_ue_golomb(&h->gb); /* idr_pic_id */    if (h->sps.poc_type == 0) {        h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)            h->delta_poc_bottom = get_se_golomb(&h->gb);    }    if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {        h->delta_poc[0] = get_se_golomb(&h->gb);        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)            h->delta_poc[1] = get_se_golomb(&h->gb);    }    ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);    if (h->pps.redundant_pic_cnt_present)        h->redundant_pic_count = get_ue_golomb(&h->gb);    ret = ff_set_ref_count(h);    if (ret < 0)        return ret;    if (slice_type != AV_PICTURE_TYPE_I &&        (h0->current_slice == 0 ||         slice_type != h0->last_slice_type ||         memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {        ff_h264_fill_default_ref_list(h);    }    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {       ret = ff_h264_decode_ref_pic_list_reordering(h);       if (ret < 0) {           h->ref_count[1] = h->ref_count[0] = 0;           return ret;       }    }    if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||        (h->pps.weighted_bipred_idc == 1 &&         h->slice_type_nos == AV_PICTURE_TYPE_B))        ff_pred_weight_table(h);    else if (h->pps.weighted_bipred_idc == 2 &&             h->slice_type_nos == AV_PICTURE_TYPE_B) {        implicit_weight_table(h, -1);    } else {        h->use_weight = 0;        for (i = 0; i < 2; i++) {            h->luma_weight_flag[i]   = 0;            h->chroma_weight_flag[i] = 0;        }    }    // If frame-mt is enabled, only update mmco tables for the first slice    // in a field. Subsequent slices can temporarily clobber h->mmco_index    // or h->mmco, which will cause ref list mix-ups and decoding errors    // further down the line. This may break decoding if the first slice is    // corrupt, thus we only do this if frame-mt is enabled.    if (h->nal_ref_idc) {        ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||                                             h0->current_slice == 0);        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))            return AVERROR_INVALIDDATA;    }    if (FRAME_MBAFF(h)) {        ff_h264_fill_mbaff_ref_list(h);        if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {            implicit_weight_table(h, 0);            implicit_weight_table(h, 1);        }    }    if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)        ff_h264_direct_dist_scale_factor(h);    ff_h264_direct_ref_list_init(h);    if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {        tmp = get_ue_golomb_31(&h->gb);        if (tmp > 2) {            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);            return AVERROR_INVALIDDATA;        }        h->cabac_init_idc = tmp;    }    h->last_qscale_diff = 0;    tmp = h->pps.init_qp + get_se_golomb(&h->gb);    if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);        return AVERROR_INVALIDDATA;    }    h->qscale       = tmp;    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);    // FIXME qscale / qp ... stuff    if (h->slice_type == AV_PICTURE_TYPE_SP)        get_bits1(&h->gb); /* sp_for_switch_flag */    if (h->slice_type == AV_PICTURE_TYPE_SP ||        h->slice_type == AV_PICTURE_TYPE_SI)        get_se_golomb(&h->gb); /* slice_qs_delta */    h->deblocking_filter     = 1;    h->slice_alpha_c0_offset = 0;    h->slice_beta_offset     = 0;    if (h->pps.deblocking_filter_parameters_present) {        tmp = get_ue_golomb_31(&h->gb);        if (tmp > 2) {            av_log(h->avctx, AV_LOG_ERROR,                   \"deblocking_filter_idc %u out of range\\n\", tmp);            return AVERROR_INVALIDDATA;        }        h->deblocking_filter = tmp;        if (h->deblocking_filter < 2)            h->deblocking_filter ^= 1;  // 1<->0        if (h->deblocking_filter) {            h->slice_alpha_c0_offset = get_se_golomb(&h->gb) * 2;            h->slice_beta_offset     = get_se_golomb(&h->gb) * 2;            if (h->slice_alpha_c0_offset >  12 ||                h->slice_alpha_c0_offset < -12 ||                h->slice_beta_offset >  12     ||                h->slice_beta_offset < -12) {                av_log(h->avctx, AV_LOG_ERROR,                       \"deblocking filter parameters %d %d out of range\\n\",                       h->slice_alpha_c0_offset, h->slice_beta_offset);                return AVERROR_INVALIDDATA;            }        }    }    if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||        (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&         h->nal_unit_type != NAL_IDR_SLICE) ||        (h->avctx->skip_loop_filter >= AVDISCARD_NONINTRA &&         h->slice_type_nos != AV_PICTURE_TYPE_I) ||        (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&         h->slice_type_nos == AV_PICTURE_TYPE_B) ||        (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&         h->nal_ref_idc == 0))        h->deblocking_filter = 0;    if (h->deblocking_filter == 1 && h0->max_contexts > 1) {        if (h->avctx->flags2 & CODEC_FLAG2_FAST) {            /* Cheat slightly for speed:             * Do not bother to deblock across slices. */            h->deblocking_filter = 2;        } else {            h0->max_contexts = 1;            if (!h0->single_decode_warning) {                av_log(h->avctx, AV_LOG_INFO,                       \"Cannot parallelize slice decoding with deblocking filter type 1, decoding such frames in sequential order\\n\"                       \"To parallelize slice decoding you need video encoded with disable_deblocking_filter_idc set to 2 (deblock only edges that do not cross slices).\\n\"                       \"Setting the flags2 libavcodec option to +fast (-flags2 +fast) will disable deblocking across slices and enable parallel slice decoding \"                       \"but will generate non-standard-compliant output.\\n\");                h0->single_decode_warning = 1;            }            if (h != h0) {                av_log(h->avctx, AV_LOG_ERROR,                       \"Deblocking switched inside frame.\\n\");                return SLICE_SINGLETHREAD;            }        }    }    h->qp_thresh = 15 -                   FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -                   FFMAX3(0,                          h->pps.chroma_qp_index_offset[0],                          h->pps.chroma_qp_index_offset[1]) +                   6 * (h->sps.bit_depth_luma - 8);    h0->last_slice_type = slice_type;    memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));    h->slice_num        = ++h0->current_slice;    if (h->slice_num)        h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;    if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y        && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y        && h->slice_num >= MAX_SLICES) {        //in case of ASO this check needs to be updated depending on how we decide to assign slice numbers in this case        av_log(h->avctx, AV_LOG_WARNING, \"Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\\n\", h->slice_num, MAX_SLICES);    }    for (j = 0; j < 2; j++) {        int id_list[16];        int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];        for (i = 0; i < 16; i++) {            id_list[i] = 60;            if (j < h->list_count && i < h->ref_count[j] &&                h->ref_list[j][i].f.buf[0]) {                int k;                AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;                for (k = 0; k < h->short_ref_count; k++)                    if (h->short_ref[k]->f.buf[0]->buffer == buf) {                        id_list[i] = k;                        break;                    }                for (k = 0; k < h->long_ref_count; k++)                    if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {                        id_list[i] = h->short_ref_count + k;                        break;                    }            }        }        ref2frm[0] =        ref2frm[1] = -1;        for (i = 0; i < 16; i++)            ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);        ref2frm[18 + 0] =        ref2frm[18 + 1] = -1;        for (i = 16; i < 48; i++)            ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +                             (h->ref_list[j][i].reference & 3);    }    h0->au_pps_id = pps_id;    h->sps.new =    h0->sps_buffers[h->pps.sps_id]->new = 0;    h->current_sps_id = h->pps.sps_id;    if (h->avctx->debug & FF_DEBUG_PICT_INFO) {        av_log(h->avctx, AV_LOG_DEBUG,               \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",               h->slice_num,               (h->picture_structure == PICT_FRAME ? \"F\" : h->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),               first_mb_in_slice,               av_get_picture_type_char(h->slice_type),               h->slice_type_fixed ? \" fix\" : \"\",               h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",               pps_id, h->frame_num,               h->cur_pic_ptr->field_poc[0],               h->cur_pic_ptr->field_poc[1],               h->ref_count[0], h->ref_count[1],               h->qscale,               h->deblocking_filter,               h->slice_alpha_c0_offset, h->slice_beta_offset,               h->use_weight,               h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",               h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");    }    return 0;}", "idx": 19242}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "function": "static void generate_bootsect(target_phys_addr_t option_rom,                              uint32_t gpr[8], uint16_t segs[6], uint16_t ip){    uint8_t rom[512], *p, *reloc;    uint8_t sum;    int i;    memset(rom, 0, sizeof(rom));    p = rom;    /* Make sure we have an option rom signature */    *p++ = 0x55;    *p++ = 0xaa;    /* ROM size in sectors*/    *p++ = 1;    /* Hook int19 */    *p++ = 0x50;\t\t/* push ax */    *p++ = 0x1e;\t\t/* push ds */    *p++ = 0x31; *p++ = 0xc0;\t/* xor ax, ax */    *p++ = 0x8e; *p++ = 0xd8;\t/* mov ax, ds */    *p++ = 0xc7; *p++ = 0x06;   /* movvw _start,0x64 */    *p++ = 0x64; *p++ = 0x00;    reloc = p;    *p++ = 0x00; *p++ = 0x00;    *p++ = 0x8c; *p++ = 0x0e;   /* mov cs,0x66 */    *p++ = 0x66; *p++ = 0x00;    *p++ = 0x1f;\t\t/* pop ds */    *p++ = 0x58;\t\t/* pop ax */    *p++ = 0xcb;\t\t/* lret */    /* Actual code */    *reloc = (p - rom);    *p++ = 0xfa;\t\t/* CLI */    *p++ = 0xfc;\t\t/* CLD */    for (i = 0; i < 6; i++) {\tif (i == 1)\t\t/* Skip CS */\t    continue;\t*p++ = 0xb8;\t\t/* MOV AX,imm16 */\t*p++ = segs[i];\t*p++ = segs[i] >> 8;\t*p++ = 0x8e;\t\t/* MOV <seg>,AX */\t*p++ = 0xc0 + (i << 3);    }    for (i = 0; i < 8; i++) {\t*p++ = 0x66;\t\t/* 32-bit operand size */\t*p++ = 0xb8 + i;\t/* MOV <reg>,imm32 */\t*p++ = gpr[i];\t*p++ = gpr[i] >> 8;\t*p++ = gpr[i] >> 16;\t*p++ = gpr[i] >> 24;    }    *p++ = 0xea;\t\t/* JMP FAR */    *p++ = ip;\t\t\t/* IP */    *p++ = ip >> 8;    *p++ = segs[1];\t\t/* CS */    *p++ = segs[1] >> 8;    /* sign rom */    sum = 0;    for (i = 0; i < (sizeof(rom) - 1); i++)        sum += rom[i];    rom[sizeof(rom) - 1] = -sum;    cpu_physical_memory_write_rom(option_rom, rom, sizeof(rom));    option_rom_setup_reset(option_rom, sizeof (rom));}", "idx": 19257}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "function": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf){    CPU_DoubleU farg;    int isneg;    int ret;    farg.ll = arg;    isneg = float64_is_neg(farg.d);    if (unlikely(float64_is_nan(farg.d))) {        if (float64_is_signaling_nan(farg.d)) {            /* Signaling NaN: flags are undefined */            ret = 0x00;        } else {            /* Quiet NaN */            ret = 0x11;        }    } else if (unlikely(float64_is_infinity(farg.d))) {        /* +/- infinity */        if (isneg)            ret = 0x09;        else            ret = 0x05;    } else {        if (float64_is_zero(farg.d)) {            /* +/- zero */            if (isneg)                ret = 0x12;            else                ret = 0x02;        } else {            if (isden(farg.d)) {                /* Denormalized numbers */                ret = 0x10;            } else {                /* Normalized numbers */                ret = 0x00;            }            if (isneg) {                ret |= 0x08;            } else {                ret |= 0x04;            }        }    }    if (set_fprf) {        /* We update FPSCR_FPRF */        env->fpscr &= ~(0x1F << FPSCR_FPRF);        env->fpscr |= ret << FPSCR_FPRF;    }    /* We just need fpcc to update Rc1 */    return ret & 0xF;}", "idx": 19274}
{"project": "qemu", "commit_id": "731de38052b245eab79e417aeac5e1dcebe6437f", "target": 0, "function": "static int raw_create(const char *filename, QemuOpts *opts, Error **errp){    int fd;    int result = 0;    int64_t total_size = 0;    bool nocow = false;    PreallocMode prealloc;    char *buf = NULL;    Error *local_err = NULL;    strstart(filename, \"file:\", &filename);    /* Read out options */    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),                          BDRV_SECTOR_SIZE);    nocow = qemu_opt_get_bool(opts, BLOCK_OPT_NOCOW, false);    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,                               PREALLOC_MODE_MAX, PREALLOC_MODE_OFF,                               &local_err);    g_free(buf);    if (local_err) {        error_propagate(errp, local_err);        result = -EINVAL;        goto out;    }    fd = qemu_open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,                   0644);    if (fd < 0) {        result = -errno;        error_setg_errno(errp, -result, \"Could not create file\");        goto out;    }    if (nocow) {#ifdef __linux__        /* Set NOCOW flag to solve performance issue on fs like btrfs.         * This is an optimisation. The FS_IOC_SETFLAGS ioctl return value         * will be ignored since any failure of this operation should not         * block the left work.         */        int attr;        if (ioctl(fd, FS_IOC_GETFLAGS, &attr) == 0) {            attr |= FS_NOCOW_FL;            ioctl(fd, FS_IOC_SETFLAGS, &attr);        }#endif    }    if (ftruncate(fd, total_size) != 0) {        result = -errno;        error_setg_errno(errp, -result, \"Could not resize file\");        goto out_close;    }    switch (prealloc) {#ifdef CONFIG_POSIX_FALLOCATE    case PREALLOC_MODE_FALLOC:        /* posix_fallocate() doesn't set errno. */        result = -posix_fallocate(fd, 0, total_size);        if (result != 0) {            error_setg_errno(errp, -result,                             \"Could not preallocate data for the new file\");        }        break;#endif    case PREALLOC_MODE_FULL:    {        int64_t num = 0, left = total_size;        buf = g_malloc0(65536);        while (left > 0) {            num = MIN(left, 65536);            result = write(fd, buf, num);            if (result < 0) {                result = -errno;                error_setg_errno(errp, -result,                                 \"Could not write to the new file\");                break;            }            left -= result;        }        fsync(fd);        g_free(buf);        break;    }    case PREALLOC_MODE_OFF:        break;    default:        result = -EINVAL;        error_setg(errp, \"Unsupported preallocation mode: %s\",                   PreallocMode_lookup[prealloc]);        break;    }out_close:    if (qemu_close(fd) != 0 && result == 0) {        result = -errno;        error_setg_errno(errp, -result, \"Could not close the new file\");    }out:    return result;}", "idx": 19277}
{"project": "qemu", "commit_id": "e3ff9f0e57472e6411dc446b41789cbd9e2cf887", "target": 0, "function": "static void test_io(void){#ifndef _WIN32/* socketpair(PF_UNIX) which does not exist on windows */    int sv[2];    int r;    unsigned i, j, k, s, t;    fd_set fds;    unsigned niov;    struct iovec *iov, *siov;    unsigned char *buf;    size_t sz;    iov_random(&iov, &niov);    sz = iov_size(iov, niov);    buf = g_malloc(sz);    for (i = 0; i < sz; ++i) {        buf[i] = i & 255;    }    iov_from_buf(iov, niov, 0, buf, sz);    siov = g_memdup(iov, sizeof(*iov) * niov);    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) < 0) {       perror(\"socketpair\");       exit(1);    }    FD_ZERO(&fds);    t = 0;    if (fork() == 0) {       /* writer */       close(sv[0]);       FD_SET(sv[1], &fds);       fcntl(sv[1], F_SETFL, O_RDWR|O_NONBLOCK);       r = g_test_rand_int_range(sz / 2, sz);       setsockopt(sv[1], SOL_SOCKET, SO_SNDBUF, &r, sizeof(r));       for (i = 0; i <= sz; ++i) {           for (j = i; j <= sz; ++j) {               k = i;               do {                   s = g_test_rand_int_range(0, j - k + 1);                   r = iov_send(sv[1], iov, niov, k, s);                   g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);                   if (r >= 0) {                       k += r;                       t += r;                       usleep(g_test_rand_int_range(0, 30));                   } else if (errno == EAGAIN) {                       select(sv[1]+1, NULL, &fds, NULL, NULL);                       continue;                   } else {                       perror(\"send\");                       exit(1);                   }               } while(k < j);           }       }       iov_free(iov, niov);       g_free(buf);       g_free(siov);       exit(0);    } else {       /* reader & verifier */       close(sv[1]);       FD_SET(sv[0], &fds);       fcntl(sv[0], F_SETFL, O_RDWR|O_NONBLOCK);       r = g_test_rand_int_range(sz / 2, sz);       setsockopt(sv[0], SOL_SOCKET, SO_RCVBUF, &r, sizeof(r));       usleep(500000);       for (i = 0; i <= sz; ++i) {           for (j = i; j <= sz; ++j) {               k = i;               iov_memset(iov, niov, 0, 0xff, -1);               do {                   s = g_test_rand_int_range(0, j - k + 1);                   r = iov_recv(sv[0], iov, niov, k, s);                   g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);                   if (r > 0) {                       k += r;                       t += r;                   } else if (!r) {                       if (s) {                           break;                       }                   } else if (errno == EAGAIN) {                       select(sv[0]+1, &fds, NULL, NULL, NULL);                       continue;                   } else {                       perror(\"recv\");                       exit(1);                   }               } while(k < j);               test_iov_bytes(iov, niov, i, j - i);           }        }       iov_free(iov, niov);       g_free(buf);       g_free(siov);     }#endif}", "idx": 19376}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "function": "qemu_irq *armv7m_init(MemoryRegion *system_memory, int mem_size, int num_irq,                      const char *kernel_filename, const char *cpu_model){    ARMCPU *cpu;    CPUARMState *env;    DeviceState *nvic;    qemu_irq *pic = g_new(qemu_irq, num_irq);    int image_size;    uint64_t entry;    uint64_t lowaddr;    int i;    int big_endian;    MemoryRegion *hack = g_new(MemoryRegion, 1);    if (cpu_model == NULL) {\tcpu_model = \"cortex-m3\";    }    cpu = cpu_arm_init(cpu_model);    if (cpu == NULL) {        fprintf(stderr, \"Unable to find CPU definition\\n\");        exit(1);    }    env = &cpu->env;    armv7m_bitband_init();    nvic = qdev_create(NULL, \"armv7m_nvic\");    qdev_prop_set_uint32(nvic, \"num-irq\", num_irq);    env->nvic = nvic;    qdev_init_nofail(nvic);    sysbus_connect_irq(SYS_BUS_DEVICE(nvic), 0,                       qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));    for (i = 0; i < num_irq; i++) {        pic[i] = qdev_get_gpio_in(nvic, i);    }#ifdef TARGET_WORDS_BIGENDIAN    big_endian = 1;#else    big_endian = 0;#endif    if (!kernel_filename && !qtest_enabled()) {        fprintf(stderr, \"Guest image must be specified (using -kernel)\\n\");        exit(1);    }    if (kernel_filename) {        image_size = load_elf(kernel_filename, NULL, NULL, &entry, &lowaddr,                              NULL, big_endian, ELF_MACHINE, 1);        if (image_size < 0) {            image_size = load_image_targphys(kernel_filename, 0, mem_size);            lowaddr = 0;        }        if (image_size < 0) {            error_report(\"Could not load kernel '%s'\", kernel_filename);            exit(1);        }    }    /* Hack to map an additional page of ram at the top of the address       space.  This stops qemu complaining about executing code outside RAM       when returning from an exception.  */    memory_region_init_ram(hack, NULL, \"armv7m.hack\", 0x1000, &error_abort);    vmstate_register_ram_global(hack);    memory_region_add_subregion(system_memory, 0xfffff000, hack);    qemu_register_reset(armv7m_reset, cpu);    return pic;}", "idx": 19394}
{"project": "FFmpeg", "commit_id": "235e76aeb877bd1b23c12e74588e86752e3dfbe7", "target": 1, "function": "av_cold void INIT_FUNC(VP9DSPContext *dsp, int bitexact){#if HAVE_YASM    int cpu_flags = av_get_cpu_flags();#define init_lpf_8_func(idx1, idx2, dir, wd, bpp, opt) \\    dsp->loop_filter_8[idx1][idx2] = ff_vp9_loop_filter_##dir##_##wd##_##bpp##_##opt#define init_lpf_16_func(idx, dir, bpp, opt) \\    dsp->loop_filter_16[idx] = loop_filter_##dir##_16_##bpp##_##opt#define init_lpf_mix2_func(idx1, idx2, idx3, dir, wd1, wd2, bpp, opt) \\    dsp->loop_filter_mix2[idx1][idx2][idx3] = loop_filter_##dir##_##wd1##wd2##_##bpp##_##opt#define init_lpf_funcs(bpp, opt) \\    init_lpf_8_func(0, 0, h,  4, bpp, opt); \\    init_lpf_8_func(0, 1, v,  4, bpp, opt); \\    init_lpf_8_func(1, 0, h,  8, bpp, opt); \\    init_lpf_8_func(1, 1, v,  8, bpp, opt); \\    init_lpf_8_func(2, 0, h, 16, bpp, opt); \\    init_lpf_8_func(2, 1, v, 16, bpp, opt); \\    init_lpf_16_func(0, h, bpp, opt); \\    init_lpf_16_func(1, v, bpp, opt); \\    init_lpf_mix2_func(0, 0, 0, h, 4, 4, bpp, opt); \\    init_lpf_mix2_func(0, 1, 0, h, 4, 8, bpp, opt); \\    init_lpf_mix2_func(1, 0, 0, h, 8, 4, bpp, opt); \\    init_lpf_mix2_func(1, 1, 0, h, 8, 8, bpp, opt); \\    init_lpf_mix2_func(0, 0, 1, v, 4, 4, bpp, opt); \\    init_lpf_mix2_func(0, 1, 1, v, 4, 8, bpp, opt); \\    init_lpf_mix2_func(1, 0, 1, v, 8, 4, bpp, opt); \\    init_lpf_mix2_func(1, 1, 1, v, 8, 8, bpp, opt)#define init_itx_func(idxa, idxb, typea, typeb, size, bpp, opt) \\    dsp->itxfm_add[idxa][idxb] = \\        ff_vp9_##typea##_##typeb##_##size##x##size##_add_##bpp##_##opt;#define init_itx_func_one(idx, typea, typeb, size, bpp, opt) \\    init_itx_func(idx, DCT_DCT,   typea, typeb, size, bpp, opt); \\    init_itx_func(idx, ADST_DCT,  typea, typeb, size, bpp, opt); \\    init_itx_func(idx, DCT_ADST,  typea, typeb, size, bpp, opt); \\    init_itx_func(idx, ADST_ADST, typea, typeb, size, bpp, opt)#define init_itx_funcs(idx, size, bpp, opt) \\    init_itx_func(idx, DCT_DCT,   idct,  idct,  size, bpp, opt); \\    init_itx_func(idx, ADST_DCT,  idct,  iadst, size, bpp, opt); \\    init_itx_func(idx, DCT_ADST,  iadst, idct,  size, bpp, opt); \\    init_itx_func(idx, ADST_ADST, iadst, iadst, size, bpp, opt); \\    if (EXTERNAL_MMXEXT(cpu_flags)) {        init_ipred_func(tm, TM_VP8, 4, BPC, mmxext);        if (!bitexact) {            init_itx_func_one(4 /* lossless */, iwht, iwht, 4, BPC, mmxext);#if BPC == 10            init_itx_func(TX_4X4, DCT_DCT, idct, idct, 4, 10, mmxext);#endif        }    }    if (EXTERNAL_SSE2(cpu_flags)) {        init_subpel3(0, put, BPC, sse2);        init_subpel3(1, avg, BPC, sse2);        init_lpf_funcs(BPC, sse2);        init_8_16_32_ipred_funcs(tm, TM_VP8, BPC, sse2);#if BPC == 10        if (!bitexact) {            init_itx_func(TX_4X4, ADST_DCT,  idct,  iadst, 4, 10, sse2);            init_itx_func(TX_4X4, DCT_ADST,  iadst, idct,  4, 10, sse2);            init_itx_func(TX_4X4, ADST_ADST, iadst, iadst, 4, 10, sse2);        }#endif    }    if (EXTERNAL_SSSE3(cpu_flags)) {        init_lpf_funcs(BPC, ssse3);#if BPC == 10        if (!bitexact) {            init_itx_funcs(TX_4X4, 4, BPC, ssse3);        }#endif    }    if (EXTERNAL_AVX(cpu_flags)) {        init_lpf_funcs(BPC, avx);    }    if (EXTERNAL_AVX2(cpu_flags)) {#if HAVE_AVX2_EXTERNAL        init_subpel3_32_64(0,  put, BPC, avx2);        init_subpel3_32_64(1,  avg, BPC, avx2);        init_subpel2(2, 0, 16, put, BPC, avx2);        init_subpel2(2, 1, 16, avg, BPC, avx2);#endif    }#endif /* HAVE_YASM */    ff_vp9dsp_init_16bpp_x86(dsp);}", "idx": 19464}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "function": "static void test_visitor_in_bool(TestInputVisitorData *data,                                 const void *unused){    bool res = false;    Visitor *v;    v = visitor_input_test_init(data, \"true\");    visit_type_bool(v, NULL, &res, &error_abort);    g_assert_cmpint(res, ==, true);}", "idx": 19478}
{"project": "FFmpeg", "commit_id": "3594554a064d76e3514fab9781c0e63ea9e08ea9", "target": 0, "function": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){  /* VIS-specific optimizations */  int accel = vis_level ();  const int high_bit_depth = avctx->bits_per_raw_sample > 8;  if (accel & ACCEL_SPARC_VIS) {      if (avctx->bits_per_raw_sample <= 8 &&          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {          c->idct_put = ff_simple_idct_put_vis;          c->idct_add = ff_simple_idct_add_vis;          c->idct     = ff_simple_idct_vis;          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;      }      if (!high_bit_depth) {      c->put_pixels_tab[0][0] = MC_put_o_16_vis;      c->put_pixels_tab[0][1] = MC_put_x_16_vis;      c->put_pixels_tab[0][2] = MC_put_y_16_vis;      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;      c->put_pixels_tab[1][0] = MC_put_o_8_vis;      c->put_pixels_tab[1][1] = MC_put_x_8_vis;      c->put_pixels_tab[1][2] = MC_put_y_8_vis;      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;      }  }}", "idx": 19494}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "function": "static void gen_dozo(DisasContext *ctx){    int l1 = gen_new_label();    int l2 = gen_new_label();    TCGv t0 = tcg_temp_new();    TCGv t1 = tcg_temp_new();    TCGv t2 = tcg_temp_new();    /* Start with XER OV disabled, the most likely case */    tcg_gen_movi_tl(cpu_ov, 0);    tcg_gen_brcond_tl(TCG_COND_GE, cpu_gpr[rB(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], l1);    tcg_gen_sub_tl(t0, cpu_gpr[rB(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);    tcg_gen_xor_tl(t1, cpu_gpr[rB(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);    tcg_gen_xor_tl(t2, cpu_gpr[rA(ctx->opcode)], t0);    tcg_gen_andc_tl(t1, t1, t2);    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], t0);    tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l2);    tcg_gen_movi_tl(cpu_ov, 1);    tcg_gen_movi_tl(cpu_so, 1);    tcg_gen_br(l2);    gen_set_label(l1);    tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);    gen_set_label(l2);    tcg_temp_free(t0);    tcg_temp_free(t1);    tcg_temp_free(t2);    if (unlikely(Rc(ctx->opcode) != 0))        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);}", "idx": 19517}
{"project": "FFmpeg", "commit_id": "4fdb41a84bc4cbc50600f1ba5ab6af64c69ca092", "target": 1, "function": "static int eval_refl(int *refl, const int16_t *coefs, RA144Context *ractx){    int b, i, j;    int buffer1[10];    int buffer2[10];    int *bp1 = buffer1;    int *bp2 = buffer2;    for (i=0; i < 10; i++)        buffer2[i] = coefs[i];    refl[9] = bp2[9];    if ((unsigned) bp2[9] + 0x1000 > 0x1fff) {        av_log(ractx, AV_LOG_ERROR, \"Overflow. Broken sample?\\n\");        return 1;    }    for (i=8; i >= 0; i--) {        b = 0x1000-((bp2[i+1] * bp2[i+1]) >> 12);        if (!b)            b = -2;        for (j=0; j <= i; j++)            bp1[j] = ((bp2[j] - ((refl[i+1] * bp2[i-j]) >> 12)) * (0x1000000 / b)) >> 12;        refl[i] = bp1[i];        if ((unsigned) bp1[i] + 0x1000 > 0x1fff)            return 1;        FFSWAP(int *, bp1, bp2);    }    return 0;}", "idx": 19561}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "function": "static inline unsigned int get_uint(ShortenContext *s, int k){    if (s->version != 0)        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);    return get_ur_golomb_shorten(&s->gb, k);}", "idx": 19593}
{"project": "FFmpeg", "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e", "target": 1, "function": "int ffurl_read(URLContext *h, unsigned char *buf, int size){    if (h->flags & AVIO_FLAG_WRITE)        return AVERROR(EIO);    return retry_transfer_wrapper(h, buf, size, 1, h->prot->url_read);}", "idx": 19630}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "function": "static void gen_rfmci(DisasContext *ctx){#if defined(CONFIG_USER_ONLY)    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);#else    if (unlikely(ctx->pr)) {        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);        return;    }    /* Restore CPU state */    gen_helper_rfmci(cpu_env);    gen_sync_exception(ctx);#endif}", "idx": 19674}
{"project": "FFmpeg", "commit_id": "b4043ef504b77c357d33ffa2be28ed1c4eeecf7f", "target": 1, "function": "static av_cold int flic_decode_init(AVCodecContext *avctx){    FlicDecodeContext *s = avctx->priv_data;    unsigned char *fli_header = (unsigned char *)avctx->extradata;    int depth;    if (avctx->extradata_size != 0 &&        avctx->extradata_size != 12 &&        avctx->extradata_size != 128 &&        avctx->extradata_size != 1024) {        av_log(avctx, AV_LOG_ERROR, \"Expected extradata of 12, 128 or 1024 bytes\\n\");        return AVERROR_INVALIDDATA;    }    s->avctx = avctx;    if (s->avctx->extradata_size == 12) {        /* special case for magic carpet FLIs */        s->fli_type = FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE;        depth = 8;    } else if (avctx->extradata_size == 1024) {        uint8_t *ptr = avctx->extradata;        int i;        for (i = 0; i < 256; i++) {            s->palette[i] = AV_RL32(ptr);            ptr += 4;        }        depth = 8;    } else if (avctx->extradata_size == 0) {        /* FLI in MOV, see e.g. FFmpeg trac issue #626 */        s->fli_type = FLI_TYPE_CODE;        depth = 8;    } else {        s->fli_type = AV_RL16(&fli_header[4]);        depth = AV_RL16(&fli_header[12]);    }    if (depth == 0) {        depth = 8; /* Some FLC generators set depth to zero, when they mean 8Bpp. Fix up here */    }    if ((s->fli_type == FLC_FLX_TYPE_CODE) && (depth == 16)) {        depth = 15; /* Original Autodesk FLX's say the depth is 16Bpp when it is really 15Bpp */    }    switch (depth) {        case 8  : avctx->pix_fmt = PIX_FMT_PAL8; break;        case 15 : avctx->pix_fmt = PIX_FMT_RGB555; break;        case 16 : avctx->pix_fmt = PIX_FMT_RGB565; break;        case 24 : avctx->pix_fmt = PIX_FMT_BGR24; /* Supposedly BGR, but havent any files to test with */                  av_log(avctx, AV_LOG_ERROR, \"24Bpp FLC/FLX is unsupported due to no test files.\\n\");                  return -1;        default :                  av_log(avctx, AV_LOG_ERROR, \"Unknown FLC/FLX depth of %d Bpp is unsupported.\\n\",depth);                  return -1;    }    avcodec_get_frame_defaults(&s->frame);    s->frame.data[0] = NULL;    s->new_palette = 0;    return 0;}", "idx": 19695}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "function": "static void gen_exception(int excp){    TCGv tmp = new_tmp();    tcg_gen_movi_i32(tmp, excp);    gen_helper_exception(tmp);    dead_tmp(tmp);}", "idx": 19708}
{"project": "FFmpeg", "commit_id": "301a24de52f5baa09beff0958327af2c2a7005dc", "target": 1, "function": "static int dnxhd_encode_picture(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){    DNXHDEncContext *ctx = avctx->priv_data;    int first_field = 1;    int offset, i, ret;    if (buf_size < ctx->cid_table->frame_size) {        av_log(avctx, AV_LOG_ERROR, \"output buffer is too small to compress picture\\n\");        return -1;    }    dnxhd_load_picture(ctx, data); encode_coding_unit:    for (i = 0; i < 3; i++) {        ctx->src[i] = ctx->frame.data[i];        if (ctx->interlaced && ctx->cur_field)            ctx->src[i] += ctx->frame.linesize[i];    }    dnxhd_write_header(avctx, buf);    if (avctx->mb_decision == FF_MB_DECISION_RD)        ret = dnxhd_encode_rdo(avctx, ctx);    else        ret = dnxhd_encode_fast(avctx, ctx);    if (ret < 0) {        av_log(avctx, AV_LOG_ERROR, \"picture could not fit ratecontrol constraints\\n\");        return -1;    }    dnxhd_setup_threads_slices(ctx, buf);    offset = 0;    for (i = 0; i < ctx->m.mb_height; i++) {        AV_WB32(ctx->msip + i * 4, offset);        offset += ctx->slice_size[i];        assert(!(ctx->slice_size[i] & 3));    }    avctx->execute(avctx, dnxhd_encode_thread, (void**)&ctx->thread[0], NULL, avctx->thread_count, sizeof(void*));    AV_WB32(buf + ctx->cid_table->coding_unit_size - 4, 0x600DC0DE); // EOF    if (ctx->interlaced && first_field) {        first_field     = 0;        ctx->cur_field ^= 1;        buf      += ctx->cid_table->coding_unit_size;        buf_size -= ctx->cid_table->coding_unit_size;        goto encode_coding_unit;    }    ctx->frame.quality = ctx->qscale*FF_QP2LAMBDA;    return ctx->cid_table->frame_size;}", "idx": 19711}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "function": "static void FUNCC(pred4x4_top_dc)(uint8_t *_src, const uint8_t *topright, int _stride){    pixel *src = (pixel*)_src;    int stride = _stride/sizeof(pixel);    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride] + 2) >>2;    ((pixel4*)(src+0*stride))[0]=    ((pixel4*)(src+1*stride))[0]=    ((pixel4*)(src+2*stride))[0]=    ((pixel4*)(src+3*stride))[0]= PIXEL_SPLAT_X4(dc);}", "idx": 19715}
{"project": "FFmpeg", "commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "target": 1, "function": "static void store_slice_mmx(uint8_t *dst, const uint16_t *src,                            int dst_stride, int src_stride,                            int width, int height, int log2_scale,                            const uint8_t dither[8][8]){    int y;    for (y = 0; y < height; y++) {        uint8_t *dst1 = dst;        const int16_t *src1 = src;        __asm__ volatile(            \"movq (%3), %%mm3           \\n\"            \"movq (%3), %%mm4           \\n\"            \"movd %4, %%mm2             \\n\"            \"pxor %%mm0, %%mm0          \\n\"            \"punpcklbw %%mm0, %%mm3     \\n\"            \"punpckhbw %%mm0, %%mm4     \\n\"            \"psraw %%mm2, %%mm3         \\n\"            \"psraw %%mm2, %%mm4         \\n\"            \"movd %5, %%mm2             \\n\"            \"1:                         \\n\"            \"movq (%0), %%mm0           \\n\"            \"movq 8(%0), %%mm1          \\n\"            \"paddw %%mm3, %%mm0         \\n\"            \"paddw %%mm4, %%mm1         \\n\"            \"psraw %%mm2, %%mm0         \\n\"            \"psraw %%mm2, %%mm1         \\n\"            \"packuswb %%mm1, %%mm0      \\n\"            \"movq %%mm0, (%1)           \\n\"            \"add $16, %0                \\n\"            \"add $8, %1                 \\n\"            \"cmp %2, %1                 \\n\"            \" jb 1b                     \\n\"            : \"+r\" (src1), \"+r\"(dst1)            : \"r\"(dst + width), \"r\"(dither[y]), \"g\"(log2_scale), \"g\"(MAX_LEVEL - log2_scale)        );        src += src_stride;        dst += dst_stride;    }}", "idx": 19718}
{"project": "FFmpeg", "commit_id": "e584914acddaeb21f5258d9947b530fbd9421ab8", "target": 0, "function": "static int wc3_read_packet(AVFormatContext *s,                           AVPacket *pkt){    Wc3DemuxContext *wc3 = s->priv_data;    ByteIOContext *pb = s->pb;    unsigned int fourcc_tag;    unsigned int size;    int packet_read = 0;    int ret = 0;    unsigned char preamble[WC3_PREAMBLE_SIZE];    unsigned char text[1024];    unsigned int palette_number;    int i;    unsigned char r, g, b;    int base_palette_index;    while (!packet_read) {        /* get the next chunk preamble */        if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=            WC3_PREAMBLE_SIZE)            ret = AVERROR(EIO);        fourcc_tag = AV_RL32(&preamble[0]);        /* chunk sizes are 16-bit aligned */        size = (AV_RB32(&preamble[4]) + 1) & (~1);        switch (fourcc_tag) {        case BRCH_TAG:            /* no-op */            break;        case SHOT_TAG:            /* load up new palette */            if ((ret = get_buffer(pb, preamble, 4)) != 4)                return AVERROR(EIO);            palette_number = AV_RL32(&preamble[0]);            if (palette_number >= wc3->palette_count)                return AVERROR_INVALIDDATA;            base_palette_index = palette_number * PALETTE_COUNT * 3;            for (i = 0; i < PALETTE_COUNT; i++) {                r = wc3->palettes[base_palette_index + i * 3 + 0];                g = wc3->palettes[base_palette_index + i * 3 + 1];                b = wc3->palettes[base_palette_index + i * 3 + 2];                wc3->palette_control.palette[i] = (r << 16) | (g << 8) | (b);            }            wc3->palette_control.palette_changed = 1;            break;        case VGA__TAG:            /* send out video chunk */            ret= av_get_packet(pb, pkt, size);            pkt->stream_index = wc3->video_stream_index;            pkt->pts = wc3->pts;            if (ret != size)                ret = AVERROR(EIO);            packet_read = 1;            break;        case TEXT_TAG:            /* subtitle chunk */#if 0            url_fseek(pb, size, SEEK_CUR);#else            if ((unsigned)size > sizeof(text) || (ret = get_buffer(pb, text, size)) != size)                ret = AVERROR(EIO);            else {                int i = 0;                av_log (s, AV_LOG_DEBUG, \"Subtitle time!\\n\");                av_log (s, AV_LOG_DEBUG, \"  inglish: %s\\n\", &text[i + 1]);                i += text[i] + 1;                av_log (s, AV_LOG_DEBUG, \"  doytsch: %s\\n\", &text[i + 1]);                i += text[i] + 1;                av_log (s, AV_LOG_DEBUG, \"  fronsay: %s\\n\", &text[i + 1]);            }#endif            break;        case AUDI_TAG:            /* send out audio chunk */            ret= av_get_packet(pb, pkt, size);            pkt->stream_index = wc3->audio_stream_index;            pkt->pts = wc3->pts;            if (ret != size)                ret = AVERROR(EIO);            /* time to advance pts */            wc3->pts++;            packet_read = 1;            break;        default:            av_log (s, AV_LOG_ERROR, \"  unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\",                preamble[0], preamble[1], preamble[2], preamble[3],                preamble[0], preamble[1], preamble[2], preamble[3]);            ret = AVERROR_INVALIDDATA;            packet_read = 1;            break;        }    }    return ret;}", "idx": 19727}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "function": "static av_cold int pnm_encode_close(AVCodecContext *avctx){    av_frame_free(&avctx->coded_frame);    return 0;}", "idx": 19756}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "function": "static void gen_mul(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb){    TCGv sr_ov = tcg_temp_new();    TCGv t0 = tcg_temp_new();    tcg_gen_muls2_tl(dest, sr_ov, srca, srcb);    tcg_gen_sari_tl(t0, dest, TARGET_LONG_BITS - 1);    tcg_gen_setcond_tl(TCG_COND_NE, sr_ov, sr_ov, t0);    tcg_temp_free(t0);    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);    gen_ove_ov(dc, sr_ov);    tcg_temp_free(sr_ov);}", "idx": 19785}
{"project": "qemu", "commit_id": "5b1ded224f46d56053f419cf24c1335b6dde40ee", "target": 1, "function": "static uint64_t get_migration_pass(void){    QDict *rsp, *rsp_return, *rsp_ram;    uint64_t result;    rsp = return_or_event(qmp(\"{ 'execute': 'query-migrate' }\"));    rsp_return = qdict_get_qdict(rsp, \"return\");    if (!qdict_haskey(rsp_return, \"ram\")) {        /* Still in setup */        result = 0;    } else {        rsp_ram = qdict_get_qdict(rsp_return, \"ram\");        result = qdict_get_try_int(rsp_ram, \"dirty-sync-count\", 0);        QDECREF(rsp);    }    return result;}", "idx": 19800}
{"project": "FFmpeg", "commit_id": "24fee95321c1463360ba7042d026dae021854360", "target": 1, "function": "static int update_offset(RTMPContext *rt, int size){    int old_flv_size;    // generate packet header and put data into buffer for FLV demuxer    if (rt->flv_off < rt->flv_size) {        // There is old unread data in the buffer, thus append at the end        old_flv_size  = rt->flv_size;        rt->flv_size += size + 15;    } else {        // All data has been read, write the new data at the start of the buffer        old_flv_size = 0;        rt->flv_size = size + 15;        rt->flv_off  = 0;    }    return old_flv_size;}", "idx": 19855}
{"project": "FFmpeg", "commit_id": "6e20554a6d33e92b81dc3cfed6082e03bff2a7f8", "target": 1, "function": "static void decode_mb(MadContext *t, int inter){    MpegEncContext *s = &t->s;    int mv_map = 0;    int mv_x, mv_y;    int j;    if (inter) {        int v = decode210(&s->gb);        if (v < 2) {            mv_map = v ? get_bits(&s->gb, 6) : 63;            mv_x = decode_motion(&s->gb);            mv_y = decode_motion(&s->gb);        } else {            mv_map = 0;        }    }    for (j=0; j<6; j++) {        if (mv_map & (1<<j)) {  // mv_x and mv_y are guarded by mv_map            int add = 2*decode_motion(&s->gb);            comp_block(t, s->mb_x, s->mb_y, j, mv_x, mv_y, add);        } else {            s->dsp.clear_block(t->block);            decode_block_intra(t, t->block);            idct_put(t, t->block, s->mb_x, s->mb_y, j);        }    }}", "idx": 19874}
{"project": "qemu", "commit_id": "ec1efab95767312ff4afb816d0d4b548e093b031", "target": 1, "function": "static bool vexpress_cfgctrl_read(arm_sysctl_state *s, unsigned int dcc,                                  unsigned int function, unsigned int site,                                  unsigned int position, unsigned int device,                                  uint32_t *val){    /* We don't support anything other than DCC 0, board stack position 0     * or sites other than motherboard/daughterboard:     */    if (dcc != 0 || position != 0 ||        (site != SYS_CFG_SITE_MB && site != SYS_CFG_SITE_DB1)) {        goto cfgctrl_unimp;    }    switch (function) {    case SYS_CFG_VOLT:        if (site == SYS_CFG_SITE_DB1 && device < s->db_num_vsensors) {            *val = s->db_voltage[device];            return true;        }        if (site == SYS_CFG_SITE_MB && device == 0) {            /* There is only one motherboard voltage sensor:             * VIO : 3.3V : bus voltage between mother and daughterboard             */            *val = 3300000;            return true;        }        break;    case SYS_CFG_OSC:        if (site == SYS_CFG_SITE_MB && device < sizeof(s->mb_clock)) {            /* motherboard clock */            *val = s->mb_clock[device];            return true;        }        if (site == SYS_CFG_SITE_DB1 && device < s->db_num_clocks) {            /* daughterboard clock */            *val = s->db_clock[device];            return true;        }        break;    default:        break;    }cfgctrl_unimp:    qemu_log_mask(LOG_UNIMP,                  \"arm_sysctl: Unimplemented SYS_CFGCTRL read of function \"                  \"0x%x DCC 0x%x site 0x%x position 0x%x device 0x%x\\n\",                  function, dcc, site, position, device);    return false;}", "idx": 19877}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "function": "static int waveformat_from_audio_settings (WAVEFORMATEX *wfx, audsettings_t *as){    memset (wfx, 0, sizeof (*wfx));    wfx->wFormatTag = WAVE_FORMAT_PCM;    wfx->nChannels = as->nchannels;    wfx->nSamplesPerSec = as->freq;    wfx->nAvgBytesPerSec = as->freq << (as->nchannels == 2);    wfx->nBlockAlign = 1 << (as->nchannels == 2);    wfx->cbSize = 0;    switch (as->fmt) {    case AUD_FMT_S8:    case AUD_FMT_U8:        wfx->wBitsPerSample = 8;        break;    case AUD_FMT_S16:    case AUD_FMT_U16:        wfx->wBitsPerSample = 16;        wfx->nAvgBytesPerSec <<= 1;        wfx->nBlockAlign <<= 1;        break;    case AUD_FMT_S32:    case AUD_FMT_U32:        wfx->wBitsPerSample = 32;        wfx->nAvgBytesPerSec <<= 2;        wfx->nBlockAlign <<= 2;        break;    default:        dolog (\"Internal logic error: Bad audio format %d\\n\", as->freq);        return -1;    }    return 0;}", "idx": 19945}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "function": "static void cpu_devinit(const char *cpu_model, unsigned int id,                        uint64_t prom_addr, qemu_irq **cpu_irqs){    CPUState *cs;    SPARCCPU *cpu;    CPUSPARCState *env;    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));    if (cpu == NULL) {        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");        exit(1);    }    env = &cpu->env;    cpu_sparc_set_id(env, id);    if (id == 0) {        qemu_register_reset(main_cpu_reset, cpu);    } else {        qemu_register_reset(secondary_cpu_reset, cpu);        cs = CPU(cpu);        cs->halted = 1;    }    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);    env->prom_addr = prom_addr;}", "idx": 19987}
{"project": "qemu", "commit_id": "783e7706937fe15523b609b545587a028a2bdd03", "target": 1, "function": "static int32_t virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq){    VirtQueueElement elem;    int32_t num_packets = 0;    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK)) {        return num_packets;    }    if (n->async_tx.elem.out_num) {        virtio_queue_set_notification(n->tx_vq, 0);        return num_packets;    }    while (virtqueue_pop(vq, &elem)) {        ssize_t ret, len = 0;        unsigned int out_num = elem.out_num;        struct iovec *out_sg = &elem.out_sg[0];        unsigned hdr_len;        /* hdr_len refers to the header received from the guest */        hdr_len = n->mergeable_rx_bufs ?            sizeof(struct virtio_net_hdr_mrg_rxbuf) :            sizeof(struct virtio_net_hdr);        if (out_num < 1 || out_sg->iov_len != hdr_len) {            error_report(\"virtio-net header not in first element\");            exit(1);        }        /* ignore the header if GSO is not supported */        if (!n->has_vnet_hdr) {            out_num--;            out_sg++;            len += hdr_len;        } else if (n->mergeable_rx_bufs) {            /* tapfd expects a struct virtio_net_hdr */            hdr_len -= sizeof(struct virtio_net_hdr);            out_sg->iov_len -= hdr_len;            len += hdr_len;        }        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,                                      virtio_net_tx_complete);        if (ret == 0) {            virtio_queue_set_notification(n->tx_vq, 0);            n->async_tx.elem = elem;            n->async_tx.len  = len;            return -EBUSY;        }        len += ret;        virtqueue_push(vq, &elem, len);        virtio_notify(&n->vdev, vq);        if (++num_packets >= n->tx_burst) {            break;        }    }    return num_packets;}", "idx": 19988}
{"project": "FFmpeg", "commit_id": "271344377a3391c1a8ccc45e021721a56f237612", "target": 1, "function": "static int mov_read_extradata(MOVContext *c, ByteIOContext *pb, MOVAtom atom){    AVStream *st = c->fc->streams[c->fc->nb_streams-1];    uint64_t size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;    uint8_t *buf;    if(size > INT_MAX || (uint64_t)atom.size > INT_MAX)        return -1;    buf= av_realloc(st->codec->extradata, size);    if(!buf)        return -1;    st->codec->extradata= buf;    buf+= st->codec->extradata_size;    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;    AV_WB32(       buf    , atom.size + 8);    AV_WL32(       buf + 4, atom.type);    get_buffer(pb, buf + 8, atom.size);    return 0;}", "idx": 20034}
{"project": "qemu", "commit_id": "98f22dc172e1ebd5341da3de0d67666442566f72", "target": 0, "function": "USBDevice *usbdevice_create(const char *cmdline){    USBBus *bus = usb_bus_find(-1 /* any */);    DeviceInfo *info;    USBDeviceInfo *usb;    char driver[32];    const char *params;    int len;    params = strchr(cmdline,':');    if (params) {        params++;        len = params - cmdline;        if (len > sizeof(driver))            len = sizeof(driver);        pstrcpy(driver, len, cmdline);    } else {        params = \"\";        pstrcpy(driver, sizeof(driver), cmdline);    }    for (info = device_info_list; info != NULL; info = info->next) {        if (info->bus_info != &usb_bus_info)            continue;        usb = DO_UPCAST(USBDeviceInfo, qdev, info);        if (usb->usbdevice_name == NULL)            continue;        if (strcmp(usb->usbdevice_name, driver) != 0)            continue;        break;    }    if (info == NULL) {#if 0        /* no error because some drivers are not converted (yet) */        error_report(\"usbdevice %s not found\", driver);#endif        return NULL;    }    if (!usb->usbdevice_init) {        if (params) {            error_report(\"usbdevice %s accepts no params\", driver);            return NULL;        }        return usb_create_simple(bus, usb->qdev.name);    }    return usb->usbdevice_init(params);}", "idx": 20053}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "function": "static CharDriverState *qemu_chr_open_mux(CharDriverState *drv){    CharDriverState *chr;    MuxDriver *d;    chr = g_malloc0(sizeof(CharDriverState));    d = g_malloc0(sizeof(MuxDriver));    chr->opaque = d;    d->drv = drv;    d->focus = -1;    chr->chr_write = mux_chr_write;    chr->chr_update_read_handler = mux_chr_update_read_handler;    chr->chr_accept_input = mux_chr_accept_input;    /* Frontend guest-open / -close notification is not support with muxes */    chr->chr_set_fe_open = NULL;    /* only default to opened state if we've realized the initial     * set of muxes     */    chr->explicit_be_open = muxes_realized ? 0 : 1;    chr->is_mux = 1;    return chr;}", "idx": 20099}
{"project": "FFmpeg", "commit_id": "ee3d7f585215458246c2dd971c2afdd2642a5ca8", "target": 0, "function": "static int unpack_vlcs(Vp3DecodeContext *s, GetBitContext *gb,                        VLC *table, int coeff_index,                        int first_fragment, int last_fragment,                        int eob_run){    int i;    int token;    int zero_run = 0;    DCTELEM coeff = 0;    Vp3Fragment *fragment;    uint8_t *perm= s->scantable.permutated;    int bits_to_get;    if ((first_fragment >= s->fragment_count) ||        (last_fragment >= s->fragment_count)) {        av_log(s->avctx, AV_LOG_ERROR, \"  vp3:unpack_vlcs(): bad fragment number (%d -> %d ?)\\n\",            first_fragment, last_fragment);        return 0;    }    for (i = first_fragment; i <= last_fragment; i++) {        int fragment_num = s->coded_fragment_list[i];        if (s->coeff_counts[fragment_num] > coeff_index)            continue;        fragment = &s->all_fragments[fragment_num];        if (!eob_run) {            /* decode a VLC into a token */            token = get_vlc2(gb, table->table, 5, 3);            /* use the token to get a zero run, a coefficient, and an eob run */            if (token <= 6) {                eob_run = eob_run_base[token];                if (eob_run_get_bits[token])                    eob_run += get_bits(gb, eob_run_get_bits[token]);                coeff = zero_run = 0;            } else {                bits_to_get = coeff_get_bits[token];                if (!bits_to_get)                    coeff = coeff_tables[token][0];                else                    coeff = coeff_tables[token][get_bits(gb, bits_to_get)];                zero_run = zero_run_base[token];                if (zero_run_get_bits[token])                    zero_run += get_bits(gb, zero_run_get_bits[token]);            }        }        if (!eob_run) {            s->coeff_counts[fragment_num] += zero_run;            if (s->coeff_counts[fragment_num] < 64){                fragment->next_coeff->coeff= coeff;                fragment->next_coeff->index= perm[s->coeff_counts[fragment_num]++]; //FIXME perm here already?                fragment->next_coeff->next= s->next_coeff;                s->next_coeff->next=NULL;                fragment->next_coeff= s->next_coeff++;            }        } else {            s->coeff_counts[fragment_num] |= 128;            eob_run--;        }    }    return eob_run;}", "idx": 20113}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "function": "static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size){    int cb_size          = 1 << log2_cb_size;    HEVCLocalContext *lc = &s->HEVClc;    int log2_min_cb_size = s->sps->log2_min_cb_size;    int length           = cb_size >> log2_min_cb_size;    int min_cb_width     = s->sps->min_cb_width;    int x_cb             = x0 >> log2_min_cb_size;    int y_cb             = y0 >> log2_min_cb_size;    int x, y;    lc->cu.x                = x0;    lc->cu.y                = y0;    lc->cu.rqt_root_cbf     = 1;    lc->cu.pred_mode        = MODE_INTRA;    lc->cu.part_mode        = PART_2Nx2N;    lc->cu.intra_split_flag = 0;    lc->cu.pcm_flag         = 0;    SAMPLE_CTB(s->skip_flag, x_cb, y_cb) = 0;    for (x = 0; x < 4; x++)        lc->pu.intra_pred_mode[x] = 1;    if (s->pps->transquant_bypass_enable_flag) {        lc->cu.cu_transquant_bypass_flag = ff_hevc_cu_transquant_bypass_flag_decode(s);        if (lc->cu.cu_transquant_bypass_flag)            set_deblocking_bypass(s, x0, y0, log2_cb_size);    } else        lc->cu.cu_transquant_bypass_flag = 0;    if (s->sh.slice_type != I_SLICE) {        uint8_t skip_flag = ff_hevc_skip_flag_decode(s, x0, y0, x_cb, y_cb);        lc->cu.pred_mode = MODE_SKIP;        x = y_cb * min_cb_width + x_cb;        for (y = 0; y < length; y++) {            memset(&s->skip_flag[x], skip_flag, length);            x += min_cb_width;        }        lc->cu.pred_mode = skip_flag ? MODE_SKIP : MODE_INTER;    }    if (SAMPLE_CTB(s->skip_flag, x_cb, y_cb)) {        hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0);        intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);        if (!s->sh.disable_deblocking_filter_flag)            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size,                                                  lc->slice_or_tiles_up_boundary,                                                  lc->slice_or_tiles_left_boundary);    } else {        if (s->sh.slice_type != I_SLICE)            lc->cu.pred_mode = ff_hevc_pred_mode_decode(s);        if (lc->cu.pred_mode != MODE_INTRA ||            log2_cb_size == s->sps->log2_min_cb_size) {            lc->cu.part_mode        = ff_hevc_part_mode_decode(s, log2_cb_size);            lc->cu.intra_split_flag = lc->cu.part_mode == PART_NxN &&                                      lc->cu.pred_mode == MODE_INTRA;        }        if (lc->cu.pred_mode == MODE_INTRA) {            if (lc->cu.part_mode == PART_2Nx2N && s->sps->pcm_enabled_flag &&                log2_cb_size >= s->sps->pcm.log2_min_pcm_cb_size &&                log2_cb_size <= s->sps->pcm.log2_max_pcm_cb_size) {                lc->cu.pcm_flag = ff_hevc_pcm_flag_decode(s);            }            if (lc->cu.pcm_flag) {                int ret;                intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);                ret = hls_pcm_sample(s, x0, y0, log2_cb_size);                if (s->sps->pcm.loop_filter_disable_flag)                    set_deblocking_bypass(s, x0, y0, log2_cb_size);                if (ret < 0)                    return ret;            } else {                intra_prediction_unit(s, x0, y0, log2_cb_size);            }        } else {            intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);            switch (lc->cu.part_mode) {            case PART_2Nx2N:                hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0);                break;            case PART_2NxN:                hls_prediction_unit(s, x0, y0,               cb_size, cb_size / 2, log2_cb_size, 0);                hls_prediction_unit(s, x0, y0 + cb_size / 2, cb_size, cb_size / 2, log2_cb_size, 1);                break;            case PART_Nx2N:                hls_prediction_unit(s, x0,               y0, cb_size / 2, cb_size, log2_cb_size, 0);                hls_prediction_unit(s, x0 + cb_size / 2, y0, cb_size / 2, cb_size, log2_cb_size, 1);                break;            case PART_2NxnU:                hls_prediction_unit(s, x0, y0,               cb_size, cb_size     / 4, log2_cb_size, 0);                hls_prediction_unit(s, x0, y0 + cb_size / 4, cb_size, cb_size * 3 / 4, log2_cb_size, 1);                break;            case PART_2NxnD:                hls_prediction_unit(s, x0, y0,                   cb_size, cb_size * 3 / 4, log2_cb_size, 0);                hls_prediction_unit(s, x0, y0 + cb_size * 3 / 4, cb_size, cb_size     / 4, log2_cb_size, 1);                break;            case PART_nLx2N:                hls_prediction_unit(s, x0,               y0, cb_size     / 4, cb_size, log2_cb_size, 0);                hls_prediction_unit(s, x0 + cb_size / 4, y0, cb_size * 3 / 4, cb_size, log2_cb_size, 1);                break;            case PART_nRx2N:                hls_prediction_unit(s, x0,                   y0, cb_size * 3 / 4, cb_size, log2_cb_size, 0);                hls_prediction_unit(s, x0 + cb_size * 3 / 4, y0, cb_size     / 4, cb_size, log2_cb_size, 1);                break;            case PART_NxN:                hls_prediction_unit(s, x0,               y0,               cb_size / 2, cb_size / 2, log2_cb_size, 0);                hls_prediction_unit(s, x0 + cb_size / 2, y0,               cb_size / 2, cb_size / 2, log2_cb_size, 1);                hls_prediction_unit(s, x0,               y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 2);                hls_prediction_unit(s, x0 + cb_size / 2, y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 3);                break;            }        }        if (!lc->cu.pcm_flag) {            if (lc->cu.pred_mode != MODE_INTRA &&                !(lc->cu.part_mode == PART_2Nx2N && lc->pu.merge_flag)) {                lc->cu.rqt_root_cbf = ff_hevc_no_residual_syntax_flag_decode(s);            }            if (lc->cu.rqt_root_cbf) {                lc->cu.max_trafo_depth = lc->cu.pred_mode == MODE_INTRA ?                                         s->sps->max_transform_hierarchy_depth_intra + lc->cu.intra_split_flag :                                         s->sps->max_transform_hierarchy_depth_inter;                hls_transform_tree(s, x0, y0, x0, y0, x0, y0, log2_cb_size,                                   log2_cb_size, 0, 0);            } else {                if (!s->sh.disable_deblocking_filter_flag)                    ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size,                                                          lc->slice_or_tiles_up_boundary,                                                          lc->slice_or_tiles_left_boundary);            }        }    }    if (s->pps->cu_qp_delta_enabled_flag && lc->tu.is_cu_qp_delta_coded == 0)        ff_hevc_set_qPy(s, x0, y0, x0, y0, log2_cb_size);    x = y_cb * min_cb_width + x_cb;    for (y = 0; y < length; y++) {        memset(&s->qp_y_tab[x], lc->qp_y, length);        x += min_cb_width;    }    set_ct_depth(s, x0, y0, log2_cb_size, lc->ct.depth);    return 0;}", "idx": 20133}
{"project": "qemu", "commit_id": "3a2d44f6dd1d6cc1e5a5ebfa736a72e035c41d1b", "target": 0, "function": "static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                             const char *model, const char *name,                             const char *ifname, const char *script,                             const char *downscript, const char *vhostfdname,                             int vnet_hdr, int fd, Error **errp){    Error *err = NULL;    TAPState *s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);    int vhostfd;    tap_set_sndbuf(s->fd, tap, &err);    if (err) {        error_propagate(errp, err);        return;    }    if (tap->has_fd || tap->has_fds) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    } else if (tap->has_helper) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",                 tap->helper);    } else {        snprintf(s->nc.info_str, sizeof(s->nc.info_str),                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,                 downscript);        if (strcmp(downscript, \"no\") != 0) {            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            snprintf(s->down_script_arg, sizeof(s->down_script_arg),                     \"%s\", ifname);        }    }    if (tap->has_vhost ? tap->vhost :        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {        VhostNetOptions options;        options.backend_type = VHOST_BACKEND_TYPE_KERNEL;        options.net_backend = &s->nc;        if (tap->has_vhostfd || tap->has_vhostfds) {            vhostfd = monitor_fd_param(cur_mon, vhostfdname, &err);            if (vhostfd == -1) {                error_propagate(errp, err);                return;            }        } else {            vhostfd = open(\"/dev/vhost-net\", O_RDWR);            if (vhostfd < 0) {                error_setg_errno(errp, errno,                                 \"tap: open vhost char device failed\");                return;            }        }        options.opaque = (void *)(uintptr_t)vhostfd;        s->vhost_net = vhost_net_init(&options);        if (!s->vhost_net) {            error_setg(errp,                       \"vhost-net requested but could not be initialized\");            return;        }    } else if (tap->has_vhostfd || tap->has_vhostfds) {        error_setg(errp, \"vhostfd= is not valid without vhost\");    }}", "idx": 20155}
{"project": "qemu", "commit_id": "fff4e48ed54cc39e5942921df91300646ad37707", "target": 1, "function": "int net_init_vhost_user(const NetClientOptions *opts, const char *name,                        NetClientState *peer, Error **errp){    int queues;    const NetdevVhostUserOptions *vhost_user_opts;    CharDriverState *chr;    assert(opts->type == NET_CLIENT_OPTIONS_KIND_VHOST_USER);    vhost_user_opts = opts->u.vhost_user;    chr = net_vhost_parse_chardev(vhost_user_opts, errp);    if (!chr) {        return -1;    }    /* verify net frontend */    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,                          (char *)name, errp)) {        return -1;    }    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;    if (queues < 1) {        error_setg(errp,                   \"vhost-user number of queues must be bigger than zero\");        return -1;    }    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);}", "idx": 20186}
{"project": "qemu", "commit_id": "4f5e19e6c570459cd524b29b24374f03860f5149", "target": 0, "function": "PCIBus *pci_prep_init(qemu_irq *pic){    PREPPCIState *s;    PCIDevice *d;    int PPC_io_memory;    s = qemu_mallocz(sizeof(PREPPCIState));    s->bus = pci_register_bus(NULL, \"pci\",                              prep_set_irq, prep_map_irq, pic, 0, 4);    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);    PPC_io_memory = cpu_register_io_memory(PPC_PCIIO_read,                                           PPC_PCIIO_write, s);    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",                            sizeof(PCIDevice), 0, NULL, NULL);    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_RAVEN);    d->config[0x08] = 0x00; // revision    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return s->bus;}", "idx": 20225}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "function": "MemoryRegion *iotlb_to_region(hwaddr index){    return address_space_memory.dispatch->sections[index & ~TARGET_PAGE_MASK].mr;}", "idx": 20232}
{"project": "qemu", "commit_id": "d9968827032039d99b38db7ad3598767e1a53bbb", "target": 1, "function": "static inline void iwmmxt_store_creg(int reg, TCGv var){    tcg_gen_st_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));}", "idx": 20270}
{"project": "qemu", "commit_id": "a63f1dfc6213c765b62e93b720229d522cd156f4", "target": 0, "function": "void helper_slbie(CPUPPCState *env, target_ulong addr){    PowerPCCPU *cpu = ppc_env_get_cpu(env);    ppc_slb_t *slb;    slb = slb_lookup(cpu, addr);    if (!slb) {        return;    }    if (slb->esid & SLB_ESID_V) {        slb->esid &= ~SLB_ESID_V;        /* XXX: given the fact that segment size is 256 MB or 1TB,         *      and we still don't have a tlb_flush_mask(env, n, mask)         *      in QEMU, we just invalidate all TLBs         */        env->tlb_need_flush |= TLB_NEED_LOCAL_FLUSH;    }}", "idx": 20277}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "function": "static int decode_dds1(uint8_t *frame, int width, int height,                       const uint8_t *src, const uint8_t *src_end){    const uint8_t *frame_start = frame;    const uint8_t *frame_end   = frame + width * height;    int mask = 0x10000, bitbuf = 0;    int i, v, offset, count, segments;    segments = bytestream_get_le16(&src);    while (segments--) {        if (mask == 0x10000) {            if (src >= src_end)                return -1;            bitbuf = bytestream_get_le16(&src);            mask = 1;        }        if (src_end - src < 2 || frame_end - frame < 2)            return -1;        if (bitbuf & mask) {            v = bytestream_get_le16(&src);            offset = (v & 0x1FFF) << 2;            count = ((v >> 13) + 2) << 1;            if (frame - frame_start < offset || frame_end - frame < count*2 + width)                return -1;            for (i = 0; i < count; i++) {                frame[0] = frame[1] =                frame[width] = frame[width + 1] = frame[-offset];                frame += 2;            }        } else if (bitbuf & (mask << 1)) {            frame += bytestream_get_le16(&src) * 2;        } else {            frame[0] = frame[1] =            frame[width] = frame[width + 1] =  *src++;            frame += 2;            frame[0] = frame[1] =            frame[width] = frame[width + 1] =  *src++;            frame += 2;        }        mask <<= 2;    }    return 0;}", "idx": 20317}
{"project": "FFmpeg", "commit_id": "9487fb4dea3498eb4711eb023f43199f68701b1e", "target": 1, "function": "yuv2422_2_c_template(SwsContext *c, const int16_t *buf[2],                     const int16_t *ubuf[2], const int16_t *vbuf[2],                     const int16_t *abuf[2], uint8_t *dest, int dstW,                     int yalpha, int uvalpha, int y,                     enum PixelFormat target){    const int16_t *buf0  = buf[0],  *buf1  = buf[1],                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1];    int  yalpha1 = 4095 - yalpha;    int uvalpha1 = 4095 - uvalpha;    int i;    for (i = 0; i < (dstW >> 1); i++) {        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;        output_pixels(i * 4, Y1, U, Y2, V);    }}", "idx": 20334}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "function": "static int mp_user_removexattr(FsContext *ctx,                               const char *path, const char *name){    char buffer[PATH_MAX];    if (strncmp(name, \"user.virtfs.\", 12) == 0) {        /*         * Don't allow fetch of user.virtfs namesapce         * in case of mapped security         */        errno = EACCES;        return -1;    }    return lremovexattr(rpath(ctx, path, buffer), name);}", "idx": 20396}
{"project": "qemu", "commit_id": "5507904e362df252f6065cb27d1ff98372db6abc", "target": 1, "function": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,                        void *value, size_t vsize){    ssize_t size = 0;    char *buffer;    void *ovalue = value;    XattrOperations *xops;    char *orig_value, *orig_value_start;    ssize_t xattr_len, parsed_len = 0, attr_len;    /* Get the actual len */    buffer = rpath(ctx, path);    xattr_len = llistxattr(buffer, value, 0);    if (xattr_len <= 0) {        g_free(buffer);        return xattr_len;    }    /* Now fetch the xattr and find the actual size */    orig_value = g_malloc(xattr_len);    xattr_len = llistxattr(buffer, orig_value, xattr_len);    g_free(buffer);    /* store the orig pointer */    orig_value_start = orig_value;    while (xattr_len > parsed_len) {        xops = get_xattr_operations(ctx->xops, orig_value);        if (!xops) {            goto next_entry;        }        if (!value) {            size += xops->listxattr(ctx, path, orig_value, value, vsize);        } else {            size = xops->listxattr(ctx, path, orig_value, value, vsize);            if (size < 0) {                goto err_out;            }            value += size;            vsize -= size;        }next_entry:        /* Got the next entry */        attr_len = strlen(orig_value) + 1;        parsed_len += attr_len;        orig_value += attr_len;    }    if (value) {        size = value - ovalue;    }err_out:    g_free(orig_value_start);    return size;}", "idx": 20418}
{"project": "FFmpeg", "commit_id": "7d89f7cbf3ccd98f9a5f58db97effa9afd2d571a", "target": 1, "function": "static int crypto_close(URLContext *h){    CryptoContext *c = h->priv_data;    if (c->hd)        ffurl_close(c->hd);    av_freep(&c->aes);    av_freep(&c->key);    av_freep(&c->iv);    return 0;}", "idx": 20448}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "function": "int spapr_vio_send_crq(VIOsPAPRDevice *dev, uint8_t *crq){    int rc;    uint8_t byte;    if (!dev->crq.qsize) {        fprintf(stderr, \"spapr_vio_send_creq on uninitialized queue\\n\");        return -1;    }    /* Maybe do a fast path for KVM just writing to the pages */    rc = spapr_tce_dma_read(dev, dev->crq.qladdr + dev->crq.qnext, &byte, 1);    if (rc) {        return rc;    }    if (byte != 0) {        return 1;    }    rc = spapr_tce_dma_write(dev, dev->crq.qladdr + dev->crq.qnext + 8,                             &crq[8], 8);    if (rc) {        return rc;    }    kvmppc_eieio();    rc = spapr_tce_dma_write(dev, dev->crq.qladdr + dev->crq.qnext, crq, 8);    if (rc) {        return rc;    }    dev->crq.qnext = (dev->crq.qnext + 16) % dev->crq.qsize;    if (dev->signal_state & 1) {        qemu_irq_pulse(dev->qirq);    }    return 0;}", "idx": 20469}
{"project": "qemu", "commit_id": "5c0ba1be37181bd8a7c96c7f81b19ae5f8e66e2d", "target": 1, "function": "static void vhost_log_put(struct vhost_dev *dev, bool sync){    struct vhost_log *log = dev->log;    if (!log) {        return;    }    dev->log = NULL;    dev->log_size = 0;    --log->refcnt;    if (log->refcnt == 0) {        /* Sync only the range covered by the old log */        if (dev->log_size && sync) {            vhost_log_sync_range(dev, 0, dev->log_size * VHOST_LOG_CHUNK - 1);        }        if (vhost_log == log) {            g_free(log->log);            vhost_log = NULL;        } else if (vhost_log_shm == log) {            qemu_memfd_free(log->log, log->size * sizeof(*(log->log)),                            log->fd);            vhost_log_shm = NULL;        }        g_free(log);    }}", "idx": 20470}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "CPUCRISState *cpu_cris_init (const char *cpu_model){\tCPUCRISState *env;\tstatic int tcg_initialized = 0;\tint i;\tenv = qemu_mallocz(sizeof(CPUCRISState));\tif (!env)\t\treturn NULL;\tcpu_exec_init(env);\tcpu_reset(env);\tif (tcg_initialized)\t\treturn env;\ttcg_initialized = 1;\tcpu_env = tcg_global_reg_new(TCG_TYPE_PTR, TCG_AREG0, \"env\");\tcc_x = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t  offsetof(CPUState, cc_x), \"cc_x\");\tcc_src = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t    offsetof(CPUState, cc_src), \"cc_src\");\tcc_dest = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t     offsetof(CPUState, cc_dest),\t\t\t\t     \"cc_dest\");\tcc_result = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t       offsetof(CPUState, cc_result),\t\t\t\t       \"cc_result\");\tcc_op = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t   offsetof(CPUState, cc_op), \"cc_op\");\tcc_size = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t     offsetof(CPUState, cc_size),\t\t\t\t     \"cc_size\");\tcc_mask = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t     offsetof(CPUState, cc_mask),\t\t\t\t     \"cc_mask\");\tenv_pc = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0, \t\t\t\t    offsetof(CPUState, pc),\t\t\t\t    \"pc\");\tenv_btarget = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t\t offsetof(CPUState, btarget),\t\t\t\t\t \"btarget\");\tenv_btaken = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t\t offsetof(CPUState, btaken),\t\t\t\t\t \"btaken\");\tfor (i = 0; i < 16; i++) {\t\tcpu_R[i] = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t\t      offsetof(CPUState, regs[i]),\t\t\t\t\t      regnames[i]);\t}\tfor (i = 0; i < 16; i++) {\t\tcpu_PR[i] = tcg_global_mem_new(TCG_TYPE_TL, TCG_AREG0,\t\t\t\t\t       offsetof(CPUState, pregs[i]),\t\t\t\t\t       pregnames[i]);\t}\tTCG_HELPER(helper_raise_exception);\tTCG_HELPER(helper_dump);\tTCG_HELPER(helper_tlb_flush_pid);\tTCG_HELPER(helper_movl_sreg_reg);\tTCG_HELPER(helper_movl_reg_sreg);\tTCG_HELPER(helper_rfe);\tTCG_HELPER(helper_rfn);\tTCG_HELPER(helper_evaluate_flags_muls);\tTCG_HELPER(helper_evaluate_flags_mulu);\tTCG_HELPER(helper_evaluate_flags_mcp);\tTCG_HELPER(helper_evaluate_flags_alu_4);\tTCG_HELPER(helper_evaluate_flags_move_4);\tTCG_HELPER(helper_evaluate_flags_move_2);\tTCG_HELPER(helper_evaluate_flags);\tTCG_HELPER(helper_top_evaluate_flags);\treturn env;}", "idx": 20499}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "function": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop){    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);    switch (memop) {    case MO_8:        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);        break;    case MO_16:        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);        break;    case MO_32:        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);        break;    case MO_64:        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);        break;    default:        g_assert_not_reached();    }}", "idx": 20520}
{"project": "FFmpeg", "commit_id": "8b92b792d18d7dc3d258f440bb0493af4e973516", "target": 0, "function": "static int decode_frame(AVCodecContext *avctx,                              void *data, int *data_size,                             uint8_t *buf, int buf_size){    H264Context *h = avctx->priv_data;    MpegEncContext *s = &h->s;    AVFrame *pict = data;     float new_aspect;    int buf_index;        s->flags= avctx->flags;    *data_size = 0;      /* no supplementary picture */    if (buf_size == 0) {        return 0;    }        if(s->flags&CODEC_FLAG_TRUNCATED){        int next= find_frame_end(s, buf, buf_size);                if( ff_combine_frame(s, next, &buf, &buf_size) < 0 )            return buf_size;//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);    }    if(s->avctx->extradata_size && s->picture_number==0){        if(0 < decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) )             return -1;    }    buf_index=decode_nal_units(h, buf, buf_size);    if(buf_index < 0)         return -1;    //FIXME do something with unavailable reference frames     //    if(ret==FRAME_SKIPED) return get_consumed_bytes(s, buf_index, buf_size);#if 0    if(s->pict_type==B_TYPE || s->low_delay){        *pict= *(AVFrame*)&s->current_picture;    } else {        *pict= *(AVFrame*)&s->last_picture;    }#endif    *pict= *(AVFrame*)&s->current_picture; //FIXME     assert(pict->data[0]);//printf(\"out %d\\n\", (int)pict->data[0]);    if(avctx->debug&FF_DEBUG_QP){        int8_t *qtab= pict->qscale_table;        int x,y;                for(y=0; y<s->mb_height; y++){            for(x=0; x<s->mb_width; x++){                printf(\"%2d \", qtab[x + y*s->mb_width]);            }            printf(\"\\n\");        }        printf(\"\\n\");    }#if 0 //?    /* Return the Picture timestamp as the frame number */    /* we substract 1 because it is added on utils.c    */    avctx->frame_number = s->picture_number - 1;#endif#if 0    /* dont output the last pic after seeking */    if(s->last_picture_ptr || s->low_delay)    //Note this isnt a issue as a IDR pic should flush teh buffers#endif        *data_size = sizeof(AVFrame);    return get_consumed_bytes(s, buf_index, buf_size);}", "idx": 20542}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "function": "static int __qemu_rdma_add_block(RDMAContext *rdma, void *host_addr,                         ram_addr_t block_offset, uint64_t length){    RDMALocalBlocks *local = &rdma->local_ram_blocks;    RDMALocalBlock *block = g_hash_table_lookup(rdma->blockmap,        (void *) block_offset);    RDMALocalBlock *old = local->block;    assert(block == NULL);    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));    if (local->nb_blocks) {        int x;        for (x = 0; x < local->nb_blocks; x++) {            g_hash_table_remove(rdma->blockmap, (void *)old[x].offset);            g_hash_table_insert(rdma->blockmap, (void *)old[x].offset,                                                &local->block[x]);        }        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);        g_free(old);    }    block = &local->block[local->nb_blocks];    block->local_host_addr = host_addr;    block->offset = block_offset;    block->length = length;    block->index = local->nb_blocks;    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;    block->transit_bitmap = bitmap_new(block->nb_chunks);    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);    block->unregister_bitmap = bitmap_new(block->nb_chunks);    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));    block->is_ram_block = local->init ? false : true;    g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);    DDPRINTF(\"Added Block: %d, addr: %\" PRIu64 \", offset: %\" PRIu64           \" length: %\" PRIu64 \" end: %\" PRIu64 \" bits %\" PRIu64 \" chunks %d\\n\",            local->nb_blocks, (uint64_t) block->local_host_addr, block->offset,            block->length, (uint64_t) (block->local_host_addr + block->length),                BITS_TO_LONGS(block->nb_chunks) *                    sizeof(unsigned long) * 8, block->nb_chunks);    local->nb_blocks++;    return 0;}", "idx": 20579}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "function": "void ff_lzw_decode_tail(LZWState *p){    struct LZWState *s = (struct LZWState *)p;    while(!s->eob_reached)        lzw_get_code(s);}", "idx": 20580}
{"project": "qemu", "commit_id": "9036de1a8ad6c565a4e5d8cd124ad8dd05e7d4d4", "target": 1, "function": "static int net_tap_init(VLANState *vlan, const char *model,                        const char *name, const char *ifname1,                        const char *setup_script, const char *down_script){    TAPState *s;    int fd;    char ifname[128];    if (ifname1 != NULL)        pstrcpy(ifname, sizeof(ifname), ifname1);    else        ifname[0] = '\\0';    TFR(fd = tap_open(ifname, sizeof(ifname)));    if (fd < 0)        return -1;    if (!setup_script || !strcmp(setup_script, \"no\"))        setup_script = \"\";    if (setup_script[0] != '\\0') {\tif (launch_script(setup_script, ifname, fd))\t    return -1;    }    s = net_tap_fd_init(vlan, model, name, fd);    if (!s)        return -1;    snprintf(s->vc->info_str, sizeof(s->vc->info_str),             \"ifname=%s,script=%s,downscript=%s\",             ifname, setup_script, down_script);    if (down_script && strcmp(down_script, \"no\")) {        snprintf(s->down_script, sizeof(s->down_script), \"%s\", down_script);        snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);    }    return 0;}", "idx": 20583}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "function": "static inline int yv12touyvy_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );  uint8_t *ysrc = src[0];  uint8_t *usrc = src[1];  uint8_t *vsrc = src[2];  const int width = c->srcW;  const int height = srcSliceH;  const int lumStride = srcStride[0];  const int chromStride = srcStride[1];  const int dstStride = dstStride_a[0];  const int vertLumPerChroma = 2;  const vector unsigned char yperm = vec_lvsl(0, ysrc);  register unsigned int y;  if(width&15){    yv12touyvy( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);    return srcSliceH;  }  /* this code assume:  1) dst is 16 bytes-aligned  2) dstStride is a multiple of 16  3) width is a multiple of 16  4) lum&chrom stride are multiple of 8  */  for(y=0; y<height; y++)    {      int i;      for (i = 0; i < width - 31; i+= 32) {\tconst unsigned int j = i >> 1;\tvector unsigned char v_yA = vec_ld(i, ysrc);\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\tvector unsigned char v_uA = vec_ld(j, usrc);\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\tvector unsigned char v_vA = vec_ld(j, vsrc);\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\tvector unsigned char v_uyvy_0 = vec_mergeh(v_uv_a, v_y1);\tvector unsigned char v_uyvy_1 = vec_mergel(v_uv_a, v_y1);\tvector unsigned char v_uyvy_2 = vec_mergeh(v_uv_b, v_y2);\tvector unsigned char v_uyvy_3 = vec_mergel(v_uv_b, v_y2);\tvec_st(v_uyvy_0, (i << 1), dst);\tvec_st(v_uyvy_1, (i << 1) + 16, dst);\tvec_st(v_uyvy_2, (i << 1) + 32, dst);\tvec_st(v_uyvy_3, (i << 1) + 48, dst);      }      if (i < width) {\tconst unsigned int j = i >> 1;\tvector unsigned char v_y1 = vec_ld(i, ysrc);\tvector unsigned char v_u = vec_ld(j, usrc);\tvector unsigned char v_v = vec_ld(j, vsrc);\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\tvector unsigned char v_uyvy_0 = vec_mergeh(v_uv_a, v_y1);\tvector unsigned char v_uyvy_1 = vec_mergel(v_uv_a, v_y1);\tvec_st(v_uyvy_0, (i << 1), dst);\tvec_st(v_uyvy_1, (i << 1) + 16, dst);      }      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\t{\t  usrc += chromStride;\t  vsrc += chromStride;\t}      ysrc += lumStride;      dst += dstStride;    }  return srcSliceH;}", "idx": 20589}
{"project": "qemu", "commit_id": "b533f658a98325d0e47b36113bd9f5bcc046fdae", "target": 1, "function": "static int kvm_physical_sync_dirty_bitmap(MemoryRegionSection *section){    KVMState *s = kvm_state;    unsigned long size, allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    hwaddr start_addr = section->offset_within_address_space;    hwaddr end_addr = start_addr + int128_get64(section->size);    d.dirty_bitmap = NULL;    while (start_addr < end_addr) {        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);        if (mem == NULL) {            break;        }        /* XXX bad kernel interface alert         * For dirty bitmap, kernel allocates array of size aligned to         * bits-per-long.  But for case when the kernel is 64bits and         * the userspace is 32bits, userspace can't align to the same         * bits-per-long, since sizeof(long) is different between kernel         * and user space.  This way, userspace will provide buffer which         * may be 4 bytes less than the kernel will use, resulting in         * userspace memory corruption (which is not detectable by valgrind         * too, in most cases).         * So for now, let's align to 64 instead of HOST_LONG_BITS here, in         * a hope that sizeof(long) wont become >8 any time soon.         */        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS),                     /*HOST_LONG_BITS*/ 64) / 8;        if (!d.dirty_bitmap) {            d.dirty_bitmap = g_malloc(size);        } else if (size > allocated_size) {            d.dirty_bitmap = g_realloc(d.dirty_bitmap, size);        }        allocated_size = size;        memset(d.dirty_bitmap, 0, allocated_size);        d.slot = mem->slot;        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {            DPRINTF(\"ioctl failed %d\\n\", errno);            ret = -1;            break;        }        kvm_get_dirty_pages_log_range(section, d.dirty_bitmap);        start_addr = mem->start_addr + mem->memory_size;    }    g_free(d.dirty_bitmap);    return ret;}", "idx": 20641}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "function": "static void pci_idx(void){    QVirtioPCIDevice *dev;    QPCIBus *bus;    QVirtQueuePCI *vqpci;    QGuestAllocator *alloc;    QVirtioBlkReq req;    void *addr;    uint64_t req_addr;    uint64_t capacity;    uint32_t features;    uint32_t free_head;    uint8_t status;    char *data;    bus = pci_test_start();    alloc = pc_alloc_init();    dev = virtio_blk_pci_init(bus, PCI_SLOT);    qpci_msix_enable(dev->pdev);    qvirtio_pci_set_msix_configuration_vector(dev, alloc, 0);    /* MSI-X is enabled */    addr = dev->addr + VIRTIO_PCI_CONFIG_OFF(true);    capacity = qvirtio_config_readq(&qvirtio_pci, &dev->vdev,                                                    (uint64_t)(uintptr_t)addr);    g_assert_cmpint(capacity, ==, TEST_IMAGE_SIZE / 512);    features = qvirtio_get_features(&qvirtio_pci, &dev->vdev);    features = features & ~(QVIRTIO_F_BAD_FEATURE |                            (1u << VIRTIO_RING_F_INDIRECT_DESC) |                            (1u << VIRTIO_F_NOTIFY_ON_EMPTY) |                            (1u << VIRTIO_BLK_F_SCSI));    qvirtio_set_features(&qvirtio_pci, &dev->vdev, features);    vqpci = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,                                                                    alloc, 0);    qvirtqueue_pci_msix_setup(dev, vqpci, alloc, 1);    qvirtio_set_driver_ok(&qvirtio_pci, &dev->vdev);    /* Write request */    req.type = VIRTIO_BLK_T_OUT;    req.ioprio = 1;    req.sector = 0;    req.data = g_malloc0(512);    strcpy(req.data, \"TEST\");    req_addr = virtio_blk_request(alloc, &req, 512);    g_free(req.data);    free_head = qvirtqueue_add(&vqpci->vq, req_addr, 16, false, true);    qvirtqueue_add(&vqpci->vq, req_addr + 16, 512, false, true);    qvirtqueue_add(&vqpci->vq, req_addr + 528, 1, true, false);    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);    qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,                           QVIRTIO_BLK_TIMEOUT_US);    /* Write request */    req.type = VIRTIO_BLK_T_OUT;    req.ioprio = 1;    req.sector = 1;    req.data = g_malloc0(512);    strcpy(req.data, \"TEST\");    req_addr = virtio_blk_request(alloc, &req, 512);    g_free(req.data);    /* Notify after processing the third request */    qvirtqueue_set_used_event(&vqpci->vq, 2);    free_head = qvirtqueue_add(&vqpci->vq, req_addr, 16, false, true);    qvirtqueue_add(&vqpci->vq, req_addr + 16, 512, false, true);    qvirtqueue_add(&vqpci->vq, req_addr + 528, 1, true, false);    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);    /* No notification expected */    status = qvirtio_wait_status_byte_no_isr(&qvirtio_pci, &dev->vdev,                                             &vqpci->vq, req_addr + 528,                                             QVIRTIO_BLK_TIMEOUT_US);    g_assert_cmpint(status, ==, 0);    guest_free(alloc, req_addr);    /* Read request */    req.type = VIRTIO_BLK_T_IN;    req.ioprio = 1;    req.sector = 1;    req.data = g_malloc0(512);    req_addr = virtio_blk_request(alloc, &req, 512);    g_free(req.data);    free_head = qvirtqueue_add(&vqpci->vq, req_addr, 16, false, true);    qvirtqueue_add(&vqpci->vq, req_addr + 16, 512, true, true);    qvirtqueue_add(&vqpci->vq, req_addr + 528, 1, true, false);    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);    qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,                           QVIRTIO_BLK_TIMEOUT_US);    status = readb(req_addr + 528);    g_assert_cmpint(status, ==, 0);    data = g_malloc0(512);    memread(req_addr + 16, data, 512);    g_assert_cmpstr(data, ==, \"TEST\");    g_free(data);    guest_free(alloc, req_addr);    /* End test */    guest_free(alloc, vqpci->vq.desc);    pc_alloc_uninit(alloc);    qpci_msix_disable(dev->pdev);    qvirtio_pci_device_disable(dev);    g_free(dev);    qpci_free_pc(bus);    test_end();}", "idx": 20648}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "function": "static inline void RENAME(rgb32to15)(const uint8_t *src, uint8_t *dst, unsigned src_size){\tconst uint8_t *s = src;\tconst uint8_t *end;#ifdef HAVE_MMX\tconst uint8_t *mm_end;#endif\tuint16_t *d = (uint16_t *)dst;\tend = s + src_size;#ifdef HAVE_MMX\tmm_end = end - 15;#if 1 //is faster only if multiplies are reasonable fast (FIXME figure out on which cpus this is faster, on Athlon its slightly faster)\tasm volatile(\t\t\"movq %3, %%mm5\t\t\t\\n\\t\"\t\t\"movq %4, %%mm6\t\t\t\\n\\t\"\t\t\"movq %5, %%mm7\t\t\t\\n\\t\"\t\t\".balign 16\t\t\t\\n\\t\"\t\t\"1:\t\t\t\t\\n\\t\"\t\tPREFETCH\" 32(%1)\t\t\\n\\t\"\t\t\"movd\t(%1), %%mm0\t\t\\n\\t\"\t\t\"movd\t4(%1), %%mm3\t\t\\n\\t\"\t\t\"punpckldq 8(%1), %%mm0\t\t\\n\\t\"\t\t\"punpckldq 12(%1), %%mm3\t\\n\\t\"\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\"\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\t\t\"pand %%mm6, %%mm3\t\t\\n\\t\"\t\t\"pmaddwd %%mm7, %%mm0\t\t\\n\\t\"\t\t\"pmaddwd %%mm7, %%mm3\t\t\\n\\t\"\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\t\t\"pand %%mm5, %%mm4\t\t\\n\\t\"\t\t\"por %%mm1, %%mm0\t\t\\n\\t\"\t\t\t\"por %%mm4, %%mm3\t\t\\n\\t\"\t\t\"psrld $6, %%mm0\t\t\\n\\t\"\t\t\"pslld $10, %%mm3\t\t\\n\\t\"\t\t\"por %%mm3, %%mm0\t\t\\n\\t\"\t\tMOVNTQ\"\t%%mm0, (%0)\t\t\\n\\t\"\t\t\"add $16, %1\t\t\t\\n\\t\"\t\t\"add $8, %0\t\t\t\\n\\t\"\t\t\"cmp %2, %1\t\t\t\\n\\t\"\t\t\" jb 1b\t\t\t\t\\n\\t\"\t\t: \"+r\" (d), \"+r\"(s)\t\t: \"r\" (mm_end), \"m\" (mask3215g), \"m\" (mask3216br), \"m\" (mul3215)\t);#else\t__asm __volatile(PREFETCH\"\t%0\"::\"m\"(*src):\"memory\");\t__asm __volatile(\t    \"movq\t%0, %%mm7\\n\\t\"\t    \"movq\t%1, %%mm6\\n\\t\"\t    ::\"m\"(red_15mask),\"m\"(green_15mask));\twhile(s < mm_end)\t{\t    __asm __volatile(\t\tPREFETCH\" 32%1\\n\\t\"\t\t\"movd\t%1, %%mm0\\n\\t\"\t\t\"movd\t4%1, %%mm3\\n\\t\"\t\t\"punpckldq 8%1, %%mm0\\n\\t\"\t\t\"punpckldq 12%1, %%mm3\\n\\t\"\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\t\t\"movq\t%%mm3, %%mm4\\n\\t\"\t\t\"movq\t%%mm3, %%mm5\\n\\t\"\t\t\"psrlq\t$3, %%mm0\\n\\t\"\t\t\"psrlq\t$3, %%mm3\\n\\t\"\t\t\"pand\t%2, %%mm0\\n\\t\"\t\t\"pand\t%2, %%mm3\\n\\t\"\t\t\"psrlq\t$6, %%mm1\\n\\t\"\t\t\"psrlq\t$6, %%mm4\\n\\t\"\t\t\"pand\t%%mm6, %%mm1\\n\\t\"\t\t\"pand\t%%mm6, %%mm4\\n\\t\"\t\t\"psrlq\t$9, %%mm2\\n\\t\"\t\t\"psrlq\t$9, %%mm5\\n\\t\"\t\t\"pand\t%%mm7, %%mm2\\n\\t\"\t\t\"pand\t%%mm7, %%mm5\\n\\t\"\t\t\"por\t%%mm1, %%mm0\\n\\t\"\t\t\"por\t%%mm4, %%mm3\\n\\t\"\t\t\"por\t%%mm2, %%mm0\\n\\t\"\t\t\"por\t%%mm5, %%mm3\\n\\t\"\t\t\"psllq\t$16, %%mm3\\n\\t\"\t\t\"por\t%%mm3, %%mm0\\n\\t\"\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\t\t:\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\t\td += 4;\t\ts += 16;\t}#endif\t__asm __volatile(SFENCE:::\"memory\");\t__asm __volatile(EMMS:::\"memory\");#endif\twhile(s < end)\t{\t\t// FIXME on bigendian\t\tconst int src= *s; s += 4;\t\t*d++ = ((src&0xFF)>>3) + ((src&0xF800)>>6) + ((src&0xF80000)>>9);\t}}", "idx": 20717}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "function": "static void intra_predict_mad_cow_dc_0l0_8x8_msa(uint8_t *src, int32_t stride){    uint8_t lp_cnt;    uint32_t src0 = 0;    uint64_t out0, out1;    for (lp_cnt = 0; lp_cnt < 4; lp_cnt++) {        src0 += src[(4 + lp_cnt) * stride - 1];    }    src0 = (src0 + 2) >> 2;    out0 = 0x8080808080808080;    out1 = src0 * 0x0101010101010101;    for (lp_cnt = 4; lp_cnt--;) {        SD(out0, src);        SD(out1, src + stride * 4);        src += stride;    }}", "idx": 20773}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "function": "static size_t v9fs_unpack(void *dst, struct iovec *out_sg, int out_num,                          size_t offset, size_t size){    return v9fs_packunpack(dst, out_sg, out_num, offset, size, 0);}", "idx": 20792}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "function": "static void vde_from_qemu(void *opaque, const uint8_t *buf, int size){    VDEState *s = opaque;    int ret;    for(;;) {        ret = vde_send(s->vde, (const char *)buf, size, 0);        if (ret < 0 && errno == EINTR) {        } else {            break;        }    }}", "idx": 20826}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "function": "static int qemu_chr_open_socket(QemuOpts *opts, CharDriverState **_chr){    CharDriverState *chr = NULL;    TCPCharDriver *s = NULL;    int fd = -1;    int is_listen;    int is_waitconnect;    int do_nodelay;    int is_unix;    int is_telnet;    int ret;    is_listen      = qemu_opt_get_bool(opts, \"server\", 0);    is_waitconnect = qemu_opt_get_bool(opts, \"wait\", 1);    is_telnet      = qemu_opt_get_bool(opts, \"telnet\", 0);    do_nodelay     = !qemu_opt_get_bool(opts, \"delay\", 1);    is_unix        = qemu_opt_get(opts, \"path\") != NULL;    if (!is_listen)        is_waitconnect = 0;    chr = g_malloc0(sizeof(CharDriverState));    s = g_malloc0(sizeof(TCPCharDriver));    if (is_unix) {        if (is_listen) {            fd = unix_listen_opts(opts);        } else {            fd = unix_connect_opts(opts);        }    } else {        if (is_listen) {            fd = inet_listen_opts(opts, 0);        } else {            fd = inet_connect_opts(opts);        }    }    if (fd < 0) {        ret = -errno;        goto fail;    }    if (!is_waitconnect)        socket_set_nonblock(fd);    s->connected = 0;    s->fd = -1;    s->listen_fd = -1;    s->msgfd = -1;    s->is_unix = is_unix;    s->do_nodelay = do_nodelay && !is_unix;    chr->opaque = s;    chr->chr_write = tcp_chr_write;    chr->chr_close = tcp_chr_close;    chr->get_msgfd = tcp_get_msgfd;    chr->chr_add_client = tcp_chr_add_client;    if (is_listen) {        s->listen_fd = fd;        qemu_set_fd_handler2(s->listen_fd, NULL, tcp_chr_accept, NULL, chr);        if (is_telnet)            s->do_telnetopt = 1;    } else {        s->connected = 1;        s->fd = fd;        socket_set_nodelay(fd);        tcp_chr_connect(chr);    }    /* for \"info chardev\" monitor command */    chr->filename = g_malloc(256);    if (is_unix) {        snprintf(chr->filename, 256, \"unix:%s%s\",                 qemu_opt_get(opts, \"path\"),                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");    } else if (is_telnet) {        snprintf(chr->filename, 256, \"telnet:%s:%s%s\",                 qemu_opt_get(opts, \"host\"), qemu_opt_get(opts, \"port\"),                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");    } else {        snprintf(chr->filename, 256, \"tcp:%s:%s%s\",                 qemu_opt_get(opts, \"host\"), qemu_opt_get(opts, \"port\"),                 qemu_opt_get_bool(opts, \"server\", 0) ? \",server\" : \"\");    }    if (is_listen && is_waitconnect) {        printf(\"QEMU waiting for connection on: %s\\n\",               chr->filename);        tcp_chr_accept(chr);        socket_set_nonblock(s->listen_fd);    }    *_chr = chr;    return 0; fail:    if (fd >= 0)        closesocket(fd);    g_free(s);    g_free(chr);    return ret;}", "idx": 20836}
{"project": "FFmpeg", "commit_id": "daca33659d12fd85062bc1798f4eb7ffeb83cc3c", "target": 1, "function": "static void assert_codec_experimental(AVCodecContext *c, int encoder){    const char *codec_string = encoder ? \"encoder\" : \"decoder\";    AVCodec *codec;    if (c->codec->capabilities & CODEC_CAP_EXPERIMENTAL &&        c->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {        av_log(NULL, AV_LOG_ERROR, \"%s '%s' is experimental and might produce bad \"                \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",                codec_string, c->codec->name);        codec = encoder ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);        if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))            av_log(NULL, AV_LOG_ERROR, \"Or use the non experimental %s '%s'.\\n\",                   codec_string, codec->name);        ffmpeg_exit(1);    }}", "idx": 20866}
{"project": "qemu", "commit_id": "90d131fb6504ed12a37dc8433375cc683c30e9da", "target": 0, "function": "mac_writereg(E1000State *s, int index, uint32_t val){    uint32_t macaddr[2];    s->mac_reg[index] = val;    if (index == RA || index == RA + 1) {        macaddr[0] = cpu_to_le32(s->mac_reg[RA]);        macaddr[1] = cpu_to_le32(s->mac_reg[RA + 1]);        qemu_format_nic_info_str(qemu_get_queue(s->nic), (uint8_t *)macaddr);    }}", "idx": 20898}
{"project": "qemu", "commit_id": "e01b444523e2b0c663b42b3e8f44ef48a6153051", "target": 0, "function": "static int ppc_hash64_pp_check(int key, int pp, bool nx){    int access;    /* Compute access rights */    /* When pp is 4, 5 or 7, the result is undefined. Set it to noaccess */    access = 0;    if (key == 0) {        switch (pp) {        case 0x0:        case 0x1:        case 0x2:            access |= PAGE_WRITE;            /* No break here */        case 0x3:        case 0x6:            access |= PAGE_READ;            break;        }    } else {        switch (pp) {        case 0x0:        case 0x6:            access = 0;            break;        case 0x1:        case 0x3:            access = PAGE_READ;            break;        case 0x2:            access = PAGE_READ | PAGE_WRITE;            break;        }    }    if (!nx) {        access |= PAGE_EXEC;    }    return access;}", "idx": 20900}
{"project": "qemu", "commit_id": "5b956f415a356449a4171d5e0c7d9a25bbc84b5a", "target": 0, "function": "static void scsi_dma_complete_noio(SCSIDiskReq *r, int ret){    assert(r->req.aiocb == NULL);    if (r->req.io_canceled) {        scsi_req_cancel_complete(&r->req);        goto done;    }    if (ret < 0) {        if (scsi_handle_rw_error(r, -ret, false)) {            goto done;        }    }    r->sector += r->sector_count;    r->sector_count = 0;    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {        scsi_write_do_fua(r);        return;    } else {        scsi_req_complete(&r->req, GOOD);    }done:    scsi_req_unref(&r->req);}", "idx": 20948}
{"project": "qemu", "commit_id": "8bd6b06d7b718b3e595aab279699ef3651ce2e48", "target": 1, "function": "void console_select(unsigned int index){    TextConsole *s;    if (index >= MAX_CONSOLES)        return;    if (active_console) {        active_console->g_width = ds_get_width(active_console->ds);        active_console->g_height = ds_get_height(active_console->ds);    }    s = consoles[index];    if (s) {        DisplayState *ds = s->ds;        if (active_console->cursor_timer) {            qemu_del_timer(active_console->cursor_timer);        }        active_console = s;        if (ds_get_bits_per_pixel(s->ds)) {            ds->surface = qemu_resize_displaysurface(ds, s->g_width, s->g_height);        } else {            s->ds->surface->width = s->width;            s->ds->surface->height = s->height;        }        if (s->cursor_timer) {            qemu_mod_timer(s->cursor_timer,                   qemu_get_clock_ms(rt_clock) + CONSOLE_CURSOR_PERIOD / 2);        }        dpy_resize(s->ds);        vga_hw_invalidate();    }}", "idx": 21074}
{"project": "FFmpeg", "commit_id": "668673f10ce225d26a96f1aeb62066e8c641c85a", "target": 1, "function": "static int parse_outputs(const char **buf, AVFilterInOut **curr_inputs,                         AVFilterInOut **open_inputs,                         AVFilterInOut **open_outputs, AVClass *log_ctx){    int ret, pad = 0;    while (**buf == '[') {        char *name = parse_link_name(buf, log_ctx);        AVFilterInOut *match;        AVFilterInOut *input = *curr_inputs;        *curr_inputs = (*curr_inputs)->next;        if (!name)        /* First check if the label is not in the open_inputs list */        match = extract_inout(name, open_inputs);        if (match) {            if ((ret = link_filter(input->filter_ctx, input->pad_idx,                                   match->filter_ctx, match->pad_idx, log_ctx)) < 0)                return ret;            av_free(match->name);            av_free(name);            av_free(match);            av_free(input);        } else {            /* Not in the list, so add the first input as a open_output */            input->name = name;            insert_inout(open_outputs, input);        *buf += strspn(*buf, WHITESPACES);        pad++;    return pad;", "idx": 21081}
{"project": "qemu", "commit_id": "374f2981d1f10bc4307f250f24b2a7ddb9b14be0", "target": 0, "function": "static void memory_init(void){    qemu_mutex_init(&flat_view_mutex);}", "idx": 21103}
{"project": "qemu", "commit_id": "7f0317cfc8da620cdb38cb5cfec5f82b8dd05403", "target": 1, "function": "void *block_job_create(const BlockJobDriver *driver, BlockDriverState *bs,                       int64_t speed, BlockCompletionFunc *cb,                       void *opaque, Error **errp){    BlockBackend *blk;    BlockJob *job;    assert(cb);    if (bs->job) {        error_setg(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));        return NULL;    }    blk = blk_new();    blk_insert_bs(blk, bs);    job = g_malloc0(driver->instance_size);    error_setg(&job->blocker, \"block device is in use by block job: %s\",               BlockJobType_lookup[driver->job_type]);    bdrv_op_block_all(bs, job->blocker);    bdrv_op_unblock(bs, BLOCK_OP_TYPE_DATAPLANE, job->blocker);    job->driver        = driver;    job->id            = g_strdup(bdrv_get_device_name(bs));    job->blk           = blk;    job->cb            = cb;    job->opaque        = opaque;    job->busy          = true;    job->refcnt        = 1;    bs->job = job;    QLIST_INSERT_HEAD(&block_jobs, job, job_list);    blk_add_aio_context_notifier(blk, block_job_attached_aio_context,                                 block_job_detach_aio_context, job);    /* Only set speed when necessary to avoid NotSupported error */    if (speed != 0) {        Error *local_err = NULL;        block_job_set_speed(job, speed, &local_err);        if (local_err) {            block_job_unref(job);            error_propagate(errp, local_err);            return NULL;        }    }    return job;}", "idx": 21122}
{"project": "FFmpeg", "commit_id": "a849ebb54e187a70eabc69cbd1b1a342e6587ec3", "target": 0, "function": "static int unpack_parse_unit(DiracParseUnit *pu, DiracParseContext *pc,                             int offset){    int8_t *start;    if (offset < 0 || pc->index - 13 < offset)        return 0;    start = pc->buffer + offset;    pu->pu_type = start[4];    pu->next_pu_offset = AV_RB32(start + 5);    pu->prev_pu_offset = AV_RB32(start + 9);    if (pu->pu_type == 0x10 && pu->next_pu_offset == 0)        pu->next_pu_offset = 13;    if (pu->next_pu_offset && pu->next_pu_offset < 13) {        av_log(NULL, AV_LOG_ERROR, \"next_pu_offset %d is invalid\\n\", pu->next_pu_offset);        return 0;    }    if (pu->prev_pu_offset && pu->prev_pu_offset < 13) {        av_log(NULL, AV_LOG_ERROR, \"prev_pu_offset %d is invalid\\n\", pu->prev_pu_offset);        return 0;    }    return 1;}", "idx": 21233}
{"project": "qemu", "commit_id": "2e8bc7874bb674b7d6837706b1249bf871941637", "target": 0, "function": "static int64_t coroutine_fn bdrv_co_get_block_status(BlockDriverState *bs,                                                     bool want_zero,                                                     int64_t sector_num,                                                     int nb_sectors, int *pnum,                                                     BlockDriverState **file){    int64_t total_sectors;    int64_t n;    int64_t ret, ret2;    BlockDriverState *local_file = NULL;    assert(pnum);    *pnum = 0;    total_sectors = bdrv_nb_sectors(bs);    if (total_sectors < 0) {        ret = total_sectors;        goto early_out;    }    if (sector_num >= total_sectors) {        ret = BDRV_BLOCK_EOF;        goto early_out;    }    if (!nb_sectors) {        ret = 0;        goto early_out;    }    n = total_sectors - sector_num;    if (n < nb_sectors) {        nb_sectors = n;    }    if (!bs->drv->bdrv_co_get_block_status) {        *pnum = nb_sectors;        ret = BDRV_BLOCK_DATA | BDRV_BLOCK_ALLOCATED;        if (sector_num + nb_sectors == total_sectors) {            ret |= BDRV_BLOCK_EOF;        }        if (bs->drv->protocol_name) {            ret |= BDRV_BLOCK_OFFSET_VALID | (sector_num * BDRV_SECTOR_SIZE);            local_file = bs;        }        goto early_out;    }    bdrv_inc_in_flight(bs);    ret = bs->drv->bdrv_co_get_block_status(bs, sector_num, nb_sectors, pnum,                                            &local_file);    if (ret < 0) {        *pnum = 0;        goto out;    }    if (ret & BDRV_BLOCK_RAW) {        assert(ret & BDRV_BLOCK_OFFSET_VALID && local_file);        ret = bdrv_co_get_block_status(local_file, want_zero,                                       ret >> BDRV_SECTOR_BITS,                                       *pnum, pnum, &local_file);        goto out;    }    if (ret & (BDRV_BLOCK_DATA | BDRV_BLOCK_ZERO)) {        ret |= BDRV_BLOCK_ALLOCATED;    } else if (want_zero) {        if (bdrv_unallocated_blocks_are_zero(bs)) {            ret |= BDRV_BLOCK_ZERO;        } else if (bs->backing) {            BlockDriverState *bs2 = bs->backing->bs;            int64_t nb_sectors2 = bdrv_nb_sectors(bs2);            if (nb_sectors2 >= 0 && sector_num >= nb_sectors2) {                ret |= BDRV_BLOCK_ZERO;            }        }    }    if (want_zero && local_file && local_file != bs &&        (ret & BDRV_BLOCK_DATA) && !(ret & BDRV_BLOCK_ZERO) &&        (ret & BDRV_BLOCK_OFFSET_VALID)) {        int file_pnum;        ret2 = bdrv_co_get_block_status(local_file, want_zero,                                        ret >> BDRV_SECTOR_BITS,                                        *pnum, &file_pnum, NULL);        if (ret2 >= 0) {            /* Ignore errors.  This is just providing extra information, it             * is useful but not necessary.             */            if (ret2 & BDRV_BLOCK_EOF &&                (!file_pnum || ret2 & BDRV_BLOCK_ZERO)) {                /*                 * It is valid for the format block driver to read                 * beyond the end of the underlying file's current                 * size; such areas read as zero.                 */                ret |= BDRV_BLOCK_ZERO;            } else {                /* Limit request to the range reported by the protocol driver */                *pnum = file_pnum;                ret |= (ret2 & BDRV_BLOCK_ZERO);            }        }    }out:    bdrv_dec_in_flight(bs);    if (ret >= 0 && sector_num + *pnum == total_sectors) {        ret |= BDRV_BLOCK_EOF;    }early_out:    if (file) {        *file = local_file;    }    return ret;}", "idx": 21343}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "function": "static void test_smbios_ep_address(test_data *data){    uint32_t off;    /* find smbios entry point structure */    for (off = 0xf0000; off < 0x100000; off += 0x10) {        uint8_t sig[] = \"_SM_\";        int i;        for (i = 0; i < sizeof sig - 1; ++i) {            sig[i] = readb(off + i);        }        if (!memcmp(sig, \"_SM_\", sizeof sig)) {            break;        }    }    g_assert_cmphex(off, <, 0x100000);    data->smbios_ep_addr = off;}", "idx": 21383}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "function": "static void do_tb_flush(CPUState *cpu, run_on_cpu_data tb_flush_count){    tb_lock();    /* If it is already been done on request of another CPU,     * just retry.     */    if (tcg_ctx.tb_ctx.tb_flush_count != tb_flush_count.host_int) {        goto done;    }#if defined(DEBUG_TB_FLUSH)    printf(\"qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\\n\",           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /           tcg_ctx.tb_ctx.nb_tbs : 0);#endif    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)        > tcg_ctx.code_gen_buffer_size) {        cpu_abort(cpu, \"Internal error: code buffer overflow\\n\");    }    CPU_FOREACH(cpu) {        int i;        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {            atomic_set(&cpu->tb_jmp_cache[i], NULL);        }    }    tcg_ctx.tb_ctx.nb_tbs = 0;    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);    page_flush_tb();    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;    /* XXX: flush processor icache at this point if cache flush is       expensive */    atomic_mb_set(&tcg_ctx.tb_ctx.tb_flush_count,                  tcg_ctx.tb_ctx.tb_flush_count + 1);done:    tb_unlock();}", "idx": 21396}
{"project": "qemu", "commit_id": "db431f6adc881a0758512cd765b3108209013512", "target": 1, "function": "int v9fs_co_st_gen(V9fsPDU *pdu, V9fsPath *path, mode_t st_mode,                   V9fsStatDotl *v9stat){    int err = 0;    V9fsState *s = pdu->s;    if (v9fs_request_cancelled(pdu)) {        return -EINTR;    if (s->ctx.exops.get_st_gen) {        v9fs_path_read_lock(s);        v9fs_co_run_in_worker(            {                err = s->ctx.exops.get_st_gen(&s->ctx, path, st_mode,                                              &v9stat->st_gen);                if (err < 0) {                    err = -errno;            });        v9fs_path_unlock(s);    return err;", "idx": 21397}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "function": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr){    PCIBonitoState *s = opaque;    uint32_t saddr;    saddr = (addr - BONITO_REGBASE) >> 2;    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);    switch (saddr) {    case BONITO_INTISR:        return s->regs[saddr];    default:        return s->regs[saddr];    }}", "idx": 21513}
{"project": "qemu", "commit_id": "3996e85c1822e05c50250f8d2d1e57b6bea1229d", "target": 1, "function": "static void xen_set_memory(struct MemoryListener *listener,                           MemoryRegionSection *section,                           bool add){    XenIOState *state = container_of(listener, XenIOState, memory_listener);    hwaddr start_addr = section->offset_within_address_space;    ram_addr_t size = int128_get64(section->size);    bool log_dirty = memory_region_is_logging(section->mr);    hvmmem_type_t mem_type;    if (!memory_region_is_ram(section->mr)) {        return;    }    if (!(section->mr != &ram_memory          && ( (log_dirty && add) || (!log_dirty && !add)))) {        return;    }    trace_xen_client_set_memory(start_addr, size, log_dirty);    start_addr &= TARGET_PAGE_MASK;    size = TARGET_PAGE_ALIGN(size);    if (add) {        if (!memory_region_is_rom(section->mr)) {            xen_add_to_physmap(state, start_addr, size,                               section->mr, section->offset_within_region);        } else {            mem_type = HVMMEM_ram_ro;            if (xc_hvm_set_mem_type(xen_xc, xen_domid, mem_type,                                    start_addr >> TARGET_PAGE_BITS,                                    size >> TARGET_PAGE_BITS)) {                DPRINTF(\"xc_hvm_set_mem_type error, addr: \"TARGET_FMT_plx\"\\n\",                        start_addr);            }        }    } else {        if (xen_remove_from_physmap(state, start_addr, size) < 0) {            DPRINTF(\"physmapping does not exist at \"TARGET_FMT_plx\"\\n\", start_addr);        }    }}", "idx": 21565}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "function": "uint32_t HELPER(servc)(CPUS390XState *env, uint64_t r1, uint64_t r2){    int r = sclp_service_call(env, r1, r2);    if (r < 0) {        program_interrupt(env, -r, 4);        return 0;    }    return r;}", "idx": 21578}
{"project": "qemu", "commit_id": "5e39d89d20b17cf6fb7f09d181d34f17b2ae2160", "target": 1, "function": "static void test_query_cpus(const void *data){    char *cli;    QDict *resp;    QList *cpus;    const QObject *e;    cli = make_cli(data, \"-smp 8 -numa node,cpus=0-3 -numa node,cpus=4-7\");    qtest_start(cli);    cpus = get_cpus(&resp);    g_assert(cpus);    while ((e = qlist_pop(cpus))) {        QDict *cpu, *props;        int64_t cpu_idx, node;        cpu = qobject_to_qdict(e);        g_assert(qdict_haskey(cpu, \"CPU\"));        g_assert(qdict_haskey(cpu, \"props\"));        cpu_idx = qdict_get_int(cpu, \"CPU\");        props = qdict_get_qdict(cpu, \"props\");        g_assert(qdict_haskey(props, \"node-id\"));        node = qdict_get_int(props, \"node-id\");        if (cpu_idx >= 0 && cpu_idx < 4) {            g_assert_cmpint(node, ==, 0);        } else {            g_assert_cmpint(node, ==, 1);        }    }    QDECREF(resp);    qtest_end();    g_free(cli);}", "idx": 21579}
{"project": "FFmpeg", "commit_id": "57623cba1301ee7874687dd7e04c611051638e9d", "target": 0, "function": "int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,                      AVPacket *avpkt, int is_vp7){    VP8Context *s = avctx->priv_data;    int ret, i, referenced, num_jobs;    enum AVDiscard skip_thresh;    VP8Frame *av_uninit(curframe), *prev_frame;    if (is_vp7)        ret = vp7_decode_frame_header(s, avpkt->data, avpkt->size);    else        ret = vp8_decode_frame_header(s, avpkt->data, avpkt->size);    if (ret < 0)        goto err;    if (!is_vp7 && s->pix_fmt == AV_PIX_FMT_NONE) {        enum AVPixelFormat pix_fmts[] = {#if CONFIG_VP8_VAAPI_HWACCEL            AV_PIX_FMT_VAAPI,#endif            AV_PIX_FMT_YUV420P,            AV_PIX_FMT_NONE,        };        s->pix_fmt = ff_get_format(s->avctx, pix_fmts);        if (s->pix_fmt < 0) {            ret = AVERROR(EINVAL);            goto err;        }        avctx->pix_fmt = s->pix_fmt;    }    prev_frame = s->framep[VP56_FRAME_CURRENT];    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||                 s->update_altref == VP56_FRAME_CURRENT;    skip_thresh = !referenced ? AVDISCARD_NONREF                              : !s->keyframe ? AVDISCARD_NONKEY                                             : AVDISCARD_ALL;    if (avctx->skip_frame >= skip_thresh) {        s->invisible = 1;        memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);        goto skip_decode;    }    s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;    // release no longer referenced frames    for (i = 0; i < 5; i++)        if (s->frames[i].tf.f->data[0] &&            &s->frames[i] != prev_frame &&            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])            vp8_release_frame(s, &s->frames[i]);    curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);    if (!s->colorspace)        avctx->colorspace = AVCOL_SPC_BT470BG;    if (s->fullrange)        avctx->color_range = AVCOL_RANGE_JPEG;    else        avctx->color_range = AVCOL_RANGE_MPEG;    /* Given that arithmetic probabilities are updated every frame, it's quite     * likely that the values we have on a random interframe are complete     * junk if we didn't start decode on a keyframe. So just don't display     * anything rather than junk. */    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||                         !s->framep[VP56_FRAME_GOLDEN]   ||                         !s->framep[VP56_FRAME_GOLDEN2])) {        av_log(avctx, AV_LOG_WARNING,               \"Discarding interframe without a prior keyframe!\\n\");        ret = AVERROR_INVALIDDATA;        goto err;    }    curframe->tf.f->key_frame = s->keyframe;    curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I                                            : AV_PICTURE_TYPE_P;    if ((ret = vp8_alloc_frame(s, curframe, referenced))) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed!\\n\");        goto err;    }    // check if golden and altref are swapped    if (s->update_altref != VP56_FRAME_NONE)        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];    else        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];    if (s->update_golden != VP56_FRAME_NONE)        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];    else        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];    if (s->update_last)        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;    else        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];    s->next_framep[VP56_FRAME_CURRENT] = curframe;    ff_thread_finish_setup(avctx);    if (avctx->hwaccel) {        ret = avctx->hwaccel->start_frame(avctx, avpkt->data, avpkt->size);        if (ret < 0)            goto err;        ret = avctx->hwaccel->decode_slice(avctx, avpkt->data, avpkt->size);        if (ret < 0)            goto err;        ret = avctx->hwaccel->end_frame(avctx);        if (ret < 0)            goto err;    } else {        s->linesize   = curframe->tf.f->linesize[0];        s->uvlinesize = curframe->tf.f->linesize[1];        memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));        /* Zero macroblock structures for top/top-left prediction         * from outside the frame. */        if (!s->mb_layout)            memset(s->macroblocks + s->mb_height * 2 - 1, 0,                   (s->mb_width + 1) * sizeof(*s->macroblocks));        if (!s->mb_layout && s->keyframe)            memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);        memset(s->ref_count, 0, sizeof(s->ref_count));        if (s->mb_layout == 1) {            // Make sure the previous frame has read its segmentation map,            // if we re-use the same map.            if (prev_frame && s->segmentation.enabled &&                !s->segmentation.update_map)                ff_thread_await_progress(&prev_frame->tf, 1, 0);            if (is_vp7)                vp7_decode_mv_mb_modes(avctx, curframe, prev_frame);            else                vp8_decode_mv_mb_modes(avctx, curframe, prev_frame);        }        if (avctx->active_thread_type == FF_THREAD_FRAME)            num_jobs = 1;        else            num_jobs = FFMIN(s->num_coeff_partitions, avctx->thread_count);        s->num_jobs   = num_jobs;        s->curframe   = curframe;        s->prev_frame = prev_frame;        s->mv_min.y   = -MARGIN;        s->mv_max.y   = ((s->mb_height - 1) << 6) + MARGIN;        for (i = 0; i < MAX_THREADS; i++) {            s->thread_data[i].thread_mb_pos = 0;            s->thread_data[i].wait_mb_pos   = INT_MAX;        }        if (is_vp7)            avctx->execute2(avctx, vp7_decode_mb_row_sliced, s->thread_data, NULL,                            num_jobs);        else            avctx->execute2(avctx, vp8_decode_mb_row_sliced, s->thread_data, NULL,                            num_jobs);    }    ff_thread_report_progress(&curframe->tf, INT_MAX, 0);    memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);skip_decode:    // if future frames don't use the updated probabilities,    // reset them to the values we saved    if (!s->update_probabilities)        s->prob[0] = s->prob[1];    if (!s->invisible) {        if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)            return ret;        *got_frame = 1;    }    return avpkt->size;err:    memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);    return ret;}", "idx": 21685}
{"project": "qemu", "commit_id": "e62fbc54d459d4cc8e91dc0938383a7f4c13768c", "target": 1, "function": "static void ppc_cpu_class_init(ObjectClass *oc, void *data){    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);    CPUClass *cc = CPU_CLASS(oc);    DeviceClass *dc = DEVICE_CLASS(oc);    pcc->parent_realize = dc->realize;    dc->realize = ppc_cpu_realizefn;    dc->unrealize = ppc_cpu_unrealizefn;    pcc->parent_reset = cc->reset;    cc->reset = ppc_cpu_reset;    cc->class_by_name = ppc_cpu_class_by_name;    cc->do_interrupt = ppc_cpu_do_interrupt;    cc->dump_state = ppc_cpu_dump_state;    cc->dump_statistics = ppc_cpu_dump_statistics;    cc->set_pc = ppc_cpu_set_pc;    cc->gdb_read_register = ppc_cpu_gdb_read_register;    cc->gdb_write_register = ppc_cpu_gdb_write_register;#ifndef CONFIG_USER_ONLY    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;    cc->vmsd = &vmstate_ppc_cpu;    cc->gdb_num_core_regs = 71;    cc->gdb_core_xml_file = \"power64-core.xml\";#else    cc->gdb_core_xml_file = \"power-core.xml\";}", "idx": 21689}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void m5208_timer_write(void *opaque, target_phys_addr_t offset,                              uint64_t value, unsigned size){    m5208_timer_state *s = (m5208_timer_state *)opaque;    int prescale;    int limit;    switch (offset) {    case 0:        /* The PIF bit is set-to-clear.  */        if (value & PCSR_PIF) {            s->pcsr &= ~PCSR_PIF;            value &= ~PCSR_PIF;        }        /* Avoid frobbing the timer if we're just twiddling IRQ bits. */        if (((s->pcsr ^ value) & ~PCSR_PIE) == 0) {            s->pcsr = value;            m5208_timer_update(s);            return;        }        if (s->pcsr & PCSR_EN)            ptimer_stop(s->timer);        s->pcsr = value;        prescale = 1 << ((s->pcsr & PCSR_PRE_MASK) >> PCSR_PRE_SHIFT);        ptimer_set_freq(s->timer, (SYS_FREQ / 2) / prescale);        if (s->pcsr & PCSR_RLD)            limit = s->pmr;        else            limit = 0xffff;        ptimer_set_limit(s->timer, limit, 0);        if (s->pcsr & PCSR_EN)            ptimer_run(s->timer, 0);        break;    case 2:        s->pmr = value;        s->pcsr &= ~PCSR_PIF;        if ((s->pcsr & PCSR_RLD) == 0) {            if (s->pcsr & PCSR_OVW)                ptimer_set_count(s->timer, value);        } else {            ptimer_set_limit(s->timer, value, s->pcsr & PCSR_OVW);        }        break;    case 4:        break;    default:        hw_error(\"m5208_timer_write: Bad offset 0x%x\\n\", (int)offset);        break;    }    m5208_timer_update(s);}", "idx": 21745}
{"project": "FFmpeg", "commit_id": "834b3760a7ca112573e813bd6c3573a8c0daf4ed", "target": 0, "function": "int swr_init(SwrContext *s){    s->in_buffer_index= 0;    s->in_buffer_count= 0;    s->resample_in_constraint= 0;    free_temp(&s->postin);    free_temp(&s->midbuf);    free_temp(&s->preout);    free_temp(&s->in_buffer);    swr_audio_convert_free(&s-> in_convert);    swr_audio_convert_free(&s->out_convert);    s-> in.planar= s-> in_sample_fmt >= 0x100;    s->out.planar= s->out_sample_fmt >= 0x100;    s-> in_sample_fmt &= 0xFF;    s->out_sample_fmt &= 0xFF;    //We assume AVOptions checked the various values and the defaults where allowed    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));        return AVERROR(EINVAL);    }    //FIXME should we allow/support using FLT on material that doesnt need it ?    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){        s->int_sample_fmt= AV_SAMPLE_FMT_S16;    }else        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){        s->resample = swr_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);    }else        swr_resample_free(&s->resample);    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME        return -1;    }    if(!s-> in_ch_layout)        s-> in_ch_layout= guess_layout(s->in.ch_count);    if(!s->out_ch_layout)        s->out_ch_layout= guess_layout(s->out.ch_count);    s->rematrix= s->out_ch_layout  !=s->in_ch_layout;#define RSC 1 //FIXME finetune    if(!s-> in.ch_count)        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);    if(!s->out.ch_count)        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);av_assert0(s-> in.ch_count);av_assert0(s->out.ch_count);    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;    s-> in.bps= av_get_bits_per_sample_fmt(s-> in_sample_fmt)/8;    s->int_bps= av_get_bits_per_sample_fmt(s->int_sample_fmt)/8;    s->out.bps= av_get_bits_per_sample_fmt(s->out_sample_fmt)/8;    s->in_convert = swr_audio_convert_alloc(s->int_sample_fmt,                                            s-> in_sample_fmt, s-> in.ch_count, 0);    s->out_convert= swr_audio_convert_alloc(s->out_sample_fmt,                                            s->int_sample_fmt, s->out.ch_count, 0);    s->postin= s->in;    s->preout= s->out;    s->midbuf= s->in;    s->in_buffer= s->in;    if(!s->resample_first){        s->midbuf.ch_count= s->out.ch_count;        s->in_buffer.ch_count = s->out.ch_count;    }    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;    if(s->rematrix && swr_rematrix_init(s)<0)        return -1;    return 0;}", "idx": 21759}
{"project": "qemu", "commit_id": "dfd917a9c2bed578c31043126c9f558190bf21e4", "target": 1, "function": "static void colo_compare_finalize(Object *obj){    CompareState *s = COLO_COMPARE(obj);    qemu_chr_fe_deinit(&s->chr_pri_in);    qemu_chr_fe_deinit(&s->chr_sec_in);    qemu_chr_fe_deinit(&s->chr_out);    g_queue_free(&s->conn_list);    if (qemu_thread_is_self(&s->thread)) {        /* compare connection */        g_queue_foreach(&s->conn_list, colo_compare_connection, s);        qemu_thread_join(&s->thread);    }    g_free(s->pri_indev);    g_free(s->sec_indev);    g_free(s->outdev);}", "idx": 21774}
{"project": "qemu", "commit_id": "81c219ac6ce0d6182e35f3976f2caa4cefcaf9f0", "target": 1, "function": "static int64_t coroutine_fn bdrv_co_get_block_status(BlockDriverState *bs,                                                     int64_t sector_num,                                                     int nb_sectors, int *pnum,                                                     BlockDriverState **file){    int64_t total_sectors;    int64_t n;    int64_t ret, ret2;    total_sectors = bdrv_nb_sectors(bs);    if (total_sectors < 0) {        return total_sectors;    }    if (sector_num >= total_sectors) {        *pnum = 0;        return BDRV_BLOCK_EOF;    }    n = total_sectors - sector_num;    if (n < nb_sectors) {        nb_sectors = n;    }    if (!bs->drv->bdrv_co_get_block_status) {        *pnum = nb_sectors;        ret = BDRV_BLOCK_DATA | BDRV_BLOCK_ALLOCATED;        if (sector_num + nb_sectors == total_sectors) {            ret |= BDRV_BLOCK_EOF;        }        if (bs->drv->protocol_name) {            ret |= BDRV_BLOCK_OFFSET_VALID | (sector_num * BDRV_SECTOR_SIZE);        }        return ret;    }    *file = NULL;    bdrv_inc_in_flight(bs);    ret = bs->drv->bdrv_co_get_block_status(bs, sector_num, nb_sectors, pnum,                                            file);    if (ret < 0) {        *pnum = 0;        goto out;    }    if (ret & BDRV_BLOCK_RAW) {        assert(ret & BDRV_BLOCK_OFFSET_VALID);        ret = bdrv_co_get_block_status(*file, ret >> BDRV_SECTOR_BITS,                                       *pnum, pnum, file);        goto out;    }    if (ret & (BDRV_BLOCK_DATA | BDRV_BLOCK_ZERO)) {        ret |= BDRV_BLOCK_ALLOCATED;    } else {        if (bdrv_unallocated_blocks_are_zero(bs)) {            ret |= BDRV_BLOCK_ZERO;        } else if (bs->backing) {            BlockDriverState *bs2 = bs->backing->bs;            int64_t nb_sectors2 = bdrv_nb_sectors(bs2);            if (nb_sectors2 >= 0 && sector_num >= nb_sectors2) {                ret |= BDRV_BLOCK_ZERO;            }        }    }    if (*file && *file != bs &&        (ret & BDRV_BLOCK_DATA) && !(ret & BDRV_BLOCK_ZERO) &&        (ret & BDRV_BLOCK_OFFSET_VALID)) {        BlockDriverState *file2;        int file_pnum;        ret2 = bdrv_co_get_block_status(*file, ret >> BDRV_SECTOR_BITS,                                        *pnum, &file_pnum, &file2);        if (ret2 >= 0) {            /* Ignore errors.  This is just providing extra information, it             * is useful but not necessary.             */            if (ret2 & BDRV_BLOCK_EOF &&                (!file_pnum || ret2 & BDRV_BLOCK_ZERO)) {                /*                 * It is valid for the format block driver to read                 * beyond the end of the underlying file's current                 * size; such areas read as zero.                 */                ret |= BDRV_BLOCK_ZERO;            } else {                /* Limit request to the range reported by the protocol driver */                *pnum = file_pnum;                ret |= (ret2 & BDRV_BLOCK_ZERO);            }        }    }out:    bdrv_dec_in_flight(bs);    if (ret >= 0 && sector_num + *pnum == total_sectors) {        ret |= BDRV_BLOCK_EOF;    }    return ret;}", "idx": 21808}
{"project": "FFmpeg", "commit_id": "ce99efc6ffedc7a8fbcc23690d9ff9f7e6f4bf44", "target": 0, "function": "matroska_read_close (AVFormatContext *s){    MatroskaDemuxContext *matroska = s->priv_data;    int n = 0;    if (matroska->writing_app)        av_free(matroska->writing_app);    if (matroska->muxing_app)        av_free(matroska->muxing_app);    if (matroska->index)        av_free(matroska->index);    if (matroska->packets != NULL) {        for (n = 0; n < matroska->num_packets; n++) {            av_free_packet(matroska->packets[n]);            av_free(matroska->packets[n]);        }        av_free(matroska->packets);    }    for (n = 0; n < matroska->num_tracks; n++) {        MatroskaTrack *track = matroska->tracks[n];        if (track->codec_id)            av_free(track->codec_id);        if (track->codec_name)            av_free(track->codec_name);        if (track->codec_priv)            av_free(track->codec_priv);        if (track->name)            av_free(track->name);        if (track->language)            av_free(track->language);        av_free(track);    }    memset(matroska, 0, sizeof(MatroskaDemuxContext));    return 0;}", "idx": 21842}
{"project": "qemu", "commit_id": "55b4e80b047300e1512df02887b7448ba3786b62", "target": 0, "function": "static void phys_section_destroy(MemoryRegion *mr){    memory_region_unref(mr);    if (mr->subpage) {        subpage_t *subpage = container_of(mr, subpage_t, iomem);        object_unref(OBJECT(&subpage->iomem));        g_free(subpage);    }}", "idx": 21853}
{"project": "FFmpeg", "commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "target": 1, "function": "int ff_h264_slice_context_init(H264Context *h, H264SliceContext *sl){    ERContext *er = &sl->er;    int mb_array_size = h->mb_height * h->mb_stride;    int y_size  = (2 * h->mb_width + 1) * (2 * h->mb_height + 1);    int c_size  = h->mb_stride * (h->mb_height + 1);    int yc_size = y_size + 2   * c_size;    int x, y, i;    sl->ref_cache[0][scan8[5]  + 1] =    sl->ref_cache[0][scan8[7]  + 1] =    sl->ref_cache[0][scan8[13] + 1] =    sl->ref_cache[1][scan8[5]  + 1] =    sl->ref_cache[1][scan8[7]  + 1] =    sl->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE;    if (sl != h->slice_ctx) {        memset(er, 0, sizeof(*er));    } else    if (CONFIG_ERROR_RESILIENCE) {        /* init ER */        er->avctx          = h->avctx;        er->decode_mb      = h264_er_decode_mb;        er->opaque         = h;        er->quarter_sample = 1;        er->mb_num      = h->mb_num;        er->mb_width    = h->mb_width;        er->mb_height   = h->mb_height;        er->mb_stride   = h->mb_stride;        er->b8_stride   = h->mb_width * 2 + 1;        // error resilience code looks cleaner with this        FF_ALLOCZ_OR_GOTO(h->avctx, er->mb_index2xy,                          (h->mb_num + 1) * sizeof(int), fail);        for (y = 0; y < h->mb_height; y++)            for (x = 0; x < h->mb_width; x++)                er->mb_index2xy[x + y * h->mb_width] = x + y * h->mb_stride;        er->mb_index2xy[h->mb_height * h->mb_width] = (h->mb_height - 1) *                                                      h->mb_stride + h->mb_width;        FF_ALLOCZ_OR_GOTO(h->avctx, er->error_status_table,                          mb_array_size * sizeof(uint8_t), fail);        FF_ALLOC_OR_GOTO(h->avctx, er->er_temp_buffer,                         h->mb_height * h->mb_stride, fail);        FF_ALLOCZ_OR_GOTO(h->avctx, sl->dc_val_base,                          yc_size * sizeof(int16_t), fail);        er->dc_val[0] = sl->dc_val_base + h->mb_width * 2 + 2;        er->dc_val[1] = sl->dc_val_base + y_size + h->mb_stride + 1;        er->dc_val[2] = er->dc_val[1] + c_size;        for (i = 0; i < yc_size; i++)            sl->dc_val_base[i] = 1024;    }    return 0;fail:    return AVERROR(ENOMEM); // ff_h264_free_tables will clean up for us}", "idx": 21911}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "function": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,                                        const AVFrame *frame, int *got_packet){    int enc_size = 0;    SchroEncoderParams *p_schro_params = avctx->priv_data;    SchroEncoder *encoder = p_schro_params->encoder;    struct FFSchroEncodedFrame *p_frame_output = NULL;    int go = 1;    SchroBuffer *enc_buf;    int presentation_frame;    int parse_code;    int last_frame_in_sequence = 0;    int pkt_size, ret;    if (!frame) {        /* Push end of sequence if not already signalled. */        if (!p_schro_params->eos_signalled) {            schro_encoder_end_of_stream(encoder);            p_schro_params->eos_signalled = 1;        }    } else {        /* Allocate frame data to schro input buffer. */        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);        if (!in_frame)            return AVERROR(ENOMEM);        /* Load next frame. */        schro_encoder_push_frame(encoder, in_frame);    }    if (p_schro_params->eos_pulled)        go = 0;    /* Now check to see if we have any output from the encoder. */    while (go) {        int err;        SchroStateEnum state;        state = schro_encoder_wait(encoder);        switch (state) {        case SCHRO_STATE_HAVE_BUFFER:        case SCHRO_STATE_END_OF_STREAM:            enc_buf = schro_encoder_pull(encoder, &presentation_frame);            if (enc_buf->length <= 0)                return AVERROR_BUG;            parse_code = enc_buf->data[4];            /* All non-frame data is prepended to actual frame data to             * be able to set the pts correctly. So we don't write data             * to the frame output queue until we actually have a frame             */            if ((err = av_reallocp(&p_schro_params->enc_buf,                                   p_schro_params->enc_buf_size +                                   enc_buf->length)) < 0) {                p_schro_params->enc_buf_size = 0;                return err;            }            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,                   enc_buf->data, enc_buf->length);            p_schro_params->enc_buf_size += enc_buf->length;            if (state == SCHRO_STATE_END_OF_STREAM) {                p_schro_params->eos_pulled = 1;                go = 0;            }            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {                schro_buffer_unref(enc_buf);                break;            }            /* Create output frame. */            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));            if (!p_frame_output)                return AVERROR(ENOMEM);            /* Set output data. */            p_frame_output->size     = p_schro_params->enc_buf_size;            p_frame_output->p_encbuf = p_schro_params->enc_buf;            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))                p_frame_output->key_frame = 1;            /* Parse the coded frame number from the bitstream. Bytes 14             * through 17 represent the frame number. */            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,                                     p_frame_output);            p_schro_params->enc_buf_size = 0;            p_schro_params->enc_buf      = NULL;            schro_buffer_unref(enc_buf);            break;        case SCHRO_STATE_NEED_FRAME:            go = 0;            break;        case SCHRO_STATE_AGAIN:            break;        default:            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");            return -1;        }    }    /* Copy 'next' frame in queue. */    if (p_schro_params->enc_frame_queue.size == 1 &&        p_schro_params->eos_pulled)        last_frame_in_sequence = 1;    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);    if (!p_frame_output)        return 0;    pkt_size = p_frame_output->size;    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)        pkt_size += p_schro_params->enc_buf_size;    if ((ret = ff_alloc_packet2(avctx, pkt, pkt_size, 0)) < 0)        goto error;    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);#if FF_API_CODED_FRAMEFF_DISABLE_DEPRECATION_WARNINGS    avctx->coded_frame->key_frame = p_frame_output->key_frame;    avctx->coded_frame->pts = p_frame_output->frame_num;FF_ENABLE_DEPRECATION_WARNINGS#endif    /* Use the frame number of the encoded frame as the pts. It is OK to     * do so since Dirac is a constant frame rate codec. It expects input     * to be of constant frame rate. */    pkt->pts = p_frame_output->frame_num;    pkt->dts = p_schro_params->dts++;    enc_size = p_frame_output->size;    /* Append the end of sequence information to the last frame in the     * sequence. */    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,               p_schro_params->enc_buf_size);        enc_size += p_schro_params->enc_buf_size;        av_freep(&p_schro_params->enc_buf);        p_schro_params->enc_buf_size = 0;    }    if (p_frame_output->key_frame)        pkt->flags |= AV_PKT_FLAG_KEY;    *got_packet = 1;error:    /* free frame */    libschroedinger_free_frame(p_frame_output);    return ret;}", "idx": 21917}
{"project": "FFmpeg", "commit_id": "d51d6ae9c41310d62f4582c07c2fad26d41eeca6", "target": 1, "function": "static int vc1_decode_p_mb_intfr(VC1Context *v){    MpegEncContext *s = &v->s;    GetBitContext *gb = &s->gb;    int i;    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;    int cbp = 0; /* cbp decoding stuff */    int mqdiff, mquant; /* MB quantization */    int ttmb = v->ttfrm; /* MB Transform type */    int mb_has_coeffs = 1; /* last_flag */    int dmv_x, dmv_y; /* Differential MV components */    int val; /* temp value */    int first_block = 1;    int dst_idx, off;    int skipped, fourmv = 0, twomv = 0;    int block_cbp = 0, pat, block_tt = 0;    int idx_mbmode = 0, mvbp;    int stride_y, fieldtx;    mquant = v->pq; /* Loosy initialization */    if (v->skip_is_raw)        skipped = get_bits1(gb);    else        skipped = v->s.mbskip_table[mb_pos];    if (!skipped) {        if (v->fourmvswitch)            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_4MV_MBMODE_VLC_BITS, 2); // try getting this done        else            idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); // in a single line        switch (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0]) {        /* store the motion vector type in a flag (useful later) */        case MV_PMODE_INTFR_4MV:            fourmv = 1;            v->blk_mv_type[s->block_index[0]] = 0;            v->blk_mv_type[s->block_index[1]] = 0;            v->blk_mv_type[s->block_index[2]] = 0;            v->blk_mv_type[s->block_index[3]] = 0;            break;        case MV_PMODE_INTFR_4MV_FIELD:            fourmv = 1;            v->blk_mv_type[s->block_index[0]] = 1;            v->blk_mv_type[s->block_index[1]] = 1;            v->blk_mv_type[s->block_index[2]] = 1;            v->blk_mv_type[s->block_index[3]] = 1;            break;        case MV_PMODE_INTFR_2MV_FIELD:            twomv = 1;            v->blk_mv_type[s->block_index[0]] = 1;            v->blk_mv_type[s->block_index[1]] = 1;            v->blk_mv_type[s->block_index[2]] = 1;            v->blk_mv_type[s->block_index[3]] = 1;            break;        case MV_PMODE_INTFR_1MV:            v->blk_mv_type[s->block_index[0]] = 0;            v->blk_mv_type[s->block_index[1]] = 0;            v->blk_mv_type[s->block_index[2]] = 0;            v->blk_mv_type[s->block_index[3]] = 0;            break;        }        if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { // intra MB            s->current_picture.f.motion_val[1][s->block_index[0]][0] = 0;            s->current_picture.f.motion_val[1][s->block_index[0]][1] = 0;            s->current_picture.f.mb_type[mb_pos]                     = MB_TYPE_INTRA;            s->mb_intra = v->is_intra[s->mb_x] = 1;            for (i = 0; i < 6; i++)                v->mb_type[0][s->block_index[i]] = 1;            fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb);            mb_has_coeffs = get_bits1(gb);            if (mb_has_coeffs)                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);            v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb);            GET_MQUANT();            s->current_picture.f.qscale_table[mb_pos] = mquant;            /* Set DC scale - y and c use the same (not sure if necessary here) */            s->y_dc_scale = s->y_dc_scale_table[mquant];            s->c_dc_scale = s->c_dc_scale_table[mquant];            dst_idx = 0;            for (i = 0; i < 6; i++) {                s->dc_val[0][s->block_index[i]] = 0;                dst_idx += i >> 2;                val = ((cbp >> (5 - i)) & 1);                v->mb_type[0][s->block_index[i]] = s->mb_intra;                v->a_avail = v->c_avail = 0;                if (i == 2 || i == 3 || !s->first_slice_line)                    v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];                if (i == 1 || i == 3 || s->mb_x)                    v->c_avail = v->mb_type[0][s->block_index[i] - 1];                vc1_decode_intra_block(v, s->block[i], i, val, mquant,                                       (i & 4) ? v->codingset2 : v->codingset);                if ((i>3) && (s->flags & CODEC_FLAG_GRAY)) continue;                v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);                if (i < 4) {                    stride_y = s->linesize << fieldtx;                    off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize;                } else {                    stride_y = s->uvlinesize;                    off = 0;                }                s->dsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, stride_y);                //TODO: loop filter            }        } else { // inter MB            mb_has_coeffs = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][3];            if (mb_has_coeffs)                cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);            if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) {                v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1);            } else {                if ((ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV)                    || (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV_FIELD)) {                    v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);                }            }            s->mb_intra = v->is_intra[s->mb_x] = 0;            for (i = 0; i < 6; i++)                v->mb_type[0][s->block_index[i]] = 0;            fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][1];            /* for all motion vector read MVDATA and motion compensate each block */            dst_idx = 0;            if (fourmv) {                mvbp = v->fourmvbp;                for (i = 0; i < 6; i++) {                    if (i < 4) {                        val   = ((mvbp >> (3 - i)) & 1);                        if (val) {                            get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                        }                        vc1_pred_mv_intfr(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0]);                        vc1_mc_4mv_luma(v, i, 0);                    } else if (i == 4) {                        vc1_mc_4mv_chroma4(v);                    }                }            } else if (twomv) {                mvbp  = v->twomvbp;                if (mvbp & 2) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0]);                vc1_mc_4mv_luma(v, 0, 0);                vc1_mc_4mv_luma(v, 1, 0);                if (mvbp & 1) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0]);                vc1_mc_4mv_luma(v, 2, 0);                vc1_mc_4mv_luma(v, 3, 0);                vc1_mc_4mv_chroma4(v);            } else {                mvbp = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][2];                if (mvbp) {                    get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0);                }                vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0]);                vc1_mc_1mv(v, 0);            }            if (cbp)                GET_MQUANT();  // p. 227            s->current_picture.f.qscale_table[mb_pos] = mquant;            if (!v->ttmbf && cbp)                ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);            for (i = 0; i < 6; i++) {                s->dc_val[0][s->block_index[i]] = 0;                dst_idx += i >> 2;                val = ((cbp >> (5 - i)) & 1);                if (!fieldtx)                    off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);                else                    off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize));                if (val) {                    pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,                                             first_block, s->dest[dst_idx] + off,                                             (i & 4) ? s->uvlinesize : (s->linesize << fieldtx),                                             (i & 4) && (s->flags & CODEC_FLAG_GRAY), &block_tt);                    block_cbp |= pat << (i << 2);                    if (!v->ttmbf && ttmb < 8)                        ttmb = -1;                    first_block = 0;                }            }        }    } else { // skipped        s->mb_intra = v->is_intra[s->mb_x] = 0;        for (i = 0; i < 6; i++) {            v->mb_type[0][s->block_index[i]] = 0;            s->dc_val[0][s->block_index[i]] = 0;        }        s->current_picture.f.mb_type[mb_pos]      = MB_TYPE_SKIP;        s->current_picture.f.qscale_table[mb_pos] = 0;        v->blk_mv_type[s->block_index[0]] = 0;        v->blk_mv_type[s->block_index[1]] = 0;        v->blk_mv_type[s->block_index[2]] = 0;        v->blk_mv_type[s->block_index[3]] = 0;        vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0]);        vc1_mc_1mv(v, 0);    }    if (s->mb_x == s->mb_width - 1)        memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0])*s->mb_stride);    return 0;}", "idx": 21940}
{"project": "qemu", "commit_id": "3ce21445387c64032a21ae73c995195307a28a36", "target": 1, "function": "static void usb_host_auto_check(void *unused){    struct USBHostDevice *s;    struct USBAutoFilter *f;    libusb_device **devs;    struct libusb_device_descriptor ddesc;    int unconnected = 0;    int i, n;    if (usb_host_init() != 0) {        return;    }    if (runstate_is_running()) {        n = libusb_get_device_list(ctx, &devs);        for (i = 0; i < n; i++) {            if (libusb_get_device_descriptor(devs[i], &ddesc) != 0) {                continue;            }            if (ddesc.bDeviceClass == LIBUSB_CLASS_HUB) {                continue;            }            QTAILQ_FOREACH(s, &hostdevs, next) {                f = &s->match;                if (f->bus_num > 0 &&                    f->bus_num != libusb_get_bus_number(devs[i])) {                    continue;                }                if (f->addr > 0 &&                    f->addr != libusb_get_device_address(devs[i])) {                    continue;                }                if (f->port != NULL) {                    char port[16] = \"-\";                    usb_host_get_port(devs[i], port, sizeof(port));                    if (strcmp(f->port, port) != 0) {                        continue;                    }                }                if (f->vendor_id > 0 &&                    f->vendor_id != ddesc.idVendor) {                    continue;                }                if (f->product_id > 0 &&                    f->product_id != ddesc.idProduct) {                    continue;                }                /* We got a match */                s->seen++;                if (s->errcount >= 3) {                    continue;                }                if (s->dh != NULL) {                    continue;                }                if (usb_host_open(s, devs[i]) < 0) {                    s->errcount++;                    continue;                }                break;            }        }        libusb_free_device_list(devs, 1);        QTAILQ_FOREACH(s, &hostdevs, next) {            if (s->dh == NULL) {                unconnected++;            }            if (s->seen == 0) {                if (s->dh) {                    usb_host_close(s);                }                s->errcount = 0;            }            s->seen = 0;        }#if 0        if (unconnected == 0) {            /* nothing to watch */            if (usb_auto_timer) {                timer_del(usb_auto_timer);                trace_usb_host_auto_scan_disabled();            }            return;        }#endif    }    if (!usb_vmstate) {        usb_vmstate = qemu_add_vm_change_state_handler(usb_host_vm_state, NULL);    }    if (!usb_auto_timer) {        usb_auto_timer = timer_new_ms(QEMU_CLOCK_REALTIME, usb_host_auto_check, NULL);        if (!usb_auto_timer) {            return;        }        trace_usb_host_auto_scan_enabled();    }    timer_mod(usb_auto_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 2000);}", "idx": 21963}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "function": "static av_cold int wmv2_decode_init(AVCodecContext *avctx){    Wmv2Context * const w= avctx->priv_data;    if(avctx->idct_algo==FF_IDCT_AUTO){        avctx->idct_algo=FF_IDCT_WMV2;    }    if(ff_msmpeg4_decode_init(avctx) < 0)        return -1;    ff_wmv2_common_init(w);    ff_intrax8_common_init(&w->x8,&w->s);    return 0;}", "idx": 21984}
{"project": "qemu", "commit_id": "5bfb723f07fde2caafa90cb40c102a4e36dfea9e", "target": 1, "function": "static void win32_rearm_timer(struct qemu_alarm_timer *t,                              int64_t nearest_delta_ns){    HANDLE hTimer = t->timer;    int nearest_delta_ms;    BOOLEAN success;    nearest_delta_ms = (nearest_delta_ns + 999999) / 1000000;    if (nearest_delta_ms < 1) {        nearest_delta_ms = 1;    }    success = ChangeTimerQueueTimer(NULL,                                    hTimer,                                    nearest_delta_ms,                                    3600000);    if (!success) {        fprintf(stderr, \"Failed to rearm win32 alarm timer: %ld\\n\",                GetLastError());        exit(-1);    }}", "idx": 21991}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "function": "static void arm_cpu_reset(CPUState *s){    ARMCPU *cpu = ARM_CPU(s);    ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);    CPUARMState *env = &cpu->env;    acc->parent_reset(s);    memset(env, 0, offsetof(CPUARMState, end_reset_fields));    g_hash_table_foreach(cpu->cp_regs, cp_reg_reset, cpu);    g_hash_table_foreach(cpu->cp_regs, cp_reg_check_reset, cpu);    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;    env->vfp.xregs[ARM_VFP_MVFR2] = cpu->mvfr2;    cpu->powered_off = cpu->start_powered_off;    s->halted = cpu->start_powered_off;    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';    }    if (arm_feature(env, ARM_FEATURE_AARCH64)) {        /* 64 bit CPUs always start in 64 bit mode */        env->aarch64 = 1;#if defined(CONFIG_USER_ONLY)        env->pstate = PSTATE_MODE_EL0t;        /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */        env->cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;        /* and to the FP/Neon instructions */        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 2, 3);#else        /* Reset into the highest available EL */        if (arm_feature(env, ARM_FEATURE_EL3)) {            env->pstate = PSTATE_MODE_EL3h;        } else if (arm_feature(env, ARM_FEATURE_EL2)) {            env->pstate = PSTATE_MODE_EL2h;        } else {            env->pstate = PSTATE_MODE_EL1h;        }        env->pc = cpu->rvbar;#endif    } else {#if defined(CONFIG_USER_ONLY)        /* Userspace expects access to cp10 and cp11 for FP/Neon */        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 4, 0xf);#endif    }#if defined(CONFIG_USER_ONLY)    env->uncached_cpsr = ARM_CPU_MODE_USR;    /* For user mode we must enable access to coprocessors */    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {        env->cp15.c15_cpar = 3;    } else if (arm_feature(env, ARM_FEATURE_XSCALE)) {        env->cp15.c15_cpar = 1;    }#else    /* SVC mode with interrupts disabled.  */    env->uncached_cpsr = ARM_CPU_MODE_SVC;    env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;    if (arm_feature(env, ARM_FEATURE_M)) {        uint32_t initial_msp; /* Loaded from 0x0 */        uint32_t initial_pc; /* Loaded from 0x4 */        uint8_t *rom;        /* For M profile we store FAULTMASK and PRIMASK in the         * PSTATE F and I bits; these are both clear at reset.         */        env->daif &= ~(PSTATE_I | PSTATE_F);        /* The reset value of this bit is IMPDEF, but ARM recommends         * that it resets to 1, so QEMU always does that rather than making         * it dependent on CPU model.         */        env->v7m.ccr = R_V7M_CCR_STKALIGN_MASK;        /* Unlike A/R profile, M profile defines the reset LR value */        env->regs[14] = 0xffffffff;        /* Load the initial SP and PC from the vector table at address 0 */        rom = rom_ptr(0);        if (rom) {            /* Address zero is covered by ROM which hasn't yet been             * copied into physical memory.             */            initial_msp = ldl_p(rom);            initial_pc = ldl_p(rom + 4);        } else {            /* Address zero not covered by a ROM blob, or the ROM blob             * is in non-modifiable memory and this is a second reset after             * it got copied into memory. In the latter case, rom_ptr             * will return a NULL pointer and we should use ldl_phys instead.             */            initial_msp = ldl_phys(s->as, 0);            initial_pc = ldl_phys(s->as, 4);        }        env->regs[13] = initial_msp & 0xFFFFFFFC;        env->regs[15] = initial_pc & ~1;        env->thumb = initial_pc & 1;    }    /* AArch32 has a hard highvec setting of 0xFFFF0000.  If we are currently     * executing as AArch32 then check if highvecs are enabled and     * adjust the PC accordingly.     */    if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {        env->regs[15] = 0xFFFF0000;    }    env->vfp.xregs[ARM_VFP_FPEXC] = 0;#endif    set_flush_to_zero(1, &env->vfp.standard_fp_status);    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);    set_default_nan_mode(1, &env->vfp.standard_fp_status);    set_float_detect_tininess(float_tininess_before_rounding,                              &env->vfp.fp_status);    set_float_detect_tininess(float_tininess_before_rounding,                              &env->vfp.standard_fp_status);#ifndef CONFIG_USER_ONLY    if (kvm_enabled()) {        kvm_arm_reset_vcpu(cpu);    }#endif    hw_breakpoint_update_all(cpu);    hw_watchpoint_update_all(cpu);}", "idx": 22052}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "function": "static inline int _find_pte (mmu_ctx_t *ctx, int is_64b, int h, int rw){    target_ulong base, pte0, pte1;    int i, good = -1;    int ret, r;    ret = -1; /* No entry found */    base = ctx->pg_addr[h];    for (i = 0; i < 8; i++) {#if defined(TARGET_PPC64)        if (is_64b) {            pte0 = ldq_phys(base + (i * 16));            pte1 =  ldq_phys(base + (i * 16) + 8);            r = pte64_check(ctx, pte0, pte1, h, rw);        } else#endif        {            pte0 = ldl_phys(base + (i * 8));            pte1 =  ldl_phys(base + (i * 8) + 4);            r = pte32_check(ctx, pte0, pte1, h, rw);        }#if defined (DEBUG_MMU)        if (loglevel != 0) {            fprintf(logfile, \"Load pte from 0x\" ADDRX \" => 0x\" ADDRX                    \" 0x\" ADDRX \" %d %d %d 0x\" ADDRX \"\\n\",                    base + (i * 8), pte0, pte1,                    (int)(pte0 >> 31), h, (int)((pte0 >> 6) & 1), ctx->ptem);        }#endif        switch (r) {        case -3:            /* PTE inconsistency */            return -1;        case -2:            /* Access violation */            ret = -2;            good = i;            break;        case -1:        default:            /* No PTE match */            break;        case 0:            /* access granted */            /* XXX: we should go on looping to check all PTEs consistency             *      but if we can speed-up the whole thing as the             *      result would be undefined if PTEs are not consistent.             */            ret = 0;            good = i;            goto done;        }    }    if (good != -1) {    done:#if defined (DEBUG_MMU)        if (loglevel != 0) {            fprintf(logfile, \"found PTE at addr 0x\" PADDRX \" prot=0x%01x \"                    \"ret=%d\\n\",                    ctx->raddr, ctx->prot, ret);        }#endif        /* Update page flags */        pte1 = ctx->raddr;        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {#if defined(TARGET_PPC64)            if (is_64b) {                stq_phys_notdirty(base + (good * 16) + 8, pte1);            } else#endif            {                stl_phys_notdirty(base + (good * 8) + 4, pte1);            }        }    }    return ret;}", "idx": 22055}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "function": "static int vhost_net_start_one(struct vhost_net *net,                               VirtIODevice *dev,                               int vq_index){    struct vhost_vring_file file = { };    int r;    if (net->dev.started) {        return 0;    }    net->dev.nvqs = 2;    net->dev.vqs = net->vqs;    net->dev.vq_index = vq_index;    r = vhost_dev_enable_notifiers(&net->dev, dev);    if (r < 0) {        goto fail_notifiers;    }    r = vhost_dev_start(&net->dev, dev);    if (r < 0) {        goto fail_start;    }    if (net->nc->info->poll) {        net->nc->info->poll(net->nc, false);    }    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {        qemu_set_fd_handler(net->backend, NULL, NULL, NULL);        file.fd = net->backend;        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {            const VhostOps *vhost_ops = net->dev.vhost_ops;            r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,                                      &file);            if (r < 0) {                r = -errno;                goto fail;            }        }    }    return 0;fail:    file.fd = -1;    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {        while (file.index-- > 0) {            const VhostOps *vhost_ops = net->dev.vhost_ops;            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,                                          &file);            assert(r >= 0);        }    }    if (net->nc->info->poll) {        net->nc->info->poll(net->nc, true);    }    vhost_dev_stop(&net->dev, dev);fail_start:    vhost_dev_disable_notifiers(&net->dev, dev);fail_notifiers:    return r;}", "idx": 22072}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "function": "static void kvm_ioapic_class_init(ObjectClass *klass, void *data){    IOAPICCommonClass *k = IOAPIC_COMMON_CLASS(klass);    DeviceClass *dc = DEVICE_CLASS(klass);    k->realize   = kvm_ioapic_realize;    k->pre_save  = kvm_ioapic_get;    k->post_load = kvm_ioapic_put;    dc->reset    = kvm_ioapic_reset;    dc->props    = kvm_ioapic_properties;}", "idx": 22127}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static void grlib_apbuart_write(void *opaque, target_phys_addr_t addr,                                uint64_t value, unsigned size){    UART          *uart = opaque;    unsigned char  c    = 0;    addr &= 0xff;    /* Unit registers */    switch (addr) {    case DATA_OFFSET:    case DATA_OFFSET + 3:       /* When only one byte write */        c = value & 0xFF;        qemu_chr_fe_write(uart->chr, &c, 1);        return;    case STATUS_OFFSET:        /* Read Only */        return;    case CONTROL_OFFSET:        uart->control = value;        return;    case SCALER_OFFSET:        /* Not supported */        return;    default:        break;    }    trace_grlib_apbuart_writel_unknown(addr, value);}", "idx": 22208}
{"project": "qemu", "commit_id": "e6b3c8ca0222f6633516c0461a713e7bddc4f076", "target": 1, "function": "static void versatile_init(ram_addr_t ram_size,                     const char *boot_device,                     const char *kernel_filename, const char *kernel_cmdline,                     const char *initrd_filename, const char *cpu_model,                     int board_id){    CPUState *env;    ram_addr_t ram_offset;    qemu_irq *cpu_pic;    qemu_irq pic[32];    qemu_irq sic[32];    DeviceState *dev;    PCIBus *pci_bus;    NICInfo *nd;    int n;    int done_smc = 0;    if (!cpu_model)        cpu_model = \"arm926\";    env = cpu_init(cpu_model);    if (!env) {        fprintf(stderr, \"Unable to find CPU definition\\n\");        exit(1);    }    ram_offset = qemu_ram_alloc(NULL, \"versatile.ram\", ram_size);    /* ??? RAM should repeat to fill physical memory space.  */    /* SDRAM at address zero.  */    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);    arm_sysctl_init(0x10000000, 0x41007004, 0x02000000);    cpu_pic = arm_pic_init_cpu(env);    dev = sysbus_create_varargs(\"pl190\", 0x10140000,                                cpu_pic[0], cpu_pic[1], NULL);    for (n = 0; n < 32; n++) {        pic[n] = qdev_get_gpio_in(dev, n);    }    dev = sysbus_create_simple(\"versatilepb_sic\", 0x10003000, NULL);    for (n = 0; n < 32; n++) {        sysbus_connect_irq(sysbus_from_qdev(dev), n, pic[n]);        sic[n] = qdev_get_gpio_in(dev, n);    }    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, sic[3]);    sysbus_create_simple(\"pl050_mouse\", 0x10007000, sic[4]);    dev = sysbus_create_varargs(\"versatile_pci\", 0x40000000,                                sic[27], sic[28], sic[29], sic[30], NULL);    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");    /* The Versatile PCI bridge does not provide access to PCI IO space,       so many of the qemu PCI devices are not useable.  */    for(n = 0; n < nb_nics; n++) {        nd = &nd_table[n];        if ((!nd->model && !done_smc) || strcmp(nd->model, \"smc91c111\") == 0) {            smc91c111_init(nd, 0x10010000, sic[25]);            done_smc = 1;        } else {            pci_nic_init_nofail(nd, \"rtl8139\", NULL);        }    }    if (usb_enabled) {        usb_ohci_init_pci(pci_bus, -1);    }    n = drive_get_max_bus(IF_SCSI);    while (n >= 0) {        pci_create_simple(pci_bus, -1, \"lsi53c895a\");        n--;    }    sysbus_create_simple(\"pl011\", 0x101f1000, pic[12]);    sysbus_create_simple(\"pl011\", 0x101f2000, pic[13]);    sysbus_create_simple(\"pl011\", 0x101f3000, pic[14]);    sysbus_create_simple(\"pl011\", 0x10009000, sic[6]);    sysbus_create_simple(\"pl080\", 0x10130000, pic[17]);    sysbus_create_simple(\"sp804\", 0x101e2000, pic[4]);    sysbus_create_simple(\"sp804\", 0x101e3000, pic[5]);    /* The versatile/PB actually has a modified Color LCD controller       that includes hardware cursor support from the PL111.  */    sysbus_create_simple(\"pl110_versatile\", 0x10120000, pic[16]);    sysbus_create_varargs(\"pl181\", 0x10005000, sic[22], sic[1], NULL);    sysbus_create_varargs(\"pl181\", 0x1000b000, sic[23], sic[2], NULL);    /* Add PL031 Real Time Clock. */    sysbus_create_simple(\"pl031\", 0x101e8000, pic[10]);    /* Memory map for Versatile/PB:  */    /* 0x10000000 System registers.  */    /* 0x10001000 PCI controller config registers.  */    /* 0x10002000 Serial bus interface.  */    /*  0x10003000 Secondary interrupt controller.  */    /* 0x10004000 AACI (audio).  */    /*  0x10005000 MMCI0.  */    /*  0x10006000 KMI0 (keyboard).  */    /*  0x10007000 KMI1 (mouse).  */    /* 0x10008000 Character LCD Interface.  */    /*  0x10009000 UART3.  */    /* 0x1000a000 Smart card 1.  */    /*  0x1000b000 MMCI1.  */    /*  0x10010000 Ethernet.  */    /* 0x10020000 USB.  */    /* 0x10100000 SSMC.  */    /* 0x10110000 MPMC.  */    /*  0x10120000 CLCD Controller.  */    /*  0x10130000 DMA Controller.  */    /*  0x10140000 Vectored interrupt controller.  */    /* 0x101d0000 AHB Monitor Interface.  */    /* 0x101e0000 System Controller.  */    /* 0x101e1000 Watchdog Interface.  */    /* 0x101e2000 Timer 0/1.  */    /* 0x101e3000 Timer 2/3.  */    /* 0x101e4000 GPIO port 0.  */    /* 0x101e5000 GPIO port 1.  */    /* 0x101e6000 GPIO port 2.  */    /* 0x101e7000 GPIO port 3.  */    /* 0x101e8000 RTC.  */    /* 0x101f0000 Smart card 0.  */    /*  0x101f1000 UART0.  */    /*  0x101f2000 UART1.  */    /*  0x101f3000 UART2.  */    /* 0x101f4000 SSPI.  */    versatile_binfo.ram_size = ram_size;    versatile_binfo.kernel_filename = kernel_filename;    versatile_binfo.kernel_cmdline = kernel_cmdline;    versatile_binfo.initrd_filename = initrd_filename;    versatile_binfo.board_id = board_id;    arm_load_kernel(env, &versatile_binfo);}", "idx": 22243}
{"project": "qemu", "commit_id": "fa4ba923bd539647ace9d70d226a848bd6a89dac", "target": 1, "function": "static void kvm_mem_ioeventfd_add(MemoryListener *listener,                                  MemoryRegionSection *section,                                  bool match_data, uint64_t data,                                  EventNotifier *e){    int fd = event_notifier_get_fd(e);    int r;    r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space,                               data, true, int128_get64(section->size),                               match_data);    if (r < 0) {        abort();    }}", "idx": 22245}
{"project": "qemu", "commit_id": "51cc2e783af5586b2e742ce9e5b2762dc50ad325", "target": 1, "function": "CPUMIPSState *cpu_mips_init (const char *cpu_model){    CPUMIPSState *env;    const mips_def_t *def;    def = cpu_mips_find_by_name(cpu_model);    if (!def)        return NULL;    env = qemu_mallocz(sizeof(CPUMIPSState));    env->cpu_model = def;    cpu_exec_init(env);    env->cpu_model_str = cpu_model;    mips_tcg_init();    cpu_reset(env);    qemu_init_vcpu(env);    return env;}", "idx": 22260}
{"project": "qemu", "commit_id": "b68cb06093a36bd6fbd4d06cd62c08629fea2242", "target": 1, "function": "static void complete_collecting_data(Flash *s){    int i;    s->cur_addr = 0;    for (i = 0; i < get_addr_length(s); ++i) {        s->cur_addr <<= 8;        s->cur_addr |= s->data[i];    }    if (get_addr_length(s) == 3) {        s->cur_addr += s->ear * MAX_3BYTES_SIZE;    }    s->state = STATE_IDLE;    switch (s->cmd_in_progress) {    case DPP:    case QPP:    case PP:    case PP4:    case PP4_4:        s->state = STATE_PAGE_PROGRAM;        break;    case READ:    case READ4:    case FAST_READ:    case FAST_READ4:    case DOR:    case DOR4:    case QOR:    case QOR4:    case DIOR:    case DIOR4:    case QIOR:    case QIOR4:        s->state = STATE_READ;        break;    case ERASE_4K:    case ERASE4_4K:    case ERASE_32K:    case ERASE4_32K:    case ERASE_SECTOR:    case ERASE4_SECTOR:        flash_erase(s, s->cur_addr, s->cmd_in_progress);        break;    case WRSR:        switch (get_man(s)) {        case MAN_SPANSION:            s->quad_enable = !!(s->data[1] & 0x02);            break;        case MAN_MACRONIX:            s->quad_enable = extract32(s->data[0], 6, 1);            if (s->len > 1) {                s->four_bytes_address_mode = extract32(s->data[1], 5, 1);            }            break;        default:            break;        }        if (s->write_enable) {            s->write_enable = false;        }        break;    case EXTEND_ADDR_WRITE:        s->ear = s->data[0];        break;    case WNVCR:        s->nonvolatile_cfg = s->data[0] | (s->data[1] << 8);        break;    case WVCR:        s->volatile_cfg = s->data[0];        break;    case WEVCR:        s->enh_volatile_cfg = s->data[0];        break;    default:        break;    }}", "idx": 22263}
{"project": "FFmpeg", "commit_id": "c5d4f87e81111427c0952278ec247fa8ab1e6e52", "target": 1, "function": "static av_always_inline float quantize_and_encode_band_cost_template(                                struct AACEncContext *s,                                PutBitContext *pb, const float *in,                                const float *scaled, int size, int scale_idx,                                int cb, const float lambda, const float uplim,                                int *bits, int BT_ZERO, int BT_UNSIGNED,                                int BT_PAIR, int BT_ESC){    const int q_idx = POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512;    const float Q   = ff_aac_pow2sf_tab [q_idx];    const float Q34 = ff_aac_pow34sf_tab[q_idx];    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];    const float CLIPPED_ESCAPE = 165140.0f*IQ;    int i, j;    float cost = 0;    const int dim = BT_PAIR ? 2 : 4;    int resbits = 0;    const int range  = aac_cb_range[cb];    const int maxval = aac_cb_maxval[cb];    int off;    if (BT_ZERO) {        for (i = 0; i < size; i++)            cost += in[i]*in[i];        if (bits)            *bits = 0;        return cost * lambda;    }    if (!scaled) {        abs_pow34_v(s->scoefs, in, size);        scaled = s->scoefs;    }    quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval);    if (BT_UNSIGNED) {        off = 0;    } else {        off = maxval;    }    for (i = 0; i < size; i += dim) {        const float *vec;        int *quants = s->qcoefs + i;        int curidx = 0;        int curbits;        float rd = 0.0f;        for (j = 0; j < dim; j++) {            curidx *= range;            curidx += quants[j] + off;        }        curbits =  ff_aac_spectral_bits[cb-1][curidx];        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];        if (BT_UNSIGNED) {            for (j = 0; j < dim; j++) {                float t = fabsf(in[i+j]);                float di;                if (BT_ESC && vec[j] == 64.0f) { //FIXME: slow                    if (t >= CLIPPED_ESCAPE) {                        di = t - CLIPPED_ESCAPE;                        curbits += 21;                    } else {                        int c = av_clip_uintp2(quant(t, Q), 13);                        di = t - c*cbrtf(c)*IQ;                        curbits += av_log2(c)*2 - 4 + 1;                    }                } else {                    di = t - vec[j]*IQ;                }                if (vec[j] != 0.0f)                    curbits++;                rd += di*di;            }        } else {            for (j = 0; j < dim; j++) {                float di = in[i+j] - vec[j]*IQ;                rd += di*di;            }        }        cost    += rd * lambda + curbits;        resbits += curbits;        if (cost >= uplim)            return uplim;        if (pb) {            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);            if (BT_UNSIGNED)                for (j = 0; j < dim; j++)                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)                        put_bits(pb, 1, in[i+j] < 0.0f);            if (BT_ESC) {                for (j = 0; j < 2; j++) {                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {                        int coef = av_clip_uintp2(quant(fabsf(in[i+j]), Q), 13);                        int len = av_log2(coef);                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);                        put_bits(pb, len, coef & ((1 << len) - 1));                    }                }            }        }    }    if (bits)        *bits = resbits;    return cost;}", "idx": 22313}
{"project": "qemu", "commit_id": "e4937694b66d1468aec3cd95e90888f291c3f599", "target": 0, "function": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,                              const char *desc_file_path, QDict *options,                              Error **errp){    int ret;    int matches;    char access[11];    char type[11];    char fname[512];    const char *p = desc;    int64_t sectors = 0;    int64_t flat_offset;    char *extent_path;    BdrvChild *extent_file;    BDRVVmdkState *s = bs->opaque;    VmdkExtent *extent;    char extent_opt_prefix[32];    Error *local_err = NULL;    while (*p) {        /* parse extent line in one of below formats:         *         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET         * RW [size in sectors] SPARSE \"file-name.vmdk\"         * RW [size in sectors] VMFS \"file-name.vmdk\"         * RW [size in sectors] VMFSSPARSE \"file-name.vmdk\"         */        flat_offset = -1;        matches = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,                         access, &sectors, type, fname, &flat_offset);        if (matches < 4 || strcmp(access, \"RW\")) {            goto next_line;        } else if (!strcmp(type, \"FLAT\")) {            if (matches != 5 || flat_offset < 0) {                error_setg(errp, \"Invalid extent lines: \\n%s\", p);                return -EINVAL;            }        } else if (!strcmp(type, \"VMFS\")) {            if (matches == 4) {                flat_offset = 0;            } else {                error_setg(errp, \"Invalid extent lines:\\n%s\", p);                return -EINVAL;            }        } else if (matches != 4) {            error_setg(errp, \"Invalid extent lines:\\n%s\", p);            return -EINVAL;        }        if (sectors <= 0 ||            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||            (strcmp(access, \"RW\"))) {            goto next_line;        }        if (!path_is_absolute(fname) && !path_has_protocol(fname) &&            !desc_file_path[0])        {            error_setg(errp, \"Cannot use relative extent paths with VMDK \"                       \"descriptor file '%s'\", bs->file->bs->filename);            return -EINVAL;        }        extent_path = g_malloc0(PATH_MAX);        path_combine(extent_path, PATH_MAX, desc_file_path, fname);        ret = snprintf(extent_opt_prefix, 32, \"extents.%d\", s->num_extents);        assert(ret < 32);        extent_file = bdrv_open_child(extent_path, options, extent_opt_prefix,                                      bs, &child_file, false, &local_err);        g_free(extent_path);        if (local_err) {            error_propagate(errp, local_err);            return -EINVAL;        }        /* save to extents array */        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {            /* FLAT extent */            ret = vmdk_add_extent(bs, extent_file, true, sectors,                            0, 0, 0, 0, 0, &extent, errp);            if (ret < 0) {                bdrv_unref_child(bs, extent_file);                return ret;            }            extent->flat_start_offset = flat_offset << 9;        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/            char *buf = vmdk_read_desc(extent_file->bs, 0, errp);            if (!buf) {                ret = -EINVAL;            } else {                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf,                                       options, errp);            }            g_free(buf);            if (ret) {                bdrv_unref_child(bs, extent_file);                return ret;            }            extent = &s->extents[s->num_extents - 1];        } else {            error_setg(errp, \"Unsupported extent type '%s'\", type);            bdrv_unref_child(bs, extent_file);            return -ENOTSUP;        }        extent->type = g_strdup(type);next_line:        /* move to next line */        while (*p) {            if (*p == '\\n') {                p++;                break;            }            p++;        }    }    return 0;}", "idx": 22326}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "function": "AVFilter **av_filter_next(AVFilter **filter){    return filter ? ++filter : &registered_avfilters[0];}", "idx": 22344}
{"project": "qemu", "commit_id": "a083a89d7277f3268a251ce635d9aae5559242bd", "target": 1, "function": "void qemu_del_vlan_client(VLANClientState *vc){    if (vc->vlan) {        QTAILQ_REMOVE(&vc->vlan->clients, vc, next);    } else {        if (vc->send_queue) {            qemu_del_net_queue(vc->send_queue);        }        QTAILQ_REMOVE(&non_vlan_clients, vc, next);        if (vc->peer) {            vc->peer->peer = NULL;        }    }    if (vc->info->cleanup) {        vc->info->cleanup(vc);    }    qemu_free(vc->name);    qemu_free(vc->model);    qemu_free(vc);}", "idx": 22450}
{"project": "qemu", "commit_id": "52b4bb7383b32e4e7512f98c57738c8fc9cb35ba", "target": 0, "function": "static uint64_t lan9118_readl(void *opaque, hwaddr offset,                              unsigned size){    lan9118_state *s = (lan9118_state *)opaque;    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);    if (offset < 0x20) {        /* RX FIFO */        return rx_fifo_pop(s);    }    switch (offset) {    case 0x40:        return rx_status_fifo_pop(s);    case 0x44:        return s->rx_status_fifo[s->tx_status_fifo_head];    case 0x48:        return tx_status_fifo_pop(s);    case 0x4c:        return s->tx_status_fifo[s->tx_status_fifo_head];    case CSR_ID_REV:        return 0x01180001;    case CSR_IRQ_CFG:        return s->irq_cfg;    case CSR_INT_STS:        return s->int_sts;    case CSR_INT_EN:        return s->int_en;    case CSR_BYTE_TEST:        return 0x87654321;    case CSR_FIFO_INT:        return s->fifo_int;    case CSR_RX_CFG:        return s->rx_cfg;    case CSR_TX_CFG:        return s->tx_cfg;    case CSR_HW_CFG:        return s->hw_cfg;    case CSR_RX_DP_CTRL:        return 0;    case CSR_RX_FIFO_INF:        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);    case CSR_TX_FIFO_INF:        return (s->tx_status_fifo_used << 16)               | (s->tx_fifo_size - s->txp->fifo_used);    case CSR_PMT_CTRL:        return s->pmt_ctrl;    case CSR_GPIO_CFG:        return s->gpio_cfg;    case CSR_GPT_CFG:        return s->gpt_cfg;    case CSR_GPT_CNT:        return ptimer_get_count(s->timer);    case CSR_WORD_SWAP:        return s->word_swap;    case CSR_FREE_RUN:        return (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / 40) - s->free_timer_start;    case CSR_RX_DROP:        /* TODO: Implement dropped frames counter.  */        return 0;    case CSR_MAC_CSR_CMD:        return s->mac_cmd;    case CSR_MAC_CSR_DATA:        return s->mac_data;    case CSR_AFC_CFG:        return s->afc_cfg;    case CSR_E2P_CMD:        return s->e2p_cmd;    case CSR_E2P_DATA:        return s->e2p_data;    }    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);    return 0;}", "idx": 22486}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "function": "static int wav_init_out (HWVoiceOut *hw, struct audsettings *as){    WAVVoiceOut *wav = (WAVVoiceOut *) hw;    int bits16 = 0, stereo = 0;    uint8_t hdr[] = {        0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x41, 0x56,        0x45, 0x66, 0x6d, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00,        0x02, 0x00, 0x44, 0xac, 0x00, 0x00, 0x10, 0xb1, 0x02, 0x00, 0x04,        0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00    };    struct audsettings wav_as = conf.settings;    (void) as;    stereo = wav_as.nchannels == 2;    switch (wav_as.fmt) {    case AUD_FMT_S8:    case AUD_FMT_U8:        bits16 = 0;        break;    case AUD_FMT_S16:    case AUD_FMT_U16:        bits16 = 1;        break;    case AUD_FMT_S32:    case AUD_FMT_U32:        dolog (\"WAVE files can not handle 32bit formats\\n\");        return -1;    }    hdr[34] = bits16 ? 0x10 : 0x08;    wav_as.endianness = 0;    audio_pcm_init_info (&hw->info, &wav_as);    hw->samples = 1024;    wav->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);    if (!wav->pcm_buf) {        dolog (\"Could not allocate buffer (%d bytes)\\n\",               hw->samples << hw->info.shift);        return -1;    }    le_store (hdr + 22, hw->info.nchannels, 2);    le_store (hdr + 24, hw->info.freq, 4);    le_store (hdr + 28, hw->info.freq << (bits16 + stereo), 4);    le_store (hdr + 32, 1 << (bits16 + stereo), 2);    wav->f = fopen (conf.wav_path, \"wb\");    if (!wav->f) {        dolog (\"Failed to open wave file `%s'\\nReason: %s\\n\",               conf.wav_path, strerror (errno));        g_free (wav->pcm_buf);        wav->pcm_buf = NULL;        return -1;    }    if (fwrite (hdr, sizeof (hdr), 1, wav->f) != 1) {        dolog (\"wav_init_out: failed to write header\\nReason: %s\\n\",               strerror(errno));        return -1;    }    return 0;}", "idx": 22507}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "function": "static int mpegts_raw_read_packet(AVFormatContext *s,                                  AVPacket *pkt){    MpegTSContext *ts = s->priv_data;    int ret, i;    int64_t pcr_h, next_pcr_h, pos;    int pcr_l, next_pcr_l;    uint8_t pcr_buf[12];    uint8_t *data;    if (av_new_packet(pkt, TS_PACKET_SIZE) < 0)        return AVERROR(ENOMEM);    pkt->pos= avio_tell(s->pb);    ret = read_packet(s, pkt->data, ts->raw_packet_size, &data);    if (ret < 0) {        av_free_packet(pkt);        return ret;    }    if (data != pkt->data)        memcpy(pkt->data, data, ts->raw_packet_size);    finished_reading_packet(s, ts->raw_packet_size);    if (ts->mpeg2ts_compute_pcr) {        /* compute exact PCR for each packet */        if (parse_pcr(&pcr_h, &pcr_l, pkt->data) == 0) {            /* we read the next PCR (XXX: optimize it by using a bigger buffer */            pos = avio_tell(s->pb);            for(i = 0; i < MAX_PACKET_READAHEAD; i++) {                avio_seek(s->pb, pos + i * ts->raw_packet_size, SEEK_SET);                avio_read(s->pb, pcr_buf, 12);                if (parse_pcr(&next_pcr_h, &next_pcr_l, pcr_buf) == 0) {                    /* XXX: not precise enough */                    ts->pcr_incr = ((next_pcr_h - pcr_h) * 300 + (next_pcr_l - pcr_l)) /                        (i + 1);                    break;                }            }            avio_seek(s->pb, pos, SEEK_SET);            /* no next PCR found: we use previous increment */            ts->cur_pcr = pcr_h * 300 + pcr_l;        }        pkt->pts = ts->cur_pcr;        pkt->duration = ts->pcr_incr;        ts->cur_pcr += ts->pcr_incr;    }    pkt->stream_index = 0;    return 0;}", "idx": 22508}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "function": "static void gen_mfdcrx(DisasContext *ctx){#if defined(CONFIG_USER_ONLY)    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);#else    if (unlikely(ctx->pr)) {        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);        return;    }    /* NIP cannot be restored if the memory exception comes from an helper */    gen_update_nip(ctx, ctx->nip - 4);    gen_helper_load_dcr(cpu_gpr[rD(ctx->opcode)], cpu_env,                        cpu_gpr[rA(ctx->opcode)]);    /* Note: Rc update flag set leads to undefined state of Rc0 */#endif}", "idx": 22510}
{"project": "qemu", "commit_id": "958c717df97ea9ca47a2253b8371130fe5f22980", "target": 0, "function": "NBDClient *nbd_client_new(NBDExport *exp, int csock,                          void (*close)(NBDClient *)){    NBDClient *client;    client = g_malloc0(sizeof(NBDClient));    client->refcount = 1;    client->exp = exp;    client->sock = csock;    if (nbd_send_negotiate(client)) {        g_free(client);        return NULL;    }    client->close = close;    qemu_co_mutex_init(&client->send_lock);    qemu_set_fd_handler2(csock, nbd_can_read, nbd_read, NULL, client);    if (exp) {        QTAILQ_INSERT_TAIL(&exp->clients, client, next);        nbd_export_get(exp);    }    return client;}", "idx": 22547}
{"project": "FFmpeg", "commit_id": "fd7af82c53ea8a2577ea8952d35fb158db594592", "target": 0, "function": "static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize){    SCPRContext *s = avctx->priv_data;    GetByteContext *gb = &s->gb;    int cx = 0, cx1 = 0, k = 0, clr = 0;    int run, r, g, b, off, y = 0, x = 0, ret;    const int cxshift = s->cxshift;    unsigned lx, ly, ptype;    reinit_tables(s);    bytestream2_skip(gb, 2);    init_rangecoder(&s->rc, gb);    while (k < avctx->width + 1) {        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);        if (ret < 0)            return ret;        cx1 = (cx << 6) & 0xFC0;        cx = r >> cxshift;        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);        if (ret < 0)            return ret;        cx1 = (cx << 6) & 0xFC0;        cx = g >> cxshift;        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);        if (ret < 0)            return ret;        cx1 = (cx << 6) & 0xFC0;        cx = b >> cxshift;        ret = decode_value(s, s->run_model[0], 256, 400, &run);        if (ret < 0)            return ret;        clr = (b << 16) + (g << 8) + r;        k += run;        while (run-- > 0) {            dst[y * linesize + x] = clr;            lx = x;            ly = y;            x++;            if (x >= avctx->width) {                x = 0;                y++;            }        }    }    off = -linesize - 1;    ptype = 0;    while (x < avctx->width && y < avctx->height) {        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);        if (ret < 0)            return ret;        if (ptype == 0) {            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);            if (ret < 0)                return ret;            cx1 = (cx << 6) & 0xFC0;            cx = r >> cxshift;            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);            if (ret < 0)                return ret;            cx1 = (cx << 6) & 0xFC0;            cx = g >> cxshift;            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);            if (ret < 0)                return ret;            cx1 = (cx << 6) & 0xFC0;            cx = b >> cxshift;            clr = (b << 16) + (g << 8) + r;        }        if (ptype > 5)            return AVERROR_INVALIDDATA;        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);        if (ret < 0)            return ret;        switch (ptype) {        case 0:            while (run-- > 0) {                dst[y * linesize + x] = clr;                lx = x;                ly = y;                x++;                if (x >= avctx->width) {                    x = 0;                    y++;                }            }            break;        case 1:            while (run-- > 0) {                dst[y * linesize + x] = dst[ly * linesize + lx];                lx = x;                ly = y;                x++;                if (x >= avctx->width) {                    x = 0;                    y++;                }            }            clr = dst[ly * linesize + lx];            break;        case 2:            while (run-- > 0) {                clr = dst[y * linesize + x + off + 1];                dst[y * linesize + x] = clr;                lx = x;                ly = y;                x++;                if (x >= avctx->width) {                    x = 0;                    y++;                }            }            break;        case 4:            while (run-- > 0) {                uint8_t *odst = (uint8_t *)dst;                r = odst[(ly * linesize + lx) * 4] +                    odst[((y * linesize + x) + off) * 4 + 4] -                    odst[((y * linesize + x) + off) * 4];                g = odst[(ly * linesize + lx) * 4 + 1] +                    odst[((y * linesize + x) + off) * 4 + 5] -                    odst[((y * linesize + x) + off) * 4 + 1];                b = odst[(ly * linesize + lx) * 4 + 2] +                    odst[((y * linesize + x) + off) * 4 + 6] -                    odst[((y * linesize + x) + off) * 4 + 2];                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);                dst[y * linesize + x] = clr;                lx = x;                ly = y;                x++;                if (x >= avctx->width) {                    x = 0;                    y++;                }            }            break;        case 5:            while (run-- > 0) {                clr = dst[y * linesize + x + off];                dst[y * linesize + x] = clr;                lx = x;                ly = y;                x++;                if (x >= avctx->width) {                    x = 0;                    y++;                }            }            break;        }        if (avctx->bits_per_coded_sample == 16) {            cx1 = (clr & 0xFF00) >> 2;            cx = (clr & 0xFFFFFF) >> 16;        } else {            cx1 = (clr & 0xFC00) >> 4;            cx = (clr & 0xFFFFFF) >> 18;        }    }    return 0;}", "idx": 22548}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "function": "static int count_cow_clusters(BDRVQcow2State *s, int nb_clusters,    uint64_t *l2_table, int l2_index){    int i;    for (i = 0; i < nb_clusters; i++) {        uint64_t l2_entry = be64_to_cpu(l2_table[l2_index + i]);        QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);        switch(cluster_type) {        case QCOW2_CLUSTER_NORMAL:            if (l2_entry & QCOW_OFLAG_COPIED) {                goto out;            }            break;        case QCOW2_CLUSTER_UNALLOCATED:        case QCOW2_CLUSTER_COMPRESSED:        case QCOW2_CLUSTER_ZERO:            break;        default:            abort();        }    }out:    assert(i <= nb_clusters);    return i;}", "idx": 22561}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "function": "static av_always_inline void filter_mb_dir(H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize, int mb_xy, int mb_type, int mvy_limit, int first_vertical_edge_done, int chroma, int chroma444, int dir) {    MpegEncContext * const s = &h->s;    int edge;    int chroma_qp_avg[2];    const int mbm_xy = dir == 0 ? mb_xy -1 : h->top_mb_xy;    const int mbm_type = dir == 0 ? h->left_type[LTOP] : h->top_type;    // how often to recheck mv-based bS when iterating between edges    static const uint8_t mask_edge_tab[2][8]={{0,3,3,3,1,1,1,1},                                              {0,3,1,1,3,3,3,3}};    const int mask_edge = mask_edge_tab[dir][(mb_type>>3)&7];    const int edges = mask_edge== 3 && !(h->cbp&15) ? 1 : 4;    // how often to recheck mv-based bS when iterating along each edge    const int mask_par0 = mb_type & (MB_TYPE_16x16 | (MB_TYPE_8x16 >> dir));    if(mbm_type && !first_vertical_edge_done){        if (FRAME_MBAFF && (dir == 1) && ((mb_y&1) == 0)            && IS_INTERLACED(mbm_type&~mb_type)            ) {            // This is a special case in the norm where the filtering must            // be done twice (one each of the field) even if we are in a            // frame macroblock.            //            unsigned int tmp_linesize   = 2 *   linesize;            unsigned int tmp_uvlinesize = 2 * uvlinesize;            int mbn_xy = mb_xy - 2 * s->mb_stride;            int j;            for(j=0; j<2; j++, mbn_xy += s->mb_stride){                DECLARE_ALIGNED(8, int16_t, bS)[4];                int qp;                if (IS_INTRA(mb_type | s->current_picture.f.mb_type[mbn_xy])) {                    AV_WN64A(bS, 0x0003000300030003ULL);                } else {                    if (!CABAC && IS_8x8DCT(s->current_picture.f.mb_type[mbn_xy])) {                        bS[0]= 1+((h->cbp_table[mbn_xy] & 0x4000)||h->non_zero_count_cache[scan8[0]+0]);                        bS[1]= 1+((h->cbp_table[mbn_xy] & 0x4000)||h->non_zero_count_cache[scan8[0]+1]);                        bS[2]= 1+((h->cbp_table[mbn_xy] & 0x8000)||h->non_zero_count_cache[scan8[0]+2]);                        bS[3]= 1+((h->cbp_table[mbn_xy] & 0x8000)||h->non_zero_count_cache[scan8[0]+3]);                    }else{                    const uint8_t *mbn_nnz = h->non_zero_count[mbn_xy] + 3*4;                    int i;                    for( i = 0; i < 4; i++ ) {                        bS[i] = 1 + !!(h->non_zero_count_cache[scan8[0]+i] | mbn_nnz[i]);                    }                    }                }                // Do not use s->qscale as luma quantizer because it has not the same                // value in IPCM macroblocks.                qp = (s->current_picture.f.qscale_table[mb_xy] + s->current_picture.f.qscale_table[mbn_xy] + 1) >> 1;                tprintf(s->avctx, \"filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d\", mb_x, mb_y, dir, edge, qp, tmp_linesize, tmp_uvlinesize);                { int i; for (i = 0; i < 4; i++) tprintf(s->avctx, \" bS[%d]:%d\", i, bS[i]); tprintf(s->avctx, \"\\n\"); }                filter_mb_edgeh( &img_y[j*linesize], tmp_linesize, bS, qp, h );                chroma_qp_avg[0] = (h->chroma_qp[0] + get_chroma_qp(h, 0, s->current_picture.f.qscale_table[mbn_xy]) + 1) >> 1;                chroma_qp_avg[1] = (h->chroma_qp[1] + get_chroma_qp(h, 1, s->current_picture.f.qscale_table[mbn_xy]) + 1) >> 1;                if (chroma) {                    if (chroma444) {                        filter_mb_edgeh (&img_cb[j*uvlinesize], tmp_uvlinesize, bS, chroma_qp_avg[0], h);                        filter_mb_edgeh (&img_cr[j*uvlinesize], tmp_uvlinesize, bS, chroma_qp_avg[1], h);                    } else {                        filter_mb_edgech(&img_cb[j*uvlinesize], tmp_uvlinesize, bS, chroma_qp_avg[0], h);                        filter_mb_edgech(&img_cr[j*uvlinesize], tmp_uvlinesize, bS, chroma_qp_avg[1], h);                    }                }            }        }else{            DECLARE_ALIGNED(8, int16_t, bS)[4];            int qp;            if( IS_INTRA(mb_type|mbm_type)) {                AV_WN64A(bS, 0x0003000300030003ULL);                if (   (!IS_INTERLACED(mb_type|mbm_type))                    || ((FRAME_MBAFF || (s->picture_structure != PICT_FRAME)) && (dir == 0))                )                    AV_WN64A(bS, 0x0004000400040004ULL);            } else {                int i;                int mv_done;                if( dir && FRAME_MBAFF && IS_INTERLACED(mb_type ^ mbm_type)) {                    AV_WN64A(bS, 0x0001000100010001ULL);                    mv_done = 1;                }                else if( mask_par0 && ((mbm_type & (MB_TYPE_16x16 | (MB_TYPE_8x16 >> dir)))) ) {                    int b_idx= 8 + 4;                    int bn_idx= b_idx - (dir ? 8:1);                    bS[0] = bS[1] = bS[2] = bS[3] = check_mv(h, 8 + 4, bn_idx, mvy_limit);                    mv_done = 1;                }                else                    mv_done = 0;                for( i = 0; i < 4; i++ ) {                    int x = dir == 0 ? 0 : i;                    int y = dir == 0 ? i    : 0;                    int b_idx= 8 + 4 + x + 8*y;                    int bn_idx= b_idx - (dir ? 8:1);                    if( h->non_zero_count_cache[b_idx] |                        h->non_zero_count_cache[bn_idx] ) {                        bS[i] = 2;                    }                    else if(!mv_done)                    {                        bS[i] = check_mv(h, b_idx, bn_idx, mvy_limit);                    }                }            }            /* Filter edge */            // Do not use s->qscale as luma quantizer because it has not the same            // value in IPCM macroblocks.            if(bS[0]+bS[1]+bS[2]+bS[3]){                qp = (s->current_picture.f.qscale_table[mb_xy] + s->current_picture.f.qscale_table[mbm_xy] + 1) >> 1;                //tprintf(s->avctx, \"filter mb:%d/%d dir:%d edge:%d, QPy:%d, QPc:%d, QPcn:%d\\n\", mb_x, mb_y, dir, edge, qp, h->chroma_qp[0], s->current_picture.qscale_table[mbn_xy]);                tprintf(s->avctx, \"filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d\", mb_x, mb_y, dir, edge, qp, linesize, uvlinesize);                //{ int i; for (i = 0; i < 4; i++) tprintf(s->avctx, \" bS[%d]:%d\", i, bS[i]); tprintf(s->avctx, \"\\n\"); }                chroma_qp_avg[0] = (h->chroma_qp[0] + get_chroma_qp(h, 0, s->current_picture.f.qscale_table[mbm_xy]) + 1) >> 1;                chroma_qp_avg[1] = (h->chroma_qp[1] + get_chroma_qp(h, 1, s->current_picture.f.qscale_table[mbm_xy]) + 1) >> 1;                if( dir == 0 ) {                    filter_mb_edgev( &img_y[0], linesize, bS, qp, h );                    if (chroma) {                        if (chroma444) {                            filter_mb_edgev ( &img_cb[0], uvlinesize, bS, chroma_qp_avg[0], h);                            filter_mb_edgev ( &img_cr[0], uvlinesize, bS, chroma_qp_avg[1], h);                        } else {                            filter_mb_edgecv( &img_cb[0], uvlinesize, bS, chroma_qp_avg[0], h);                            filter_mb_edgecv( &img_cr[0], uvlinesize, bS, chroma_qp_avg[1], h);                        }                    }                } else {                    filter_mb_edgeh( &img_y[0], linesize, bS, qp, h );                    if (chroma) {                        if (chroma444) {                            filter_mb_edgeh ( &img_cb[0], uvlinesize, bS, chroma_qp_avg[0], h);                            filter_mb_edgeh ( &img_cr[0], uvlinesize, bS, chroma_qp_avg[1], h);                        } else {                            filter_mb_edgech( &img_cb[0], uvlinesize, bS, chroma_qp_avg[0], h);                            filter_mb_edgech( &img_cr[0], uvlinesize, bS, chroma_qp_avg[1], h);                        }                    }                }            }        }    }    /* Calculate bS */    for( edge = 1; edge < edges; edge++ ) {        DECLARE_ALIGNED(8, int16_t, bS)[4];        int qp;        if( IS_8x8DCT(mb_type & (edge<<24)) ) // (edge&1) && IS_8x8DCT(mb_type)            continue;        if( IS_INTRA(mb_type)) {            AV_WN64A(bS, 0x0003000300030003ULL);        } else {            int i;            int mv_done;            if( edge & mask_edge ) {                AV_ZERO64(bS);                mv_done = 1;            }            else if( mask_par0 ) {                int b_idx= 8 + 4 + edge * (dir ? 8:1);                int bn_idx= b_idx - (dir ? 8:1);                bS[0] = bS[1] = bS[2] = bS[3] = check_mv(h, b_idx, bn_idx, mvy_limit);                mv_done = 1;            }            else                mv_done = 0;            for( i = 0; i < 4; i++ ) {                int x = dir == 0 ? edge : i;                int y = dir == 0 ? i    : edge;                int b_idx= 8 + 4 + x + 8*y;                int bn_idx= b_idx - (dir ? 8:1);                if( h->non_zero_count_cache[b_idx] |                    h->non_zero_count_cache[bn_idx] ) {                    bS[i] = 2;                }                else if(!mv_done)                {                    bS[i] = check_mv(h, b_idx, bn_idx, mvy_limit);                }            }            if(bS[0]+bS[1]+bS[2]+bS[3] == 0)                continue;        }        /* Filter edge */        // Do not use s->qscale as luma quantizer because it has not the same        // value in IPCM macroblocks.        qp = s->current_picture.f.qscale_table[mb_xy];        //tprintf(s->avctx, \"filter mb:%d/%d dir:%d edge:%d, QPy:%d, QPc:%d, QPcn:%d\\n\", mb_x, mb_y, dir, edge, qp, h->chroma_qp[0], s->current_picture.qscale_table[mbn_xy]);        tprintf(s->avctx, \"filter mb:%d/%d dir:%d edge:%d, QPy:%d ls:%d uvls:%d\", mb_x, mb_y, dir, edge, qp, linesize, uvlinesize);        //{ int i; for (i = 0; i < 4; i++) tprintf(s->avctx, \" bS[%d]:%d\", i, bS[i]); tprintf(s->avctx, \"\\n\"); }        if( dir == 0 ) {            filter_mb_edgev( &img_y[4*edge << h->pixel_shift], linesize, bS, qp, h );            if (chroma) {                if (chroma444) {                    filter_mb_edgev ( &img_cb[4*edge << h->pixel_shift], uvlinesize, bS, h->chroma_qp[0], h);                    filter_mb_edgev ( &img_cr[4*edge << h->pixel_shift], uvlinesize, bS, h->chroma_qp[1], h);                } else if( (edge&1) == 0 ) {                    filter_mb_edgecv( &img_cb[2*edge << h->pixel_shift], uvlinesize, bS, h->chroma_qp[0], h);                    filter_mb_edgecv( &img_cr[2*edge << h->pixel_shift], uvlinesize, bS, h->chroma_qp[1], h);                }            }        } else {            filter_mb_edgeh( &img_y[4*edge*linesize], linesize, bS, qp, h );            if (chroma) {                if (chroma444) {                    filter_mb_edgeh ( &img_cb[4*edge*uvlinesize], uvlinesize, bS, h->chroma_qp[0], h);                    filter_mb_edgeh ( &img_cr[4*edge*uvlinesize], uvlinesize, bS, h->chroma_qp[1], h);                } else if( (edge&1) == 0 ) {                    filter_mb_edgech( &img_cb[2*edge*uvlinesize], uvlinesize, bS, h->chroma_qp[0], h);                    filter_mb_edgech( &img_cr[2*edge*uvlinesize], uvlinesize, bS, h->chroma_qp[1], h);                }            }        }    }}", "idx": 22628}
{"project": "FFmpeg", "commit_id": "a7a17e3f1915ce69b787dc58c5d8dba0910fc0a4", "target": 0, "function": "void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,                                           int log2_trafo_size){    HEVCLocalContext *lc = &s->HEVClc;    MvField *tab_mvf     = s->ref->tab_mvf;    int log2_min_pu_size = s->sps->log2_min_pu_size;    int log2_min_tu_size = s->sps->log2_min_tb_size;    int min_pu_width     = s->sps->min_pu_width;    int min_tu_width     = s->sps->min_tb_width;    int is_intra = tab_mvf[(y0 >> log2_min_pu_size) * min_pu_width +                           (x0 >> log2_min_pu_size)].is_intra;    int i, j, bs;    if (y0 > 0 && (y0 & 7) == 0) {        int yp_pu = (y0 - 1) >> log2_min_pu_size;        int yq_pu =  y0      >> log2_min_pu_size;        int yp_tu = (y0 - 1) >> log2_min_tu_size;        int yq_tu =  y0      >> log2_min_tu_size;        for (i = 0; i < (1 << log2_trafo_size); i += 4) {            int x_pu = (x0 + i) >> log2_min_pu_size;            int x_tu = (x0 + i) >> log2_min_tu_size;            MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];            MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];            uint8_t top_cbf_luma  = s->cbf_luma[yp_tu * min_tu_width + x_tu];            uint8_t curr_cbf_luma = s->cbf_luma[yq_tu * min_tu_width + x_tu];            RefPicList *top_refPicList = ff_hevc_get_ref_list(s, s->ref,                                                              x0 + i, y0 - 1);            bs = boundary_strength(s, curr, curr_cbf_luma,                                   top, top_cbf_luma, top_refPicList, 1);            if (!s->sh.slice_loop_filter_across_slices_enabled_flag &&                lc->boundary_flags & BOUNDARY_UPPER_SLICE &&                (y0 % (1 << s->sps->log2_ctb_size)) == 0)                bs = 0;            else if (!s->pps->loop_filter_across_tiles_enabled_flag &&                     lc->boundary_flags & BOUNDARY_UPPER_TILE &&                     (y0 % (1 << s->sps->log2_ctb_size)) == 0)                bs = 0;            if (bs)                s->horizontal_bs[((x0 + i) + y0 * s->bs_width) >> 2] = bs;        }    }    // bs for TU internal horizontal PU boundaries    if (log2_trafo_size > s->sps->log2_min_pu_size && !is_intra)        for (j = 8; j < (1 << log2_trafo_size); j += 8) {            int yp_pu = (y0 + j - 1) >> log2_min_pu_size;            int yq_pu = (y0 + j)     >> log2_min_pu_size;            int yp_tu = (y0 + j - 1) >> log2_min_tu_size;            int yq_tu = (y0 + j)     >> log2_min_tu_size;            for (i = 0; i < (1 << log2_trafo_size); i += 4) {                int x_pu = (x0 + i) >> log2_min_pu_size;                int x_tu = (x0 + i) >> log2_min_tu_size;                MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];                MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];                uint8_t top_cbf_luma  = s->cbf_luma[yp_tu * min_tu_width + x_tu];                uint8_t curr_cbf_luma = s->cbf_luma[yq_tu * min_tu_width + x_tu];                RefPicList *top_refPicList = ff_hevc_get_ref_list(s, s->ref,                                                                  x0 + i,                                                                  y0 + j - 1);                bs = boundary_strength(s, curr, curr_cbf_luma,                                       top, top_cbf_luma, top_refPicList, 0);                if (bs)                    s->horizontal_bs[((x0 + i) + (y0 + j) * s->bs_width) >> 2] = bs;            }        }    // bs for vertical TU boundaries    if (x0 > 0 && (x0 & 7) == 0) {        int xp_pu = (x0 - 1) >> log2_min_pu_size;        int xq_pu =  x0      >> log2_min_pu_size;        int xp_tu = (x0 - 1) >> log2_min_tu_size;        int xq_tu =  x0      >> log2_min_tu_size;        for (i = 0; i < (1 << log2_trafo_size); i += 4) {            int y_pu      = (y0 + i) >> log2_min_pu_size;            int y_tu      = (y0 + i) >> log2_min_tu_size;            MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];            MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];            uint8_t left_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xp_tu];            uint8_t curr_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xq_tu];            RefPicList *left_refPicList = ff_hevc_get_ref_list(s, s->ref,                                                               x0 - 1, y0 + i);            bs = boundary_strength(s, curr, curr_cbf_luma,                                   left, left_cbf_luma, left_refPicList, 1);            if (!s->sh.slice_loop_filter_across_slices_enabled_flag &&                lc->boundary_flags & BOUNDARY_LEFT_SLICE &&                (x0 % (1 << s->sps->log2_ctb_size)) == 0)                bs = 0;            else if (!s->pps->loop_filter_across_tiles_enabled_flag &&                     lc->boundary_flags & BOUNDARY_LEFT_TILE &&                     (x0 % (1 << s->sps->log2_ctb_size)) == 0)                bs = 0;            if (bs)                s->vertical_bs[(x0 >> 3) + ((y0 + i) >> 2) * s->bs_width] = bs;        }    }    // bs for TU internal vertical PU boundaries    if (log2_trafo_size > log2_min_pu_size && !is_intra)        for (j = 0; j < (1 << log2_trafo_size); j += 4) {            int y_pu = (y0 + j) >> log2_min_pu_size;            int y_tu = (y0 + j) >> log2_min_tu_size;            for (i = 8; i < (1 << log2_trafo_size); i += 8) {                int xp_pu = (x0 + i - 1) >> log2_min_pu_size;                int xq_pu = (x0 + i)     >> log2_min_pu_size;                int xp_tu = (x0 + i - 1) >> log2_min_tu_size;                int xq_tu = (x0 + i)     >> log2_min_tu_size;                MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];                MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];                uint8_t left_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xp_tu];                uint8_t curr_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xq_tu];                RefPicList *left_refPicList = ff_hevc_get_ref_list(s, s->ref,                                                                   x0 + i - 1,                                                                   y0 + j);                bs = boundary_strength(s, curr, curr_cbf_luma,                                       left, left_cbf_luma, left_refPicList, 0);                if (bs)                    s->vertical_bs[((x0 + i) >> 3) + ((y0 + j) >> 2) * s->bs_width] = bs;            }        }}", "idx": 22632}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "function": "static int vhost_net_set_vnet_endian(VirtIODevice *dev, NetClientState *peer,                                     bool set){    int r = 0;    if (virtio_has_feature(dev, VIRTIO_F_VERSION_1) ||        (virtio_legacy_is_cross_endian(dev) && !virtio_is_big_endian(dev))) {        r = qemu_set_vnet_le(peer, set);        if (r) {            error_report(\"backend does not support LE vnet headers\");        }    } else if (virtio_legacy_is_cross_endian(dev)) {        r = qemu_set_vnet_be(peer, set);        if (r) {            error_report(\"backend does not support BE vnet headers\");        }    }    return r;}", "idx": 22754}
{"project": "FFmpeg", "commit_id": "985c5f226af35fff00a86bc36cc8eaa8da3d23b0", "target": 0, "function": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,                                              int *got_picture_ptr,                                              const AVPacket *avpkt){    AVCodecInternal *avci = avctx->internal;    int ret;    // copy to ensure we do not change avpkt    AVPacket tmp = *avpkt;    if (!avctx->codec)        return AVERROR(EINVAL);    if (avctx->codec->type != AVMEDIA_TYPE_VIDEO) {        av_log(avctx, AV_LOG_ERROR, \"Invalid media type for video\\n\");        return AVERROR(EINVAL);    }    *got_picture_ptr = 0;    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))        return AVERROR(EINVAL);    avcodec_get_frame_defaults(picture);    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {        int did_split = av_packet_split_side_data(&tmp);        ret = apply_param_change(avctx, &tmp);        if (ret < 0) {            av_log(avctx, AV_LOG_ERROR, \"Error applying parameter changes.\\n\");            if (avctx->err_recognition & AV_EF_EXPLODE)                goto fail;        }        avctx->internal->pkt = &tmp;        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,                                         &tmp);        else {            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,                                       &tmp);            picture->pkt_dts = avpkt->dts;            if(!avctx->has_b_frames){                av_frame_set_pkt_pos(picture, avpkt->pos);            }            //FIXME these should be under if(!avctx->has_b_frames)            /* get_buffer is supposed to set frame parameters */            if (!(avctx->codec->capabilities & CODEC_CAP_DR1)) {                if (!picture->sample_aspect_ratio.num)    picture->sample_aspect_ratio = avctx->sample_aspect_ratio;                if (!picture->width)                      picture->width               = avctx->width;                if (!picture->height)                     picture->height              = avctx->height;                if (picture->format == AV_PIX_FMT_NONE)   picture->format              = avctx->pix_fmt;            }        }        add_metadata_from_side_data(avctx, picture);fail:        emms_c(); //needed to avoid an emms_c() call before every return;        avctx->internal->pkt = NULL;        if (did_split) {            av_packet_free_side_data(&tmp);            if(ret == tmp.size)                ret = avpkt->size;        }        if (*got_picture_ptr) {            if (!avctx->refcounted_frames) {                int err = unrefcount_frame(avci, picture);                if (err < 0)                    return err;            }            avctx->frame_number++;            av_frame_set_best_effort_timestamp(picture,                                               guess_correct_pts(avctx,                                                                 picture->pkt_pts,                                                                 picture->pkt_dts));        } else            av_frame_unref(picture);    } else        ret = 0;    /* many decoders assign whole AVFrames, thus overwriting extended_data;     * make sure it's set correctly */    picture->extended_data = picture->data;    return ret;}", "idx": 22762}
{"project": "qemu", "commit_id": "553a6a59f6931bf3a034945e0c1585f4b05d6000", "target": 0, "function": "static int ehci_state_executing(EHCIQueue *q, int async){    int again = 0;    int reload, nakcnt;    ehci_execute_complete(q);    if (q->usb_status == USB_RET_ASYNC) {        goto out;    }    if (q->usb_status == USB_RET_PROCERR) {        again = -1;        goto out;    }    // 4.10.3    if (!async) {        int transactCtr = get_field(q->qh.epcap, QH_EPCAP_MULT);        transactCtr--;        set_field(&q->qh.epcap, transactCtr, QH_EPCAP_MULT);        // 4.10.3, bottom of page 82, should exit this state when transaction        // counter decrements to 0    }    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);    if (reload) {        nakcnt = get_field(q->qh.altnext_qtd, QH_ALTNEXT_NAKCNT);        if (q->usb_status == USB_RET_NAK) {            if (nakcnt) {                nakcnt--;            }        } else {            nakcnt = reload;        }        set_field(&q->qh.altnext_qtd, nakcnt, QH_ALTNEXT_NAKCNT);    }    /* 4.10.5 */    if ((q->usb_status == USB_RET_NAK) || (q->qh.token & QTD_TOKEN_ACTIVE)) {        ehci_set_state(q->ehci, async, EST_HORIZONTALQH);    } else {        ehci_set_state(q->ehci, async, EST_WRITEBACK);    }    again = 1;out:    ehci_flush_qh(q);    return again;}", "idx": 22769}
{"project": "FFmpeg", "commit_id": "e29d2d9c92e19b0caf05a2064d132ccdecdfc3d5", "target": 0, "function": "static int seg_check_bitstream(struct AVFormatContext *s, const AVPacket *pkt){    SegmentContext *seg = s->priv_data;    AVFormatContext *oc = seg->avf;    if (oc->oformat->check_bitstream) {        int ret = oc->oformat->check_bitstream(oc, pkt);        if (ret == 1) {            AVStream *st = s->streams[pkt->stream_index];            AVStream *ost = oc->streams[pkt->stream_index];            st->internal->bsfcs = ost->internal->bsfcs;            st->internal->nb_bsfcs = ost->internal->nb_bsfcs;            ost->internal->bsfcs = NULL;            ost->internal->nb_bsfcs = 0;        }        return ret;    }    return 1;}", "idx": 22797}
{"project": "qemu", "commit_id": "b952b5589a36114e06201c0d2e82c293dbad2b1f", "target": 1, "function": "void qmp_drive_mirror(const char *device, const char *target,                      bool has_format, const char *format,                      enum MirrorSyncMode sync,                      bool has_mode, enum NewImageMode mode,                      bool has_speed, int64_t speed, Error **errp){    BlockDriverInfo bdi;    BlockDriverState *bs;    BlockDriverState *source, *target_bs;    BlockDriver *proto_drv;    BlockDriver *drv = NULL;    Error *local_err = NULL;    int flags;    uint64_t size;    int ret;    if (!has_speed) {        speed = 0;    }    if (!has_mode) {        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;    }    bs = bdrv_find(device);    if (!bs) {        error_set(errp, QERR_DEVICE_NOT_FOUND, device);        return;    }    if (!bdrv_is_inserted(bs)) {        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);        return;    }    if (!has_format) {        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;    }    if (format) {        drv = bdrv_find_format(format);        if (!drv) {            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);            return;        }    }    if (bdrv_in_use(bs)) {        error_set(errp, QERR_DEVICE_IN_USE, device);        return;    }    flags = bs->open_flags | BDRV_O_RDWR;    source = bs->backing_hd;    if (!source && sync == MIRROR_SYNC_MODE_TOP) {        sync = MIRROR_SYNC_MODE_FULL;    }    proto_drv = bdrv_find_protocol(target);    if (!proto_drv) {        error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);        return;    }    if (sync == MIRROR_SYNC_MODE_FULL && mode != NEW_IMAGE_MODE_EXISTING) {        /* create new image w/o backing file */        assert(format && drv);        bdrv_get_geometry(bs, &size);        size *= 512;        ret = bdrv_img_create(target, format,                              NULL, NULL, NULL, size, flags);    } else {        switch (mode) {        case NEW_IMAGE_MODE_EXISTING:            ret = 0;            break;        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:            /* create new image with backing file */            ret = bdrv_img_create(target, format,                                  source->filename,                                  source->drv->format_name,                                  NULL, -1, flags);            break;        default:            abort();        }    }    if (ret) {        error_set(errp, QERR_OPEN_FILE_FAILED, target);        return;    }    target_bs = bdrv_new(\"\");    ret = bdrv_open(target_bs, target, flags | BDRV_O_NO_BACKING, drv);    if (ret < 0) {        bdrv_delete(target_bs);        error_set(errp, QERR_OPEN_FILE_FAILED, target);        return;    }    /* We need a backing file if we will copy parts of a cluster.  */    if (bdrv_get_info(target_bs, &bdi) >= 0 && bdi.cluster_size != 0 &&        bdi.cluster_size >= BDRV_SECTORS_PER_DIRTY_CHUNK * 512) {        ret = bdrv_open_backing_file(target_bs);        if (ret < 0) {            bdrv_delete(target_bs);            error_set(errp, QERR_OPEN_FILE_FAILED, target);            return;        }    }    mirror_start(bs, target_bs, speed, sync, block_job_cb, bs, &local_err);    if (local_err != NULL) {        bdrv_delete(target_bs);        error_propagate(errp, local_err);        return;    }    /* Grab a reference so hotplug does not delete the BlockDriverState from     * underneath us.     */    drive_get_ref(drive_get_by_blockdev(bs));}", "idx": 22841}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "function": "static av_cold int libopenjpeg_encode_close(AVCodecContext *avctx){    LibOpenJPEGContext *ctx = avctx->priv_data;    opj_cio_close(ctx->stream);    ctx->stream = NULL;    opj_destroy_compress(ctx->compress);    ctx->compress = NULL;    opj_image_destroy(ctx->image);    ctx->image = NULL;    av_freep(&avctx->coded_frame);    return 0;}", "idx": 22905}
{"project": "FFmpeg", "commit_id": "8e2555d3b1855374707a4d53bf93d3e07d61e05c", "target": 0, "function": "static av_cold int g722_encode_close(AVCodecContext *avctx){    G722Context *c = avctx->priv_data;    int i;    for (i = 0; i < 2; i++) {        av_freep(&c->paths[i]);        av_freep(&c->node_buf[i]);        av_freep(&c->nodep_buf[i]);    }    return 0;}", "idx": 22991}
{"project": "qemu", "commit_id": "e046fb449947a48e013bf25d806ecb60e5a88319", "target": 0, "function": "static int io_channel_send_full(QIOChannel *ioc,                                const void *buf, size_t len,                                int *fds, size_t nfds){    size_t offset = 0;    while (offset < len) {        ssize_t ret = 0;        struct iovec iov = { .iov_base = (char *)buf + offset,                             .iov_len = len - offset };        ret = qio_channel_writev_full(            ioc, &iov, 1,            fds, nfds, NULL);        if (ret == QIO_CHANNEL_ERR_BLOCK) {            errno = EAGAIN;            return -1;        } else if (ret < 0) {            if (offset) {                return offset;            }            errno = EINVAL;            return -1;        }        offset += ret;    }    return offset;}", "idx": 23065}
{"project": "qemu", "commit_id": "02a2cbc872df99205eeafd399f01c210e0b797c4", "target": 0, "function": "static bool vtd_process_inv_desc(IntelIOMMUState *s){    VTDInvDesc inv_desc;    uint8_t desc_type;    VTD_DPRINTF(INV, \"iq head %\"PRIu16, s->iq_head);    if (!vtd_get_inv_desc(s->iq, s->iq_head, &inv_desc)) {        s->iq_last_desc_type = VTD_INV_DESC_NONE;        return false;    }    desc_type = inv_desc.lo & VTD_INV_DESC_TYPE;    /* FIXME: should update at first or at last? */    s->iq_last_desc_type = desc_type;    switch (desc_type) {    case VTD_INV_DESC_CC:        VTD_DPRINTF(INV, \"Context-cache Invalidate Descriptor hi 0x%\"PRIx64                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);        if (!vtd_process_context_cache_desc(s, &inv_desc)) {            return false;        }        break;    case VTD_INV_DESC_IOTLB:        VTD_DPRINTF(INV, \"IOTLB Invalidate Descriptor hi 0x%\"PRIx64                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);        if (!vtd_process_iotlb_desc(s, &inv_desc)) {            return false;        }        break;    case VTD_INV_DESC_WAIT:        VTD_DPRINTF(INV, \"Invalidation Wait Descriptor hi 0x%\"PRIx64                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);        if (!vtd_process_wait_desc(s, &inv_desc)) {            return false;        }        break;    case VTD_INV_DESC_IEC:        VTD_DPRINTF(INV, \"Interrupt Entry Cache Invalidation \"                    \"not implemented yet\");        /*         * Since currently we do not cache interrupt entries, we can         * just mark this descriptor as \"good\" and move on.         */        break;    default:        VTD_DPRINTF(GENERAL, \"error: unkonw Invalidation Descriptor type \"                    \"hi 0x%\"PRIx64 \" lo 0x%\"PRIx64 \" type %\"PRIu8,                    inv_desc.hi, inv_desc.lo, desc_type);        return false;    }    s->iq_head++;    if (s->iq_head == s->iq_size) {        s->iq_head = 0;    }    return true;}", "idx": 23071}
{"project": "qemu", "commit_id": "7848c8d19f8556666df25044bbd5d8b29439c368", "target": 0, "function": "static inline void helper_ret_protected(CPUX86State *env, int shift,                                        int is_iret, int addend){    uint32_t new_cs, new_eflags, new_ss;    uint32_t new_es, new_ds, new_fs, new_gs;    uint32_t e1, e2, ss_e1, ss_e2;    int cpl, dpl, rpl, eflags_mask, iopl;    target_ulong ssp, sp, new_eip, new_esp, sp_mask;#ifdef TARGET_X86_64    if (shift == 2) {        sp_mask = -1;    } else#endif    {        sp_mask = get_sp_mask(env->segs[R_SS].flags);    }    sp = env->regs[R_ESP];    ssp = env->segs[R_SS].base;    new_eflags = 0; /* avoid warning */#ifdef TARGET_X86_64    if (shift == 2) {        POPQ(sp, new_eip);        POPQ(sp, new_cs);        new_cs &= 0xffff;        if (is_iret) {            POPQ(sp, new_eflags);        }    } else#endif    {        if (shift == 1) {            /* 32 bits */            POPL(ssp, sp, sp_mask, new_eip);            POPL(ssp, sp, sp_mask, new_cs);            new_cs &= 0xffff;            if (is_iret) {                POPL(ssp, sp, sp_mask, new_eflags);                if (new_eflags & VM_MASK) {                    goto return_to_vm86;                }            }        } else {            /* 16 bits */            POPW(ssp, sp, sp_mask, new_eip);            POPW(ssp, sp, sp_mask, new_cs);            if (is_iret) {                POPW(ssp, sp, sp_mask, new_eflags);            }        }    }    LOG_PCALL(\"lret new %04x:\" TARGET_FMT_lx \" s=%d addend=0x%x\\n\",              new_cs, new_eip, shift, addend);    LOG_PCALL_STATE(CPU(x86_env_get_cpu(env)));    if ((new_cs & 0xfffc) == 0) {        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);    }    if (load_segment(env, &e1, &e2, new_cs) != 0) {        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);    }    if (!(e2 & DESC_S_MASK) ||        !(e2 & DESC_CS_MASK)) {        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);    }    cpl = env->hflags & HF_CPL_MASK;    rpl = new_cs & 3;    if (rpl < cpl) {        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);    }    dpl = (e2 >> DESC_DPL_SHIFT) & 3;    if (e2 & DESC_C_MASK) {        if (dpl > rpl) {            raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);        }    } else {        if (dpl != rpl) {            raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);        }    }    if (!(e2 & DESC_P_MASK)) {        raise_exception_err(env, EXCP0B_NOSEG, new_cs & 0xfffc);    }    sp += addend;    if (rpl == cpl && (!(env->hflags & HF_CS64_MASK) ||                       ((env->hflags & HF_CS64_MASK) && !is_iret))) {        /* return to same privilege level */        cpu_x86_load_seg_cache(env, R_CS, new_cs,                       get_seg_base(e1, e2),                       get_seg_limit(e1, e2),                       e2);    } else {        /* return to different privilege level */#ifdef TARGET_X86_64        if (shift == 2) {            POPQ(sp, new_esp);            POPQ(sp, new_ss);            new_ss &= 0xffff;        } else#endif        {            if (shift == 1) {                /* 32 bits */                POPL(ssp, sp, sp_mask, new_esp);                POPL(ssp, sp, sp_mask, new_ss);                new_ss &= 0xffff;            } else {                /* 16 bits */                POPW(ssp, sp, sp_mask, new_esp);                POPW(ssp, sp, sp_mask, new_ss);            }        }        LOG_PCALL(\"new ss:esp=%04x:\" TARGET_FMT_lx \"\\n\",                  new_ss, new_esp);        if ((new_ss & 0xfffc) == 0) {#ifdef TARGET_X86_64            /* NULL ss is allowed in long mode if cpl != 3 */            /* XXX: test CS64? */            if ((env->hflags & HF_LMA_MASK) && rpl != 3) {                cpu_x86_load_seg_cache(env, R_SS, new_ss,                                       0, 0xffffffff,                                       DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |                                       DESC_S_MASK | (rpl << DESC_DPL_SHIFT) |                                       DESC_W_MASK | DESC_A_MASK);                ss_e2 = DESC_B_MASK; /* XXX: should not be needed? */            } else#endif            {                raise_exception_err(env, EXCP0D_GPF, 0);            }        } else {            if ((new_ss & 3) != rpl) {                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);            }            if (load_segment(env, &ss_e1, &ss_e2, new_ss) != 0) {                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);            }            if (!(ss_e2 & DESC_S_MASK) ||                (ss_e2 & DESC_CS_MASK) ||                !(ss_e2 & DESC_W_MASK)) {                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);            }            dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;            if (dpl != rpl) {                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);            }            if (!(ss_e2 & DESC_P_MASK)) {                raise_exception_err(env, EXCP0B_NOSEG, new_ss & 0xfffc);            }            cpu_x86_load_seg_cache(env, R_SS, new_ss,                                   get_seg_base(ss_e1, ss_e2),                                   get_seg_limit(ss_e1, ss_e2),                                   ss_e2);        }        cpu_x86_load_seg_cache(env, R_CS, new_cs,                       get_seg_base(e1, e2),                       get_seg_limit(e1, e2),                       e2);        cpu_x86_set_cpl(env, rpl);        sp = new_esp;#ifdef TARGET_X86_64        if (env->hflags & HF_CS64_MASK) {            sp_mask = -1;        } else#endif        {            sp_mask = get_sp_mask(ss_e2);        }        /* validate data segments */        validate_seg(env, R_ES, rpl);        validate_seg(env, R_DS, rpl);        validate_seg(env, R_FS, rpl);        validate_seg(env, R_GS, rpl);        sp += addend;    }    SET_ESP(sp, sp_mask);    env->eip = new_eip;    if (is_iret) {        /* NOTE: 'cpl' is the _old_ CPL */        eflags_mask = TF_MASK | AC_MASK | ID_MASK | RF_MASK | NT_MASK;        if (cpl == 0) {            eflags_mask |= IOPL_MASK;        }        iopl = (env->eflags >> IOPL_SHIFT) & 3;        if (cpl <= iopl) {            eflags_mask |= IF_MASK;        }        if (shift == 0) {            eflags_mask &= 0xffff;        }        cpu_load_eflags(env, new_eflags, eflags_mask);    }    return; return_to_vm86:    POPL(ssp, sp, sp_mask, new_esp);    POPL(ssp, sp, sp_mask, new_ss);    POPL(ssp, sp, sp_mask, new_es);    POPL(ssp, sp, sp_mask, new_ds);    POPL(ssp, sp, sp_mask, new_fs);    POPL(ssp, sp, sp_mask, new_gs);    /* modify processor state */    cpu_load_eflags(env, new_eflags, TF_MASK | AC_MASK | ID_MASK |                    IF_MASK | IOPL_MASK | VM_MASK | NT_MASK | VIF_MASK |                    VIP_MASK);    load_seg_vm(env, R_CS, new_cs & 0xffff);    cpu_x86_set_cpl(env, 3);    load_seg_vm(env, R_SS, new_ss & 0xffff);    load_seg_vm(env, R_ES, new_es & 0xffff);    load_seg_vm(env, R_DS, new_ds & 0xffff);    load_seg_vm(env, R_FS, new_fs & 0xffff);    load_seg_vm(env, R_GS, new_gs & 0xffff);    env->eip = new_eip & 0xffff;    env->regs[R_ESP] = new_esp;}", "idx": 23081}
{"project": "qemu", "commit_id": "7ad4c7200111d20eb97eed4f46b6026e3f0b0eef", "target": 0, "function": "char *g_strdup(const char *s){    char *dup;    size_t i;    if (!s) {        return NULL;    }    __coverity_string_null_sink__(s);    __coverity_string_size_sink__(s);    dup = __coverity_alloc_nosize__();    __coverity_mark_as_afm_allocated__(dup, AFM_free);    for (i = 0; (dup[i] = s[i]); i++) ;    return dup;}", "idx": 23110}
{"project": "FFmpeg", "commit_id": "41ee459e88093a0b7ae13b8539ed9ccd0ebd0f0b", "target": 1, "function": "static int dpx_probe(AVProbeData *p){    const uint8_t *b = p->buf;    if (AV_RN32(b) == AV_RN32(\"SDPX\") || AV_RN32(b) == AV_RN32(\"XPDS\"))        return AVPROBE_SCORE_EXTENSION + 1;    return 0;}", "idx": 23284}
{"project": "qemu", "commit_id": "94fb0909645de18481cc726ee0ec9b5afa861394", "target": 1, "function": "static int ram_decompress_buf(RamDecompressState *s, uint8_t *buf, int len){    int ret, clen;    s->zstream.avail_out = len;    s->zstream.next_out = buf;    while (s->zstream.avail_out > 0) {        if (s->zstream.avail_in == 0) {            if (qemu_get_be16(s->f) != RAM_CBLOCK_MAGIC)                return -1;            clen = qemu_get_be16(s->f);            if (clen > IOBUF_SIZE)                return -1;            qemu_get_buffer(s->f, s->buf, clen);            s->zstream.avail_in = clen;            s->zstream.next_in = s->buf;        }        ret = inflate(&s->zstream, Z_PARTIAL_FLUSH);        if (ret != Z_OK && ret != Z_STREAM_END) {            return -1;        }    }    return 0;}", "idx": 23301}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "function": "void pci_default_write_config(PCIDevice *d,                               uint32_t address, uint32_t val, int len){    int can_write, i;    uint32_t end, addr;    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) ||                      (address >= 0x30 && address < 0x34))) {        PCIIORegion *r;        int reg;        if ( address >= 0x30 ) {            reg = PCI_ROM_SLOT;        }else{            reg = (address - 0x10) >> 2;        }        r = &d->io_regions[reg];        if (r->size == 0)            goto default_config;        /* compute the stored value */        if (reg == PCI_ROM_SLOT) {            /* keep ROM enable bit */            val &= (~(r->size - 1)) | 1;        } else {            val &= ~(r->size - 1);            val |= r->type;        }        *(uint32_t *)(d->config + address) = cpu_to_le32(val);        pci_update_mappings(d);        return;    } default_config:    /* not efficient, but simple */    addr = address;    for(i = 0; i < len; i++) {        /* default read/write accesses */        switch(d->config[0x0e]) {        case 0x00:        case 0x80:            switch(addr) {            case 0x00:            case 0x01:            case 0x02:            case 0x03:            case 0x08:            case 0x09:            case 0x0a:            case 0x0b:            case 0x0e:            case 0x10 ... 0x27: /* base */            case 0x30 ... 0x33: /* rom */            case 0x3d:                can_write = 0;                break;            default:                can_write = 1;                break;            }            break;        default:        case 0x01:            switch(addr) {            case 0x00:            case 0x01:            case 0x02:            case 0x03:            case 0x08:            case 0x09:            case 0x0a:            case 0x0b:            case 0x0e:            case 0x38 ... 0x3b: /* rom */            case 0x3d:                can_write = 0;                break;            default:                can_write = 1;                break;            }            break;        }        if (can_write) {            d->config[addr] = val;        }        addr++;        val >>= 8;    }    end = address + len;    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {        /* if the command register is modified, we must modify the mappings */        pci_update_mappings(d);    }}", "idx": 23307}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "function": "static int get_char(GDBState *s){    uint8_t ch;    int ret;    for(;;) {        ret = qemu_recv(s->fd, &ch, 1, 0);        if (ret < 0) {            if (errno == ECONNRESET)                s->fd = -1;            if (errno != EINTR && errno != EAGAIN)                return -1;        } else if (ret == 0) {            close(s->fd);            s->fd = -1;            return -1;        } else {            break;        }    }    return ch;}", "idx": 23367}
{"project": "FFmpeg", "commit_id": "308429e124b97337a768839c1d5091900e974e7e", "target": 0, "function": "static int wav_write_trailer(AVFormatContext *s){    AVIOContext *pb  = s->pb;    WAVMuxContext    *wav = s->priv_data;    int64_t file_size, data_size;    int64_t number_of_samples = 0;    int rf64 = 0;    avio_flush(pb);    if (s->pb->seekable) {        if (wav->write_peak != 2) {            ff_end_tag(pb, wav->data);            avio_flush(pb);        }        if (wav->write_peak && wav->peak_output) {            peak_write_chunk(s);            avio_flush(pb);        }        /* update file size */        file_size = avio_tell(pb);        data_size = file_size - wav->data;        if (wav->rf64 == RF64_ALWAYS || (wav->rf64 == RF64_AUTO && file_size - 8 > UINT32_MAX)) {            rf64 = 1;        } else {            avio_seek(pb, 4, SEEK_SET);            avio_wl32(pb, (uint32_t)(file_size - 8));            avio_seek(pb, file_size, SEEK_SET);            avio_flush(pb);        }        number_of_samples = av_rescale(wav->maxpts - wav->minpts + wav->last_duration,                                       s->streams[0]->codec->sample_rate * (int64_t)s->streams[0]->time_base.num,                                       s->streams[0]->time_base.den);        if(s->streams[0]->codec->codec_tag != 0x01) {            /* Update num_samps in fact chunk */            avio_seek(pb, wav->fact_pos, SEEK_SET);            if (rf64 || (wav->rf64 == RF64_AUTO && number_of_samples > UINT32_MAX)) {                rf64 = 1;                avio_wl32(pb, -1);            } else {                avio_wl32(pb, number_of_samples);                avio_seek(pb, file_size, SEEK_SET);                avio_flush(pb);            }        }        if (rf64) {            /* overwrite RIFF with RF64 */            avio_seek(pb, 0, SEEK_SET);            ffio_wfourcc(pb, \"RF64\");            avio_wl32(pb, -1);            /* write ds64 chunk (overwrite JUNK if rf64 == RF64_AUTO) */            avio_seek(pb, wav->ds64 - 8, SEEK_SET);            ffio_wfourcc(pb, \"ds64\");            avio_wl32(pb, 28);                  /* ds64 chunk size */            avio_wl64(pb, file_size - 8);       /* RF64 chunk size */            avio_wl64(pb, data_size);           /* data chunk size */            avio_wl64(pb, number_of_samples);   /* fact chunk number of samples */            avio_wl32(pb, 0);                   /* number of table entries for non-'data' chunks */            /* write -1 in data chunk size */            avio_seek(pb, wav->data - 4, SEEK_SET);            avio_wl32(pb, -1);            avio_seek(pb, file_size, SEEK_SET);            avio_flush(pb);        }    }    if (wav->write_peak)        peak_free_buffers(s);    return 0;}", "idx": 23417}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "function": "static bool iscsi_allocationmap_is_allocated(IscsiLun *iscsilun,                                             int64_t sector_num, int nb_sectors){    unsigned long size;    if (iscsilun->allocationmap == NULL) {        return true;    }    size = DIV_ROUND_UP(sector_num + nb_sectors, iscsilun->cluster_sectors);    return !(find_next_bit(iscsilun->allocationmap, size,                           sector_num / iscsilun->cluster_sectors) == size);}", "idx": 23461}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "function": "void net_slirp_smb(const char *exported_dir){    if (slirp_smb_export) {        fprintf(stderr, \"-smb given twice\\n\");        exit(1);    }    slirp_smb_export = exported_dir;    if (slirp_inited) {        slirp_smb(exported_dir);    }}", "idx": 23533}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "function": "int qemu_savevm_state(QEMUFile *f){    int saved_vm_running;    int ret;    saved_vm_running = vm_running;    vm_stop(0);    ret = qemu_savevm_state_begin(f);    if (ret < 0)        goto out;    do {        ret = qemu_savevm_state_iterate(f);        if (ret < 0)            goto out;    } while (ret == 0);    ret = qemu_savevm_state_complete(f);out:    if (saved_vm_running)        vm_start();    return ret;}", "idx": 23603}
{"project": "qemu", "commit_id": "6484e422479c93f28e3f8a68258b0eacd3b31e6d", "target": 0, "function": "int qemu_set_fd_handler2(int fd,                         IOCanReadHandler *fd_read_poll,                         IOHandler *fd_read,                         IOHandler *fd_write,                         void *opaque){    IOHandlerRecord *ioh;    assert(fd >= 0);    if (!fd_read && !fd_write) {        QLIST_FOREACH(ioh, &io_handlers, next) {            if (ioh->fd == fd) {                ioh->deleted = 1;                break;            }        }    } else {        QLIST_FOREACH(ioh, &io_handlers, next) {            if (ioh->fd == fd)                goto found;        }        ioh = g_malloc0(sizeof(IOHandlerRecord));        QLIST_INSERT_HEAD(&io_handlers, ioh, next);    found:        ioh->fd = fd;        ioh->fd_read_poll = fd_read_poll;        ioh->fd_read = fd_read;        ioh->fd_write = fd_write;        ioh->opaque = opaque;        ioh->pollfds_idx = -1;        ioh->deleted = 0;        qemu_notify_event();    }    return 0;}", "idx": 23611}
{"project": "qemu", "commit_id": "91bea4e2bb1a5f7954a3b3a4f2e28e96bd25c458", "target": 1, "function": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,                 QEMUIOVector *qiov, int nb_sectors,                 BlockDriverCompletionFunc *cb,                 void *opaque){    IscsiLun *iscsilun = bs->opaque;    IscsiAIOCB *acb;    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);    trace_iscsi_aio_writev(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);    acb->iscsilun    = iscsilun;    acb->qiov        = qiov;    acb->nb_sectors  = nb_sectors;    acb->sector_num  = sector_num;    acb->retries     = ISCSI_CMD_RETRIES;    if (iscsi_aio_writev_acb(acb) != 0) {        qemu_aio_release(acb);    iscsi_set_events(iscsilun);    return &acb->common;", "idx": 23657}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "function": "static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len){    bool print16 = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT);    bool printall = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL);    const int width = 16;    int i;    char tmp[3 * width + 1];    char *p = tmp;    if (!printall && !print16) {        return;    }    for (i = 0; ; i++) {        if (i && (!(i % width) || (i == len))) {            if (!printall) {                trace_usb_ohci_td_pkt_short(msg, tmp);                break;            }            trace_usb_ohci_td_pkt_full(msg, tmp);            p = tmp;            *p = 0;        }        if (i == len) {            break;        }        p += sprintf(p, \" %.2x\", buf[i]);    }}", "idx": 23663}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static inline uint64_t ldq_phys_internal(target_phys_addr_t addr,                                         enum device_endian endian){    uint8_t *ptr;    uint64_t val;    MemoryRegionSection *section;    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);    if (!(memory_region_is_ram(section->mr) ||          memory_region_is_romd(section->mr))) {        /* I/O case */        addr = memory_region_section_addr(section, addr);        /* XXX This is broken when device endian != cpu endian.               Fix and add \"endian\" variable check */#ifdef TARGET_WORDS_BIGENDIAN        val = io_mem_read(section->mr, addr, 4) << 32;        val |= io_mem_read(section->mr, addr + 4, 4);#else        val = io_mem_read(section->mr, addr, 4);        val |= io_mem_read(section->mr, addr + 4, 4) << 32;#endif    } else {        /* RAM case */        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)                                & TARGET_PAGE_MASK)                               + memory_region_section_addr(section, addr));        switch (endian) {        case DEVICE_LITTLE_ENDIAN:            val = ldq_le_p(ptr);            break;        case DEVICE_BIG_ENDIAN:            val = ldq_be_p(ptr);            break;        default:            val = ldq_p(ptr);            break;        }    }    return val;}", "idx": 23686}
{"project": "FFmpeg", "commit_id": "8b31c086b6065084644b86a63c9171f3094cf6ad", "target": 0, "function": "static int decode_tag(AVCodecContext * avctx,                      void *data, int *data_size,                      AVPacket *avpkt) {    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    NellyMoserDecodeContext *s = avctx->priv_data;    int blocks, i;    int16_t* samples;    *data_size = 0;    samples = (int16_t*)data;    if (buf_size < avctx->block_align)        return buf_size;    if (buf_size % 64) {        av_log(avctx, AV_LOG_ERROR, \"Tag size %d.\\n\", buf_size);        return buf_size;    }    blocks = buf_size / 64;    /* Normal numbers of blocks for sample rates:     *  8000 Hz - 1     * 11025 Hz - 2     * 16000 Hz - 3     * 22050 Hz - 4     * 44100 Hz - 8     */    for (i=0 ; i<blocks ; i++) {        nelly_decode_block(s, &buf[i*NELLY_BLOCK_LEN], s->float_buf);        s->fmt_conv.float_to_int16(&samples[i*NELLY_SAMPLES], s->float_buf, NELLY_SAMPLES);        *data_size += NELLY_SAMPLES*sizeof(int16_t);    }    return buf_size;}", "idx": 23756}
{"project": "FFmpeg", "commit_id": "9ac831c2c02e6e1c9c322b8bb77881c1dbac6f08", "target": 0, "function": "static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,                            AVPacket *avpkt){    VP8Context *s = avctx->priv_data;    int ret, mb_x, mb_y, i, y, referenced;    enum AVDiscard skip_thresh;    AVFrame *curframe;    if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)        return ret;    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT                                || s->update_altref == VP56_FRAME_CURRENT;    skip_thresh = !referenced ? AVDISCARD_NONREF :                    !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL;    if (avctx->skip_frame >= skip_thresh) {        s->invisible = 1;        goto skip_decode;    }    for (i = 0; i < 4; i++)        if (&s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {            curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i];            break;        }    if (curframe->data[0])        avctx->release_buffer(avctx, curframe);    curframe->key_frame = s->keyframe;    curframe->pict_type = s->keyframe ? FF_I_TYPE : FF_P_TYPE;    curframe->reference = referenced ? 3 : 0;    if ((ret = avctx->get_buffer(avctx, curframe))) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed!\\n\");        return ret;    }    // Given that arithmetic probabilities are updated every frame, it's quite likely    // that the values we have on a random interframe are complete junk if we didn't    // start decode on a keyframe. So just don't display anything rather than junk.    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||                         !s->framep[VP56_FRAME_GOLDEN] ||                         !s->framep[VP56_FRAME_GOLDEN2])) {        av_log(avctx, AV_LOG_WARNING, \"Discarding interframe without a prior keyframe!\\n\");        return AVERROR_INVALIDDATA;    }    s->linesize   = curframe->linesize[0];    s->uvlinesize = curframe->linesize[1];    if (!s->edge_emu_buffer)        s->edge_emu_buffer = av_malloc(21*s->linesize);    memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));    // top edge of 127 for intra prediction    if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {        memset(curframe->data[0] - s->linesize  -1, 127, s->linesize  +1);        memset(curframe->data[1] - s->uvlinesize-1, 127, s->uvlinesize+1);        memset(curframe->data[2] - s->uvlinesize-1, 127, s->uvlinesize+1);    }    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {        VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)];        VP8Macroblock *mb = s->macroblocks + mb_y*s->mb_stride;        uint8_t *intra4x4 = s->intra4x4_pred_mode + 4*mb_y*s->b4_stride;        uint8_t *dst[3] = {            curframe->data[0] + 16*mb_y*s->linesize,            curframe->data[1] +  8*mb_y*s->uvlinesize,            curframe->data[2] +  8*mb_y*s->uvlinesize        };        memset(s->left_nnz, 0, sizeof(s->left_nnz));        // left edge of 129 for intra prediction        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE))            for (i = 0; i < 3; i++)                for (y = 0; y < 16>>!!i; y++)                    dst[i][y*curframe->linesize[i]-1] = 129;        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {            decode_mb_mode(s, mb, mb_x, mb_y, intra4x4 + 4*mb_x);            if (!mb->skip)                decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);            else {                AV_ZERO128(s->non_zero_count_cache);    // luma                AV_ZERO64(s->non_zero_count_cache[4]);  // chroma            }            if (mb->mode <= MODE_I4x4) {                intra_predict(s, dst, mb, intra4x4 + 4*mb_x, mb_x, mb_y);                memset(mb->bmv, 0, sizeof(mb->bmv));            } else {                inter_predict(s, dst, mb, mb_x, mb_y);            }            if (!mb->skip) {                idct_mb(s, dst[0], dst[1], dst[2], mb);            } else {                AV_ZERO64(s->left_nnz);                AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned                // Reset DC block predictors if they would exist if the mb had coefficients                if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {                    s->left_nnz[8]      = 0;                    s->top_nnz[mb_x][8] = 0;                }            }            dst[0] += 16;            dst[1] += 8;            dst[2] += 8;            mb++;        }        if (mb_y && s->filter.level && avctx->skip_loop_filter < skip_thresh) {            if (s->filter.simple)                filter_mb_row_simple(s, mb_y-1);            else                filter_mb_row(s, mb_y-1);        }    }    if (s->filter.level && avctx->skip_loop_filter < skip_thresh) {        if (s->filter.simple)            filter_mb_row_simple(s, mb_y-1);        else            filter_mb_row(s, mb_y-1);    }skip_decode:    // if future frames don't use the updated probabilities,    // reset them to the values we saved    if (!s->update_probabilities)        s->prob[0] = s->prob[1];    // check if golden and altref are swapped    if (s->update_altref == VP56_FRAME_GOLDEN &&        s->update_golden == VP56_FRAME_GOLDEN2)        FFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN], s->framep[VP56_FRAME_GOLDEN2]);    else {        if (s->update_altref != VP56_FRAME_NONE)            s->framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];        if (s->update_golden != VP56_FRAME_NONE)            s->framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];    }    if (s->update_last) // move cur->prev        s->framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_CURRENT];    // release no longer referenced frames    for (i = 0; i < 4; i++)        if (s->frames[i].data[0] &&            &s->frames[i] != s->framep[VP56_FRAME_CURRENT] &&            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])            avctx->release_buffer(avctx, &s->frames[i]);    if (!s->invisible) {        *(AVFrame*)data = *s->framep[VP56_FRAME_CURRENT];        *data_size = sizeof(AVFrame);    }    return avpkt->size;}", "idx": 23792}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "function": "static ssize_t local_readlink(FsContext *fs_ctx, V9fsPath *fs_path,                              char *buf, size_t bufsz){    ssize_t tsize = -1;    char buffer[PATH_MAX];    char *path = fs_path->data;    if ((fs_ctx->export_flags & V9FS_SM_MAPPED) ||        (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE)) {        int fd;        fd = open(rpath(fs_ctx, path, buffer), O_RDONLY | O_NOFOLLOW);        if (fd == -1) {            return -1;        }        do {            tsize = read(fd, (void *)buf, bufsz);        } while (tsize == -1 && errno == EINTR);        close(fd);        return tsize;    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||               (fs_ctx->export_flags & V9FS_SM_NONE)) {        tsize = readlink(rpath(fs_ctx, path, buffer), buf, bufsz);    }    return tsize;}", "idx": 23824}
{"project": "qemu", "commit_id": "a209f4615c6853a226e847810b6c607c71b6a046", "target": 0, "function": "static int virtio_blk_handle_scsi_req(VirtIOBlockReq *req){    int status = VIRTIO_BLK_S_OK;    struct virtio_scsi_inhdr *scsi = NULL;    VirtIODevice *vdev = VIRTIO_DEVICE(req->dev);    VirtQueueElement *elem = &req->elem;    VirtIOBlock *blk = req->dev;#ifdef __linux__    int i;    VirtIOBlockIoctlReq *ioctl_req;#endif    /*     * We require at least one output segment each for the virtio_blk_outhdr     * and the SCSI command block.     *     * We also at least require the virtio_blk_inhdr, the virtio_scsi_inhdr     * and the sense buffer pointer in the input segments.     */    if (elem->out_num < 2 || elem->in_num < 3) {        status = VIRTIO_BLK_S_IOERR;        goto fail;    }    /*     * The scsi inhdr is placed in the second-to-last input segment, just     * before the regular inhdr.     */    scsi = (void *)elem->in_sg[elem->in_num - 2].iov_base;    if (!blk->conf.scsi) {        status = VIRTIO_BLK_S_UNSUPP;        goto fail;    }    /*     * No support for bidirection commands yet.     */    if (elem->out_num > 2 && elem->in_num > 3) {        status = VIRTIO_BLK_S_UNSUPP;        goto fail;    }#ifdef __linux__    ioctl_req = g_new0(VirtIOBlockIoctlReq, 1);    ioctl_req->req = req;    ioctl_req->hdr.interface_id = 'S';    ioctl_req->hdr.cmd_len = elem->out_sg[1].iov_len;    ioctl_req->hdr.cmdp = elem->out_sg[1].iov_base;    ioctl_req->hdr.dxfer_len = 0;    if (elem->out_num > 2) {        /*         * If there are more than the minimally required 2 output segments         * there is write payload starting from the third iovec.         */        ioctl_req->hdr.dxfer_direction = SG_DXFER_TO_DEV;        ioctl_req->hdr.iovec_count = elem->out_num - 2;        for (i = 0; i < ioctl_req->hdr.iovec_count; i++) {            ioctl_req->hdr.dxfer_len += elem->out_sg[i + 2].iov_len;        }        ioctl_req->hdr.dxferp = elem->out_sg + 2;    } else if (elem->in_num > 3) {        /*         * If we have more than 3 input segments the guest wants to actually         * read data.         */        ioctl_req->hdr.dxfer_direction = SG_DXFER_FROM_DEV;        ioctl_req->hdr.iovec_count = elem->in_num - 3;        for (i = 0; i < ioctl_req->hdr.iovec_count; i++) {            ioctl_req->hdr.dxfer_len += elem->in_sg[i].iov_len;        }        ioctl_req->hdr.dxferp = elem->in_sg;    } else {        /*         * Some SCSI commands don't actually transfer any data.         */        ioctl_req->hdr.dxfer_direction = SG_DXFER_NONE;    }    ioctl_req->hdr.sbp = elem->in_sg[elem->in_num - 3].iov_base;    ioctl_req->hdr.mx_sb_len = elem->in_sg[elem->in_num - 3].iov_len;    blk_aio_ioctl(blk->blk, SG_IO, &ioctl_req->hdr,                  virtio_blk_ioctl_complete, ioctl_req);    return -EINPROGRESS;#else    abort();#endiffail:    /* Just put anything nonzero so that the ioctl fails in the guest.  */    if (scsi) {        virtio_stl_p(vdev, &scsi->errors, 255);    }    return status;}", "idx": 23869}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "function": "opts_visitor_cleanup(OptsVisitor *ov){    if (ov->unprocessed_opts != NULL) {        g_hash_table_destroy(ov->unprocessed_opts);    }    g_free(ov->fake_id_opt);    memset(ov, '\\0', sizeof *ov);}", "idx": 23918}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "function": "static void setup_rt_frame(int sig, struct target_sigaction *ka,                           target_siginfo_t *info,                           target_sigset_t *set, CPUAlphaState *env){    abi_ulong frame_addr, r26;    struct target_rt_sigframe *frame;    int i, err = 0;    frame_addr = get_sigframe(ka, env, sizeof(*frame));    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {        goto give_sigsegv;    }    err |= copy_siginfo_to_user(&frame->info, info);    __put_user(0, &frame->uc.tuc_flags);    __put_user(0, &frame->uc.tuc_link);    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);    __put_user(target_sigaltstack_used.ss_sp,               &frame->uc.tuc_stack.ss_sp);    __put_user(sas_ss_flags(env->ir[IR_SP]),               &frame->uc.tuc_stack.ss_flags);    __put_user(target_sigaltstack_used.ss_size,               &frame->uc.tuc_stack.ss_size);    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);    }    if (ka->sa_restorer) {        r26 = ka->sa_restorer;    } else {        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,                   &frame->retcode[1]);        __put_user(INSN_CALLSYS, &frame->retcode[2]);        /* imb(); */        r26 = frame_addr;    }    if (err) {    give_sigsegv:       if (sig == TARGET_SIGSEGV) {            ka->_sa_handler = TARGET_SIG_DFL;        }        force_sig(TARGET_SIGSEGV);    }    env->ir[IR_RA] = r26;    env->ir[IR_PV] = env->pc = ka->_sa_handler;    env->ir[IR_A0] = sig;    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);    env->ir[IR_SP] = frame_addr;}", "idx": 23933}
{"project": "qemu", "commit_id": "6133b39f3c36623425a6ede9e89d93175fde15cd", "target": 1, "function": "void coroutine_fn co_aio_sleep_ns(AioContext *ctx, QEMUClockType type,                                  int64_t ns){    CoSleepCB sleep_cb = {        .co = qemu_coroutine_self(),    };    sleep_cb.ts = aio_timer_new(ctx, type, SCALE_NS, co_sleep_cb, &sleep_cb);    timer_mod(sleep_cb.ts, qemu_clock_get_ns(type) + ns);    qemu_coroutine_yield();    timer_del(sleep_cb.ts);    timer_free(sleep_cb.ts);", "idx": 23948}
{"project": "qemu", "commit_id": "daf767b16aeb32e5b9a77066ba130fe723f875ca", "target": 1, "function": "void cpu_set_log(int log_flags){    loglevel = log_flags;    if (loglevel && !logfile) {        logfile = fopen(logfilename, log_append ? \"a\" : \"w\");        if (!logfile) {            perror(logfilename);            _exit(1);        }#if !defined(CONFIG_SOFTMMU)        /* must avoid mmap() usage of glibc by setting a buffer \"by hand\" */        {            static char logfile_buf[4096];            setvbuf(logfile, logfile_buf, _IOLBF, sizeof(logfile_buf));        }#elif !defined(_WIN32)        /* Win32 doesn't support line-buffering and requires size >= 2 */        setvbuf(logfile, NULL, _IOLBF, 0);#endif        log_append = 1;    }    if (!loglevel && logfile) {        fclose(logfile);        logfile = NULL;    }}", "idx": 23950}
{"project": "FFmpeg", "commit_id": "d3e5fbb1406995e07fccbff3ca8c1e24f57a1f7b", "target": 0, "function": "static void do_apply_filter(APEContext *ctx, int version, APEFilter *f,                            int32_t *data, int count, int order, int fracbits){    int res;    int absres;    while (count--) {        /* round fixedpoint scalar product */        res = ctx->adsp.scalarproduct_and_madd_int16(f->coeffs,                                                     f->delay - order,                                                     f->adaptcoeffs - order,                                                     order, APESIGN(*data));        res = (res + (1 << (fracbits - 1))) >> fracbits;        res += *data;        *data++ = res;        /* Update the output history */        *f->delay++ = av_clip_int16(res);        if (version < 3980) {            /* Version ??? to < 3.98 files (untested) */            f->adaptcoeffs[0]  = (res == 0) ? 0 : ((res >> 28) & 8) - 4;            f->adaptcoeffs[-4] >>= 1;            f->adaptcoeffs[-8] >>= 1;        } else {            /* Version 3.98 and later files */            /* Update the adaption coefficients */            absres = FFABS(res);            if (absres)                *f->adaptcoeffs = ((res & (-1<<31)) ^ (-1<<30)) >>                                  (25 + (absres <= f->avg*3) + (absres <= f->avg*4/3));            else                *f->adaptcoeffs = 0;            f->avg += (absres - f->avg) / 16;            f->adaptcoeffs[-1] >>= 1;            f->adaptcoeffs[-2] >>= 1;            f->adaptcoeffs[-8] >>= 1;        }        f->adaptcoeffs++;        /* Have we filled the history buffer? */        if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {            memmove(f->historybuffer, f->delay - (order * 2),                    (order * 2) * sizeof(*f->historybuffer));            f->delay = f->historybuffer + order * 2;            f->adaptcoeffs = f->historybuffer + order;        }    }}", "idx": 23991}
{"project": "FFmpeg", "commit_id": "ae4cffd9fc5bc495692920d646d7d1462315cfa6", "target": 0, "function": "static inline void RENAME(rgb32tobgr15)(const uint8_t *src, uint8_t *dst, unsigned src_size){\tconst uint8_t *s = src;\tconst uint8_t *end;#ifdef HAVE_MMX\tconst uint8_t *mm_end;#endif\tuint16_t *d = (uint16_t *)dst;\tend = s + src_size;#ifdef HAVE_MMX\t__asm __volatile(PREFETCH\"\t%0\"::\"m\"(*src):\"memory\");\t__asm __volatile(\t    \"movq\t%0, %%mm7\\n\\t\"\t    \"movq\t%1, %%mm6\\n\\t\"\t    ::\"m\"(red_15mask),\"m\"(green_15mask));\tmm_end = end - 15;\twhile(s < mm_end)\t{\t    __asm __volatile(\t\tPREFETCH\" 32%1\\n\\t\"\t\t\"movd\t%1, %%mm0\\n\\t\"\t\t\"movd\t4%1, %%mm3\\n\\t\"\t\t\"punpckldq 8%1, %%mm0\\n\\t\"\t\t\"punpckldq 12%1, %%mm3\\n\\t\"\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\t\t\"movq\t%%mm3, %%mm4\\n\\t\"\t\t\"movq\t%%mm3, %%mm5\\n\\t\"\t\t\"psllq\t$7, %%mm0\\n\\t\"\t\t\"psllq\t$7, %%mm3\\n\\t\"\t\t\"pand\t%%mm7, %%mm0\\n\\t\"\t\t\"pand\t%%mm7, %%mm3\\n\\t\"\t\t\"psrlq\t$6, %%mm1\\n\\t\"\t\t\"psrlq\t$6, %%mm4\\n\\t\"\t\t\"pand\t%%mm6, %%mm1\\n\\t\"\t\t\"pand\t%%mm6, %%mm4\\n\\t\"\t\t\"psrlq\t$19, %%mm2\\n\\t\"\t\t\"psrlq\t$19, %%mm5\\n\\t\"\t\t\"pand\t%2, %%mm2\\n\\t\"\t\t\"pand\t%2, %%mm5\\n\\t\"\t\t\"por\t%%mm1, %%mm0\\n\\t\"\t\t\"por\t%%mm4, %%mm3\\n\\t\"\t\t\"por\t%%mm2, %%mm0\\n\\t\"\t\t\"por\t%%mm5, %%mm3\\n\\t\"\t\t\"psllq\t$16, %%mm3\\n\\t\"\t\t\"por\t%%mm3, %%mm0\\n\\t\"\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\t\t:\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\t\td += 4;\t\ts += 16;\t}\t__asm __volatile(SFENCE:::\"memory\");\t__asm __volatile(EMMS:::\"memory\");#endif\twhile(s < end)\t{\t\tconst int src= *((uint32_t*)s)++;\t\t*d++ = ((src&0xF8)<<7) + ((src&0xF800)>>6) + ((src&0xF80000)>>19);\t}}", "idx": 23997}
{"project": "FFmpeg", "commit_id": "c0b17ea106b94f79255f81ec36ea50096e1ae985", "target": 1, "function": "static int roq_dpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                                 const AVFrame *frame, int *got_packet_ptr){    int i, stereo, data_size, ret;    const int16_t *in = frame ? (const int16_t *)frame->data[0] : NULL;    uint8_t *out;    ROQDPCMContext *context = avctx->priv_data;    stereo = (avctx->channels == 2);    if (!in && context->input_frames >= 8)        return 0;    if (in && context->input_frames < 8) {        memcpy(&context->frame_buffer[context->buffered_samples * avctx->channels],               in, avctx->frame_size * avctx->channels * sizeof(*in));        context->buffered_samples += avctx->frame_size;        if (context->input_frames == 0)            context->first_pts = frame->pts;        if (context->input_frames < 7) {            context->input_frames++;            return 0;        in = context->frame_buffer;    if (stereo) {        context->lastSample[0] &= 0xFF00;        context->lastSample[1] &= 0xFF00;    if (context->input_frames == 7 || !in)        data_size = avctx->channels * context->buffered_samples;    else        data_size = avctx->channels * avctx->frame_size;    if ((ret = ff_alloc_packet2(avctx, avpkt, ROQ_HEADER_SIZE + data_size)))        return ret;    out = avpkt->data;    bytestream_put_byte(&out, stereo ? 0x21 : 0x20);    bytestream_put_byte(&out, 0x10);    bytestream_put_le32(&out, data_size);    if (stereo) {        bytestream_put_byte(&out, (context->lastSample[1])>>8);        bytestream_put_byte(&out, (context->lastSample[0])>>8);    } else        bytestream_put_le16(&out, context->lastSample[0]);    /* Write the actual samples */    for (i = 0; i < data_size; i++)        *out++ = dpcm_predict(&context->lastSample[i & 1], *in++);    avpkt->pts      = context->input_frames <= 7 ? context->first_pts : frame->pts;    avpkt->duration = data_size / avctx->channels;    context->input_frames++;    if (!in)        context->input_frames = FFMAX(context->input_frames, 8);    *got_packet_ptr = 1;    return 0;", "idx": 24013}
{"project": "qemu", "commit_id": "a3251186fc6a04d421e9c4b65aa04ec32379ec38", "target": 0, "function": "static CCPrepare gen_prepare_cc(DisasContext *s, int b, TCGv reg){    int inv, jcc_op, size, cond;    CCPrepare cc;    TCGv t0;    inv = b & 1;    jcc_op = (b >> 1) & 7;    switch (s->cc_op) {    case CC_OP_SUBB ... CC_OP_SUBQ:        /* We optimize relational operators for the cmp/jcc case.  */        size = s->cc_op - CC_OP_SUBB;        switch (jcc_op) {        case JCC_BE:            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);            gen_extu(size, cpu_tmp4);            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);            cc = (CCPrepare) { .cond = TCG_COND_LEU, .reg = cpu_tmp4,                               .reg2 = t0, .mask = -1, .use_reg2 = true };            break;        case JCC_L:            cond = TCG_COND_LT;            goto fast_jcc_l;        case JCC_LE:            cond = TCG_COND_LE;        fast_jcc_l:            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);            gen_exts(size, cpu_tmp4);            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, true);            cc = (CCPrepare) { .cond = cond, .reg = cpu_tmp4,                               .reg2 = t0, .mask = -1, .use_reg2 = true };            break;        default:            goto slow_jcc;        }        break;    default:    slow_jcc:        /* This actually generates good code for JC, JZ and JS.  */        switch (jcc_op) {        case JCC_O:            cc = gen_prepare_eflags_o(s, reg);            break;        case JCC_B:            cc = gen_prepare_eflags_c(s, reg);            break;        case JCC_Z:            cc = gen_prepare_eflags_z(s, reg);            break;        case JCC_BE:            gen_compute_eflags(s);            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = cpu_cc_src,                               .mask = CC_Z | CC_C };            break;        case JCC_S:            cc = gen_prepare_eflags_s(s, reg);            break;        case JCC_P:            cc = gen_prepare_eflags_p(s, reg);            break;        case JCC_L:            gen_compute_eflags(s);            if (TCGV_EQUAL(reg, cpu_cc_src)) {                reg = cpu_tmp0;            }            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */            tcg_gen_xor_tl(reg, reg, cpu_cc_src);            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,                               .mask = CC_S };            break;        default:        case JCC_LE:            gen_compute_eflags(s);            if (TCGV_EQUAL(reg, cpu_cc_src)) {                reg = cpu_tmp0;            }            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */            tcg_gen_xor_tl(reg, reg, cpu_cc_src);            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,                               .mask = CC_S | CC_Z };            break;        }        break;    }    if (inv) {        cc.cond = tcg_invert_cond(cc.cond);    }    return cc;}", "idx": 24053}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "function": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr){    unsigned int i;    /* Discard jump cache entries for any tb which might potentially       overlap the flushed page.  */    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);    memset(&cpu->tb_jmp_cache[i], 0,           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));    i = tb_jmp_cache_hash_page(addr);    memset(&cpu->tb_jmp_cache[i], 0,           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));}", "idx": 24075}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "function": "static int find_image_format(BlockDriverState *bs, const char *filename,                             BlockDriver **pdrv, Error **errp){    BlockDriver *drv;    uint8_t buf[BLOCK_PROBE_BUF_SIZE];    int ret = 0;    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */    if (bs->sg || !bdrv_is_inserted(bs) || bdrv_getlength(bs) == 0) {        *pdrv = &bdrv_raw;        return ret;    }    ret = bdrv_pread(bs, 0, buf, sizeof(buf));    if (ret < 0) {        error_setg_errno(errp, -ret, \"Could not read image for determining its \"                         \"format\");        *pdrv = NULL;        return ret;    }    drv = bdrv_probe_all(buf, ret, filename);    if (!drv) {        error_setg(errp, \"Could not determine image format: No compatible \"                   \"driver found\");        ret = -ENOENT;    }    *pdrv = drv;    return ret;}", "idx": 24092}
{"project": "FFmpeg", "commit_id": "a057ef6923fba7947d8ccf27b751bf91fde3a755", "target": 0, "function": "static int mp_decode_layer3(MPADecodeContext *s){    int nb_granules, main_data_begin;    int gr, ch, blocksplit_flag, i, j, k, n, bits_pos;    GranuleDef *g;    int16_t exponents[576]; //FIXME try INTFLOAT    /* read side info */    if (s->lsf) {        main_data_begin = get_bits(&s->gb, 8);        skip_bits(&s->gb, s->nb_channels);        nb_granules = 1;    } else {        main_data_begin = get_bits(&s->gb, 9);        if (s->nb_channels == 2)            skip_bits(&s->gb, 3);        else            skip_bits(&s->gb, 5);        nb_granules = 2;        for (ch = 0; ch < s->nb_channels; ch++) {            s->granules[ch][0].scfsi = 0;/* all scale factors are transmitted */            s->granules[ch][1].scfsi = get_bits(&s->gb, 4);        }    }    for (gr = 0; gr < nb_granules; gr++) {        for (ch = 0; ch < s->nb_channels; ch++) {            av_dlog(s->avctx, \"gr=%d ch=%d: side_info\\n\", gr, ch);            g = &s->granules[ch][gr];            g->part2_3_length = get_bits(&s->gb, 12);            g->big_values     = get_bits(&s->gb,  9);            if (g->big_values > 288) {                av_log(s->avctx, AV_LOG_ERROR, \"big_values too big\\n\");                return AVERROR_INVALIDDATA;            }            g->global_gain = get_bits(&s->gb, 8);            /* if MS stereo only is selected, we precompute the               1/sqrt(2) renormalization factor */            if ((s->mode_ext & (MODE_EXT_MS_STEREO | MODE_EXT_I_STEREO)) ==                MODE_EXT_MS_STEREO)                g->global_gain -= 2;            if (s->lsf)                g->scalefac_compress = get_bits(&s->gb, 9);            else                g->scalefac_compress = get_bits(&s->gb, 4);            blocksplit_flag = get_bits1(&s->gb);            if (blocksplit_flag) {                g->block_type = get_bits(&s->gb, 2);                if (g->block_type == 0) {                    av_log(s->avctx, AV_LOG_ERROR, \"invalid block type\\n\");                    return AVERROR_INVALIDDATA;                }                g->switch_point = get_bits1(&s->gb);                for (i = 0; i < 2; i++)                    g->table_select[i] = get_bits(&s->gb, 5);                for (i = 0; i < 3; i++)                    g->subblock_gain[i] = get_bits(&s->gb, 3);                ff_init_short_region(s, g);            } else {                int region_address1, region_address2;                g->block_type = 0;                g->switch_point = 0;                for (i = 0; i < 3; i++)                    g->table_select[i] = get_bits(&s->gb, 5);                /* compute huffman coded region sizes */                region_address1 = get_bits(&s->gb, 4);                region_address2 = get_bits(&s->gb, 3);                av_dlog(s->avctx, \"region1=%d region2=%d\\n\",                        region_address1, region_address2);                ff_init_long_region(s, g, region_address1, region_address2);            }            ff_region_offset2size(g);            ff_compute_band_indexes(s, g);            g->preflag = 0;            if (!s->lsf)                g->preflag = get_bits1(&s->gb);            g->scalefac_scale     = get_bits1(&s->gb);            g->count1table_select = get_bits1(&s->gb);            av_dlog(s->avctx, \"block_type=%d switch_point=%d\\n\",                    g->block_type, g->switch_point);        }    }    if (!s->adu_mode) {        const uint8_t *ptr = s->gb.buffer + (get_bits_count(&s->gb)>>3);        int extrasize = av_clip(get_bits_left(&s->gb) >> 3, 0, EXTRABYTES);        assert((get_bits_count(&s->gb) & 7) == 0);        /* now we get bits from the main_data_begin offset */        av_dlog(s->avctx, \"seekback: %d\\n\", main_data_begin);    //av_log(NULL, AV_LOG_ERROR, \"backstep:%d, lastbuf:%d\\n\", main_data_begin, s->last_buf_size);        memcpy(s->last_buf + s->last_buf_size, ptr, extrasize);        s->in_gb = s->gb;        init_get_bits(&s->gb, s->last_buf, s->last_buf_size*8);#if !UNCHECKED_BITSTREAM_READER        s->gb.size_in_bits_plus8 += FFMAX(extrasize, LAST_BUF_SIZE - s->last_buf_size) * 8;#endif        skip_bits_long(&s->gb, 8*(s->last_buf_size - main_data_begin));    }    for (gr = 0; gr < nb_granules; gr++) {        for (ch = 0; ch < s->nb_channels; ch++) {            g = &s->granules[ch][gr];            if (get_bits_count(&s->gb) < 0) {                av_log(s->avctx, AV_LOG_DEBUG, \"mdb:%d, lastbuf:%d skipping granule %d\\n\",                       main_data_begin, s->last_buf_size, gr);                skip_bits_long(&s->gb, g->part2_3_length);                memset(g->sb_hybrid, 0, sizeof(g->sb_hybrid));                if (get_bits_count(&s->gb) >= s->gb.size_in_bits && s->in_gb.buffer) {                    skip_bits_long(&s->in_gb, get_bits_count(&s->gb) - s->gb.size_in_bits);                    s->gb           = s->in_gb;                    s->in_gb.buffer = NULL;                }                continue;            }            bits_pos = get_bits_count(&s->gb);            if (!s->lsf) {                uint8_t *sc;                int slen, slen1, slen2;                /* MPEG1 scale factors */                slen1 = slen_table[0][g->scalefac_compress];                slen2 = slen_table[1][g->scalefac_compress];                av_dlog(s->avctx, \"slen1=%d slen2=%d\\n\", slen1, slen2);                if (g->block_type == 2) {                    n = g->switch_point ? 17 : 18;                    j = 0;                    if (slen1) {                        for (i = 0; i < n; i++)                            g->scale_factors[j++] = get_bits(&s->gb, slen1);                    } else {                        for (i = 0; i < n; i++)                            g->scale_factors[j++] = 0;                    }                    if (slen2) {                        for (i = 0; i < 18; i++)                            g->scale_factors[j++] = get_bits(&s->gb, slen2);                        for (i = 0; i < 3; i++)                            g->scale_factors[j++] = 0;                    } else {                        for (i = 0; i < 21; i++)                            g->scale_factors[j++] = 0;                    }                } else {                    sc = s->granules[ch][0].scale_factors;                    j = 0;                    for (k = 0; k < 4; k++) {                        n = k == 0 ? 6 : 5;                        if ((g->scfsi & (0x8 >> k)) == 0) {                            slen = (k < 2) ? slen1 : slen2;                            if (slen) {                                for (i = 0; i < n; i++)                                    g->scale_factors[j++] = get_bits(&s->gb, slen);                            } else {                                for (i = 0; i < n; i++)                                    g->scale_factors[j++] = 0;                            }                        } else {                            /* simply copy from last granule */                            for (i = 0; i < n; i++) {                                g->scale_factors[j] = sc[j];                                j++;                            }                        }                    }                    g->scale_factors[j++] = 0;                }            } else {                int tindex, tindex2, slen[4], sl, sf;                /* LSF scale factors */                if (g->block_type == 2)                    tindex = g->switch_point ? 2 : 1;                else                    tindex = 0;                sf = g->scalefac_compress;                if ((s->mode_ext & MODE_EXT_I_STEREO) && ch == 1) {                    /* intensity stereo case */                    sf >>= 1;                    if (sf < 180) {                        lsf_sf_expand(slen, sf, 6, 6, 0);                        tindex2 = 3;                    } else if (sf < 244) {                        lsf_sf_expand(slen, sf - 180, 4, 4, 0);                        tindex2 = 4;                    } else {                        lsf_sf_expand(slen, sf - 244, 3, 0, 0);                        tindex2 = 5;                    }                } else {                    /* normal case */                    if (sf < 400) {                        lsf_sf_expand(slen, sf, 5, 4, 4);                        tindex2 = 0;                    } else if (sf < 500) {                        lsf_sf_expand(slen, sf - 400, 5, 4, 0);                        tindex2 = 1;                    } else {                        lsf_sf_expand(slen, sf - 500, 3, 0, 0);                        tindex2 = 2;                        g->preflag = 1;                    }                }                j = 0;                for (k = 0; k < 4; k++) {                    n  = lsf_nsf_table[tindex2][tindex][k];                    sl = slen[k];                    if (sl) {                        for (i = 0; i < n; i++)                            g->scale_factors[j++] = get_bits(&s->gb, sl);                    } else {                        for (i = 0; i < n; i++)                            g->scale_factors[j++] = 0;                    }                }                /* XXX: should compute exact size */                for (; j < 40; j++)                    g->scale_factors[j] = 0;            }            exponents_from_scale_factors(s, g, exponents);            /* read Huffman coded residue */            huffman_decode(s, g, exponents, bits_pos + g->part2_3_length);        } /* ch */        if (s->nb_channels == 2)            compute_stereo(s, &s->granules[0][gr], &s->granules[1][gr]);        for (ch = 0; ch < s->nb_channels; ch++) {            g = &s->granules[ch][gr];            reorder_block(s, g);            compute_antialias(s, g);            compute_imdct(s, g, &s->sb_samples[ch][18 * gr][0], s->mdct_buf[ch]);        }    } /* gr */    if (get_bits_count(&s->gb) < 0)        skip_bits_long(&s->gb, -get_bits_count(&s->gb));    return nb_granules * 18;}", "idx": 24155}
{"project": "qemu", "commit_id": "883bca776daa43111e9c39008f0038f7c62ae723", "target": 0, "function": "static int uhci_handle_td(UHCIState *s, uint32_t addr, UHCI_TD *td,                          uint32_t *int_mask, bool queuing){    UHCIAsync *async;    int len = 0, max_len;    uint8_t pid;    USBDevice *dev;    USBEndpoint *ep;    /* Is active ? */    if (!(td->ctrl & TD_CTRL_ACTIVE))        return TD_RESULT_NEXT_QH;    async = uhci_async_find_td(s, addr, td);    if (async) {        /* Already submitted */        async->queue->valid = 32;        if (!async->done)            return TD_RESULT_ASYNC_CONT;        if (queuing) {            /* we are busy filling the queue, we are not prepared               to consume completed packages then, just leave them               in async state */            return TD_RESULT_ASYNC_CONT;        }        uhci_async_unlink(async);        goto done;    }    /* Allocate new packet */    async = uhci_async_alloc(uhci_queue_get(s, td), addr);    /* valid needs to be large enough to handle 10 frame delay     * for initial isochronous requests     */    async->queue->valid = 32;    async->isoc = td->ctrl & TD_CTRL_IOS;    max_len = ((td->token >> 21) + 1) & 0x7ff;    pid = td->token & 0xff;    dev = uhci_find_device(s, (td->token >> 8) & 0x7f);    ep = usb_ep_get(dev, pid, (td->token >> 15) & 0xf);    usb_packet_setup(&async->packet, pid, ep, addr);    qemu_sglist_add(&async->sgl, td->buffer, max_len);    usb_packet_map(&async->packet, &async->sgl);    switch(pid) {    case USB_TOKEN_OUT:    case USB_TOKEN_SETUP:        len = usb_handle_packet(dev, &async->packet);        if (len >= 0)            len = max_len;        break;    case USB_TOKEN_IN:        len = usb_handle_packet(dev, &async->packet);        break;    default:        /* invalid pid : frame interrupted */        uhci_async_free(async);        s->status |= UHCI_STS_HCPERR;        uhci_update_irq(s);        return TD_RESULT_STOP_FRAME;    }     if (len == USB_RET_ASYNC) {        uhci_async_link(async);        return TD_RESULT_ASYNC_START;    }    async->packet.result = len;done:    len = uhci_complete_td(s, td, async, int_mask);    usb_packet_unmap(&async->packet, &async->sgl);    uhci_async_free(async);    return len;}", "idx": 24158}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "function": "static void vfio_platform_eoi(VFIODevice *vbasedev){    VFIOINTp *intp;    VFIOPlatformDevice *vdev =        container_of(vbasedev, VFIOPlatformDevice, vbasedev);    qemu_mutex_lock(&vdev->intp_mutex);    QLIST_FOREACH(intp, &vdev->intp_list, next) {        if (intp->state == VFIO_IRQ_ACTIVE) {            trace_vfio_platform_eoi(intp->pin,                                event_notifier_get_fd(&intp->interrupt));            intp->state = VFIO_IRQ_INACTIVE;            /* deassert the virtual IRQ */            qemu_set_irq(intp->qemuirq, 0);            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {                /* unmasks the physical level-sensitive IRQ */                vfio_unmask_single_irqindex(vbasedev, intp->pin);            }            /* a single IRQ can be active at a time */            break;        }    }    /* in case there are pending IRQs, handle the first one */    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);        vfio_intp_inject_pending_lockheld(intp);        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);    }    qemu_mutex_unlock(&vdev->intp_mutex);}", "idx": 24162}
{"project": "qemu", "commit_id": "6ecd0b6ba0591ef280ed984103924d4bdca5ac32", "target": 0, "function": "static void pmuserenr_write(CPUARMState *env, const ARMCPRegInfo *ri,                            uint64_t value){    env->cp15.c9_pmuserenr = value & 1;}", "idx": 24214}
{"project": "FFmpeg", "commit_id": "7fb92be7e50ea4ba5712804326c6814ae02dd190", "target": 1, "function": "static inline void qtrle_decode_2n4bpp(QtrleContext *s, int stream_ptr,                             int row_ptr, int lines_to_change, int bpp){    int rle_code, i;    int pixel_ptr;    int row_inc = s->frame.linesize[0];    unsigned char pi[16];  /* 16 palette indices */    unsigned char *rgb = s->frame.data[0];    int pixel_limit = s->frame.linesize[0] * s->avctx->height;    int num_pixels = (bpp == 4) ? 8 : 16;    while (lines_to_change--) {        CHECK_STREAM_PTR(2);        pixel_ptr = row_ptr + (num_pixels * (s->buf[stream_ptr++] - 1));        while ((rle_code = (signed char)s->buf[stream_ptr++]) != -1) {            if (rle_code == 0) {                /* there's another skip code in the stream */                CHECK_STREAM_PTR(1);                pixel_ptr += (num_pixels * (s->buf[stream_ptr++] - 1));            } else if (rle_code < 0) {                /* decode the run length code */                rle_code = -rle_code;                /* get the next 4 bytes from the stream, treat them as palette                 * indexes, and output them rle_code times */                CHECK_STREAM_PTR(4);                for (i = num_pixels-1; i >= 0; i--) {                    pi[num_pixels-1-i] = (s->buf[stream_ptr] >> ((i*bpp) & 0x07)) & ((1<<bpp)-1);                    stream_ptr+= ((i & ((num_pixels>>2)-1)) == 0);                }                CHECK_PIXEL_PTR(rle_code * num_pixels);                while (rle_code--) {                    for (i = 0; i < num_pixels; i++)                        rgb[pixel_ptr++] = pi[i];                }            } else {                /* copy the same pixel directly to output 4 times */                rle_code *= 4;                CHECK_STREAM_PTR(rle_code);                CHECK_PIXEL_PTR(rle_code*(num_pixels>>2));                while (rle_code--) {                    if(bpp == 4) {                        rgb[pixel_ptr++] = ((s->buf[stream_ptr]) >> 4) & 0x0f;                        rgb[pixel_ptr++] = (s->buf[stream_ptr++]) & 0x0f;                    } else {                        rgb[pixel_ptr++] = ((s->buf[stream_ptr]) >> 6) & 0x03;                        rgb[pixel_ptr++] = ((s->buf[stream_ptr]) >> 4) & 0x03;                        rgb[pixel_ptr++] = ((s->buf[stream_ptr]) >> 2) & 0x03;                        rgb[pixel_ptr++] = (s->buf[stream_ptr++]) & 0x03;                    }                }            }        }        row_ptr += row_inc;    }}", "idx": 24241}
{"project": "FFmpeg", "commit_id": "74853ed3f845212f4092e7b7e89dc2262926f4f5", "target": 1, "function": "static void init_input_filter(FilterGraph *fg, AVFilterInOut *in){    InputStream *ist;    enum AVMediaType type = avfilter_pad_get_type(in->filter_ctx->input_pads, in->pad_idx);    int i;    // TODO: support other filter types    if (type != AVMEDIA_TYPE_VIDEO && type != AVMEDIA_TYPE_AUDIO) {        av_log(NULL, AV_LOG_FATAL, \"Only video and audio filters supported \"               \"currently.\\n\");        exit_program(1);    }    if (in->name) {        AVFormatContext *s;        AVStream       *st = NULL;        char *p;        int file_idx = strtol(in->name, &p, 0);        if (file_idx < 0 || file_idx >= nb_input_files) {            av_log(NULL, AV_LOG_FATAL, \"Invalid file index %d in filtegraph description %s.\\n\",                   file_idx, fg->graph_desc);            exit_program(1);        }        s = input_files[file_idx]->ctx;        for (i = 0; i < s->nb_streams; i++) {            if (s->streams[i]->codec->codec_type != type)                continue;            if (check_stream_specifier(s, s->streams[i], *p == ':' ? p + 1 : p) == 1) {                st = s->streams[i];                break;            }        }        if (!st) {            av_log(NULL, AV_LOG_FATAL, \"Stream specifier '%s' in filtergraph description %s \"                   \"matches no streams.\\n\", p, fg->graph_desc);            exit_program(1);        }        ist = input_streams[input_files[file_idx]->ist_index + st->index];    } else {        /* find the first unused stream of corresponding type */        for (i = 0; i < nb_input_streams; i++) {            ist = input_streams[i];            if (ist->st->codec->codec_type == type && ist->discard)                break;        }        if (i == nb_input_streams) {            av_log(NULL, AV_LOG_FATAL, \"Cannot find a matching stream for \"                   \"unlabeled input pad %d on filter %s\", in->pad_idx,                   in->filter_ctx->name);            exit_program(1);        }    }    ist->discard         = 0;    ist->decoding_needed = 1;    ist->st->discard = AVDISCARD_NONE;    fg->inputs = grow_array(fg->inputs, sizeof(*fg->inputs),                            &fg->nb_inputs, fg->nb_inputs + 1);    if (!(fg->inputs[fg->nb_inputs - 1] = av_mallocz(sizeof(*fg->inputs[0]))))        exit_program(1);    fg->inputs[fg->nb_inputs - 1]->ist   = ist;    fg->inputs[fg->nb_inputs - 1]->graph = fg;    ist->filters = grow_array(ist->filters, sizeof(*ist->filters),                              &ist->nb_filters, ist->nb_filters + 1);    ist->filters[ist->nb_filters - 1] = fg->inputs[fg->nb_inputs - 1];}", "idx": 24255}
{"project": "qemu", "commit_id": "fff39a7ad09da07ef490de05c92c91f22f8002f2", "target": 1, "function": "static void v9fs_rename(void *opaque){    int32_t fid;    ssize_t err = 0;    size_t offset = 7;    V9fsString name;    int32_t newdirfid;    V9fsFidState *fidp;    V9fsPDU *pdu = opaque;    V9fsState *s = pdu->s;    v9fs_string_init(&name);    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);    if (err < 0) {    fidp = get_fid(pdu, fid);    if (fidp == NULL) {    BUG_ON(fidp->fid_type != P9_FID_NONE);    /* if fs driver is not path based, return EOPNOTSUPP */    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {        err = -EOPNOTSUPP;        goto out;    v9fs_path_write_lock(s);    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);    v9fs_path_unlock(s);    if (!err) {        err = offset;out:    put_fid(pdu, fidp);out_nofid:    pdu_complete(pdu, err);    v9fs_string_free(&name);", "idx": 24265}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "function": "target_ulong helper_srad(CPUPPCState *env, target_ulong value,                         target_ulong shift){    int64_t ret;    if (likely(!(shift & 0x40))) {        if (likely((uint64_t)shift != 0)) {            shift &= 0x3f;            ret = (int64_t)value >> shift;            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {                env->ca = 0;            } else {                env->ca = 1;            }        } else {            ret = (int64_t)value;            env->ca = 0;        }    } else {        ret = (int64_t)value >> 63;        env->ca = (ret != 0);    }    return ret;}", "idx": 24336}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "function": "void powerpc_display_perf_report(void){  int i;#ifndef POWERPC_PERF_USE_PMC  fprintf(stderr, \"PowerPC performance report\\n Values are from the Time Base register, and represent 4 bus cycles.\\n\");#else /* POWERPC_PERF_USE_PMC */  fprintf(stderr, \"PowerPC performance report\\n Values are from the PMC registers, and represent whatever the registers are set to record.\\n\");#endif /* POWERPC_PERF_USE_PMC */  for(i = 0 ; i < powerpc_perf_total ; i++)  {    if (perfdata[i][powerpc_data_num] != (unsigned long long)0)      fprintf(stderr, \" Function \\\"%s\\\" (pmc1):\\n\\tmin: %llu\\n\\tmax: %llu\\n\\tavg: %1.2lf (%llu)\\n\",              perfname[i],              perfdata[i][powerpc_data_min],              perfdata[i][powerpc_data_max],              (double)perfdata[i][powerpc_data_sum] /              (double)perfdata[i][powerpc_data_num],              perfdata[i][powerpc_data_num]);#ifdef POWERPC_PERF_USE_PMC    if (perfdata_pmc2[i][powerpc_data_num] != (unsigned long long)0)      fprintf(stderr, \" Function \\\"%s\\\" (pmc2):\\n\\tmin: %llu\\n\\tmax: %llu\\n\\tavg: %1.2lf (%llu)\\n\",              perfname[i],              perfdata_pmc2[i][powerpc_data_min],              perfdata_pmc2[i][powerpc_data_max],              (double)perfdata_pmc2[i][powerpc_data_sum] /              (double)perfdata_pmc2[i][powerpc_data_num],              perfdata_pmc2[i][powerpc_data_num]);    if (perfdata_pmc3[i][powerpc_data_num] != (unsigned long long)0)      fprintf(stderr, \" Function \\\"%s\\\" (pmc3):\\n\\tmin: %llu\\n\\tmax: %llu\\n\\tavg: %1.2lf (%llu)\\n\",              perfname[i],              perfdata_pmc3[i][powerpc_data_min],              perfdata_pmc3[i][powerpc_data_max],              (double)perfdata_pmc3[i][powerpc_data_sum] /              (double)perfdata_pmc3[i][powerpc_data_num],              perfdata_pmc3[i][powerpc_data_num]);#endif  }}", "idx": 24344}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "function": "static int standard_decode_i_mbs(VC9Context *v){    int x, y, ac_pred, cbpcy;    /* Select ttmb table depending on pq */    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];    else v->ttmb_vlc = &vc9_ttmb_vlc[2];    for (y=0; y<v->height_mb; y++)    {        for (x=0; x<v->width_mb; x++)        {            cbpcy = get_vlc2(&v->gb, vc9_cbpcy_i_vlc.table,                             VC9_CBPCY_I_VLC_BITS, 2);            ac_pred = get_bits(&v->gb, 1);            //Decode blocks from that mb wrt cbpcy        }    }    return 0;}", "idx": 24395}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static void dead_tmp(TCGv tmp){    int i;    num_temps--;    i = num_temps;    if (GET_TCGV(temps[i]) == GET_TCGV(tmp))        return;    /* Shuffle this temp to the last slot.  */    while (GET_TCGV(temps[i]) != GET_TCGV(tmp))        i--;    while (i < num_temps) {        temps[i] = temps[i + 1];        i++;    }    temps[i] = tmp;}", "idx": 24455}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "function": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){    long i;#if !HAVE_FAST_UNALIGNED    if((long)src2 & (sizeof(long)-1)){        for(i=0; i+7<w; i+=8){            dst[i+0] = src1[i+0]-src2[i+0];            dst[i+1] = src1[i+1]-src2[i+1];            dst[i+2] = src1[i+2]-src2[i+2];            dst[i+3] = src1[i+3]-src2[i+3];            dst[i+4] = src1[i+4]-src2[i+4];            dst[i+5] = src1[i+5]-src2[i+5];            dst[i+6] = src1[i+6]-src2[i+6];            dst[i+7] = src1[i+7]-src2[i+7];        }    }else#endif    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){        long a = *(long*)(src1+i);        long b = *(long*)(src2+i);        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);    }    for(; i<w; i++)        dst[i+0] = src1[i+0]-src2[i+0];}", "idx": 24472}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "function": "static void virtio_blk_flush_complete(void *opaque, int ret){    VirtIOBlockReq *req = opaque;    if (ret) {        if (virtio_blk_handle_rw_error(req, -ret, 0)) {            return;        }    }    virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);    block_acct_done(bdrv_get_stats(req->dev->bs), &req->acct);    virtio_blk_free_request(req);}", "idx": 24509}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "function": "void ppc_hw_interrupt (CPUState *env){    env->exception_index = -1;}", "idx": 24510}
{"project": "FFmpeg", "commit_id": "b83ccbffe9b109fcd18dbd178d6b4f300e6d6799", "target": 1, "function": "static void do_video_out(AVFormatContext *s,                         AVOutputStream *ost,                         AVInputStream *ist,                         AVFrame *in_picture,                         int *frame_size){    int nb_frames, i, ret;    int64_t topBand, bottomBand, leftBand, rightBand;    AVFrame *final_picture, *formatted_picture, *resampling_dst, *padding_src;    AVFrame picture_crop_temp, picture_pad_temp;    AVCodecContext *enc, *dec;    avcodec_get_frame_defaults(&picture_crop_temp);    avcodec_get_frame_defaults(&picture_pad_temp);    enc = ost->st->codec;    dec = ist->st->codec;    /* by default, we output a single frame */    nb_frames = 1;    *frame_size = 0;    if(video_sync_method){        double vdelta;        vdelta = get_sync_ipts(ost) / av_q2d(enc->time_base) - ost->sync_opts;        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c        if (vdelta < -1.1)            nb_frames = 0;        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){            if(vdelta<=-0.6){                nb_frames=0;            }else if(vdelta>0.6)            ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));        }else if (vdelta > 1.1)            nb_frames = lrintf(vdelta);//fprintf(stderr, \"vdelta:%f, ost->sync_opts:%\"PRId64\", ost->sync_ipts:%f nb_frames:%d\\n\", vdelta, ost->sync_opts, get_sync_ipts(ost), nb_frames);        if (nb_frames == 0){            ++nb_frames_drop;            if (verbose>2)                fprintf(stderr, \"*** drop!\\n\");        }else if (nb_frames > 1) {            nb_frames_dup += nb_frames;            if (verbose>2)                fprintf(stderr, \"*** %d dup!\\n\", nb_frames-1);        }    }else        ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));    nb_frames= FFMIN(nb_frames, max_frames[CODEC_TYPE_VIDEO] - ost->frame_number);    if (nb_frames <= 0)        return;    if (ost->video_crop) {        if (av_picture_crop((AVPicture *)&picture_crop_temp, (AVPicture *)in_picture, dec->pix_fmt, ost->topBand, ost->leftBand) < 0) {            fprintf(stderr, \"error cropping picture\\n\");            if (exit_on_error)                av_exit(1);            return;        }        formatted_picture = &picture_crop_temp;    } else {        formatted_picture = in_picture;    }    final_picture = formatted_picture;    padding_src = formatted_picture;    resampling_dst = &ost->pict_tmp;    if (ost->video_pad) {        final_picture = &ost->pict_tmp;        if (ost->video_resample) {            if (av_picture_crop((AVPicture *)&picture_pad_temp, (AVPicture *)final_picture, enc->pix_fmt, ost->padtop, ost->padleft) < 0) {                fprintf(stderr, \"error padding picture\\n\");                if (exit_on_error)                    av_exit(1);                return;            }            resampling_dst = &picture_pad_temp;        }    }    if (ost->video_resample) {        padding_src = NULL;        final_picture = &ost->pict_tmp;        if(  (ost->resample_height != (ist->st->codec->height - (ost->topBand  + ost->bottomBand)))          || (ost->resample_width  != (ist->st->codec->width  - (ost->leftBand + ost->rightBand)))          || (ost->resample_pix_fmt!= ist->st->codec->pix_fmt) ) {            fprintf(stderr,\"Input Stream #%d.%d frame size changed to %dx%d, %s\\n\", ist->file_index, ist->index, ist->st->codec->width, ist->st->codec->height,avcodec_get_pix_fmt_name(ist->st->codec->pix_fmt));            /* keep bands proportional to the frame size */            topBand    = ((int64_t)ist->st->codec->height * ost->original_topBand    / ost->original_height) & ~1;            bottomBand = ((int64_t)ist->st->codec->height * ost->original_bottomBand / ost->original_height) & ~1;            leftBand   = ((int64_t)ist->st->codec->width  * ost->original_leftBand   / ost->original_width)  & ~1;            rightBand  = ((int64_t)ist->st->codec->width  * ost->original_rightBand  / ost->original_width)  & ~1;            /* sanity check to ensure no bad band sizes sneak in */            assert(topBand    <= INT_MAX && topBand    >= 0);            assert(bottomBand <= INT_MAX && bottomBand >= 0);            assert(leftBand   <= INT_MAX && leftBand   >= 0);            assert(rightBand  <= INT_MAX && rightBand  >= 0);            ost->topBand    = topBand;            ost->bottomBand = bottomBand;            ost->leftBand   = leftBand;            ost->rightBand  = rightBand;            ost->resample_height = ist->st->codec->height - (ost->topBand  + ost->bottomBand);            ost->resample_width  = ist->st->codec->width  - (ost->leftBand + ost->rightBand);            ost->resample_pix_fmt= ist->st->codec->pix_fmt;            /* initialize a new scaler context */            sws_freeContext(ost->img_resample_ctx);            sws_flags = av_get_int(sws_opts, \"sws_flags\", NULL);            ost->img_resample_ctx = sws_getContext(                ist->st->codec->width  - (ost->leftBand + ost->rightBand),                ist->st->codec->height - (ost->topBand  + ost->bottomBand),                ist->st->codec->pix_fmt,                ost->st->codec->width  - (ost->padleft  + ost->padright),                ost->st->codec->height - (ost->padtop   + ost->padbottom),                ost->st->codec->pix_fmt,                sws_flags, NULL, NULL, NULL);            if (ost->img_resample_ctx == NULL) {                fprintf(stderr, \"Cannot get resampling context\\n\");                av_exit(1);            }        }        sws_scale(ost->img_resample_ctx, formatted_picture->data, formatted_picture->linesize,              0, ost->resample_height, resampling_dst->data, resampling_dst->linesize);    }    if (ost->video_pad) {        av_picture_pad((AVPicture*)final_picture, (AVPicture *)padding_src,                enc->height, enc->width, enc->pix_fmt,                ost->padtop, ost->padbottom, ost->padleft, ost->padright, padcolor);    }    /* duplicates frame if needed */    for(i=0;i<nb_frames;i++) {        AVPacket pkt;        av_init_packet(&pkt);        pkt.stream_index= ost->index;        if (s->oformat->flags & AVFMT_RAWPICTURE) {            /* raw pictures are written as AVPicture structure to               avoid any copies. We support temorarily the older               method. */            AVFrame* old_frame = enc->coded_frame;            enc->coded_frame = dec->coded_frame; //FIXME/XXX remove this hack            pkt.data= (uint8_t *)final_picture;            pkt.size=  sizeof(AVPicture);            pkt.pts= av_rescale_q(ost->sync_opts, enc->time_base, ost->st->time_base);            pkt.flags |= PKT_FLAG_KEY;            write_frame(s, &pkt, ost->st->codec, bitstream_filters[ost->file_index][pkt.stream_index]);            enc->coded_frame = old_frame;        } else {            AVFrame big_picture;            big_picture= *final_picture;            /* better than nothing: use input picture interlaced               settings */            big_picture.interlaced_frame = in_picture->interlaced_frame;            if(avcodec_opts[CODEC_TYPE_VIDEO]->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)){                if(top_field_first == -1)                    big_picture.top_field_first = in_picture->top_field_first;                else                    big_picture.top_field_first = top_field_first;            }            /* handles sameq here. This is not correct because it may               not be a global option */            if (same_quality) {                big_picture.quality = ist->st->quality;            }else                big_picture.quality = ost->st->quality;            if(!me_threshold)                big_picture.pict_type = 0;//            big_picture.pts = AV_NOPTS_VALUE;            big_picture.pts= ost->sync_opts;//            big_picture.pts= av_rescale(ost->sync_opts, AV_TIME_BASE*(int64_t)enc->time_base.num, enc->time_base.den);//av_log(NULL, AV_LOG_DEBUG, \"%\"PRId64\" -> encoder\\n\", ost->sync_opts);            ret = avcodec_encode_video(enc,                                       bit_buffer, bit_buffer_size,                                       &big_picture);            if (ret < 0) {                fprintf(stderr, \"Video encoding failed\\n\");                av_exit(1);            }            if(ret>0){                pkt.data= bit_buffer;                pkt.size= ret;                if(enc->coded_frame->pts != AV_NOPTS_VALUE)                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/                if(enc->coded_frame->key_frame)                    pkt.flags |= PKT_FLAG_KEY;                write_frame(s, &pkt, ost->st->codec, bitstream_filters[ost->file_index][pkt.stream_index]);                *frame_size = ret;                video_size += ret;                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",                //        enc->frame_number-1, ret, enc->pict_type);                /* if two pass, output log */                if (ost->logfile && enc->stats_out) {                    fprintf(ost->logfile, \"%s\", enc->stats_out);                }            }        }        ost->sync_opts++;        ost->frame_number++;    }}", "idx": 24564}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "function": "static void s390_virtio_device_sync(VirtIOS390Device *dev){    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);    ram_addr_t cur_offs;    uint8_t num_vq;    int i;    virtio_reset(dev->vdev);    /* Sync dev space */    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);    num_vq = s390_virtio_device_num_vq(dev);    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);    /* Sync virtqueues */    for (i = 0; i < num_vq; i++) {        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +                        (i * VIRTIO_VQCONFIG_LEN);        ram_addr_t vring;        vring = s390_virtio_next_ring(bus);        virtio_queue_set_addr(dev->vdev, i, vring);        virtio_queue_set_vector(dev->vdev, i, i);        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));    }    cur_offs = dev->dev_offs;    cur_offs += VIRTIO_DEV_OFFS_CONFIG;    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;    /* Sync feature bitmap */    if (dev->vdev->get_features) {        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));    }    dev->feat_offs = cur_offs + dev->feat_len;    cur_offs += dev->feat_len * 2;    /* Sync config space */    if (dev->vdev->get_config) {        dev->vdev->get_config(dev->vdev, dev->vdev->config);    }    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);    cur_offs += dev->vdev->config_len;}", "idx": 24606}
{"project": "FFmpeg", "commit_id": "e4f85b849913794395bb03dfc09546cd41b10882", "target": 0, "function": "static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr){    WtvContext *wtv = s->priv_data;    ByteIOContext *pb = wtv->pb;    while (!url_feof(pb)) {        ff_asf_guid g;        int len, sid, consumed;        ff_get_guid(pb, &g);        len = get_le32(pb);        if (len < 32)            break;        sid = get_le32(pb) & 0x7FFF;        url_fskip(pb, 8);        consumed = 32;        if (!ff_guidcmp(g, stream_guid)) {            if (ff_find_stream_index(s, sid) < 0) {                ff_asf_guid mediatype, subtype, formattype;                int size;                consumed += 20;                url_fskip(pb, 16);                if (get_le32(pb)) {                    url_fskip(pb, 8);                    ff_get_guid(pb, &mediatype);                    ff_get_guid(pb, &subtype);                    url_fskip(pb, 12);                    ff_get_guid(pb, &formattype);                    size = get_le32(pb);                    parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);                    consumed += 72 + size;                }            }        } else if (!ff_guidcmp(g, stream2_guid)) {            int stream_index = ff_find_stream_index(s, sid);            if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) {                ff_asf_guid mediatype, subtype, formattype;                int size;                url_fskip(pb, 12);                ff_get_guid(pb, &mediatype);                ff_get_guid(pb, &subtype);                url_fskip(pb, 12);                ff_get_guid(pb, &formattype);                size = get_le32(pb);                parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size);                consumed += 76 + size;            }        } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) ||                   !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||                   !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) ||                   !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) ||                   !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) ||                   !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) {            int stream_index = ff_find_stream_index(s, sid);            if (stream_index >= 0) {                AVStream *st = s->streams[stream_index];                uint8_t buf[258];                const uint8_t *pbuf = buf;                int buf_size;                url_fskip(pb, 8);                consumed += 8;                if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||                    !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) {                    url_fskip(pb, 6);                    consumed += 6;                }                buf_size = FFMIN(len - consumed, sizeof(buf));                get_buffer(pb, buf, buf_size);                consumed += buf_size;                ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, 0, 0, 0, 0);            }        } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) {            int stream_index = ff_find_stream_index(s, sid);            if (stream_index >= 0) {                url_fskip(pb, 12);                if (get_le32(pb))                    av_log(s, AV_LOG_WARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", stream_index);                consumed += 16;            }        } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) {            int stream_index = ff_find_stream_index(s, sid);            if (stream_index >= 0) {                AVStream *st = s->streams[stream_index];                uint8_t language[4];                url_fskip(pb, 12);                get_buffer(pb, language, 3);                if (language[0]) {                    language[3] = 0;                    av_metadata_set2(&st->metadata, \"language\", language, 0);                }                consumed += 15;            }        } else if (!ff_guidcmp(g, timestamp_guid)) {            int stream_index = ff_find_stream_index(s, sid);            if (stream_index >= 0) {                url_fskip(pb, 8);                wtv->pts = get_le64(pb);                consumed += 16;                if (wtv->pts == -1)                    wtv->pts = AV_NOPTS_VALUE;                else {                    wtv->last_valid_pts = wtv->pts;                    if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch)                        wtv->epoch = wtv->pts;                if (mode == SEEK_TO_PTS && wtv->pts >= seekts) {#define WTV_PAD8(x) (((x) + 7) & ~7)                    url_fskip(pb, WTV_PAD8(len) - consumed);                    return 0;                }                }            }        } else if (!ff_guidcmp(g, data_guid)) {            int stream_index = ff_find_stream_index(s, sid);            if (mode == SEEK_TO_DATA && stream_index >= 0) {                WtvStream *wst = s->streams[stream_index]->priv_data;                wst->seen_data = 1;                if (len_ptr) {                    *len_ptr = len;                }                return stream_index;            }        } else if (            !ff_guidcmp(g, /* DSATTRIB_CAPTURE_STREAMTIME */ (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) ||            !ff_guidcmp(g, /* DSATTRIB_PicSampleSeq */ (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) ||            !ff_guidcmp(g, /* DSATTRIB_TRANSPORT_PROPERTIES */ (const ff_asf_guid){0x12,0xF6,0x22,0xB6,0xAD,0x47,0x71,0x46,0xAD,0x6C,0x05,0xA9,0x8E,0x65,0xDE,0x3A}) ||            !ff_guidcmp(g, /* dvr_ms_vid_frame_rep_data */ (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) ||            !ff_guidcmp(g, /* EVENTID_AudioTypeSpanningEvent */ (const ff_asf_guid){0xBE,0xBF,0x1C,0x50,0x49,0xB8,0xCE,0x42,0x9B,0xE9,0x3D,0xB8,0x69,0xFB,0x82,0xB3}) ||            !ff_guidcmp(g, /* EVENTID_ChannelChangeSpanningEvent */ (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) ||            !ff_guidcmp(g, /* EVENTID_ChannelInfoSpanningEvent */ (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) ||            !ff_guidcmp(g, /* EVENTID_ChannelTypeSpanningEvent */ (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) ||            !ff_guidcmp(g, /* EVENTID_PIDListSpanningEvent */ (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) ||            !ff_guidcmp(g, /* EVENTID_SignalAndServiceStatusSpanningEvent */ (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) ||            !ff_guidcmp(g, /* EVENTID_StreamTypeSpanningEvent */ (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x96,0xC3,0xD2,0xC2,0x7E,0x9A,0xDA,0x11,0x8B,0xF7,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||            !ff_guidcmp(g, (const ff_asf_guid){0x97,0xC3,0xD2,0xC2,0x7E,0x9A,0xDA,0x11,0x8B,0xF7,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||            !ff_guidcmp(g, (const ff_asf_guid){0xA1,0xC3,0xD2,0xC2,0x7E,0x9A,0xDA,0x11,0x8B,0xF7,0x00,0x07,0xE9,0x5E,0xAD,0x8D})) {            //ignore known guids        } else            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"PRI_GUID\"\\n\", ARG_GUID(g));        url_fskip(pb, WTV_PAD8(len) - consumed);    }    return AVERROR_EOF;}", "idx": 24658}
{"project": "FFmpeg", "commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "target": 1, "function": "static inline int64_t gb_get_v(GetBitContext *gb){    int64_t v = 0;    int bits = 0;    while(get_bits1(gb) && bits < 64-7){        v <<= 7;        v |= get_bits(gb, 7);        bits += 7;    }    v <<= 7;    v |= get_bits(gb, 7);    return v;}", "idx": 24666}
{"project": "qemu", "commit_id": "ba801af429aaa68f6cc03842c8b6be81a6ede65a", "target": 0, "function": "void helper_mtc0_wired(CPUMIPSState *env, target_ulong arg1){    env->CP0_Wired = arg1 % env->tlb->nb_tlb;}", "idx": 24715}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "function": "static void openrisc_sim_machine_init(MachineClass *mc){    mc->desc = \"or1k simulation\";    mc->init = openrisc_sim_init;    mc->max_cpus = 1;    mc->is_default = 1;}", "idx": 24716}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "function": "static int multiwrite_req_compare(const void *a, const void *b){    const BlockRequest *req1 = a, *req2 = b;    /*     * Note that we can't simply subtract req2->sector from req1->sector     * here as that could overflow the return value.     */    if (req1->sector > req2->sector) {        return 1;    } else if (req1->sector < req2->sector) {        return -1;    } else {        return 0;    }}", "idx": 24717}
{"project": "qemu", "commit_id": "945473847b4bb0869915aa47dabc4d2abbc87bdb", "target": 0, "function": "restore_fpu_state(CPUSPARCState *env, qemu_siginfo_fpu_t *fpu){        int err;#if 0#ifdef CONFIG_SMP        if (current->flags & PF_USEDFPU)                regs->psr &= ~PSR_EF;#else        if (current == last_task_used_math) {                last_task_used_math = 0;                regs->psr &= ~PSR_EF;        }#endif        current->used_math = 1;        current->flags &= ~PF_USEDFPU;#endif#if 0        if (verify_area (VERIFY_READ, fpu, sizeof(*fpu)))                return -EFAULT;#endif        /* XXX: incorrect */        err = copy_from_user(&env->fpr[0], fpu->si_float_regs[0],                             (sizeof(abi_ulong) * 32));        err |= __get_user(env->fsr, &fpu->si_fsr);#if 0        err |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);        if (current->thread.fpqdepth != 0)                err |= __copy_from_user(&current->thread.fpqueue[0],                                        &fpu->si_fpqueue[0],                                        ((sizeof(unsigned long) +                                        (sizeof(unsigned long *)))*16));#endif        return err;}", "idx": 24719}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "function": "static int coroutine_fn qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset,                                              size_t len){    /* Allocate buffer for zero writes */    if (acb->flags & QED_AIOCB_ZERO) {        struct iovec *iov = acb->qiov->iov;        if (!iov->iov_base) {            iov->iov_base = qemu_try_blockalign(acb->bs, iov->iov_len);            if (iov->iov_base == NULL) {                return -ENOMEM;            }            memset(iov->iov_base, 0, iov->iov_len);        }    }    /* Calculate the I/O vector */    acb->cur_cluster = offset;    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);    /* Do the actual write */    return qed_aio_write_main(acb);}", "idx": 24726}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "function": "static void moxiesim_init(MachineState *machine){    MoxieCPU *cpu = NULL;    ram_addr_t ram_size = machine->ram_size;    const char *cpu_model = machine->cpu_model;    const char *kernel_filename = machine->kernel_filename;    const char *kernel_cmdline = machine->kernel_cmdline;    const char *initrd_filename = machine->initrd_filename;    CPUMoxieState *env;    MemoryRegion *address_space_mem = get_system_memory();    MemoryRegion *ram = g_new(MemoryRegion, 1);    MemoryRegion *rom = g_new(MemoryRegion, 1);    hwaddr ram_base = 0x200000;    LoaderParams loader_params;    /* Init CPUs. */    if (cpu_model == NULL) {        cpu_model = \"MoxieLite-moxie-cpu\";    }    cpu = MOXIE_CPU(cpu_generic_init(TYPE_MOXIE_CPU, cpu_model));    if (!cpu) {        fprintf(stderr, \"Unable to find CPU definition\\n\");        exit(1);    }    env = &cpu->env;    qemu_register_reset(main_cpu_reset, cpu);    /* Allocate RAM. */    memory_region_init_ram(ram, NULL, \"moxiesim.ram\", ram_size, &error_fatal);    memory_region_add_subregion(address_space_mem, ram_base, ram);    memory_region_init_ram(rom, NULL, \"moxie.rom\", 128 * 0x1000, &error_fatal);    memory_region_add_subregion(get_system_memory(), 0x1000, rom);    if (kernel_filename) {        loader_params.ram_size = ram_size;        loader_params.kernel_filename = kernel_filename;        loader_params.kernel_cmdline = kernel_cmdline;        loader_params.initrd_filename = initrd_filename;        load_kernel(cpu, &loader_params);    }    /* A single 16450 sits at offset 0x3f8.  */    if (serial_hds[0]) {        serial_mm_init(address_space_mem, 0x3f8, 0, env->irq[4],                       8000000/16, serial_hds[0], DEVICE_LITTLE_ENDIAN);    }}", "idx": 24733}
{"project": "qemu", "commit_id": "1e886639791762e89b51aa0507f523c6a1448831", "target": 0, "function": "vdi_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,               QEMUIOVector *qiov, int flags){    BDRVVdiState *s = bs->opaque;    QEMUIOVector local_qiov;    uint32_t bmap_entry;    uint32_t block_index;    uint32_t offset_in_block;    uint32_t n_bytes;    uint32_t bmap_first = VDI_UNALLOCATED;    uint32_t bmap_last = VDI_UNALLOCATED;    uint8_t *block = NULL;    uint64_t bytes_done = 0;    int ret = 0;    logout(\"\\n\");    qemu_iovec_init(&local_qiov, qiov->niov);    while (ret >= 0 && bytes > 0) {        block_index = offset / s->block_size;        offset_in_block = offset % s->block_size;        n_bytes = MIN(bytes, s->block_size - offset_in_block);        logout(\"will write %u bytes starting at offset %\" PRIu64 \"\\n\",               n_bytes, offset);        /* prepare next AIO request */        bmap_entry = le32_to_cpu(s->bmap[block_index]);        if (!VDI_IS_ALLOCATED(bmap_entry)) {            /* Allocate new block and write to it. */            uint64_t data_offset;            bmap_entry = s->header.blocks_allocated;            s->bmap[block_index] = cpu_to_le32(bmap_entry);            s->header.blocks_allocated++;            data_offset = s->header.offset_data +                          (uint64_t)bmap_entry * s->block_size;            if (block == NULL) {                block = g_malloc(s->block_size);                bmap_first = block_index;            }            bmap_last = block_index;            /* Copy data to be written to new block and zero unused parts. */            memset(block, 0, offset_in_block);            qemu_iovec_to_buf(qiov, bytes_done, block + offset_in_block,                              n_bytes);            memset(block + offset_in_block + n_bytes, 0,                   s->block_size - n_bytes - offset_in_block);            /* Note that this coroutine does not yield anywhere from reading the             * bmap entry until here, so in regards to all the coroutines trying             * to write to this cluster, the one doing the allocation will             * always be the first to try to acquire the lock.             * Therefore, it is also the first that will actually be able to             * acquire the lock and thus the padded cluster is written before             * the other coroutines can write to the affected area. */            qemu_co_mutex_lock(&s->write_lock);            ret = bdrv_pwrite(bs->file, data_offset, block, s->block_size);            qemu_co_mutex_unlock(&s->write_lock);        } else {            uint64_t data_offset = s->header.offset_data +                                   (uint64_t)bmap_entry * s->block_size +                                   offset_in_block;            qemu_co_mutex_lock(&s->write_lock);            /* This lock is only used to make sure the following write operation             * is executed after the write issued by the coroutine allocating             * this cluster, therefore we do not need to keep it locked.             * As stated above, the allocating coroutine will always try to lock             * the mutex before all the other concurrent accesses to that             * cluster, therefore at this point we can be absolutely certain             * that that write operation has returned (there may be other writes             * in flight, but they do not concern this very operation). */            qemu_co_mutex_unlock(&s->write_lock);            qemu_iovec_reset(&local_qiov);            qemu_iovec_concat(&local_qiov, qiov, bytes_done, n_bytes);            ret = bdrv_co_pwritev(bs->file, data_offset, n_bytes,                                  &local_qiov, 0);        }        bytes -= n_bytes;        offset += n_bytes;        bytes_done += n_bytes;        logout(\"%u bytes written\\n\", n_bytes);    }    qemu_iovec_destroy(&local_qiov);    logout(\"finished data write\\n\");    if (ret < 0) {        return ret;    }    if (block) {        /* One or more new blocks were allocated. */        VdiHeader *header = (VdiHeader *) block;        uint8_t *base;        uint64_t offset;        uint32_t n_sectors;        logout(\"now writing modified header\\n\");        assert(VDI_IS_ALLOCATED(bmap_first));        *header = s->header;        vdi_header_to_le(header);        ret = bdrv_write(bs->file, 0, block, 1);        g_free(block);        block = NULL;        if (ret < 0) {            return ret;        }        logout(\"now writing modified block map entry %u...%u\\n\",               bmap_first, bmap_last);        /* Write modified sectors from block map. */        bmap_first /= (SECTOR_SIZE / sizeof(uint32_t));        bmap_last /= (SECTOR_SIZE / sizeof(uint32_t));        n_sectors = bmap_last - bmap_first + 1;        offset = s->bmap_sector + bmap_first;        base = ((uint8_t *)&s->bmap[0]) + bmap_first * SECTOR_SIZE;        logout(\"will write %u block map sectors starting from entry %u\\n\",               n_sectors, bmap_first);        ret = bdrv_write(bs->file, offset, base, n_sectors);    }    return ret;}", "idx": 24747}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "function": "static void send_msg(IPMIBmcSim *ibs,                     uint8_t *cmd, unsigned int cmd_len,                     uint8_t *rsp, unsigned int *rsp_len,                     unsigned int max_rsp_len){    IPMIInterface *s = ibs->parent.intf;    IPMIInterfaceClass *k = IPMI_INTERFACE_GET_CLASS(s);    IPMIRcvBufEntry *msg;    uint8_t *buf;    uint8_t netfn, rqLun, rsLun, rqSeq;    IPMI_CHECK_CMD_LEN(3);    if (cmd[2] != 0) {        /* We only handle channel 0 with no options */        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;        return;    }    IPMI_CHECK_CMD_LEN(10);    if (cmd[3] != 0x40) {        /* We only emulate a MC at address 0x40. */        rsp[2] = 0x83; /* NAK on write */        return;    }    cmd += 3; /* Skip the header. */    cmd_len -= 3;    /*     * At this point we \"send\" the message successfully.  Any error will     * be returned in the response.     */    if (ipmb_checksum(cmd, cmd_len, 0) != 0 ||        cmd[3] != 0x20) { /* Improper response address */        return; /* No response */    }    netfn = cmd[1] >> 2;    rqLun = cmd[4] & 0x3;    rsLun = cmd[1] & 0x3;    rqSeq = cmd[4] >> 2;    if (rqLun != 2) {        /* We only support LUN 2 coming back to us. */        return;    }    msg = g_malloc(sizeof(*msg));    msg->buf[0] = ((netfn | 1) << 2) | rqLun; /* NetFN, and make a response */    msg->buf[1] = ipmb_checksum(msg->buf, 1, 0);    msg->buf[2] = cmd[0]; /* rsSA */    msg->buf[3] = (rqSeq << 2) | rsLun;    msg->buf[4] = cmd[5]; /* Cmd */    msg->buf[5] = 0; /* Completion Code */    msg->len = 6;    if ((cmd[1] >> 2) != IPMI_NETFN_APP || cmd[5] != IPMI_CMD_GET_DEVICE_ID) {        /* Not a command we handle. */        msg->buf[5] = IPMI_CC_INVALID_CMD;        goto end_msg;    }    buf = msg->buf + msg->len; /* After the CC */    buf[0] = 0;    buf[1] = 0;    buf[2] = 0;    buf[3] = 0;    buf[4] = 0x51;    buf[5] = 0;    buf[6] = 0;    buf[7] = 0;    buf[8] = 0;    buf[9] = 0;    buf[10] = 0;    msg->len += 11; end_msg:    msg->buf[msg->len] = ipmb_checksum(msg->buf, msg->len, 0);    msg->len++;    qemu_mutex_lock(&ibs->lock);    QTAILQ_INSERT_TAIL(&ibs->rcvbufs, msg, entry);    ibs->msg_flags |= IPMI_BMC_MSG_FLAG_RCV_MSG_QUEUE;    k->set_atn(s, 1, attn_irq_enabled(ibs));    qemu_mutex_unlock(&ibs->lock);}", "idx": 24778}
{"project": "FFmpeg", "commit_id": "bb4c9d0a8ead02f7d943c2bae3e36b30e605b30b", "target": 0, "function": "static int alloc_frame_buffer(AVCodecContext *avctx,  Picture *pic,                              MotionEstContext *me, ScratchpadContext *sc,                              int chroma_x_shift, int chroma_y_shift,                              int linesize, int uvlinesize){    int edges_needed = av_codec_is_encoder(avctx->codec);    int r, ret;    pic->tf.f = pic->f;    if (avctx->codec_id != AV_CODEC_ID_WMV3IMAGE &&        avctx->codec_id != AV_CODEC_ID_VC1IMAGE  &&        avctx->codec_id != AV_CODEC_ID_MSS2) {        if (edges_needed) {            pic->f->width  = avctx->width  + 2 * EDGE_WIDTH;            pic->f->height = avctx->height + 2 * EDGE_WIDTH;        }        r = ff_thread_get_buffer(avctx, &pic->tf,                                 pic->reference ? AV_GET_BUFFER_FLAG_REF : 0);    } else {        pic->f->width  = avctx->width;        pic->f->height = avctx->height;        pic->f->format = avctx->pix_fmt;        r = avcodec_default_get_buffer2(avctx, pic->f, 0);    }    if (r < 0 || !pic->f->buf[0]) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %p)\\n\",               r, pic->f->data[0]);        return -1;    }    if (edges_needed) {        int i;        for (i = 0; pic->f->data[i]; i++) {            int offset = (EDGE_WIDTH >> (i ? chroma_y_shift : 0)) *                         pic->f->linesize[i] +                         (EDGE_WIDTH >> (i ? chroma_x_shift : 0));            pic->f->data[i] += offset;        }        pic->f->width  = avctx->width;        pic->f->height = avctx->height;    }    if (avctx->hwaccel) {        assert(!pic->hwaccel_picture_private);        if (avctx->hwaccel->frame_priv_data_size) {            pic->hwaccel_priv_buf = av_buffer_allocz(avctx->hwaccel->frame_priv_data_size);            if (!pic->hwaccel_priv_buf) {                av_log(avctx, AV_LOG_ERROR, \"alloc_frame_buffer() failed (hwaccel private data allocation)\\n\");                return -1;            }            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;        }    }    if (linesize && (linesize   != pic->f->linesize[0] ||                     uvlinesize != pic->f->linesize[1])) {        av_log(avctx, AV_LOG_ERROR,               \"get_buffer() failed (stride changed)\\n\");        ff_mpeg_unref_picture(avctx, pic);        return -1;    }    if (pic->f->linesize[1] != pic->f->linesize[2]) {        av_log(avctx, AV_LOG_ERROR,               \"get_buffer() failed (uv stride mismatch)\\n\");        ff_mpeg_unref_picture(avctx, pic);        return -1;    }    if (!sc->edge_emu_buffer &&        (ret = ff_mpeg_framesize_alloc(avctx, me, sc,                                       pic->f->linesize[0])) < 0) {        av_log(avctx, AV_LOG_ERROR,               \"get_buffer() failed to allocate context scratch buffers.\\n\");        ff_mpeg_unref_picture(avctx, pic);        return ret;    }    return 0;}", "idx": 24785}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "function": "int64_t qemu_clock_deadline_ns_all(QEMUClockType type){    int64_t deadline = -1;    QEMUTimerList *timer_list;    QEMUClock *clock = qemu_clock_ptr(type);    QLIST_FOREACH(timer_list, &clock->timerlists, list) {        deadline = qemu_soonest_timeout(deadline,                                        timerlist_deadline_ns(timer_list));    }    return deadline;}", "idx": 24843}
{"project": "qemu", "commit_id": "a178274efabcbbc5d44805b51def874e47051325", "target": 0, "function": "static int spapr_phb_init(SysBusDevice *s){    sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);    PCIHostState *phb = PCI_HOST_BRIDGE(s);    char *namebuf;    int i;    PCIBus *bus;    sphb->dtbusname = g_strdup_printf(\"pci@%\" PRIx64, sphb->buid);    namebuf = alloca(strlen(sphb->dtbusname) + 32);    /* Initialize memory regions */    sprintf(namebuf, \"%s.mmio\", sphb->dtbusname);    memory_region_init(&sphb->memspace, namebuf, INT64_MAX);    sprintf(namebuf, \"%s.mmio-alias\", sphb->dtbusname);    memory_region_init_alias(&sphb->memwindow, namebuf, &sphb->memspace,                             SPAPR_PCI_MEM_WIN_BUS_OFFSET, sphb->mem_win_size);    memory_region_add_subregion(get_system_memory(), sphb->mem_win_addr,                                &sphb->memwindow);    /* On ppc, we only have MMIO no specific IO space from the CPU     * perspective.  In theory we ought to be able to embed the PCI IO     * memory region direction in the system memory space.  However,     * if any of the IO BAR subregions use the old_portio mechanism,     * that won't be processed properly unless accessed from the     * system io address space.  This hack to bounce things via     * system_io works around the problem until all the users of     * old_portion are updated */    sprintf(namebuf, \"%s.io\", sphb->dtbusname);    memory_region_init(&sphb->iospace, namebuf, SPAPR_PCI_IO_WIN_SIZE);    /* FIXME: fix to support multiple PHBs */    memory_region_add_subregion(get_system_io(), 0, &sphb->iospace);    sprintf(namebuf, \"%s.io-alias\", sphb->dtbusname);    memory_region_init_io(&sphb->iowindow, &spapr_io_ops, sphb,                          namebuf, SPAPR_PCI_IO_WIN_SIZE);    memory_region_add_subregion(get_system_memory(), sphb->io_win_addr,                                &sphb->iowindow);    /* As MSI/MSIX interrupts trigger by writing at MSI/MSIX vectors,     * we need to allocate some memory to catch those writes coming     * from msi_notify()/msix_notify() */    if (msi_supported) {        sprintf(namebuf, \"%s.msi\", sphb->dtbusname);        memory_region_init_io(&sphb->msiwindow, &spapr_msi_ops, sphb,                              namebuf, SPAPR_MSIX_MAX_DEVS * 0x10000);        memory_region_add_subregion(get_system_memory(), sphb->msi_win_addr,                                    &sphb->msiwindow);    }    bus = pci_register_bus(DEVICE(s),                           sphb->busname ? sphb->busname : sphb->dtbusname,                           pci_spapr_set_irq, pci_spapr_map_irq, sphb,                           &sphb->memspace, &sphb->iospace,                           PCI_DEVFN(0, 0), PCI_NUM_PINS);    phb->bus = bus;    sphb->dma_liobn = SPAPR_PCI_BASE_LIOBN | (pci_find_domain(bus) << 16);    sphb->dma_window_start = 0;    sphb->dma_window_size = 0x40000000;    sphb->dma = spapr_tce_new_dma_context(sphb->dma_liobn, sphb->dma_window_size);    pci_setup_iommu(bus, spapr_pci_dma_context_fn, sphb);    QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);    /* Initialize the LSI table */    for (i = 0; i < PCI_NUM_PINS; i++) {        uint32_t irq;        irq = spapr_allocate_lsi(0);        if (!irq) {            return -1;        }        sphb->lsi_table[i].irq = irq;    }    return 0;}", "idx": 24851}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "function": "static BlockAIOCB *bdrv_co_aio_prw_vector(BdrvChild *child,                                          int64_t offset,                                          QEMUIOVector *qiov,                                          BdrvRequestFlags flags,                                          BlockCompletionFunc *cb,                                          void *opaque,                                          bool is_write){    Coroutine *co;    BlockAIOCBCoroutine *acb;    /* Matched by bdrv_co_complete's bdrv_dec_in_flight.  */    bdrv_inc_in_flight(child->bs);    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);    acb->child = child;    acb->need_bh = true;    acb->req.error = -EINPROGRESS;    acb->req.offset = offset;    acb->req.qiov = qiov;    acb->req.flags = flags;    acb->is_write = is_write;    co = qemu_coroutine_create(bdrv_co_do_rw, acb);    qemu_coroutine_enter(co);    bdrv_co_maybe_schedule_bh(acb);    return &acb->common;}", "idx": 24894}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "function": "static void hextile_enc_cord(uint8_t *ptr, int x, int y, int w, int h){    ptr[0] = ((x & 0x0F) << 4) | (y & 0x0F);    ptr[1] = (((w - 1) & 0x0F) << 4) | ((h - 1) & 0x0F);}", "idx": 24943}
{"project": "qemu", "commit_id": "41bf234d8e35e9273290df278e2aeb88c0c50a4f", "target": 0, "function": "static void gic_reset(gic_state *s){    int i;    memset(s->irq_state, 0, GIC_NIRQ * sizeof(gic_irq_state));    for (i = 0 ; i < NUM_CPU(s); i++) {        s->priority_mask[i] = 0xf0;        s->current_pending[i] = 1023;        s->running_irq[i] = 1023;        s->running_priority[i] = 0x100;#ifdef NVIC        /* The NVIC doesn't have per-cpu interfaces, so enable by default.  */        s->cpu_enabled[i] = 1;#else        s->cpu_enabled[i] = 0;#endif    }    for (i = 0; i < 16; i++) {        GIC_SET_ENABLED(i);        GIC_SET_TRIGGER(i);    }#ifdef NVIC    /* The NVIC is always enabled.  */    s->enabled = 1;#else    s->enabled = 0;#endif}", "idx": 24994}
{"project": "FFmpeg", "commit_id": "02fb320adadacfc8446a1278582351078a024dee", "target": 1, "function": "static int libopenjpeg_decode_frame(AVCodecContext *avctx,                                    void *data, int *data_size,                                    AVPacket *avpkt){    uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    LibOpenJPEGContext *ctx = avctx->priv_data;    AVFrame *picture = &ctx->image, *output = data;    opj_dinfo_t *dec;    opj_cio_t *stream;    opj_image_t *image;    int width, height, ret = -1;    int pixel_size = 0;    int ispacked = 0;    *data_size = 0;    // Check if input is a raw jpeg2k codestream or in jp2 wrapping    if((AV_RB32(buf) == 12) &&       (AV_RB32(buf + 4) == JP2_SIG_TYPE) &&       (AV_RB32(buf + 8) == JP2_SIG_VALUE)) {        dec = opj_create_decompress(CODEC_JP2);    } else {        // If the AVPacket contains a jp2c box, then skip to        // the starting byte of the codestream.        if (AV_RB32(buf + 4) == AV_RB32(\"jp2c\"))            buf += 8;        dec = opj_create_decompress(CODEC_J2K);    if(!dec) {        av_log(avctx, AV_LOG_ERROR, \"Error initializing decoder.\\n\");    opj_set_event_mgr((opj_common_ptr)dec, NULL, NULL);    ctx->dec_params.cp_limit_decoding = LIMIT_TO_MAIN_HEADER;    // Tie decoder with decoding parameters    opj_setup_decoder(dec, &ctx->dec_params);    stream = opj_cio_open((opj_common_ptr)dec, buf, buf_size);    if(!stream) {        av_log(avctx, AV_LOG_ERROR, \"Codestream could not be opened for reading.\\n\");    // Decode the header only    image = opj_decode_with_info(dec, stream, NULL);    opj_cio_close(stream);    width  = image->x1 - image->x0;    height = image->y1 - image->y0;    if(av_image_check_size(width, height, 0, avctx) < 0) {        av_log(avctx, AV_LOG_ERROR, \"%dx%d dimension invalid.\\n\", width, height);        goto done;    avcodec_set_dimensions(avctx, width, height);    switch (image->numcomps) {    case 1:  avctx->pix_fmt = (image->comps[0].bpp == 8) ? PIX_FMT_GRAY8 : PIX_FMT_GRAY16;             break;    case 2:  avctx->pix_fmt = PIX_FMT_GRAY8A;             break;    case 3:    case 4:  avctx->pix_fmt = check_image_attributes(avctx, image);             break;    default: av_log(avctx, AV_LOG_ERROR, \"%d components unsupported.\\n\", image->numcomps);             goto done;    if(picture->data[0])        ff_thread_release_buffer(avctx, picture);    if(ff_thread_get_buffer(avctx, picture) < 0){        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed\\n\");    ctx->dec_params.cp_limit_decoding = NO_LIMITATION;    ctx->dec_params.cp_reduce = avctx->lowres;    // Tie decoder with decoding parameters    opj_setup_decoder(dec, &ctx->dec_params);    stream = opj_cio_open((opj_common_ptr)dec, buf, buf_size);    if(!stream) {        av_log(avctx, AV_LOG_ERROR, \"Codestream could not be opened for reading.\\n\");    // Decode the codestream    image = opj_decode_with_info(dec, stream, NULL);    opj_cio_close(stream);    pixel_size = av_pix_fmt_descriptors[avctx->pix_fmt].comp[0].step_minus1 + 1;    ispacked = libopenjpeg_ispacked(avctx->pix_fmt);    switch (pixel_size) {    case 1:        if (ispacked) {            libopenjpeg_copy_to_packed8(picture, image);        } else {            libopenjpeg_copyto8(picture, image);        break;    case 2:        if (ispacked) {            libopenjpeg_copy_to_packed8(picture, image);        } else {            libopenjpeg_copyto16(picture, image);        break;    case 3:    case 4:        if (ispacked) {            libopenjpeg_copy_to_packed8(picture, image);        break;    case 6:    case 8:        if (ispacked) {            libopenjpeg_copy_to_packed16(picture, image);        break;    default:        av_log(avctx, AV_LOG_ERROR, \"unsupported pixel size %d\\n\", pixel_size);        goto done;    *output    = ctx->image;    *data_size = sizeof(AVPicture);    ret = buf_size;done:    opj_image_destroy(image);    return ret;", "idx": 25058}
{"project": "FFmpeg", "commit_id": "67db4ff3b66e96a20ddf1c264d07e146334ae88e", "target": 0, "function": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = avctx->priv_data;    if (avctx->bit_rate > 0) {        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;    }    if (avctx->rc_max_rate > 0)        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;    if (ctx->rc < 0) {        if (ctx->flags & NVENC_ONE_PASS)            ctx->twopass = 0;        if (ctx->flags & NVENC_TWO_PASSES)            ctx->twopass = 1;        if (ctx->twopass < 0)            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;        if (ctx->cbr) {            if (ctx->twopass) {                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;            } else {                ctx->rc = NV_ENC_PARAMS_RC_CBR;            }        } else if (avctx->global_quality > 0) {            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;        } else if (ctx->twopass) {            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;        }    }    if (ctx->flags & NVENC_LOSSLESS) {        set_lossless(avctx);    } else if (ctx->rc >= 0) {        nvenc_override_rate_control(avctx);    } else {        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;        set_vbr(avctx);    }    if (avctx->rc_buffer_size > 0) {        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;    }    if (ctx->aq) {        ctx->encode_config.rcParams.enableAQ   = 1;        ctx->encode_config.rcParams.aqStrength = ctx->aq_strength;        av_log(avctx, AV_LOG_VERBOSE, \"AQ enabled.\\n\");    }    if (ctx->temporal_aq) {        ctx->encode_config.rcParams.enableTemporalAQ = 1;        av_log(avctx, AV_LOG_VERBOSE, \"Temporal AQ enabled.\\n\");    }    if (ctx->rc_lookahead) {        int lkd_bound = FFMIN(ctx->nb_surfaces, ctx->async_depth) -                        ctx->encode_config.frameIntervalP - 4;        if (lkd_bound < 0) {            av_log(avctx, AV_LOG_WARNING,                   \"Lookahead not enabled. Increase buffer delay (-delay).\\n\");        } else {            ctx->encode_config.rcParams.enableLookahead = 1;            ctx->encode_config.rcParams.lookaheadDepth  = av_clip(ctx->rc_lookahead, 0, lkd_bound);            ctx->encode_config.rcParams.disableIadapt   = ctx->no_scenecut;            ctx->encode_config.rcParams.disableBadapt   = !ctx->b_adapt;            av_log(avctx, AV_LOG_VERBOSE,                   \"Lookahead enabled: depth %d, scenecut %s, B-adapt %s.\\n\",                   ctx->encode_config.rcParams.lookaheadDepth,                   ctx->encode_config.rcParams.disableIadapt ? \"disabled\" : \"enabled\",                   ctx->encode_config.rcParams.disableBadapt ? \"disabled\" : \"enabled\");        }    }    if (ctx->strict_gop) {        ctx->encode_config.rcParams.strictGOPTarget = 1;        av_log(avctx, AV_LOG_VERBOSE, \"Strict GOP target enabled.\\n\");    }    if (ctx->nonref_p)        ctx->encode_config.rcParams.enableNonRefP = 1;    if (ctx->zerolatency)        ctx->encode_config.rcParams.zeroReorderDelay = 1;    if (ctx->quality)        ctx->encode_config.rcParams.targetQuality = ctx->quality;}", "idx": 25092}
{"project": "FFmpeg", "commit_id": "53c05b1eacd5f7dbfa3651b45e797adaea0a5ff8", "target": 0, "function": "static void filter_mb( H264Context *h, int mb_x, int mb_y ) {    MpegEncContext * const s = &h->s;    const int mb_xy= mb_x + mb_y*s->mb_stride;    uint8_t *img_y  = s->current_picture.data[0] + (mb_y * 16* s->linesize  ) + mb_x * 16;    uint8_t *img_cb = s->current_picture.data[1] + (mb_y * 8 * s->uvlinesize) + mb_x * 8;    uint8_t *img_cr = s->current_picture.data[2] + (mb_y * 8 * s->uvlinesize) + mb_x * 8;    int linesize, uvlinesize;    int dir;#if 0    /* FIXME what's that ? */    if( !s->decode )        return;#endif    /* FIXME Implement deblocking filter for field MB */    if( h->sps.mb_aff ) {        return;    }    linesize = s->linesize;    uvlinesize = s->uvlinesize;    /* dir : 0 -> vertical edge, 1 -> horizontal edge */    for( dir = 0; dir < 2; dir++ )    {        int start = 0;        int edge;        /* test picture boundary */        if( ( dir == 0 && mb_x == 0 ) || ( dir == 1 && mb_y == 0 ) ) {            start = 1;        }        /* FIXME test slice boundary */        if( h->disable_deblocking_filter_idc == 2 ) {        }        /* Calculate bS */        for( edge = start; edge < 4; edge++ ) {            /* mbn_xy: neighbour macroblock (how that works for field ?) */            int mbn_xy = edge > 0 ? mb_xy : ( dir == 0 ? mb_xy -1 : mb_xy - s->mb_stride );            int bS[4];            int qp;            if( IS_INTRA( s->current_picture.mb_type[mb_xy] ) ||                IS_INTRA( s->current_picture.mb_type[mbn_xy] ) ) {                bS[0] = bS[1] = bS[2] = bS[3] = ( edge == 0 ? 4 : 3 );            } else {                int i;                for( i = 0; i < 4; i++ ) {                    static const uint8_t block_idx_xy[4][4] = {                        { 0, 2, 8,  10}, { 1, 3, 9,  11},                        { 4, 6, 12, 14}, { 5, 7, 13, 15}                    };                    int x = dir == 0 ? edge : i;                    int y = dir == 0 ? i    : edge;                    int xn = (x - (dir == 0 ? 1 : 0 ))&0x03;                    int yn = (y - (dir == 0 ? 0 : 1 ))&0x03;                    if( h->non_zero_count[mb_xy][block_idx_xy[x][y]] != 0 ||                        h->non_zero_count[mbn_xy][block_idx_xy[xn][yn]] != 0 ) {                        bS[i] = 2;                    }                    else if( h->slice_type == P_TYPE ) {                        const int b8_xy = h->mb2b8_xy[mb_xy]+(y>>1)*h->b8_stride+(x>>1);                        const int b8n_xy= h->mb2b8_xy[mbn_xy]+(yn>>1)*h->b8_stride+(xn>>1);                        const int b_xy  = h->mb2b_xy[mb_xy]+y*h->b_stride+x;                        const int bn_xy = h->mb2b_xy[mbn_xy]+yn*h->b_stride+xn;                        if( s->current_picture.ref_index[0][b8_xy] != s->current_picture.ref_index[0][b8n_xy] ||                            ABS( s->current_picture.motion_val[0][b_xy][0] - s->current_picture.motion_val[0][bn_xy][0] ) >= 4 ||                            ABS( s->current_picture.motion_val[0][b_xy][1] - s->current_picture.motion_val[0][bn_xy][1] ) >= 4 )                            bS[i] = 1;                        else                            bS[i] = 0;                    }                    else {                        /* FIXME Add support for B frame */                        return;                    }                }            }            /* Filter edge */            qp = ( s->current_picture.qscale_table[mb_xy] + s->current_picture.qscale_table[mbn_xy] + 1 ) >> 1;            if( dir == 0 ) {                filter_mb_edgev( h, &img_y[4*edge], linesize, bS, qp );                if( (edge&1) == 0 ) {                    int chroma_qp = ( get_chroma_qp( h, s->current_picture.qscale_table[mb_xy] ) +                                      get_chroma_qp( h, s->current_picture.qscale_table[mbn_xy] ) + 1 ) >> 1;                    filter_mb_edgecv( h, &img_cb[2*edge], uvlinesize, bS, chroma_qp );                    filter_mb_edgecv( h, &img_cr[2*edge], uvlinesize, bS, chroma_qp );                }            } else {                filter_mb_edgeh( h, &img_y[4*edge*linesize], linesize, bS, qp );                if( (edge&1) == 0 ) {                    int chroma_qp = ( get_chroma_qp( h, s->current_picture.qscale_table[mb_xy] ) +                                      get_chroma_qp( h, s->current_picture.qscale_table[mbn_xy] ) + 1 ) >> 1;                    filter_mb_edgech( h, &img_cb[2*edge*uvlinesize], uvlinesize, bS, chroma_qp );                    filter_mb_edgech( h, &img_cr[2*edge*uvlinesize], uvlinesize, bS, chroma_qp );                }            }        }    }}", "idx": 25118}
{"project": "qemu", "commit_id": "a3adb7ad3bd9c517d569e7e23b249e7f7d616015", "target": 0, "function": "static void help(int exitcode){    const char *options_help =#define QEMU_OPTIONS_GENERATE_HELP#include \"qemu-options-wrapper.h\"        ;    version();    printf(\"usage: %s [options] [disk_image]\\n\"           \"\\n\"           \"'disk_image' is a raw hard disk image for IDE hard disk 0\\n\"           \"\\n\"           \"%s\\n\"           \"During emulation, the following keys are useful:\\n\"           \"ctrl-alt-f      toggle full screen\\n\"           \"ctrl-alt-n      switch to virtual console 'n'\\n\"           \"ctrl-alt        toggle mouse and keyboard grab\\n\"           \"\\n\"           \"When using -nographic, press 'ctrl-a h' to get some help.\\n\",           error_get_progname(),           options_help);    exit(exitcode);}", "idx": 25200}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "function": "static int decode_syncpoint(NUTContext *nut, int64_t *ts, int64_t *back_ptr){    AVFormatContext *s= nut->avf;    ByteIOContext *bc = &s->pb;    int64_t end, tmp;    AVRational time_base;    nut->last_syncpoint_pos= url_ftell(bc)-8;    end= get_packetheader(nut, bc, 1);    end += url_ftell(bc);    tmp= get_v(bc);    *back_ptr= nut->last_syncpoint_pos - 16*get_v(bc);    if(*back_ptr < 0)        return -1;    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count], tmp);    if(skip_reserved(bc, end) || get_checksum(bc)){        av_log(s, AV_LOG_ERROR, \"sync point checksum mismatch\\n\");        return -1;    }    *ts= tmp / s->nb_streams * av_q2d(nut->time_base[tmp % s->nb_streams])*AV_TIME_BASE;    add_sp(nut, nut->last_syncpoint_pos, *back_ptr, *ts);    return 0;}", "idx": 25227}
{"project": "qemu", "commit_id": "f6e6652d7c9251236fc1ecc6cece36104c7af15b", "target": 1, "function": "static int dmg_read_resource_fork(BlockDriverState *bs, DmgHeaderState *ds,                                  uint64_t info_begin, uint64_t info_length){    BDRVDMGState *s = bs->opaque;    int ret;    uint32_t count, rsrc_data_offset;    uint8_t *buffer = NULL;    uint64_t info_end;    uint64_t offset;    /* read offset from begin of resource fork (info_begin) to resource data */    ret = read_uint32(bs, info_begin, &rsrc_data_offset);    if (ret < 0) {        goto fail;    } else if (rsrc_data_offset > info_length) {        ret = -EINVAL;        goto fail;    }    /* read length of resource data */    ret = read_uint32(bs, info_begin + 8, &count);    if (ret < 0) {        goto fail;    } else if (count == 0 || rsrc_data_offset + count > info_length) {        ret = -EINVAL;        goto fail;    }    /* begin of resource data (consisting of one or more resources) */    offset = info_begin + rsrc_data_offset;    /* end of resource data (there is possibly a following resource map     * which will be ignored). */    info_end = offset + count;    /* read offsets (mish blocks) from one or more resources in resource data */    while (offset < info_end) {        /* size of following resource */        ret = read_uint32(bs, offset, &count);        if (ret < 0) {            goto fail;        } else if (count == 0) {            ret = -EINVAL;            goto fail;        }        offset += 4;        buffer = g_realloc(buffer, count);        ret = bdrv_pread(bs->file, offset, buffer, count);        if (ret < 0) {            goto fail;        }        ret = dmg_read_mish_block(s, ds, buffer, count);        if (ret < 0) {            goto fail;        }        /* advance offset by size of resource */        offset += count;    }    ret = 0;fail:    g_free(buffer);    return ret;}", "idx": 25257}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "function": "static inline void mix_2f_2r_to_dolby(AC3DecodeContext *ctx){    int i;    float (*output)[256] = ctx->audio_block.block_output;    for (i = 0; i < 256; i++) {        output[1][i] -= output[3][i];        output[2][i] += output[4][i];    }    memset(output[3], 0, sizeof(output[3]));    memset(output[4], 0, sizeof(output[4]));}", "idx": 25297}
{"project": "FFmpeg", "commit_id": "934982c4ace1a3d5d627b518782ed092a456c49e", "target": 0, "function": "static int indeo3_decode_frame(AVCodecContext *avctx,                               void *data, int *data_size,                               unsigned char *buf, int buf_size){    Indeo3DecodeContext *s=avctx->priv_data;    unsigned char *src, *dest;    int y;    /* no supplementary picture */    if (buf_size == 0) {        return 0;    }    iv_decode_frame(s, buf, buf_size);    if(s->frame.data[0])        avctx->release_buffer(avctx, &s->frame);    s->frame.reference = 0;    if(avctx->get_buffer(avctx, &s->frame) < 0) {        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return -1;    }    src = s->cur_frame->Ybuf;    dest = s->frame.data[0];    for (y = 0; y < s->height; y++) {      memcpy(dest, src, s->cur_frame->y_w);      src += s->cur_frame->y_w;      dest += s->frame.linesize[0];    }    if (!(s->avctx->flags & CODEC_FLAG_GRAY))    {    src = s->cur_frame->Ubuf;    dest = s->frame.data[1];    for (y = 0; y < s->height / 4; y++) {      memcpy(dest, src, s->cur_frame->uv_w);      src += s->cur_frame->uv_w;      dest += s->frame.linesize[1];    }    src = s->cur_frame->Vbuf;    dest = s->frame.data[2];    for (y = 0; y < s->height / 4; y++) {      memcpy(dest, src, s->cur_frame->uv_w);      src += s->cur_frame->uv_w;      dest += s->frame.linesize[2];    }    }    *data_size=sizeof(AVFrame);    *(AVFrame*)data= s->frame;    return buf_size;}", "idx": 25309}
{"project": "qemu", "commit_id": "bb89c2e901b1a0c1cb6b94392cae1f98e6660ed7", "target": 1, "function": "static void monitor_call_handler(Monitor *mon, const mon_cmd_t *cmd,                                 const QDict *params){    QObject *data = NULL;    cmd->mhandler.cmd_new(mon, params, &data);    if (is_async_return(data)) {        /*         * Asynchronous commands have no initial return data but they can         * generate errors.  Data is returned via the async completion handler.         */        if (monitor_ctrl_mode(mon) && monitor_has_error(mon)) {            monitor_protocol_emitter(mon, NULL);        }    } else if (monitor_ctrl_mode(mon)) {        /* Monitor Protocol */        monitor_protocol_emitter(mon, data);    } else {        /* User Protocol */         if (data)            cmd->user_print(mon, data);    }    qobject_decref(data);}", "idx": 25336}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "function": "static void openpic_tmr_write(void *opaque, hwaddr addr, uint64_t val,                                unsigned len){    OpenPICState *opp = opaque;    int idx;    DPRINTF(\"%s: addr %08x <= %08x\\n\", __func__, addr, val);    if (addr & 0xF)        return;    idx = (addr >> 6) & 0x3;    addr = addr & 0x30;    if (addr == 0x0) {        /* TIFR (TFRR) */        opp->tifr = val;        return;    }    switch (addr & 0x30) {    case 0x00: /* TICC (GTCCR) */        break;    case 0x10: /* TIBC (GTBCR) */        if ((opp->timers[idx].ticc & TICC_TOG) != 0 &&            (val & TIBC_CI) == 0 &&            (opp->timers[idx].tibc & TIBC_CI) != 0) {            opp->timers[idx].ticc &= ~TICC_TOG;        }        opp->timers[idx].tibc = val;        break;    case 0x20: /* TIVP (GTIVPR) */        write_IRQreg_ipvp(opp, opp->irq_tim0 + idx, val);        break;    case 0x30: /* TIDE (GTIDR) */        write_IRQreg_ide(opp, opp->irq_tim0 + idx, val);        break;    }}", "idx": 25338}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "function": "static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,    const char **throttling_group, ThrottleConfig *throttle_cfg,    BlockdevDetectZeroesOptions *detect_zeroes, Error **errp){    const char *discard;    Error *local_error = NULL;    const char *aio;    if (bdrv_flags) {        if (!qemu_opt_get_bool(opts, \"read-only\", false)) {            *bdrv_flags |= BDRV_O_RDWR;        }        if (qemu_opt_get_bool(opts, \"copy-on-read\", false)) {            *bdrv_flags |= BDRV_O_COPY_ON_READ;        }        if ((discard = qemu_opt_get(opts, \"discard\")) != NULL) {            if (bdrv_parse_discard_flags(discard, bdrv_flags) != 0) {                error_setg(errp, \"Invalid discard option\");                return;            }        }        if ((aio = qemu_opt_get(opts, \"aio\")) != NULL) {            if (!strcmp(aio, \"native\")) {                *bdrv_flags |= BDRV_O_NATIVE_AIO;            } else if (!strcmp(aio, \"threads\")) {                /* this is the default */            } else {               error_setg(errp, \"invalid aio option\");               return;            }        }    }    /* disk I/O throttling */    if (throttling_group) {        *throttling_group = qemu_opt_get(opts, \"throttling.group\");    }    if (throttle_cfg) {        memset(throttle_cfg, 0, sizeof(*throttle_cfg));        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].avg =            qemu_opt_get_number(opts, \"throttling.bps-total\", 0);        throttle_cfg->buckets[THROTTLE_BPS_READ].avg  =            qemu_opt_get_number(opts, \"throttling.bps-read\", 0);        throttle_cfg->buckets[THROTTLE_BPS_WRITE].avg =            qemu_opt_get_number(opts, \"throttling.bps-write\", 0);        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].avg =            qemu_opt_get_number(opts, \"throttling.iops-total\", 0);        throttle_cfg->buckets[THROTTLE_OPS_READ].avg =            qemu_opt_get_number(opts, \"throttling.iops-read\", 0);        throttle_cfg->buckets[THROTTLE_OPS_WRITE].avg =            qemu_opt_get_number(opts, \"throttling.iops-write\", 0);        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].max =            qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);        throttle_cfg->buckets[THROTTLE_BPS_READ].max  =            qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);        throttle_cfg->buckets[THROTTLE_BPS_WRITE].max =            qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].max =            qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);        throttle_cfg->buckets[THROTTLE_OPS_READ].max =            qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);        throttle_cfg->buckets[THROTTLE_OPS_WRITE].max =            qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);        throttle_cfg->op_size =            qemu_opt_get_number(opts, \"throttling.iops-size\", 0);        if (!check_throttle_config(throttle_cfg, errp)) {            return;        }    }    if (detect_zeroes) {        *detect_zeroes =            qapi_enum_parse(BlockdevDetectZeroesOptions_lookup,                            qemu_opt_get(opts, \"detect-zeroes\"),                            BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX,                            BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,                            &local_error);        if (local_error) {            error_propagate(errp, local_error);            return;        }        if (bdrv_flags &&            *detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&            !(*bdrv_flags & BDRV_O_UNMAP))        {            error_setg(errp, \"setting detect-zeroes to unmap is not allowed \"                             \"without setting discard operation to unmap\");            return;        }    }}", "idx": 25360}
{"project": "FFmpeg", "commit_id": "aaae59700f7fc10fd80cb93b38c5d109900872d9", "target": 0, "function": "static int avisynth_read_packet_video(AVFormatContext *s, AVPacket *pkt,                                      int discard){    AviSynthContext *avs = s->priv_data;    AVS_VideoFrame *frame;    unsigned char *dst_p;    const unsigned char *src_p;    int n, i, plane, rowsize, planeheight, pitch, bits;    const char *error;    if (avs->curr_frame >= avs->vi->num_frames)        return AVERROR_EOF;    /* This must happen even if the stream is discarded to prevent desync. */    n = avs->curr_frame++;    if (discard)        return 0;#ifdef USING_AVISYNTH    /* Define the bpp values for the new AviSynth 2.6 colorspaces.     * Since AvxSynth doesn't have these functions, special-case     * it in order to avoid implicit declaration errors. */    if (avs_library.avs_is_yv24(avs->vi))        bits = 24;    else if (avs_library.avs_is_yv16(avs->vi))        bits = 16;    else if (avs_library.avs_is_yv411(avs->vi))        bits = 12;    else if (avs_library.avs_is_y8(avs->vi))        bits = 8;    else        bits = avs_library.avs_bits_per_pixel(avs->vi);#else    bits = avs_bits_per_pixel(avs->vi);#endif    /* Without the cast to int64_t, calculation overflows at about 9k x 9k     * resolution. */    pkt->size = (((int64_t)avs->vi->width *                  (int64_t)avs->vi->height) * bits) / 8;    if (!pkt->size)        return AVERROR_UNKNOWN;    if (av_new_packet(pkt, pkt->size) < 0)        return AVERROR(ENOMEM);    pkt->pts      = n;    pkt->dts      = n;    pkt->duration = 1;    pkt->stream_index = avs->curr_stream;    frame = avs_library.avs_get_frame(avs->clip, n);    error = avs_library.avs_clip_get_error(avs->clip);    if (error) {        av_log(s, AV_LOG_ERROR, \"%s\\n\", error);        avs->error = 1;        av_packet_unref(pkt);        return AVERROR_UNKNOWN;    }    dst_p = pkt->data;    for (i = 0; i < avs->n_planes; i++) {        plane = avs->planes[i];#ifdef USING_AVISYNTH        src_p = avs_library.avs_get_read_ptr_p(frame, plane);        pitch = avs_library.avs_get_pitch_p(frame, plane);        rowsize     = avs_library.avs_get_row_size_p(frame, plane);        planeheight = avs_library.avs_get_height_p(frame, plane);#else        src_p = avs_get_read_ptr_p(frame, plane);        pitch = avs_get_pitch_p(frame, plane);        rowsize     = avs_get_row_size_p(frame, plane);        planeheight = avs_get_height_p(frame, plane);#endif        /* Flip RGB video. */        if (avs_is_rgb24(avs->vi) || avs_is_rgb(avs->vi)) {            src_p = src_p + (planeheight - 1) * pitch;            pitch = -pitch;        }        avs_library.avs_bit_blt(avs->env, dst_p, rowsize, src_p, pitch,                                 rowsize, planeheight);        dst_p += rowsize * planeheight;    }    avs_library.avs_release_video_frame(frame);    return 0;}", "idx": 25416}
{"project": "FFmpeg", "commit_id": "6bd665b7c5798803366b877903fa3bce7f129d05", "target": 0, "function": "void avpriv_tak_parse_streaminfo(GetBitContext *gb, TAKStreamInfo *s){    uint64_t channel_mask = 0;    int frame_type, i;    s->codec = get_bits(gb, TAK_ENCODER_CODEC_BITS);    skip_bits(gb, TAK_ENCODER_PROFILE_BITS);    frame_type = get_bits(gb, TAK_SIZE_FRAME_DURATION_BITS);    s->samples = get_bits64(gb, TAK_SIZE_SAMPLES_NUM_BITS);    s->data_type   = get_bits(gb, TAK_FORMAT_DATA_TYPE_BITS);    s->sample_rate = get_bits(gb, TAK_FORMAT_SAMPLE_RATE_BITS) +                     TAK_SAMPLE_RATE_MIN;    s->bps         = get_bits(gb, TAK_FORMAT_BPS_BITS) +                     TAK_BPS_MIN;    s->channels    = get_bits(gb, TAK_FORMAT_CHANNEL_BITS) +                     TAK_CHANNELS_MIN;    if (get_bits1(gb)) {        skip_bits(gb, TAK_FORMAT_VALID_BITS);        if (get_bits1(gb)) {            for (i = 0; i < s->channels; i++) {                int value = get_bits(gb, TAK_FORMAT_CH_LAYOUT_BITS);                if (value < FF_ARRAY_ELEMS(tak_channel_layouts))                    channel_mask |= tak_channel_layouts[value];            }        }    }    s->ch_layout     = channel_mask;    s->frame_samples = tak_get_nb_samples(s->sample_rate, frame_type);}", "idx": 25425}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "function": "static void moxie_cpu_initfn(Object *obj){    CPUState *cs = CPU(obj);    MoxieCPU *cpu = MOXIE_CPU(obj);    static int inited;    cs->env_ptr = &cpu->env;    cpu_exec_init(cs, &error_abort);    if (tcg_enabled() && !inited) {        inited = 1;        moxie_translate_init();    }}", "idx": 25435}
{"project": "qemu", "commit_id": "4577b09a278fe9134ecb9192c2ae2ed67a0d0aa7", "target": 1, "function": "udp_listen(Slirp *slirp, uint32_t haddr, u_int hport, uint32_t laddr,           u_int lport, int flags){\tstruct sockaddr_in addr;\tstruct socket *so;\tsocklen_t addrlen = sizeof(struct sockaddr_in);\tso = socreate(slirp);\tif (!so) {\tso->s = qemu_socket(AF_INET,SOCK_DGRAM,0);\tso->so_expire = curtime + SO_EXPIRE;\tinsque(so, &slirp->udb);\taddr.sin_family = AF_INET;\taddr.sin_addr.s_addr = haddr;\taddr.sin_port = hport;\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\t\tudp_detach(so);\tsocket_set_fast_reuse(so->s);\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\tso->fhost.sin = addr;\tsotranslate_accept(so);\tso->so_lfamily = AF_INET;\tso->so_lport = lport;\tso->so_laddr.s_addr = laddr;\tif (flags != SS_FACCEPTONCE)\t   so->so_expire = 0;\tso->so_state &= SS_PERSISTENT_MASK;\tso->so_state |= SS_ISFCONNECTED | flags;\treturn so;", "idx": 25452}
{"project": "qemu", "commit_id": "49dd946bb5419681c8668b09a6d10f42bc707b78", "target": 1, "function": "static void coroutine_fn v9fs_walk(void *opaque){    int name_idx;    V9fsQID *qids = NULL;    int i, err = 0;    V9fsPath dpath, path;    uint16_t nwnames;    struct stat stbuf;    size_t offset = 7;    int32_t fid, newfid;    V9fsString *wnames = NULL;    V9fsFidState *fidp;    V9fsFidState *newfidp = NULL;    V9fsPDU *pdu = opaque;    V9fsState *s = pdu->s;    V9fsQID qid;    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);    if (err < 0) {        pdu_complete(pdu, err);        return ;    }    offset += err;    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);    if (nwnames && nwnames <= P9_MAXWELEM) {        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);        qids   = g_malloc0(sizeof(qids[0]) * nwnames);        for (i = 0; i < nwnames; i++) {            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);            if (err < 0) {                goto out_nofid;            }            if (name_is_illegal(wnames[i].data)) {                err = -ENOENT;                goto out_nofid;            }            offset += err;        }    } else if (nwnames > P9_MAXWELEM) {        err = -EINVAL;        goto out_nofid;    }    fidp = get_fid(pdu, fid);    if (fidp == NULL) {        err = -ENOENT;        goto out_nofid;    }    v9fs_path_init(&dpath);    v9fs_path_init(&path);    err = fid_to_qid(pdu, fidp, &qid);    if (err < 0) {        goto out;    }    /*     * Both dpath and path initially poin to fidp.     * Needed to handle request with nwnames == 0     */    v9fs_path_copy(&dpath, &fidp->path);    v9fs_path_copy(&path, &fidp->path);    for (name_idx = 0; name_idx < nwnames; name_idx++) {        if (not_same_qid(&pdu->s->root_qid, &qid) ||            strcmp(\"..\", wnames[name_idx].data)) {            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,                                       &path);            if (err < 0) {                goto out;            }            err = v9fs_co_lstat(pdu, &path, &stbuf);            if (err < 0) {                goto out;            }            stat_to_qid(&stbuf, &qid);            v9fs_path_copy(&dpath, &path);        }        memcpy(&qids[name_idx], &qid, sizeof(qid));    }    if (fid == newfid) {        BUG_ON(fidp->fid_type != P9_FID_NONE);        v9fs_path_copy(&fidp->path, &path);    } else {        newfidp = alloc_fid(s, newfid);        if (newfidp == NULL) {            err = -EINVAL;            goto out;        }        newfidp->uid = fidp->uid;        v9fs_path_copy(&newfidp->path, &path);    }    err = v9fs_walk_marshal(pdu, nwnames, qids);    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);out:    put_fid(pdu, fidp);    if (newfidp) {        put_fid(pdu, newfidp);    }    v9fs_path_free(&dpath);    v9fs_path_free(&path);out_nofid:    pdu_complete(pdu, err);    if (nwnames && nwnames <= P9_MAXWELEM) {        for (name_idx = 0; name_idx < nwnames; name_idx++) {            v9fs_string_free(&wnames[name_idx]);        }        g_free(wnames);        g_free(qids);    }}", "idx": 25491}
{"project": "qemu", "commit_id": "c547e5640d5b0993cdfb252331065c1a1d813bd8", "target": 1, "function": "static int blkdebug_debug_resume(BlockDriverState *bs, const char *tag){    BDRVBlkdebugState *s = bs->opaque;    BlkdebugSuspendedReq *r;    QLIST_FOREACH(r, &s->suspended_reqs, next) {        if (!strcmp(r->tag, tag)) {            qemu_coroutine_enter(r->co, NULL);            return 0;        }    }    return -ENOENT;}", "idx": 25556}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "function": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                         AVFilterBufferRef *picref, int flags){    BufferSourceContext *c = buffer_filter->priv;    AVFilterBufferRef *buf;    int ret;    if (!picref) {        c->eof = 1;        return 0;    } else if (c->eof)        return AVERROR(EINVAL);    if (!av_fifo_space(c->fifo) &&        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +                                         sizeof(buf))) < 0)        return ret;    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {        ret = check_format_change(buffer_filter, picref);        if (ret < 0)            return ret;    }    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)        buf = picref;    else        buf = copy_buffer_ref(buffer_filter, picref);    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {        if (buf != picref)            avfilter_unref_buffer(buf);        return ret;    }    c->nb_failed_requests = 0;    return 0;}", "idx": 25566}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "function": "static void tb_invalidate_phys_page(tb_page_addr_t addr,                                    uintptr_t pc, void *puc){    TranslationBlock *tb;    PageDesc *p;    int n;#ifdef TARGET_HAS_PRECISE_SMC    TranslationBlock *current_tb = NULL;    CPUState *cpu = current_cpu;    CPUArchState *env = NULL;    int current_tb_modified = 0;    target_ulong current_pc = 0;    target_ulong current_cs_base = 0;    int current_flags = 0;#endif    addr &= TARGET_PAGE_MASK;    p = page_find(addr >> TARGET_PAGE_BITS);    if (!p) {        return;    }    tb = p->first_tb;#ifdef TARGET_HAS_PRECISE_SMC    if (tb && pc != 0) {        current_tb = tb_find_pc(pc);    }    if (cpu != NULL) {        env = cpu->env_ptr;    }#endif    while (tb != NULL) {        n = (uintptr_t)tb & 3;        tb = (TranslationBlock *)((uintptr_t)tb & ~3);#ifdef TARGET_HAS_PRECISE_SMC        if (current_tb == tb &&            (current_tb->cflags & CF_COUNT_MASK) != 1) {                /* If we are modifying the current TB, we must stop                   its execution. We could be more precise by checking                   that the modification is after the current PC, but it                   would require a specialized function to partially                   restore the CPU state */            current_tb_modified = 1;            cpu_restore_state_from_tb(current_tb, env, pc);            cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,                                 &current_flags);        }#endif /* TARGET_HAS_PRECISE_SMC */        tb_phys_invalidate(tb, addr);        tb = tb->page_next[n];    }    p->first_tb = NULL;#ifdef TARGET_HAS_PRECISE_SMC    if (current_tb_modified) {        /* we generate a block containing just the instruction           modifying the memory. It will ensure that it cannot modify           itself */        cpu->current_tb = NULL;        tb_gen_code(env, current_pc, current_cs_base, current_flags, 1);        cpu_resume_from_signal(env, puc);    }#endif}", "idx": 25681}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "function": "static void bt_submit_sco(struct HCIInfo *info,                const uint8_t *data, int length){    struct bt_hci_s *hci = hci_from_info(info);    uint16_t handle;    int datalen;    if (length < 3)        return;    handle = acl_handle((data[1] << 8) | data[0]);    datalen = data[2];    length -= 3;    if (bt_hci_handle_bad(hci, handle)) {        fprintf(stderr, \"%s: invalid SCO handle %03x\\n\",                        __FUNCTION__, handle);        return;    }    if (datalen > length) {        fprintf(stderr, \"%s: SCO packet too short (%iB < %iB)\\n\",                        __FUNCTION__, length, datalen);        return;    }    /* TODO */    /* TODO: increase counter and send EVT_NUM_COMP_PKTS if synchronous     * Flow Control is enabled.     * (See Read/Write_Synchronous_Flow_Control_Enable on page 513 and     * page 514.)  */}", "idx": 25705}
{"project": "FFmpeg", "commit_id": "e856ac23732822ac04fe5dd959cff94c7249c17e", "target": 0, "function": "static int msrle_decode_pal4(AVCodecContext *avctx, AVFrame *pic,                             GetByteContext *gb){    unsigned char rle_code;    unsigned char extra_byte, odd_pixel;    unsigned char stream_byte;    int pixel_ptr = 0;    int line = avctx->height - 1;    int i;    while (line >= 0 && pixel_ptr <= avctx->width) {        if (bytestream2_get_bytes_left(gb) <= 0) {            av_log(avctx, AV_LOG_ERROR,                   \"MS RLE: bytestream overrun, %dx%d left\\n\",                   avctx->width - pixel_ptr, line);            return AVERROR_INVALIDDATA;        }        rle_code = stream_byte = bytestream2_get_byteu(gb);        if (rle_code == 0) {            /* fetch the next byte to see how to handle escape code */            stream_byte = bytestream2_get_byte(gb);            if (stream_byte == 0) {                /* line is done, goto the next one */                line--;                pixel_ptr = 0;            } else if (stream_byte == 1) {                /* decode is done */                return 0;            } else if (stream_byte == 2) {                /* reposition frame decode coordinates */                stream_byte = bytestream2_get_byte(gb);                pixel_ptr += stream_byte;                stream_byte = bytestream2_get_byte(gb);                avpriv_request_sample(avctx, \"Unused stream byte %X\", stream_byte);            } else {                // copy pixels from encoded stream                odd_pixel =  stream_byte & 1;                rle_code = (stream_byte + 1) / 2;                extra_byte = rle_code & 0x01;                if (pixel_ptr + 2*rle_code - odd_pixel > avctx->width ||                    bytestream2_get_bytes_left(gb) < rle_code) {                    av_log(avctx, AV_LOG_ERROR,                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");                    return AVERROR_INVALIDDATA;                }                for (i = 0; i < rle_code; i++) {                    if (pixel_ptr >= avctx->width)                        break;                    stream_byte = bytestream2_get_byteu(gb);                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte >> 4;                    pixel_ptr++;                    if (i + 1 == rle_code && odd_pixel)                        break;                    if (pixel_ptr >= avctx->width)                        break;                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte & 0x0F;                    pixel_ptr++;                }                // if the RLE code is odd, skip a byte in the stream                if (extra_byte)                    bytestream2_skip(gb, 1);            }        } else {            // decode a run of data            if (pixel_ptr + rle_code > avctx->width + 1) {                av_log(avctx, AV_LOG_ERROR,                       \"MS RLE: frame ptr just went out of bounds (run) %d %d %d\\n\", pixel_ptr, rle_code, avctx->width);                return AVERROR_INVALIDDATA;            }            stream_byte = bytestream2_get_byte(gb);            for (i = 0; i < rle_code; i++) {                if (pixel_ptr >= avctx->width)                    break;                if ((i & 1) == 0)                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte >> 4;                else                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte & 0x0F;                pixel_ptr++;            }        }    }    /* one last sanity check on the way out */    if (bytestream2_get_bytes_left(gb)) {        av_log(avctx, AV_LOG_ERROR,               \"MS RLE: ended frame decode with %d bytes left over\\n\",               bytestream2_get_bytes_left(gb));        return AVERROR_INVALIDDATA;    }    return 0;}", "idx": 25835}
{"project": "FFmpeg", "commit_id": "3206ea4ba31ebf446a3c4f1220adb895b3272c15", "target": 0, "function": "static void update_initial_durations(AVFormatContext *s, AVStream *st,                                     int stream_index, int duration){    AVPacketList *pktl = s->internal->packet_buffer ? s->internal->packet_buffer : s->internal->parse_queue;    int64_t cur_dts    = RELATIVE_TS_BASE;    if (st->first_dts != AV_NOPTS_VALUE) {        if (st->update_initial_durations_done)            return;        st->update_initial_durations_done = 1;        cur_dts = st->first_dts;        for (; pktl; pktl = get_next_pkt(s, st, pktl)) {            if (pktl->pkt.stream_index == stream_index) {                if (pktl->pkt.pts != pktl->pkt.dts  ||                    pktl->pkt.dts != AV_NOPTS_VALUE ||                    pktl->pkt.duration)                    break;                cur_dts -= duration;            }        }        if (pktl && pktl->pkt.dts != st->first_dts) {            av_log(s, AV_LOG_DEBUG, \"first_dts %s not matching first dts %s (pts %s, duration %\"PRId64\") in the queue\\n\",                   av_ts2str(st->first_dts), av_ts2str(pktl->pkt.dts), av_ts2str(pktl->pkt.pts), pktl->pkt.duration);            return;        }        if (!pktl) {            av_log(s, AV_LOG_DEBUG, \"first_dts %s but no packet with dts in the queue\\n\", av_ts2str(st->first_dts));            return;        }        pktl          = s->internal->packet_buffer ? s->internal->packet_buffer : s->internal->parse_queue;        st->first_dts = cur_dts;    } else if (st->cur_dts != RELATIVE_TS_BASE)        return;    for (; pktl; pktl = get_next_pkt(s, st, pktl)) {        if (pktl->pkt.stream_index != stream_index)            continue;        if (pktl->pkt.pts == pktl->pkt.dts  &&            (pktl->pkt.dts == AV_NOPTS_VALUE || pktl->pkt.dts == st->first_dts) &&            !pktl->pkt.duration) {            pktl->pkt.dts = cur_dts;            if (!st->internal->avctx->has_b_frames)                pktl->pkt.pts = cur_dts;//            if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO)                pktl->pkt.duration = duration;        } else            break;        cur_dts = pktl->pkt.dts + pktl->pkt.duration;    }    if (!pktl)        st->cur_dts = cur_dts;}", "idx": 25836}
{"project": "qemu", "commit_id": "1ba4b6a553ad9ff4645af7fab8adfc6e810fcc69", "target": 1, "function": "void bdrv_append_temp_snapshot(BlockDriverState *bs, Error **errp){    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */    char tmp_filename[PATH_MAX + 1];    int64_t total_size;    BlockDriver *bdrv_qcow2;    QEMUOptionParameter *create_options;    QDict *snapshot_options;    BlockDriverState *bs_snapshot;    Error *local_err;    int ret;    /* if snapshot, we create a temporary backing file and open it       instead of opening 'filename' directly */    /* Get the required size from the image */    total_size = bdrv_getlength(bs);    if (total_size < 0) {        error_setg_errno(errp, -total_size, \"Could not get image size\");        return;    }    total_size &= BDRV_SECTOR_MASK;    /* Create the temporary image */    ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));    if (ret < 0) {        error_setg_errno(errp, -ret, \"Could not get temporary filename\");        return;    }    bdrv_qcow2 = bdrv_find_format(\"qcow2\");    create_options = parse_option_parameters(\"\", bdrv_qcow2->create_options,                                             NULL);    set_option_parameter_int(create_options, BLOCK_OPT_SIZE, total_size);    ret = bdrv_create(bdrv_qcow2, tmp_filename, create_options, &local_err);    free_option_parameters(create_options);    if (ret < 0) {        error_setg_errno(errp, -ret, \"Could not create temporary overlay \"                         \"'%s': %s\", tmp_filename,                         error_get_pretty(local_err));        error_free(local_err);        return;    }    /* Prepare a new options QDict for the temporary file */    snapshot_options = qdict_new();    qdict_put(snapshot_options, \"file.driver\",              qstring_from_str(\"file\"));    qdict_put(snapshot_options, \"file.filename\",              qstring_from_str(tmp_filename));    bs_snapshot = bdrv_new(\"\", &error_abort);    bs_snapshot->is_temporary = 1;    ret = bdrv_open(&bs_snapshot, NULL, NULL, snapshot_options,                    bs->open_flags & ~BDRV_O_SNAPSHOT, bdrv_qcow2, &local_err);    if (ret < 0) {        error_propagate(errp, local_err);        return;    }    bdrv_append(bs_snapshot, bs);}", "idx": 25844}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "function": "static int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom){    int ret = 0;    int length = 0;    uint64_t original_size;    if (c->fc->nb_streams >= 1) {        AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;        if (codec->codec_id == AV_CODEC_ID_H264)            return 0;        if (atom.size == 16) {            original_size = codec->extradata_size;            ret = mov_realloc_extradata(codec, atom);            if (!ret) {                length =  mov_read_atom_into_extradata(c, pb, atom, codec, codec->extradata + original_size);                if (length == atom.size) {                    const uint8_t range_value = codec->extradata[original_size + 19];                    switch (range_value) {                    case 1:                        codec->color_range = AVCOL_RANGE_MPEG;                        break;                    case 2:                        codec->color_range = AVCOL_RANGE_JPEG;                        break;                    default:                        av_log(c, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);                        break;                    }                    av_dlog(c, \"color_range: %d\\n\", codec->color_range);                } else {                  /* For some reason the whole atom was not added to the extradata */                  av_log(c, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");                }            } else {                av_log(c, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");            }        } else {            av_log(c, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);        }    }    return ret;}", "idx": 25897}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "function": "int AUD_read (SWVoiceIn *sw, void *buf, int size){    int bytes;    if (!sw) {        /* XXX: Consider options */        return size;    }    if (!sw->hw->enabled) {        dolog (\"Reading from disabled voice %s\\n\", SW_NAME (sw));        return 0;    }    bytes = sw->hw->pcm_ops->read (sw, buf, size);    return bytes;}", "idx": 25968}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "function": "int ffurl_get_file_handle(URLContext *h){    if (!h->prot->url_get_file_handle)        return -1;    return h->prot->url_get_file_handle(h);}", "idx": 26009}
{"project": "qemu", "commit_id": "cc84de9570ffe01a9c3c169bd62ab9586a9a080c", "target": 0, "function": "static void unblock_io_signals(void){    sigset_t set;    sigemptyset(&set);    sigaddset(&set, SIGUSR2);    sigaddset(&set, SIGIO);    sigaddset(&set, SIGALRM);    pthread_sigmask(SIG_UNBLOCK, &set, NULL);    sigemptyset(&set);    sigaddset(&set, SIGUSR1);    pthread_sigmask(SIG_BLOCK, &set, NULL);}", "idx": 26064}
{"project": "FFmpeg", "commit_id": "c4360559ee2a6c8c624f24fc7e2a1cf00972ba68", "target": 1, "function": "static int paf_video_decode(AVCodecContext *avctx, void *data,                            int *got_frame, AVPacket *pkt){    PAFVideoDecContext *c = avctx->priv_data;    uint8_t code, *dst, *end;    int i, frame, ret;    if (pkt->size < 2)        return AVERROR_INVALIDDATA;    bytestream2_init(&c->gb, pkt->data, pkt->size);    code = bytestream2_get_byte(&c->gb);    if ((code & 0xF) > 4) {        avpriv_request_sample(avctx, \"unknown/invalid code\");        return AVERROR_INVALIDDATA;    }    if ((ret = ff_reget_buffer(avctx, c->pic)) < 0)        return ret;    if (code & 0x20) {  // frame is keyframe        for (i = 0; i < 4; i++)            memset(c->frame[i], 0, c->frame_size);        memset(c->pic->data[1], 0, AVPALETTE_SIZE);        c->current_frame  = 0;        c->pic->key_frame = 1;        c->pic->pict_type = AV_PICTURE_TYPE_I;    } else {        c->pic->key_frame = 0;        c->pic->pict_type = AV_PICTURE_TYPE_P;    }    if (code & 0x40) {  // palette update        uint32_t *out = (uint32_t *)c->pic->data[1];        int index, count;        index = bytestream2_get_byte(&c->gb);        count = bytestream2_get_byte(&c->gb) + 1;        if (index + count > 256)            return AVERROR_INVALIDDATA;        if (bytestream2_get_bytes_left(&c->gb) < 3 * count)            return AVERROR_INVALIDDATA;        out += index;        for (i = 0; i < count; i++) {            unsigned r, g, b;            r = bytestream2_get_byteu(&c->gb);            r = r << 2 | r >> 4;            g = bytestream2_get_byteu(&c->gb);            g = g << 2 | g >> 4;            b = bytestream2_get_byteu(&c->gb);            b = b << 2 | b >> 4;            *out++ = (0xFFU << 24) | (r << 16) | (g << 8) | b;        }        c->pic->palette_has_changed = 1;    }    switch (code & 0x0F) {    case 0:        /* Block-based motion compensation using 4x4 blocks with either         * horizontal or vertical vectors; might incorporate VQ as well. */        if ((ret = decode_0(c, pkt->data, code)) < 0)            return ret;        break;    case 1:        /* Uncompressed data. This mode specifies that (width * height) bytes         * should be copied directly from the encoded buffer into the output. */        dst = c->frame[c->current_frame];        // possibly chunk length data        bytestream2_skip(&c->gb, 2);        if (bytestream2_get_bytes_left(&c->gb) < c->video_size)            return AVERROR_INVALIDDATA;        bytestream2_get_bufferu(&c->gb, dst, c->video_size);        break;    case 2:        /* Copy reference frame: Consume the next byte in the stream as the         * reference frame (which should be 0, 1, 2, or 3, and should not be         * the same as the current frame number). */        frame = bytestream2_get_byte(&c->gb);        if (frame > 3)            return AVERROR_INVALIDDATA;        if (frame != c->current_frame)            memcpy(c->frame[c->current_frame], c->frame[frame], c->frame_size);        break;    case 4:        /* Run length encoding.*/        dst = c->frame[c->current_frame];        end = dst + c->video_size;        bytestream2_skip(&c->gb, 2);        while (dst < end) {            int8_t code;            int count;            if (bytestream2_get_bytes_left(&c->gb) < 2)                return AVERROR_INVALIDDATA;            code  = bytestream2_get_byteu(&c->gb);            count = FFABS(code) + 1;            if (dst + count > end)                return AVERROR_INVALIDDATA;            if (code < 0)                memset(dst, bytestream2_get_byteu(&c->gb), count);            else                bytestream2_get_buffer(&c->gb, dst, count);            dst += count;        }        break;    default:        av_assert0(0);    }    av_image_copy_plane(c->pic->data[0], c->pic->linesize[0],                        c->frame[c->current_frame], c->width,                        c->width, c->height);    c->current_frame = (c->current_frame + 1) & 3;    if ((ret = av_frame_ref(data, c->pic)) < 0)        return ret;    *got_frame = 1;    return pkt->size;}", "idx": 26089}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "function": "static bool is_zero_sectors(BlockDriverState *bs, int64_t start,                            uint32_t count){    int nr;    BlockDriverState *file;    int64_t res;    if (start + count > bs->total_sectors) {        count = bs->total_sectors - start;    }    if (!count) {        return true;    }    res = bdrv_get_block_status_above(bs, NULL, start, count,                                      &nr, &file);    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;}", "idx": 26227}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "function": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,                omap_clk clk){    int iomemtype;    s->pwt.base = base;    s->pwt.clk = clk;    omap_pwt_reset(s);    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,                    omap_pwt_writefn, s);    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);}", "idx": 26243}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "function": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu){    CPUPPCState *env = &cpu->env;    struct kvm_sregs sregs;    int ret;    int i;    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);    if (ret < 0) {        return ret;    }    if (!env->external_htab) {        ppc_store_sdr1(env, sregs.u.s.sdr1);    }    /* Sync SLB */#ifdef TARGET_PPC64    /*     * The packed SLB array we get from KVM_GET_SREGS only contains     * information about valid entries. So we flush our internal copy     * to get rid of stale ones, then put all valid SLB entries back     * in.     */    memset(env->slb, 0, sizeof(env->slb));    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;        /*         * Only restore valid entries         */        if (rb & SLB_ESID_V) {            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);        }    }#endif    /* Sync SRs */    for (i = 0; i < 16; i++) {        env->sr[i] = sregs.u.s.ppc32.sr[i];    }    /* Sync BATs */    for (i = 0; i < 8; i++) {        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;    }    return 0;}", "idx": 26257}
{"project": "qemu", "commit_id": "2ad645d2854746b55ddfd1d8e951f689cca5d78f", "target": 1, "function": "static void test_endianness_split(gconstpointer data){    const TestCase *test = data;    char *args;    args = g_strdup_printf(\"-display none -M %s%s%s -device pc-testdev\",                           test->machine,                           test->superio ? \" -device \" : \"\",                           test->superio ?: \"\");    qtest_start(args);    isa_outl(test, 0xe8, 0x87654321);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654321);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);    isa_outw(test, 0xea, 0x8866);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x88664321);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8866);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);    isa_outw(test, 0xe8, 0x4422);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x88664422);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8866);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4422);    isa_outb(test, 0xeb, 0x87);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87664422);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8766);    isa_outb(test, 0xea, 0x65);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654422);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4422);    isa_outb(test, 0xe9, 0x43);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654322);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4322);    isa_outb(test, 0xe8, 0x21);    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654321);    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);    qtest_quit(global_qtest);    g_free(args);}", "idx": 26350}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "function": "static void vfio_msix_enable(VFIOPCIDevice *vdev){    vfio_disable_interrupts(vdev);    vdev->msi_vectors = g_malloc0(vdev->msix->entries * sizeof(VFIOMSIVector));    vdev->interrupt = VFIO_INT_MSIX;    /*     * Some communication channels between VF & PF or PF & fw rely on the     * physical state of the device and expect that enabling MSI-X from the     * guest enables the same on the host.  When our guest is Linux, the     * guest driver call to pci_enable_msix() sets the enabling bit in the     * MSI-X capability, but leaves the vector table masked.  We therefore     * can't rely on a vector_use callback (from request_irq() in the guest)     * to switch the physical device into MSI-X mode because that may come a     * long time after pci_enable_msix().  This code enables vector 0 with     * triggering to userspace, then immediately release the vector, leaving     * the physical device with no vectors enabled, but MSI-X enabled, just     * like the guest view.     */    vfio_msix_vector_do_use(&vdev->pdev, 0, NULL, NULL);    vfio_msix_vector_release(&vdev->pdev, 0);    if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use,                                  vfio_msix_vector_release, NULL)) {        error_report(\"vfio: msix_set_vector_notifiers failed\");    }    trace_vfio_msix_enable(vdev->vbasedev.name);}", "idx": 26356}
{"project": "qemu", "commit_id": "0d931d706266d6ada3bf22d3afca1afdc8d12fa9", "target": 1, "function": "static gboolean serial_xmit(GIOChannel *chan, GIOCondition cond, void *opaque){    SerialState *s = opaque;    do {        if (s->tsr_retry <= 0) {            if (s->fcr & UART_FCR_FE) {                if (fifo8_is_empty(&s->xmit_fifo)) {                    return FALSE;                }                s->tsr = fifo8_pop(&s->xmit_fifo);                if (!s->xmit_fifo.num) {                    s->lsr |= UART_LSR_THRE;                }            } else if ((s->lsr & UART_LSR_THRE)) {                return FALSE;            } else {                s->tsr = s->thr;                s->lsr |= UART_LSR_THRE;                s->lsr &= ~UART_LSR_TEMT;            }        }        if (s->mcr & UART_MCR_LOOP) {            /* in loopback mode, say that we just received a char */            serial_receive1(s, &s->tsr, 1);        } else if (qemu_chr_fe_write(s->chr, &s->tsr, 1) != 1) {            if (s->tsr_retry >= 0 && s->tsr_retry < MAX_XMIT_RETRY &&                qemu_chr_fe_add_watch(s->chr, G_IO_OUT|G_IO_HUP,                                      serial_xmit, s) > 0) {                s->tsr_retry++;                return FALSE;            }            s->tsr_retry = 0;        } else {            s->tsr_retry = 0;        }        /* Transmit another byte if it is already available. It is only           possible when FIFO is enabled and not empty. */    } while ((s->fcr & UART_FCR_FE) && !fifo8_is_empty(&s->xmit_fifo));    s->last_xmit_ts = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);    if (s->lsr & UART_LSR_THRE) {        s->lsr |= UART_LSR_TEMT;        s->thr_ipending = 1;        serial_update_irq(s);    }    return FALSE;}", "idx": 26369}
{"project": "FFmpeg", "commit_id": "7dafb3a25a580a5f8f1a5083835c67be9ed17043", "target": 1, "function": "static int cudaupload_query_formats(AVFilterContext *ctx){    int ret;    static const enum AVPixelFormat input_pix_fmts[] = {        AV_PIX_FMT_NV12, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV444P,        AV_PIX_FMT_NONE,    };    static const enum AVPixelFormat output_pix_fmts[] = {        AV_PIX_FMT_CUDA, AV_PIX_FMT_NONE,    };    AVFilterFormats *in_fmts  = ff_make_format_list(input_pix_fmts);    AVFilterFormats *out_fmts = ff_make_format_list(output_pix_fmts);    ret = ff_formats_ref(in_fmts, &ctx->inputs[0]->out_formats);    if (ret < 0)        return ret;    ret = ff_formats_ref(out_fmts, &ctx->outputs[0]->in_formats);    if (ret < 0)        return ret;    return 0;}", "idx": 26419}
{"project": "FFmpeg", "commit_id": "46e1af3b0f2c28936dfa88063cc5a35f466f5ac3", "target": 0, "function": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, int stride,                        int width, int height,                        const uint8_t *src, int src_size, int use_pred){    int i, j, slice, pix;    int sstart, send;    VLC vlc;    GetBitContext gb;    int prev;    const int cmask = ~(!plane_no && c->avctx->pix_fmt == PIX_FMT_YUV420P);    if (build_huff(src, &vlc)) {        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");        return AVERROR_INVALIDDATA;    }    src      += 256;    src_size -= 256;    send = 0;    for (slice = 0; slice < c->slices; slice++) {        uint8_t *dest;        int slice_data_start, slice_data_end, slice_size;        sstart = send;        send   = (height * (slice + 1) / c->slices) & cmask;        dest   = dst + sstart * stride;        // slice offset and size validation was done earlier        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;        slice_data_end   = AV_RL32(src + slice * 4);        slice_size       = slice_data_end - slice_data_start;        if (!slice_size) {            for (j = sstart; j < send; j++) {                for (i = 0; i < width * step; i += step)                    dest[i] = 0x80;                dest += stride;            }            continue;        }        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4, slice_size);        memset(c->slice_bits + slice_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);        c->dsp.bswap_buf((uint32_t*)c->slice_bits, (uint32_t*)c->slice_bits,                         (slice_data_end - slice_data_start + 3) >> 2);        init_get_bits(&gb, c->slice_bits, slice_size * 8);        prev = 0x80;        for (j = sstart; j < send; j++) {            for (i = 0; i < width * step; i += step) {                if (get_bits_left(&gb) <= 0) {                    av_log(c->avctx, AV_LOG_ERROR, \"Slice decoding ran out of bits\\n\");                    goto fail;                }                pix = get_vlc2(&gb, vlc.table, vlc.bits, 4);                if (pix < 0) {                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");                    goto fail;                }                if (use_pred) {                    prev += pix;                    pix   = prev;                }                dest[i] = pix;            }            dest += stride;        }        if (get_bits_left(&gb) > 32)            av_log(c->avctx, AV_LOG_WARNING, \"%d bits left after decoding slice\\n\",                   get_bits_left(&gb));    }    free_vlc(&vlc);    return 0;fail:    free_vlc(&vlc);    return AVERROR_INVALIDDATA;}", "idx": 26440}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size){        struct fs_dma_ctrl *ctrl = opaque;\tint c;\tuint32_t r = 0;\tif (size != 4) {\t\tdma_rinvalid(opaque, addr);\t}\t/* Make addr relative to this channel and bounded to nr regs.  */\tc = fs_channel(addr);\taddr &= 0xff;\taddr >>= 2;\tswitch (addr)\t{\t\tcase RW_STAT:\t\t\tr = ctrl->channels[c].state & 7;\t\t\tr |= ctrl->channels[c].eol << 5;\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\t\t\tbreak;\t\tdefault:\t\t\tr = ctrl->channels[c].regs[addr];\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\t\t\t\t  __func__, c, addr));\t\t\tbreak;\t}\treturn r;}", "idx": 26451}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "function": "START_TEST(qint_from_int64_test){    QInt *qi;    const int64_t value = 0x1234567890abcdefLL;    qi = qint_from_int(value);    fail_unless((int64_t) qi->value == value);    QDECREF(qi);}", "idx": 26456}
{"project": "FFmpeg", "commit_id": "1d3a9e63e0dcbcba633d939cdfb79e977259be13", "target": 1, "function": "static int rv10_decode_frame(AVCodecContext *avctx,                             void *data, int *data_size,                             AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    MpegEncContext *s = avctx->priv_data;    int i;    AVFrame *pict = data;    int slice_count;    const uint8_t *slices_hdr = NULL;    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);    /* no supplementary picture */    if (buf_size == 0) {        return 0;    }    if(!avctx->slice_count){        slice_count = (*buf++) + 1;        slices_hdr = buf + 4;        buf += 8 * slice_count;    }else        slice_count = avctx->slice_count;    for(i=0; i<slice_count; i++){        int offset= get_slice_offset(avctx, slices_hdr, i);        int size, size2;        if(i+1 == slice_count)            size= buf_size - offset;        else            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;        if(i+2 >= slice_count)            size2= buf_size - offset;        else            size2= get_slice_offset(avctx, slices_hdr, i+2) - offset;        if(rv10_decode_packet(avctx, buf+offset, size, size2) > 8*size)            i++;    }    if(s->current_picture_ptr != NULL && s->mb_y>=s->mb_height){        ff_er_frame_end(s);        MPV_frame_end(s);        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {            *pict= *(AVFrame*)s->current_picture_ptr;        } else if (s->last_picture_ptr != NULL) {            *pict= *(AVFrame*)s->last_picture_ptr;        }        if(s->last_picture_ptr || s->low_delay){            *data_size = sizeof(AVFrame);            ff_print_debug_info(s, pict);        }        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)    }    return buf_size;}", "idx": 26501}
{"project": "qemu", "commit_id": "bbc5842211cdd90103cfe52f2ca24afac880694f", "target": 1, "function": "static inline void write_IRQreg (openpic_t *opp, int n_IRQ,                                 uint32_t reg, uint32_t val){    uint32_t tmp;    switch (reg) {    case IRQ_IPVP:        /* NOTE: not fully accurate for special IRQs, but simple and           sufficient */        /* ACTIVITY bit is read-only */        opp->src[n_IRQ].ipvp =            (opp->src[n_IRQ].ipvp & 0x40000000) |            (val & 0x800F00FF);        openpic_update_irq(opp, n_IRQ);        DPRINTF(\"Set IPVP %d to 0x%08x -> 0x%08x\\n\",                n_IRQ, val, opp->src[n_IRQ].ipvp);        break;    case IRQ_IDE:        tmp = val & 0xC0000000;        tmp |= val & ((1 << MAX_CPU) - 1);        opp->src[n_IRQ].ide = tmp;        DPRINTF(\"Set IDE %d to 0x%08x\\n\", n_IRQ, opp->src[n_IRQ].ide);        break;    }}", "idx": 26511}
{"project": "FFmpeg", "commit_id": "233f6f889ea310c2213f1f678b68e424791bf843", "target": 0, "function": "AVOption *av_set_string(void *obj, const char *name, const char *val){    AVOption *o= find_opt(obj, name);    if(!o || !val || o->offset<=0)         return NULL;    if(o->type != FF_OPT_TYPE_STRING){        double d=0, tmp_d;        for(;;){            int i;            char buf[256], *tail;            for(i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+'; i++)                buf[i]= val[i];            buf[i]=0;            val+= i;                        tmp_d= av_parse_num(buf, &tail);            if(tail > buf)                d+= tmp_d;            else{                AVOption *o_named= find_opt(obj, buf);                if(o_named && o_named->type == FF_OPT_TYPE_CONST)                     d+= o_named->default_val;                else if(!strcmp(buf, \"default\")) d+= o->default_val;                else if(!strcmp(buf, \"max\"    )) d+= o->max;                else if(!strcmp(buf, \"min\"    )) d+= o->min;                else return NULL;            }            if(*val == '+') val++;            if(!*val)                return av_set_number(obj, name, d, 1, 1);        }        return NULL;    }        memcpy(((uint8_t*)obj) + o->offset, val, sizeof(val));    return o;}", "idx": 26526}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "function": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b){    TCGv_i64 tmp64 = tcg_temp_new_i64();    tcg_gen_extu_i32_i64(tmp64, b);    dead_tmp(b);    tcg_gen_shli_i64(tmp64, tmp64, 32);    tcg_gen_add_i64(a, tmp64, a);    tcg_temp_free_i64(tmp64);    return a;}", "idx": 26531}
{"project": "qemu", "commit_id": "65e7545ea3c65a6468fb59418a6dbe66ef71d6d1", "target": 0, "function": "static void sunkbd_event(void *opaque, int ch){    ChannelState *s = opaque;    int release = ch & 0x80;    trace_escc_sunkbd_event_in(ch);    switch (ch) {    case 58: // Caps lock press        s->caps_lock_mode ^= 1;        if (s->caps_lock_mode == 2)            return; // Drop second press        break;    case 69: // Num lock press        s->num_lock_mode ^= 1;        if (s->num_lock_mode == 2)            return; // Drop second press        break;    case 186: // Caps lock release        s->caps_lock_mode ^= 2;        if (s->caps_lock_mode == 3)            return; // Drop first release        break;    case 197: // Num lock release        s->num_lock_mode ^= 2;        if (s->num_lock_mode == 3)            return; // Drop first release        break;    case 0xe0:        s->e0_mode = 1;        return;    default:        break;    }    if (s->e0_mode) {        s->e0_mode = 0;        ch = e0_keycodes[ch & 0x7f];    } else {        ch = keycodes[ch & 0x7f];    }    trace_escc_sunkbd_event_out(ch);    put_queue(s, ch | release);}", "idx": 26593}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "function": "START_TEST(unterminated_dict){    QObject *obj = qobject_from_json(\"{'abc':32\");    fail_unless(obj == NULL);}", "idx": 26605}
{"project": "FFmpeg", "commit_id": "ef4c71e8f83a46fb31a11f0a066efb90821c579f", "target": 0, "function": "static void init_filter_param(AVFilterContext *ctx, FilterParam *fp, const char *effect_type, int width){    int z;    const char *effect;    effect = fp->amount == 0 ? \"none\" : fp->amount < 0 ? \"blur\" : \"sharpen\";    av_log(ctx, AV_LOG_VERBOSE, \"effect:%s type:%s msize_x:%d msize_y:%d amount:%0.2f\\n\",           effect, effect_type, fp->msize_x, fp->msize_y, fp->amount / 65535.0);    for (z = 0; z < 2 * fp->steps_y; z++)        fp->sc[z] = av_malloc(sizeof(*(fp->sc[z])) * (width + 2 * fp->steps_x));}", "idx": 26611}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "function": "void do_td (int flags){    if (!likely(!(((int64_t)T0 < (int64_t)T1 && (flags & 0x10)) ||                  ((int64_t)T0 > (int64_t)T1 && (flags & 0x08)) ||                  ((int64_t)T0 == (int64_t)T1 && (flags & 0x04)) ||                  ((uint64_t)T0 < (uint64_t)T1 && (flags & 0x02)) ||                  ((uint64_t)T0 > (uint64_t)T1 && (flags & 0x01)))))        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);}", "idx": 26655}
{"project": "qemu", "commit_id": "339064d5063924e5176842abbf6c8089f3479c5b", "target": 1, "function": "void *qemu_blockalign(BlockDriverState *bs, size_t size){    return qemu_memalign((bs && bs->buffer_alignment) ? bs->buffer_alignment : 512, size);}", "idx": 26717}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "function": "static void vc1_inv_trans_4x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block){    int i;    int dc = block[0];    const uint8_t *cm;    dc = (17 * dc +  4) >> 3;    dc = (12 * dc + 64) >> 7;    cm = ff_cropTbl + MAX_NEG_CROP + dc;    for(i = 0; i < 8; i++){        dest[0] = cm[dest[0]];        dest[1] = cm[dest[1]];        dest[2] = cm[dest[2]];        dest[3] = cm[dest[3]];        dest += linesize;    }}", "idx": 26733}
{"project": "FFmpeg", "commit_id": "7620d48f2eab67812d8c535d12a98eaa754a1177", "target": 1, "function": "int avformat_network_init(void){#if CONFIG_NETWORK    int ret;    ff_network_inited_globally = 1;    if ((ret = ff_network_init()) < 0)        return ret;    ff_tls_init();#endif    return 0;}", "idx": 26768}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "function": "static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,                                             SocketAddress *addr,                                             size_t *naddrs,                                             SocketAddress ***addrs,                                             Error **errp){    struct addrinfo ai, *res, *e;    InetSocketAddress *iaddr = addr->u.inet.data;    char port[33];    char uaddr[INET6_ADDRSTRLEN + 1];    char uport[33];    int rc;    Error *err = NULL;    size_t i;    *naddrs = 0;    *addrs = NULL;    memset(&ai, 0, sizeof(ai));    ai.ai_flags = AI_PASSIVE;    if (iaddr->has_numeric && iaddr->numeric) {        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;    }    ai.ai_family = inet_ai_family_from_address(iaddr, &err);    ai.ai_socktype = SOCK_STREAM;    if (err) {        error_propagate(errp, err);        return -1;    }    if (iaddr->host == NULL) {        error_setg(errp, \"host not specified\");        return -1;    }    if (iaddr->port != NULL) {        pstrcpy(port, sizeof(port), iaddr->port);    } else {        port[0] = '\\0';    }    rc = getaddrinfo(strlen(iaddr->host) ? iaddr->host : NULL,                     strlen(port) ? port : NULL, &ai, &res);    if (rc != 0) {        error_setg(errp, \"address resolution failed for %s:%s: %s\",                   iaddr->host, port, gai_strerror(rc));        return -1;    }    for (e = res; e != NULL; e = e->ai_next) {        (*naddrs)++;    }    *addrs = g_new0(SocketAddress *, *naddrs);    /* create socket + bind */    for (i = 0, e = res; e != NULL; i++, e = e->ai_next) {        SocketAddress *newaddr = g_new0(SocketAddress, 1);        InetSocketAddress *newiaddr = g_new0(InetSocketAddress, 1);        newaddr->u.inet.data = newiaddr;        newaddr->type = SOCKET_ADDRESS_KIND_INET;        getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen,                    uaddr, INET6_ADDRSTRLEN, uport, 32,                    NI_NUMERICHOST | NI_NUMERICSERV);        *newiaddr = (InetSocketAddress){            .host = g_strdup(uaddr),            .port = g_strdup(uport),            .has_numeric = true,            .numeric = true,            .has_to = iaddr->has_to,            .to = iaddr->to,            .has_ipv4 = false,            .has_ipv6 = false,        };        (*addrs)[i] = newaddr;    }    freeaddrinfo(res);    return 0;}", "idx": 26778}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "function": "void acpi_pm1_cnt_init(ACPIREGS *ar, qemu_irq cmos_s3){    ar->pm1.cnt.cmos_s3 = cmos_s3;}", "idx": 26791}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "function": "static void sdhci_generic_reset(DeviceState *ds){    SDHCIState *s = SDHCI(ds);    SDHCI_GET_CLASS(s)->reset(s);}", "idx": 26803}
{"project": "FFmpeg", "commit_id": "fecb3e82a4ba09dc11a51ad0961ab491881a53a1", "target": 1, "function": "static inline int mxf_read_utf16_string(AVIOContext *pb, int size, char** str, int be){    int ret;    size_t buf_size;    if (size < 0)        return AVERROR(EINVAL);    buf_size = size + size / 2 + 1;    *str = av_malloc(buf_size);    if (!*str)        return AVERROR(ENOMEM);    if (be)        ret = avio_get_str16be(pb, size, *str, buf_size);    else        ret = avio_get_str16le(pb, size, *str, buf_size);    if (ret < 0) {        av_freep(str);        return ret;    }    return ret;}", "idx": 26838}
{"project": "FFmpeg", "commit_id": "258dfff8394d383beaa639d19912b3f068f67e16", "target": 1, "function": "void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl,                        char *line, int line_size, int *print_prefix){    char part[3][512];    format_line(ptr, level, fmt, vl, part, sizeof(part[0]), print_prefix, NULL);    snprintf(line, line_size, \"%s%s%s\", part[0], part[1], part[2]);}", "idx": 26867}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "function": "static void *thread_func(void *p){    struct thread_info *info = p;    rcu_register_thread();    atomic_inc(&n_ready_threads);    while (!atomic_mb_read(&test_start)) {        cpu_relax();    }    rcu_read_lock();    while (!atomic_read(&test_stop)) {        info->r = xorshift64star(info->r);        info->func(info);    }    rcu_read_unlock();    rcu_unregister_thread();    return NULL;}", "idx": 26873}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "function": "static unsigned int dec_addi_acr(DisasContext *dc){\tTCGv t0;\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u, $acr\\n\",\t\t  memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\tcris_cc_mask(dc, 0);\tt0 = tcg_temp_new(TCG_TYPE_TL);\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\ttcg_gen_add_tl(cpu_R[R_ACR], cpu_R[dc->op1], t0);\ttcg_temp_free(t0);\treturn 2;}", "idx": 26894}
{"project": "qemu", "commit_id": "56439e9d55626b65ecb887f1ac3714652555312e", "target": 1, "function": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,                         int nb_sectors, QEMUIOVector *qiov){    BDRVQcowState *s = bs->opaque;    int index_in_cluster;    int ret = 0, n;    uint64_t cluster_offset;    struct iovec hd_iov;    QEMUIOVector hd_qiov;    uint8_t *buf;    void *orig_buf;    if (qiov->niov > 1) {        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);        if (buf == NULL) {            return -ENOMEM;        }    } else {        orig_buf = NULL;        buf = (uint8_t *)qiov->iov->iov_base;    }    qemu_co_mutex_lock(&s->lock);    while (nb_sectors != 0) {        /* prepare next request */        cluster_offset = get_cluster_offset(bs, sector_num << 9,                                                 0, 0, 0, 0);        index_in_cluster = sector_num & (s->cluster_sectors - 1);        n = s->cluster_sectors - index_in_cluster;        if (n > nb_sectors) {            n = nb_sectors;        }        if (!cluster_offset) {            if (bs->backing) {                /* read from the base image */                hd_iov.iov_base = (void *)buf;                hd_iov.iov_len = n * 512;                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);                qemu_co_mutex_unlock(&s->lock);                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);                qemu_co_mutex_lock(&s->lock);                if (ret < 0) {                    goto fail;                }            } else {                /* Note: in this case, no need to wait */                memset(buf, 0, 512 * n);            }        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {            /* add AIO support for compressed blocks ? */            if (decompress_cluster(bs, cluster_offset) < 0) {                goto fail;            }            memcpy(buf,                   s->cluster_cache + index_in_cluster * 512, 512 * n);        } else {            if ((cluster_offset & 511) != 0) {                goto fail;            }            hd_iov.iov_base = (void *)buf;            hd_iov.iov_len = n * 512;            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);            qemu_co_mutex_unlock(&s->lock);            ret = bdrv_co_readv(bs->file,                                (cluster_offset >> 9) + index_in_cluster,                                n, &hd_qiov);            qemu_co_mutex_lock(&s->lock);            if (ret < 0) {                break;            }            if (bs->encrypted) {                assert(s->crypto);                if (qcrypto_block_decrypt(s->crypto, sector_num, buf,                                          n * BDRV_SECTOR_SIZE, NULL) < 0) {                    goto fail;                }            }        }        ret = 0;        nb_sectors -= n;        sector_num += n;        buf += n * 512;    }done:    qemu_co_mutex_unlock(&s->lock);    if (qiov->niov > 1) {        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);        qemu_vfree(orig_buf);    }    return ret;fail:    ret = -EIO;    goto done;}", "idx": 26918}
{"project": "qemu", "commit_id": "c650c008e326f3a1e84083bc269265456057a212", "target": 0, "function": "static void setup_frame(int sig, struct target_sigaction *ka,                        target_sigset_t *set, CPUPPCState *env){    struct target_sigframe *frame;    struct target_sigcontext *sc;    target_ulong frame_addr, newsp;    int err = 0;    int signal;    frame_addr = get_sigframe(ka, env, sizeof(*frame));    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))        goto sigsegv;    sc = &frame->sctx;    signal = current_exec_domain_sig(sig);    __put_user(ka->_sa_handler, &sc->handler);    __put_user(set->sig[0], &sc->oldmask);#if defined(TARGET_PPC64)    __put_user(set->sig[0] >> 32, &sc->_unused[3]);#else    __put_user(set->sig[1], &sc->_unused[3]);#endif    __put_user(h2g(&frame->mctx), &sc->regs);    __put_user(sig, &sc->signal);    /* Save user regs.  */    err |= save_user_regs(env, &frame->mctx, TARGET_NR_sigreturn);    /* The kernel checks for the presence of a VDSO here.  We don't       emulate a vdso, so use a sigreturn system call.  */    env->lr = (target_ulong) h2g(frame->mctx.tramp);    /* Turn off all fp exceptions.  */    env->fpscr = 0;    /* Create a stack frame for the caller of the handler.  */    newsp = frame_addr - SIGNAL_FRAMESIZE;    err |= put_user(env->gpr[1], newsp, target_ulong);    if (err)        goto sigsegv;    /* Set up registers for signal handler.  */    env->gpr[1] = newsp;    env->gpr[3] = signal;    env->gpr[4] = frame_addr + offsetof(struct target_sigframe, sctx);    env->nip = (target_ulong) ka->_sa_handler;    /* Signal handlers are entered in big-endian mode.  */    env->msr &= ~MSR_LE;    unlock_user_struct(frame, frame_addr, 1);    return;sigsegv:    unlock_user_struct(frame, frame_addr, 1);    qemu_log(\"segfaulting from setup_frame\\n\");    force_sig(TARGET_SIGSEGV);}", "idx": 26961}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "function": "static uint64_t mv88w8618_audio_read(void *opaque, target_phys_addr_t offset,                                    unsigned size){    mv88w8618_audio_state *s = opaque;    switch (offset) {    case MP_AUDIO_PLAYBACK_MODE:        return s->playback_mode;    case MP_AUDIO_CLOCK_DIV:        return s->clock_div;    case MP_AUDIO_IRQ_STATUS:        return s->status;    case MP_AUDIO_IRQ_ENABLE:        return s->irq_enable;    case MP_AUDIO_TX_STATUS:        return s->play_pos >> 2;    default:        return 0;    }}", "idx": 26963}
{"project": "FFmpeg", "commit_id": "c04c3282b4334ff64cfd69d40fea010602e830fd", "target": 0, "function": "static int raw_read_header(AVFormatContext *s, AVFormatParameters *ap){    AVStream *st;    int id;    st = av_new_stream(s, 0);    if (!st)        return AVERROR_NOMEM;    if (ap) {        id = s->iformat->value;        if (id == CODEC_ID_RAWVIDEO) {            st->codec->codec_type = CODEC_TYPE_VIDEO;        } else {            st->codec->codec_type = CODEC_TYPE_AUDIO;        }        st->codec->codec_id = id;        switch(st->codec->codec_type) {        case CODEC_TYPE_AUDIO:            st->codec->sample_rate = ap->sample_rate;            st->codec->channels = ap->channels;            av_set_pts_info(st, 64, 1, st->codec->sample_rate);            break;        case CODEC_TYPE_VIDEO:            av_set_pts_info(st, 64, ap->time_base.num, ap->time_base.den);            st->codec->width = ap->width;            st->codec->height = ap->height;            st->codec->pix_fmt = ap->pix_fmt;            if(st->codec->pix_fmt == PIX_FMT_NONE)                st->codec->pix_fmt= PIX_FMT_YUV420P;            break;        default:            return -1;        }    } else {        return -1;    }    return 0;}", "idx": 27019}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "function": "void ff_mpeg_unref_picture(MpegEncContext *s, Picture *pic){    int off = offsetof(Picture, mb_mean) + sizeof(pic->mb_mean);    pic->tf.f = &pic->f;    /* WM Image / Screen codecs allocate internal buffers with different     * dimensions / colorspaces; ignore user-defined callbacks for these. */    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&        s->codec_id != AV_CODEC_ID_MSS2)        ff_thread_release_buffer(s->avctx, &pic->tf);    else        av_frame_unref(&pic->f);    av_buffer_unref(&pic->hwaccel_priv_buf);    if (pic->needs_realloc)        ff_free_picture_tables(pic);    memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);}", "idx": 27029}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "function": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit){    const char *driver;    DeviceState *dev;    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";    dev = qdev_create(&bus->qbus, driver);    qdev_prop_set_uint32(dev, \"scsi-id\", unit);    qdev_prop_set_drive(dev, \"drive\", dinfo);    qdev_init(dev);    return DO_UPCAST(SCSIDevice, qdev, dev);}", "idx": 27140}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "function": "static void pixel_format_message (VncState *vs) {    char pad[3] = { 0, 0, 0 };    vnc_write_u8(vs, vs->depth * 8); /* bits-per-pixel */    if (vs->depth == 4) vnc_write_u8(vs, 24); /* depth */    else vnc_write_u8(vs, vs->depth * 8); /* depth */#ifdef WORDS_BIGENDIAN    vnc_write_u8(vs, 1);             /* big-endian-flag */#else    vnc_write_u8(vs, 0);             /* big-endian-flag */#endif    vnc_write_u8(vs, 1);             /* true-color-flag */    if (vs->depth == 4) {        vnc_write_u16(vs, 0xFF);     /* red-max */        vnc_write_u16(vs, 0xFF);     /* green-max */        vnc_write_u16(vs, 0xFF);     /* blue-max */        vnc_write_u8(vs, 16);        /* red-shift */        vnc_write_u8(vs, 8);         /* green-shift */        vnc_write_u8(vs, 0);         /* blue-shift */        vs->send_hextile_tile = send_hextile_tile_32;    } else if (vs->depth == 2) {        vnc_write_u16(vs, 31);       /* red-max */        vnc_write_u16(vs, 63);       /* green-max */        vnc_write_u16(vs, 31);       /* blue-max */        vnc_write_u8(vs, 11);        /* red-shift */        vnc_write_u8(vs, 5);         /* green-shift */        vnc_write_u8(vs, 0);         /* blue-shift */        vs->send_hextile_tile = send_hextile_tile_16;    } else if (vs->depth == 1) {        /* XXX: change QEMU pixel 8 bit pixel format to match the VNC one ? */        vnc_write_u16(vs, 7);        /* red-max */        vnc_write_u16(vs, 7);        /* green-max */        vnc_write_u16(vs, 3);        /* blue-max */        vnc_write_u8(vs, 5);         /* red-shift */        vnc_write_u8(vs, 2);         /* green-shift */        vnc_write_u8(vs, 0);         /* blue-shift */        vs->send_hextile_tile = send_hextile_tile_8;    }    vs->client_red_max = vs->server_red_max;    vs->client_green_max = vs->server_green_max;    vs->client_blue_max = vs->server_blue_max;    vs->client_red_shift = vs->server_red_shift;    vs->client_green_shift = vs->server_green_shift;    vs->client_blue_shift = vs->server_blue_shift;    vs->pix_bpp = vs->depth * 8;    vs->write_pixels = vnc_write_pixels_copy;    vnc_write(vs, pad, 3);           /* padding */}", "idx": 27146}
{"project": "FFmpeg", "commit_id": "31fdf3065daceb31e12fd26a367445676d761180", "target": 1, "function": "static void filter(AVFilterContext *ctx){    IDETContext *idet = ctx->priv;    int y, i;    int64_t alpha[2]={0};    int64_t delta=0;    Type type, best_type;    int match = 0;    for (i = 0; i < idet->csp->nb_components; i++) {        int w = idet->cur->video->w;        int h = idet->cur->video->h;        int refs = idet->cur->linesize[i];        if (i && i<3) {            w >>= idet->csp->log2_chroma_w;            h >>= idet->csp->log2_chroma_h;        }        for (y = 2; y < h - 2; y++) {            uint8_t *prev = &idet->prev->data[i][y*refs];            uint8_t *cur  = &idet->cur ->data[i][y*refs];            uint8_t *next = &idet->next->data[i][y*refs];            alpha[ y   &1] += idet->filter_line(cur-refs, prev, cur+refs, w);            alpha[(y^1)&1] += idet->filter_line(cur-refs, next, cur+refs, w);            delta          += idet->filter_line(cur-refs,  cur, cur+refs, w);        }    }    if      (alpha[0] / (float)alpha[1] > idet->interlace_threshold){        type = TFF;    }else if(alpha[1] / (float)alpha[0] > idet->interlace_threshold){        type = BFF;    }else if(alpha[1] / (float)delta    > idet->progressive_threshold){        type = PROGRSSIVE;    }else{        type = UNDETERMINED;    }    memmove(idet->history+1, idet->history, HIST_SIZE-1);    idet->history[0] = type;    best_type = UNDETERMINED;    for(i=0; i<HIST_SIZE; i++){        if(idet->history[i] != UNDETERMINED){            if(best_type == UNDETERMINED)                best_type = idet->history[i];            if(idet->history[i] == best_type) {                match++;            }else{                match=0;                break;            }        }    }    if(idet->last_type == UNDETERMINED){        if(match  ) idet->last_type = best_type;    }else{        if(match>2) idet->last_type = best_type;    }    if      (idet->last_type == TFF){        idet->cur->video->top_field_first = 1;        idet->cur->video->interlaced = 1;    }else if(idet->last_type == BFF){        idet->cur->video->top_field_first = 0;        idet->cur->video->interlaced = 1;    }else if(idet->last_type == PROGRSSIVE){        idet->cur->video->interlaced = 0;    }    idet->prestat [           type] ++;    idet->poststat[idet->last_type] ++;    av_log(ctx, AV_LOG_DEBUG, \"Single frame:%s, Multi frame:%s\\n\", type2str(type), type2str(idet->last_type));}", "idx": 27154}
{"project": "FFmpeg", "commit_id": "0634c5425306547e593bedbbbd2d982d7f0a27cf", "target": 0, "function": "static int aac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                            const AVFrame *frame, int *got_packet_ptr){    AACEncContext *s = avctx->priv_data;    float **samples = s->planar_samples, *samples2, *la, *overlap;    ChannelElement *cpe;    SingleChannelElement *sce;    IndividualChannelStream *ics;    int i, its, ch, w, chans, tag, start_ch, ret, frame_bits;    int target_bits, rate_bits, too_many_bits, too_few_bits;    int ms_mode = 0, is_mode = 0, tns_mode = 0, pred_mode = 0;    int chan_el_counter[4];    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];    if (s->last_frame == 2)        return 0;    /* add current frame to queue */    if (frame) {        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0)            return ret;    }    copy_input_samples(s, frame);    if (s->psypp)        ff_psy_preprocess(s->psypp, s->planar_samples, s->channels);    if (!avctx->frame_number)        return 0;    start_ch = 0;    for (i = 0; i < s->chan_map[0]; i++) {        FFPsyWindowInfo* wi = windows + start_ch;        tag      = s->chan_map[i+1];        chans    = tag == TYPE_CPE ? 2 : 1;        cpe      = &s->cpe[i];        for (ch = 0; ch < chans; ch++) {            float clip_avoidance_factor;            sce = &cpe->ch[ch];            ics = &sce->ics;            s->cur_channel = start_ch + ch;            overlap  = &samples[s->cur_channel][0];            samples2 = overlap + 1024;            la       = samples2 + (448+64);            if (!frame)                la = NULL;            if (tag == TYPE_LFE) {                wi[ch].window_type[0] = ONLY_LONG_SEQUENCE;                wi[ch].window_shape   = 0;                wi[ch].num_windows    = 1;                wi[ch].grouping[0]    = 1;                /* Only the lowest 12 coefficients are used in a LFE channel.                 * The expression below results in only the bottom 8 coefficients                 * being used for 11.025kHz to 16kHz sample rates.                 */                ics->num_swb = s->samplerate_index >= 8 ? 1 : 3;            } else {                wi[ch] = s->psy.model->window(&s->psy, samples2, la, s->cur_channel,                                              ics->window_sequence[0]);            }            ics->window_sequence[1] = ics->window_sequence[0];            ics->window_sequence[0] = wi[ch].window_type[0];            ics->use_kb_window[1]   = ics->use_kb_window[0];            ics->use_kb_window[0]   = wi[ch].window_shape;            ics->num_windows        = wi[ch].num_windows;            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];            ics->num_swb            = tag == TYPE_LFE ? ics->num_swb : s->psy.num_bands[ics->num_windows == 8];            ics->max_sfb            = FFMIN(ics->max_sfb, ics->num_swb);            ics->swb_offset         = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ?                                        ff_swb_offset_128 [s->samplerate_index]:                                        ff_swb_offset_1024[s->samplerate_index];            ics->tns_max_bands      = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ?                                        ff_tns_max_bands_128 [s->samplerate_index]:                                        ff_tns_max_bands_1024[s->samplerate_index];            clip_avoidance_factor = 0.0f;            for (w = 0; w < ics->num_windows; w++)                ics->group_len[w] = wi[ch].grouping[w];            for (w = 0; w < ics->num_windows; w++) {                if (wi[ch].clipping[w] > CLIP_AVOIDANCE_FACTOR) {                    ics->window_clipping[w] = 1;                    clip_avoidance_factor = FFMAX(clip_avoidance_factor, wi[ch].clipping[w]);                } else {                    ics->window_clipping[w] = 0;                }            }            if (clip_avoidance_factor > CLIP_AVOIDANCE_FACTOR) {                ics->clip_avoidance_factor = CLIP_AVOIDANCE_FACTOR / clip_avoidance_factor;            } else {                ics->clip_avoidance_factor = 1.0f;            }            apply_window_and_mdct(s, sce, overlap);            if (s->options.ltp && s->coder->update_ltp) {                s->coder->update_ltp(s, sce);                apply_window[sce->ics.window_sequence[0]](s->fdsp, sce, &sce->ltp_state[0]);                s->mdct1024.mdct_calc(&s->mdct1024, sce->lcoeffs, sce->ret_buf);            }            if (isnan(cpe->ch->coeffs[0])) {                av_log(avctx, AV_LOG_ERROR, \"Input contains NaN\\n\");                return AVERROR(EINVAL);            }            avoid_clipping(s, sce);        }        start_ch += chans;    }    if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels, 0)) < 0)        return ret;    frame_bits = its = 0;    do {        init_put_bits(&s->pb, avpkt->data, avpkt->size);        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & AV_CODEC_FLAG_BITEXACT))            put_bitstream_info(s, LIBAVCODEC_IDENT);        start_ch = 0;        target_bits = 0;        memset(chan_el_counter, 0, sizeof(chan_el_counter));        for (i = 0; i < s->chan_map[0]; i++) {            FFPsyWindowInfo* wi = windows + start_ch;            const float *coeffs[2];            tag      = s->chan_map[i+1];            chans    = tag == TYPE_CPE ? 2 : 1;            cpe      = &s->cpe[i];            cpe->common_window = 0;            memset(cpe->is_mask, 0, sizeof(cpe->is_mask));            memset(cpe->ms_mask, 0, sizeof(cpe->ms_mask));            put_bits(&s->pb, 3, tag);            put_bits(&s->pb, 4, chan_el_counter[tag]++);            for (ch = 0; ch < chans; ch++) {                sce = &cpe->ch[ch];                coeffs[ch] = sce->coeffs;                sce->ics.predictor_present = 0;                sce->ics.ltp.present = 0;                memset(sce->ics.ltp.used, 0, sizeof(sce->ics.ltp.used));                memset(sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));                memset(&sce->tns, 0, sizeof(TemporalNoiseShaping));                for (w = 0; w < 128; w++)                    if (sce->band_type[w] > RESERVED_BT)                        sce->band_type[w] = 0;            }            s->psy.bitres.alloc = -1;            s->psy.bitres.bits = s->last_frame_pb_count / s->channels;            s->psy.model->analyze(&s->psy, start_ch, coeffs, wi);            if (s->psy.bitres.alloc > 0) {                /* Lambda unused here on purpose, we need to take psy's unscaled allocation */                target_bits += s->psy.bitres.alloc                    * (s->lambda / (avctx->global_quality ? avctx->global_quality : 120));                s->psy.bitres.alloc /= chans;            }            s->cur_type = tag;            for (ch = 0; ch < chans; ch++) {                s->cur_channel = start_ch + ch;                if (s->options.pns && s->coder->mark_pns)                    s->coder->mark_pns(s, avctx, &cpe->ch[ch]);                s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda);            }            if (chans > 1                && wi[0].window_type[0] == wi[1].window_type[0]                && wi[0].window_shape   == wi[1].window_shape) {                cpe->common_window = 1;                for (w = 0; w < wi[0].num_windows; w++) {                    if (wi[0].grouping[w] != wi[1].grouping[w]) {                        cpe->common_window = 0;                        break;                    }                }            }            for (ch = 0; ch < chans; ch++) { /* TNS and PNS */                sce = &cpe->ch[ch];                s->cur_channel = start_ch + ch;                if (s->options.tns && s->coder->search_for_tns)                    s->coder->search_for_tns(s, sce);                if (s->options.tns && s->coder->apply_tns_filt)                    s->coder->apply_tns_filt(s, sce);                if (sce->tns.present)                    tns_mode = 1;                if (s->options.pns && s->coder->search_for_pns)                    s->coder->search_for_pns(s, avctx, sce);            }            s->cur_channel = start_ch;            if (s->options.intensity_stereo) { /* Intensity Stereo */                if (s->coder->search_for_is)                    s->coder->search_for_is(s, avctx, cpe);                if (cpe->is_mode) is_mode = 1;                apply_intensity_stereo(cpe);            }            if (s->options.pred) { /* Prediction */                for (ch = 0; ch < chans; ch++) {                    sce = &cpe->ch[ch];                    s->cur_channel = start_ch + ch;                    if (s->options.pred && s->coder->search_for_pred)                        s->coder->search_for_pred(s, sce);                    if (cpe->ch[ch].ics.predictor_present) pred_mode = 1;                }                if (s->coder->adjust_common_pred)                    s->coder->adjust_common_pred(s, cpe);                for (ch = 0; ch < chans; ch++) {                    sce = &cpe->ch[ch];                    s->cur_channel = start_ch + ch;                    if (s->options.pred && s->coder->apply_main_pred)                        s->coder->apply_main_pred(s, sce);                }                s->cur_channel = start_ch;            }            if (s->options.mid_side) { /* Mid/Side stereo */                if (s->options.mid_side == -1 && s->coder->search_for_ms)                    s->coder->search_for_ms(s, cpe);                else if (cpe->common_window)                    memset(cpe->ms_mask, 1, sizeof(cpe->ms_mask));                apply_mid_side_stereo(cpe);            }            adjust_frame_information(cpe, chans);            if (s->options.ltp) { /* LTP */                for (ch = 0; ch < chans; ch++) {                    sce = &cpe->ch[ch];                    s->cur_channel = start_ch + ch;                    if (s->coder->search_for_ltp)                        s->coder->search_for_ltp(s, sce, cpe->common_window);                    if (sce->ics.ltp.present) pred_mode = 1;                }                s->cur_channel = start_ch;                if (s->coder->adjust_common_ltp)                    s->coder->adjust_common_ltp(s, cpe);            }            if (chans == 2) {                put_bits(&s->pb, 1, cpe->common_window);                if (cpe->common_window) {                    put_ics_info(s, &cpe->ch[0].ics);                    if (s->coder->encode_main_pred)                        s->coder->encode_main_pred(s, &cpe->ch[0]);                    if (s->coder->encode_ltp_info)                        s->coder->encode_ltp_info(s, &cpe->ch[0], 1);                    encode_ms_info(&s->pb, cpe);                    if (cpe->ms_mode) ms_mode = 1;                }            }            for (ch = 0; ch < chans; ch++) {                s->cur_channel = start_ch + ch;                encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window);            }            start_ch += chans;        }        if (avctx->flags & CODEC_FLAG_QSCALE) {            /* When using a constant Q-scale, don't mess with lambda */            break;        }        /* rate control stuff         * allow between the nominal bitrate, and what psy's bit reservoir says to target         * but drift towards the nominal bitrate always         */        frame_bits = put_bits_count(&s->pb);        rate_bits = avctx->bit_rate * 1024 / avctx->sample_rate;        rate_bits = FFMIN(rate_bits, 6144 * s->channels - 3);        too_many_bits = FFMAX(target_bits, rate_bits);        too_many_bits = FFMIN(too_many_bits, 6144 * s->channels - 3);        too_few_bits = FFMIN(FFMAX(rate_bits - rate_bits/4, target_bits), too_many_bits);        /* When using ABR, be strict (but only for increasing) */        too_few_bits = too_few_bits - too_few_bits/8;        too_many_bits = too_many_bits + too_many_bits/2;        if (   its == 0 /* for steady-state Q-scale tracking */            || (its < 5 && (frame_bits < too_few_bits || frame_bits > too_many_bits))            || frame_bits >= 6144 * s->channels - 3  )        {            float ratio = ((float)rate_bits) / frame_bits;            if (frame_bits >= too_few_bits && frame_bits <= too_many_bits) {                /*                 * This path is for steady-state Q-scale tracking                 * When frame bits fall within the stable range, we still need to adjust                 * lambda to maintain it like so in a stable fashion (large jumps in lambda                 * create artifacts and should be avoided), but slowly                 */                ratio = sqrtf(sqrtf(ratio));                ratio = av_clipf(ratio, 0.9f, 1.1f);            } else {                /* Not so fast though */                ratio = sqrtf(ratio);            }            s->lambda = FFMIN(s->lambda * ratio, 65536.f);            /* Keep iterating if we must reduce and lambda is in the sky */            if (ratio > 0.9f && ratio < 1.1f) {                break;            } else {                if (is_mode || ms_mode || tns_mode || pred_mode) {                    for (i = 0; i < s->chan_map[0]; i++) {                        // Must restore coeffs                        chans = tag == TYPE_CPE ? 2 : 1;                        cpe = &s->cpe[i];                        for (ch = 0; ch < chans; ch++)                            memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs));                    }                }                its++;            }        } else {            break;        }    } while (1);    if (s->options.ltp && s->coder->ltp_insert_new_frame)        s->coder->ltp_insert_new_frame(s);    put_bits(&s->pb, 3, TYPE_END);    flush_put_bits(&s->pb);    s->last_frame_pb_count = put_bits_count(&s->pb);    s->lambda_sum += s->lambda;    s->lambda_count++;    if (!frame)        s->last_frame++;    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,                       &avpkt->duration);    avpkt->size = put_bits_count(&s->pb) >> 3;    *got_packet_ptr = 1;    return 0;}", "idx": 27165}
{"project": "qemu", "commit_id": "7a39fe588251ba042c91bf23d53b0ba820bf964c", "target": 0, "function": "int kvm_arch_pre_run(CPUState *env, struct kvm_run *run){    /* Inject NMI */    if (env->interrupt_request & CPU_INTERRUPT_NMI) {        env->interrupt_request &= ~CPU_INTERRUPT_NMI;        DPRINTF(\"injected NMI\\n\");        kvm_vcpu_ioctl(env, KVM_NMI);    }    if (!kvm_irqchip_in_kernel()) {        /* Force the VCPU out of its inner loop to process the INIT request */        if (env->interrupt_request & CPU_INTERRUPT_INIT) {            env->exit_request = 1;        }        /* Try to inject an interrupt if the guest can accept it */        if (run->ready_for_interrupt_injection &&            (env->interrupt_request & CPU_INTERRUPT_HARD) &&            (env->eflags & IF_MASK)) {            int irq;            env->interrupt_request &= ~CPU_INTERRUPT_HARD;            irq = cpu_get_pic_interrupt(env);            if (irq >= 0) {                struct kvm_interrupt intr;                intr.irq = irq;                /* FIXME: errors */                DPRINTF(\"injected interrupt %d\\n\", irq);                kvm_vcpu_ioctl(env, KVM_INTERRUPT, &intr);            }        }        /* If we have an interrupt but the guest is not ready to receive an         * interrupt, request an interrupt window exit.  This will         * cause a return to userspace as soon as the guest is ready to         * receive interrupts. */        if ((env->interrupt_request & CPU_INTERRUPT_HARD)) {            run->request_interrupt_window = 1;        } else {            run->request_interrupt_window = 0;        }        DPRINTF(\"setting tpr\\n\");        run->cr8 = cpu_get_apic_tpr(env->apic_state);    }    return 0;}", "idx": 27176}
{"project": "qemu", "commit_id": "dcb2b9e1003a9179650b44c747faa4e5767ce92b", "target": 0, "function": "static void gen_msync(DisasContext *ctx){    /* interpreted as no-op */}", "idx": 27177}
{"project": "qemu", "commit_id": "fe345a3d5d7ed4bc2965c65542832b1fa785ae9d", "target": 1, "function": "static void diag288_timer_expired(void *dev){    qemu_log_mask(CPU_LOG_RESET, \"Watchdog timer expired.\\n\");    watchdog_perform_action();    /* Reset the watchdog only if the guest was notified about expiry. */    switch (get_watchdog_action()) {    case WDT_DEBUG:    case WDT_NONE:    case WDT_PAUSE:         return;    }    wdt_diag288_reset(dev);}", "idx": 27213}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "function": "static void encode_gray_bitstream(HYuvContext *s, int count){    int i;        count/=2;    if(s->flags&CODEC_FLAG_PASS1){        for(i=0; i<count; i++){            s->stats[0][ s->temp[0][2*i  ] ]++;            s->stats[0][ s->temp[0][2*i+1] ]++;        }    }else if(s->context){        for(i=0; i<count; i++){            s->stats[0][ s->temp[0][2*i  ] ]++;            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);            s->stats[0][ s->temp[0][2*i+1] ]++;            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);        }    }else{        for(i=0; i<count; i++){            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);        }    }}", "idx": 27219}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "function": "static av_cold int libschroedinger_encode_init(AVCodecContext *avctx){    SchroEncoderParams *p_schro_params = avctx->priv_data;    SchroVideoFormatEnum preset;    /* Initialize the libraries that libschroedinger depends on. */    schro_init();    /* Create an encoder object. */    p_schro_params->encoder = schro_encoder_new();    if (!p_schro_params->encoder) {        av_log(avctx, AV_LOG_ERROR,               \"Unrecoverable Error: schro_encoder_new failed. \");        return -1;    }    /* Initialize the format. */    preset = ff_get_schro_video_format_preset(avctx);    p_schro_params->format =                    schro_encoder_get_video_format(p_schro_params->encoder);    schro_video_format_set_std_video_format(p_schro_params->format, preset);    p_schro_params->format->width  = avctx->width;    p_schro_params->format->height = avctx->height;    if (set_chroma_format(avctx) == -1)        return -1;    if (avctx->color_primaries == AVCOL_PRI_BT709) {        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_HDTV;    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_625;    } else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M) {        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_525;    }    if (avctx->colorspace == AVCOL_SPC_BT709) {        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_HDTV;    } else if (avctx->colorspace == AVCOL_SPC_BT470BG) {        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_SDTV;    }    if (avctx->color_trc == AVCOL_TRC_BT709) {        p_schro_params->format->transfer_function = SCHRO_TRANSFER_CHAR_TV_GAMMA;    }    if (ff_get_schro_frame_format(p_schro_params->format->chroma_format,                                  &p_schro_params->frame_format) == -1) {        av_log(avctx, AV_LOG_ERROR,               \"This codec currently supports only planar YUV 4:2:0, 4:2:2\"               \" and 4:4:4 formats.\\n\");        return -1;    }    p_schro_params->format->frame_rate_numerator   = avctx->time_base.den;    p_schro_params->format->frame_rate_denominator = avctx->time_base.num;    p_schro_params->frame_size = avpicture_get_size(avctx->pix_fmt,                                                    avctx->width,                                                    avctx->height);    avctx->coded_frame = av_frame_alloc();    if (!avctx->coded_frame)        return AVERROR(ENOMEM);    if (!avctx->gop_size) {        schro_encoder_setting_set_double(p_schro_params->encoder,                                         \"gop_structure\",                                         SCHRO_ENCODER_GOP_INTRA_ONLY);        if (avctx->coder_type == FF_CODER_TYPE_VLC)            schro_encoder_setting_set_double(p_schro_params->encoder,                                             \"enable_noarith\", 1);    } else {        schro_encoder_setting_set_double(p_schro_params->encoder,                                         \"au_distance\", avctx->gop_size);        avctx->has_b_frames = 1;        p_schro_params->dts = -1;    }    /* FIXME - Need to handle SCHRO_ENCODER_RATE_CONTROL_LOW_DELAY. */    if (avctx->flags & CODEC_FLAG_QSCALE) {        if (!avctx->global_quality) {            /* lossless coding */            schro_encoder_setting_set_double(p_schro_params->encoder,                                             \"rate_control\",                                             SCHRO_ENCODER_RATE_CONTROL_LOSSLESS);        } else {            int quality;            schro_encoder_setting_set_double(p_schro_params->encoder,                                             \"rate_control\",                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);            quality = avctx->global_quality / FF_QP2LAMBDA;            if (quality > 10)                quality = 10;            schro_encoder_setting_set_double(p_schro_params->encoder,                                             \"quality\", quality);        }    } else {        schro_encoder_setting_set_double(p_schro_params->encoder,                                         \"rate_control\",                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);        schro_encoder_setting_set_double(p_schro_params->encoder,                                         \"bitrate\", avctx->bit_rate);    }    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)        /* All material can be coded as interlaced or progressive           irrespective of the type of source material. */        schro_encoder_setting_set_double(p_schro_params->encoder,                                         \"interlaced_coding\", 1);    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger     * and libdirac support other bit-depth data. */    schro_video_format_set_std_signal_range(p_schro_params->format,                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);    /* Set the encoder format. */    schro_encoder_set_video_format(p_schro_params->encoder,                                   p_schro_params->format);    /* Set the debug level. */    schro_debug_set_level(avctx->debug);    schro_encoder_start(p_schro_params->encoder);    /* Initialize the encoded frame queue. */    ff_schro_queue_init(&p_schro_params->enc_frame_queue);    return 0;}", "idx": 27296}
{"project": "linux kernel", "commit_id": "124d3b7041f9a0ca7c43a6293e1cae4576c32fd5", "target": 1, "function": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes){    if (likely(i->nr_segs == 1)) {        i->iov_offset += bytes;    } else {        const struct iovec *iov = i->iov;        size_t base = i->iov_offset;        while (bytes) {            int copy = min(bytes, iov->iov_len - base);            bytes -= copy;            base += copy;            if (iov->iov_len == base) {                iov++;                base = 0;            }        }        i->iov = iov;        i->iov_offset = base;    }}void iov_iter_advance(struct iov_iter *i, size_t bytes){    BUG_ON(i->count < bytes);    __iov_iter_advance_iov(i, bytes);    i->count -= bytes;}EXPORT_SYMBOL(iov_iter_advance);/* * Fault in the first iovec of the given iov_iter, to a maximum length * of bytes. Returns 0 on success, or non-zero if the memory could not be * accessed (ie. because it is an invalid address). * * writev-intensive code may want this to prefault several iovecs -- that * would be possible (callers must not rely on the fact that _only_ the * first iovec will be faulted with the current implementation). */int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes){    char __user *buf = i->iov->iov_base + i->iov_offset;    bytes = min(bytes, i->iov->iov_len - i->iov_offset);    return fault_in_pages_readable(buf, bytes);}EXPORT_SYMBOL(iov_iter_fault_in_readable);/* * Return the count of just the current iov_iter segment. */size_t iov_iter_single_seg_count(struct iov_iter *i){    const struct iovec *iov = i->iov;    if (i->nr_segs == 1)        return i->count;    else        return min(i->count, iov->iov_len - i->iov_offset);}EXPORT_SYMBOL(iov_iter_single_seg_count);/* * Performs necessary checks before doing a write * * Can adjust writing position or amount of bytes to write. * Returns appropriate error code that caller should return or * zero in case that write should be allowed. */inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk){    struct inode *inode = file->f_mapping->host;    unsigned long limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;        if (unlikely(*pos < 0))                return -EINVAL;    if (!isblk) {        /* FIXME: this is for backwards compatibility with 2.4 */        if (file->f_flags & O_APPEND)                        *pos = i_size_read(inode);        if (limit != RLIM_INFINITY) {            if (*pos >= limit) {                send_sig(SIGXFSZ, current, 0);                return -EFBIG;            }            if (*count > limit - (typeof(limit))*pos) {                *count = limit - (typeof(limit))*pos;            }        }    }    /*     * LFS rule     */    if (unlikely(*pos + *count > MAX_NON_LFS &&                !(file->f_flags & O_LARGEFILE))) {        if (*pos >= MAX_NON_LFS) {            return -EFBIG;        }        if (*count > MAX_NON_LFS - (unsigned long)*pos) {            *count = MAX_NON_LFS - (unsigned long)*pos;        }    }    /*     * Are we about to exceed the fs block limit ?     *     * If we have written data it becomes a short write.  If we have     * exceeded without writing data we send a signal and return EFBIG.     * Linus frestrict idea will clean these up nicely..     */    if (likely(!isblk)) {        if (unlikely(*pos >= inode->i_sb->s_maxbytes)) {            if (*count || *pos > inode->i_sb->s_maxbytes) {                return -EFBIG;            }            /* zero-length writes at ->s_maxbytes are OK */        }        if (unlikely(*pos + *count > inode->i_sb->s_maxbytes))            *count = inode->i_sb->s_maxbytes - *pos;    } else {#ifdef CONFIG_BLOCK        loff_t isize;        if (bdev_read_only(I_BDEV(inode)))            return -EPERM;        isize = i_size_read(inode);        if (*pos >= isize) {            if (*count || *pos > isize)                return -ENOSPC;        }        if (*pos + *count > isize)            *count = isize - *pos;#else        return -EPERM;#endif    }    return 0;}EXPORT_SYMBOL(generic_write_checks);int pagecache_write_begin(struct file *file, struct address_space *mapping,                loff_t pos, unsigned len, unsigned flags,                struct page **pagep, void **fsdata){    const struct address_space_operations *aops = mapping->a_ops;    if (aops->write_begin) {        return aops->write_begin(file, mapping, pos, len, flags,                            pagep, fsdata);    } else {        int ret;        pgoff_t index = pos >> PAGE_CACHE_SHIFT;        unsigned offset = pos & (PAGE_CACHE_SIZE - 1);        struct inode *inode = mapping->host;        struct page *page;again:        page = __grab_cache_page(mapping, index);        *pagep = page;        if (!page)            return -ENOMEM;        if (flags & AOP_FLAG_UNINTERRUPTIBLE && !PageUptodate(page)) {            /*             * There is no way to resolve a short write situation             * for a !Uptodate page (except by double copying in             * the caller done by generic_perform_write_2copy).             *             * Instead, we have to bring it uptodate here.             */            ret = aops->readpage(file, page);            page_cache_release(page);            if (ret) {                if (ret == AOP_TRUNCATED_PAGE)                    goto again;                return ret;            }            goto again;        }        ret = aops->prepare_write(file, page, offset, offset+len);        if (ret) {            unlock_page(page);            page_cache_release(page);            if (pos + len > inode->i_size)                vmtruncate(inode, inode->i_size);        }        return ret;    }}EXPORT_SYMBOL(pagecache_write_begin);int pagecache_write_end(struct file *file, struct address_space *mapping,                loff_t pos, unsigned len, unsigned copied,                struct page *page, void *fsdata){    const struct address_space_operations *aops = mapping->a_ops;    int ret;    if (aops->write_end) {        mark_page_accessed(page);        ret = aops->write_end(file, mapping, pos, len, copied,                            page, fsdata);    } else {        unsigned offset = pos & (PAGE_CACHE_SIZE - 1);        struct inode *inode = mapping->host;        flush_dcache_page(page);        ret = aops->commit_write(file, page, offset, offset+len);        unlock_page(page);        mark_page_accessed(page);        page_cache_release(page);        if (ret < 0) {            if (pos + len > inode->i_size)                vmtruncate(inode, inode->i_size);        } else if (ret > 0)            ret = min_t(size_t, copied, ret);        else            ret = copied;    }    return ret;}EXPORT_SYMBOL(pagecache_write_end);ssize_tgeneric_file_direct_write(struct kiocb *iocb, const struct iovec *iov,        unsigned long *nr_segs, loff_t pos, loff_t *ppos,        size_t count, size_t ocount){    struct file *file = iocb->ki_filp;    struct address_space *mapping = file->f_mapping;    struct inode    *inode = mapping->host;    ssize_t     written;    if (count != ocount)        *nr_segs = iov_shorten((struct iovec *)iov, *nr_segs, count);    written = generic_file_direct_IO(WRITE, iocb, iov, pos, *nr_segs);    if (written > 0) {        loff_t end = pos + written;        if (end > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {            i_size_write(inode,  end);            mark_inode_dirty(inode);        }        *ppos = end;    }    /*     * Sync the fs metadata but not the minor inode changes and     * of course not the data as we did direct DMA for the IO.     * i_mutex is held, which protects generic_osync_inode() from     * livelocking.  AIO O_DIRECT ops attempt to sync metadata here.     */    if ((written >= 0 || written == -EIOCBQUEUED) &&        ((file->f_flags & O_SYNC) || IS_SYNC(inode))) {        int err = generic_osync_inode(inode, mapping, OSYNC_METADATA);        if (err < 0)            written = err;    }    return written;}EXPORT_SYMBOL(generic_file_direct_write);/* * Find or create a page at the given pagecache position. Return the locked * page. This function is specifically for buffered writes. */struct page *__grab_cache_page(struct address_space *mapping, pgoff_t index){    int status;    struct page *page;repeat:    page = find_lock_page(mapping, index);    if (likely(page))        return page;    page = page_cache_alloc(mapping);    if (!page)        return NULL;    status = add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);    if (unlikely(status)) {        page_cache_release(page);        if (status == -EEXIST)            goto repeat;        return NULL;    }    return page;}EXPORT_SYMBOL(__grab_cache_page);static ssize_t generic_perform_write_2copy(struct file *file,                struct iov_iter *i, loff_t pos){    struct address_space *mapping = file->f_mapping;    const struct address_space_operations *a_ops = mapping->a_ops;    struct inode *inode = mapping->host;    long status = 0;    ssize_t written = 0;    do {        struct page *src_page;        struct page *page;        pgoff_t index;      /* Pagecache index for current page */        unsigned long offset;   /* Offset into pagecache page */        unsigned long bytes;    /* Bytes to write to page */        size_t copied;      /* Bytes copied from user */        offset = (pos & (PAGE_CACHE_SIZE - 1));        index = pos >> PAGE_CACHE_SHIFT;        bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,                        iov_iter_count(i));        /*         * a non-NULL src_page indicates that we're doing the         * copy via get_user_pages and kmap.         */        src_page = NULL;        /*         * Bring in the user page that we will copy from _first_.         * Otherwise there's a nasty deadlock on copying from the         * same page as we're writing to, without it being marked         * up-to-date.         *         * Not only is this an optimisation, but it is also required         * to check that the address is actually valid, when atomic         * usercopies are used, below.         */        if (unlikely(iov_iter_fault_in_readable(i, bytes))) {            status = -EFAULT;            break;        }        page = __grab_cache_page(mapping, index);        if (!page) {            status = -ENOMEM;            break;        }        /*         * non-uptodate pages cannot cope with short copies, and we         * cannot take a pagefault with the destination page locked.         * So pin the source page to copy it.         */        if (!PageUptodate(page) && !segment_eq(get_fs(), KERNEL_DS)) {            unlock_page(page);            src_page = alloc_page(GFP_KERNEL);            if (!src_page) {                page_cache_release(page);                status = -ENOMEM;                break;            }            /*             * Cannot get_user_pages with a page locked for the             * same reason as we can't take a page fault with a             * page locked (as explained below).             */            copied = iov_iter_copy_from_user(src_page, i,                                offset, bytes);            if (unlikely(copied == 0)) {                status = -EFAULT;                page_cache_release(page);                page_cache_release(src_page);                break;            }            bytes = copied;            lock_page(page);            /*             * Can't handle the page going uptodate here, because             * that means we would use non-atomic usercopies, which             * zero out the tail of the page, which can cause             * zeroes to become transiently visible. We could just             * use a non-zeroing copy, but the APIs aren't too             * consistent.             */            if (unlikely(!page->mapping || PageUptodate(page))) {                unlock_page(page);                page_cache_release(page);                page_cache_release(src_page);                continue;            }        }        status = a_ops->prepare_write(file, page, offset, offset+bytes);        if (unlikely(status))            goto fs_write_aop_error;        if (!src_page) {            /*             * Must not enter the pagefault handler here, because             * we hold the page lock, so we might recursively             * deadlock on the same lock, or get an ABBA deadlock             * against a different lock, or against the mmap_sem             * (which nests outside the page lock).  So increment             * preempt count, and use _atomic usercopies.             *             * The page is uptodate so we are OK to encounter a             * short copy: if unmodified parts of the page are             * marked dirty and written out to disk, it doesn't             * really matter.             */            pagefault_disable();            copied = iov_iter_copy_from_user_atomic(page, i,                                offset, bytes);            pagefault_enable();        } else {            void *src, *dst;            src = kmap_atomic(src_page, KM_USER0);            dst = kmap_atomic(page, KM_USER1);            memcpy(dst + offset, src + offset, bytes);            kunmap_atomic(dst, KM_USER1);            kunmap_atomic(src, KM_USER0);            copied = bytes;        }        flush_dcache_page(page);        status = a_ops->commit_write(file, page, offset, offset+bytes);        if (unlikely(status < 0))            goto fs_write_aop_error;        if (unlikely(status > 0)) /* filesystem did partial write */            copied = min_t(size_t, copied, status);        unlock_page(page);        mark_page_accessed(page);        page_cache_release(page);        if (src_page)            page_cache_release(src_page);        iov_iter_advance(i, copied);        pos += copied;        written += copied;        balance_dirty_pages_ratelimited(mapping);        cond_resched();        continue;fs_write_aop_error:        unlock_page(page);        page_cache_release(page);        if (src_page)            page_cache_release(src_page);        /*         * prepare_write() may have instantiated a few blocks         * outside i_size.  Trim these off again. Don't need         * i_size_read because we hold i_mutex.         */        if (pos + bytes > inode->i_size)            vmtruncate(inode, inode->i_size);        break;    } while (iov_iter_count(i));    return written ? written : status;}static ssize_t generic_perform_write(struct file *file,                struct iov_iter *i, loff_t pos){    struct address_space *mapping = file->f_mapping;    const struct address_space_operations *a_ops = mapping->a_ops;    long status = 0;    ssize_t written = 0;    unsigned int flags = 0;    /*     * Copies from kernel address space cannot fail (NFSD is a big user).     */    if (segment_eq(get_fs(), KERNEL_DS))        flags |= AOP_FLAG_UNINTERRUPTIBLE;    do {        struct page *page;        pgoff_t index;      /* Pagecache index for current page */        unsigned long offset;   /* Offset into pagecache page */        unsigned long bytes;    /* Bytes to write to page */        size_t copied;      /* Bytes copied from user */        void *fsdata;        offset = (pos & (PAGE_CACHE_SIZE - 1));        index = pos >> PAGE_CACHE_SHIFT;        bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,                        iov_iter_count(i));again:        /*         * Bring in the user page that we will copy from _first_.         * Otherwise there's a nasty deadlock on copying from the         * same page as we're writing to, without it being marked         * up-to-date.         *         * Not only is this an optimisation, but it is also required         * to check that the address is actually valid, when atomic         * usercopies are used, below.         */        if (unlikely(iov_iter_fault_in_readable(i, bytes))) {            status = -EFAULT;            break;        }        status = a_ops->write_begin(file, mapping, pos, bytes, flags,                        &page, &fsdata);        if (unlikely(status))            break;        pagefault_disable();        copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);        pagefault_enable();        flush_dcache_page(page);        status = a_ops->write_end(file, mapping, pos, bytes, copied,                        page, fsdata);        if (unlikely(status < 0))            break;        copied = status;        cond_resched();        if (unlikely(copied == 0)) {            /*             * If we were unable to copy any data at all, we must             * fall back to a single segment length write.             *             * If we didn't fallback here, we could livelock             * because not all segments in the iov can be copied at             * once without a pagefault.             */            bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,                        iov_iter_single_seg_count(i));            goto again;        }        iov_iter_advance(i, copied);        pos += copied;        written += copied;        balance_dirty_pages_ratelimited(mapping);    } while (iov_iter_count(i));    return written ? written : status;}", "idx": 27325}
{"project": "linux kernel", "commit_id": "b9aae1e43eb2c8e989510187cff0ba3e996f9a4c", "target": 1, "function": "EXTERN SV*decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix){    STRLEN len;    char *s = SvPV_force(sv, len);    char *t = s;    char *end = s + len;    char *ent_start;    char *repl;    STRLEN repl_len;#ifdef UNICODE_HTML_PARSER    char buf[UTF8_MAXLEN];    int repl_utf8;    int high_surrogate = 0;#else    char buf[1];#endif#if defined(__GNUC__) && defined(UNICODE_HTML_PARSER)    /* gcc -Wall reports this variable as possibly used uninitialized */    repl_utf8 = 0;#endif    while (s < end) {    assert(t <= s);    if ((*t++ = *s++) != '&')        continue;    ent_start = s;    repl = 0;    if (*s == '#') {        UV num = 0;        UV prev = 0;        int ok = 0;        s++;        if (*s == 'x' || *s == 'X') {        s++;        while (*s) {            char *tmp = strchr(PL_hexdigit, *s);            if (!tmp)            break;    @@ -117,7 +117,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)        }        }        else {        while (isDIGIT(*s)) {            num = num * 10 + (*s - '0');            if (prev && num < prev) {            /* overflow */    @@ -180,7 +180,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)    }    else {        char *ent_name = s;        while (isALNUM(*s))        s++;        if (ent_name != s && entity2char) {        SV** svp;    @@ -216,7 +216,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)    if (repl) {        char *repl_allocated = 0;        if (*s == ';')        s++;        t--;  /* '&' already copied, undo it */#ifdef UNICODE_HTML_PARSER        if (*s != '&') {        high_surrogate = 0;        }        if (!SvUTF8(sv) && repl_utf8) {        /* need to upgrade sv before we continue */        STRLEN before_gap_len = t - SvPVX(sv);        char *before_gap = (char*)bytes_to_utf8((U8*)SvPVX(sv), &before_gap_len);        STRLEN after_gap_len = end - s;        char *after_gap = (char*)bytes_to_utf8((U8*)s, &after_gap_len);        sv_setpvn(sv, before_gap, before_gap_len);        sv_catpvn(sv, after_gap, after_gap_len);        SvUTF8_on(sv);        Safefree(before_gap);        Safefree(after_gap);        s = t = SvPVX(sv) + before_gap_len;        end = SvPVX(sv) + before_gap_len + after_gap_len;        }        else if (SvUTF8(sv) && !repl_utf8) {        repl = (char*)bytes_to_utf8((U8*)repl, &repl_len);        repl_allocated = repl;        }#endif        if (t + repl_len > s) {        /* need to grow the string */        grow_gap(aTHX_ sv, repl_len - (s - t), &t, &s, &end);        }        /* copy replacement string into string */        while (repl_len--)        *t++ = *repl++;        if (repl_allocated)        Safefree(repl_allocated);    }    else {        while (ent_start < s)        *t++ = *ent_start++;    }    }    *t = '\u0000';    SvCUR_set(sv, t - SvPVX(sv));    return sv;}", "idx": 27330}
{"project": "linux kernel", "commit_id": "8909c9ad8ff03611c9c96c9a92656213e4bb495b", "target": 0, "function": "void dev_load(struct net *net, const char *name){    struct net_device *dev;    int no_module;    rcu_read_lock();    dev = dev_get_by_name_rcu(net, name);    rcu_read_unlock();    no_module = !dev;    if (no_module && capable(CAP_NET_ADMIN))        no_module = request_module(\"netdev-%s\", name);    if (no_module && capable(CAP_SYS_MODULE)) {        if (!request_module(\"%s\", name))            pr_err(\"Loading kernel module for a network device \"\"with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \"\"instead\", name);    }}EXPORT_SYMBOL(dev_load);", "idx": 27344}
{"project": "linux kernel", "commit_id": "1309d7afbed112f0e8e90be9af975550caa0076b", "target": 1, "function": "int tpm_open(struct inode *inode, struct file *file){    int minor = iminor(inode);    struct tpm_chip *chip = NULL, *pos;    rcu_read_lock();    list_for_each_entry_rcu(pos, &tpm_chip_list, list) {        if (pos->vendor.miscdev.minor == minor) {            chip = pos;            get_device(chip->dev);            break;        }    }    rcu_read_unlock();    if (!chip)        return -ENODEV;    if (test_and_set_bit(0, &chip->is_open)) {        dev_dbg(chip->dev, \"Another process owns this TPM\");        put_device(chip->dev);        return -EBUSY;    }    chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);    if (chip->data_buffer == NULL) {        clear_bit(0, &chip->is_open);        put_device(chip->dev);        return -ENOMEM;    }    atomic_set(&chip->data_pending, 0);    file->private_data = chip;    return 0;}", "idx": 27350}
