[
    {
        "project": "FFmpeg",
        "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065",
        "target": 0,
        "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8",
        "target": 0,
        "func": "int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b",
        "target": 1,
        "func": "static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) / 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "afb4632cc30e83287338690c785ebac180436a59",
        "target": 1,
        "func": "static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { // header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); // flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    /* Since codec is based on 4x4 blocks, size is aligned to 4. */\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); // pitch\n\n    bytestream2_skip(gbc, 4); // depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    /* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. */\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height / TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* Use the decompress function on the texture, one block per thread. */\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n        uint8_t *dst = frame->data[0];\n\n        int x, y, i;\n\n\n\n        /* Use the first 64 bytes as palette, then copy the rest. */\n\n        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);\n\n        for (i = 0; i < 16; i++) {\n\n            AV_WN32(frame->data[1] + i*4,\n\n                    (frame->data[1][2+i*4]<<0)+\n\n                    (frame->data[1][1+i*4]<<8)+\n\n                    (frame->data[1][0+i*4]<<16)+\n\n                    (frame->data[1][3+i*4]<<24)\n\n            );\n\n        }\n\n        frame->palette_has_changed = 1;\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width / 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * frame->width / 2);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (y = 0; y < frame->height; y++) {\n\n            for (x = 0; x < frame->width; x += 2) {\n\n                uint8_t val = bytestream2_get_byte(gbc);\n\n                dst[x    ] = val & 0xF;\n\n                dst[x + 1] = val >> 4;\n\n            }\n\n            dst += frame->linesize[0];\n\n        }\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            /* Use the first 1024 bytes as palette, then copy the rest. */\n\n            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);\n\n            for (i = 0; i < 256; i++)\n\n                AV_WN32(frame->data[1] + i*4,\n\n                        (frame->data[1][2+i*4]<<0)+\n\n                        (frame->data[1][1+i*4]<<8)+\n\n                        (frame->data[1][0+i*4]<<16)+\n\n                        (frame->data[1][3+i*4]<<24)\n\n                );\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    /* Run any post processing here if needed. */\n\n    if (ctx->postproc != DDS_NONE)\n\n        run_postproc(avctx, frame);\n\n\n\n    /* Frame is ready to be output. */\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "da032427786d9db4ab21014998cb1245083d6c85",
        "target": 1,
        "func": "static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w /= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { /* simulate crop */\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e",
        "target": 1,
        "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);"
    },
    {
        "project": "qemu",
        "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b",
        "target": 1,
        "func": "static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    /* set ACPI PM I/O space base address */\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    /* enable ACPI I/O */\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    /* set Root Complex BAR */\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "8dea1dd406189dae6108104faf27f397835ae871",
        "target": 1,
        "func": "static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ESPState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);\n\n    DPRINTF(\"read reg[%d]: 0x%2.2x\\n\", saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                /* Data in/out.  */\n\n                fprintf(stderr, \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        // Clear interrupt/error status bits\n\n        s->rregs[ESP_RSTAT] &= ~(STAT_GE | STAT_PE);\n\n        esp_lower_irq(s);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "ad0193bf9cb258695a7f929954edd6e2e51de4d9",
        "target": 1,
        "func": "int av_vsrc_buffer_add_frame2(AVFilterContext *buffer_filter, AVFrame *frame,\n\n                              int64_t pts, AVRational pixel_aspect, int width,\n\n                              int height, enum PixelFormat  pix_fmt,\n\n                              const char *sws_param)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    int ret;\n\n\n\n    if (c->has_frame) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if(width != c->w || height != c->h || pix_fmt != c->pix_fmt){\n\n        AVFilterContext *scale= buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO, \"Changing filter graph input to accept %dx%d %d (%d %d)\\n\",\n\n               width,height,pix_fmt, c->pix_fmt, scale->outputs[0]->format);\n\n\n\n        if(!scale || strcmp(scale->filter->name,\"scale\")){\n\n            AVFilter *f= avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if(avfilter_open(&scale, f, \"Input equalizer\") < 0)\n\n                return -1;\n\n\n\n            if((ret=avfilter_init_filter(scale, sws_param, NULL))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if((ret=avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        }\n\n\n\n        c->pix_fmt= scale->inputs[0]->format= pix_fmt;\n\n        c->w= scale->inputs[0]->w= width;\n\n        c->h= scale->inputs[0]->h= height;\n\n\n\n        link= scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    memcpy(c->frame.data    , frame->data    , sizeof(frame->data));\n\n    memcpy(c->frame.linesize, frame->linesize, sizeof(frame->linesize));\n\n    c->frame.interlaced_frame= frame->interlaced_frame;\n\n    c->frame.top_field_first = frame->top_field_first;\n\n    c->frame.key_frame = frame->key_frame;\n\n    c->frame.pict_type = frame->pict_type;\n\n    c->pts = pts;\n\n    c->pixel_aspect = pixel_aspect;\n\n    c->has_frame = 1;\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "6c150fbd341ac10b8559abcfd5915cfff17b70c6",
        "target": 1,
        "func": "static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,\n\n                                         DeviceState *dev,\n\n                                         uint8_t **exp_cap, Error **errp)\n\n{\n\n    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;\n\n    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);\n\n\n\n    PCIE_DEV_PRINTF(PCI_DEVICE(dev), \"hotplug state: 0x%x\\n\", sltsta);\n\n    if (sltsta & PCI_EXP_SLTSTA_EIS) {\n\n        /* the slot is electromechanically locked.\n\n         * This error is propagated up to qdev and then to HMP/QMP.\n\n         */\n\n        error_setg_errno(errp, -EBUSY, \"slot is electromechanically locked\");\n\n    }\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "0b9f0e2fd7c5070fa06cd6bd5ec69055e3a7d2b1",
        "target": 1,
        "func": "void qmp_getfd(const char *fdname, Error **errp)\n\n{\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_FD_NOT_SUPPLIED);\n\n        return;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                  \"a name not starting with a digit\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return;\n\n    }\n\n\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n\n    monfd->name = g_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n\n}"
    },
    {
        "project": "qemu",
        "commit_id": "ad7f375df681503baa6ebef065818868e1216976",
        "target": 1,
        "func": "static void qmp_deserialize(void **native_out, void *datap,\n\n                            VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));\n\n    QObject *obj = qobject_from_json(qstring_get_str(output_json));\n\n\n\n    QDECREF(output_json);\n\n    d->qiv = qmp_input_visitor_new(obj);\n\n    qobject_decref(obj);\n\n    visit(qmp_input_get_visitor(d->qiv), native_out, errp);\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c",
        "target": 1,
        "func": "static bool coroutine_fn yield_and_check(BackupBlockJob *job)\n\n{\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    /* we need to yield so that bdrv_drain_all() returns.\n\n     * (without, VM does not reboot)\n\n     */\n\n    if (job->common.speed) {\n\n        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,\n\n                                                      job->sectors_read);\n\n        job->sectors_read = 0;\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n    } else {\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n    }\n\n\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "3e32e8a96e6995cde3d8a13d68e31226ee83f290",
        "target": 1,
        "func": "static int virtio_scsi_do_tmf(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIDevice *d = virtio_scsi_device_find(s, req->req.tmf.lun);\n\n    SCSIRequest *r, *next;\n\n    BusChild *kid;\n\n    int target;\n\n    int ret = 0;\n\n\n\n    if (s->dataplane_started) {\n\n        assert(blk_get_aio_context(d->conf.blk) == s->ctx);\n\n    }\n\n    /* Here VIRTIO_SCSI_S_OK means \"FUNCTION COMPLETE\".  */\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_OK;\n\n\n\n    virtio_tswap32s(VIRTIO_DEVICE(s), &req->req.tmf.subtype);\n\n    switch (req->req.tmf.subtype) {\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            VirtIOSCSIReq *cmd_req = r->hba_private;\n\n            if (cmd_req && cmd_req->req.cmd.tag == req->req.tmf.tag) {\n\n                break;\n\n            }\n\n        }\n\n        if (r) {\n\n            /*\n\n             * Assert that the request has not been completed yet, we\n\n             * check for it in the loop above.\n\n             */\n\n            assert(r->hba_private);\n\n            if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK) {\n\n                /* \"If the specified command is present in the task set, then\n\n                 * return a service response set to FUNCTION SUCCEEDED\".\n\n                 */\n\n                req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n            } else {\n\n                VirtIOSCSICancelNotifier *notifier;\n\n\n\n                req->remaining = 1;\n\n                notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                notifier->tmf_req = req;\n\n                notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                scsi_req_cancel_async(r, &notifier->notifier);\n\n                ret = -EINPROGRESS;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        s->resetting++;\n\n        qdev_reset_all(&d->qdev);\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK_SET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n\n\n        /* Add 1 to \"remaining\" until virtio_scsi_do_tmf returns.\n\n         * This way, if the bus starts calling back to the notifiers\n\n         * even before we finish the loop, virtio_scsi_cancel_notify\n\n         * will not complete the TMF too early.\n\n         */\n\n        req->remaining = 1;\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            if (r->hba_private) {\n\n                if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK_SET) {\n\n                    /* \"If there is any command present in the task set, then\n\n                     * return a service response set to FUNCTION SUCCEEDED\".\n\n                     */\n\n                    req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n                    break;\n\n                } else {\n\n                    VirtIOSCSICancelNotifier *notifier;\n\n\n\n                    req->remaining++;\n\n                    notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                    notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                    notifier->tmf_req = req;\n\n                    scsi_req_cancel_async(r, &notifier->notifier);\n\n                }\n\n            }\n\n        }\n\n        if (--req->remaining > 0) {\n\n            ret = -EINPROGRESS;\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET:\n\n        target = req->req.tmf.lun[1];\n\n        s->resetting++;\n\n        QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n             d = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n             if (d->channel == 0 && d->id == target) {\n\n                qdev_reset_all(&d->qdev);\n\n             }\n\n        }\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_ACA:\n\n    default:\n\n        req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_REJECTED;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n\n\nincorrect_lun:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_INCORRECT_LUN;\n\n    return ret;\n\n\n\nfail:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_BAD_TARGET;\n\n    return ret;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e",
        "target": 1,
        "func": "int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "9bff5d8135fc3f37932d4177727d293aa93ce79b",
        "target": 1,
        "func": "int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,\n\n                            uint8_t bar_nr)\n\n{\n\n    int ret;\n\n    char *name;\n\n    uint32_t bar_size = 4096;\n\n    uint32_t bar_pba_offset = bar_size / 2;\n\n    uint32_t bar_pba_size = (nentries / 8 + 1) * 8;\n\n\n\n    /*\n\n     * Migration compatibility dictates that this remains a 4k\n\n     * BAR with the vector table in the lower half and PBA in\n\n     * the upper half for nentries which is lower or equal to 128.\n\n     * No need to care about using more than 65 entries for legacy\n\n     * machine types who has at most 64 queues.\n\n     */\n\n    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {\n\n        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;\n\n    }\n\n\n\n    if (bar_pba_offset + bar_pba_size > 4096) {\n\n        bar_size = bar_pba_offset + bar_pba_size;\n\n    }\n\n\n\n    if (bar_size & (bar_size - 1)) {\n\n        bar_size = 1 << qemu_fls(bar_size);\n\n    }\n\n\n\n    name = g_strdup_printf(\"%s-msix\", dev->name);\n\n    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);\n\n    g_free(name);\n\n\n\n    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,\n\n                    0, &dev->msix_exclusive_bar,\n\n                    bar_nr, bar_pba_offset,\n\n                    0);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &dev->msix_exclusive_bar);\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3",
        "target": 0,
        "func": "void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1",
        "target": 0,
        "func": "static void restore_native_fp_frstor(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    fp->fpuc = env->fpuc;\n\n    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    fptag = 0;\n\n    for (i=7; i>=0; i--) {\n\n\tfptag <<= 2;\n\n\tif (env->fptags[i]) {\n\n            fptag |= 3;\n\n        } else {\n\n            /* the FPU automatically computes it */\n\n        }\n\n    }\n\n    fp->fptag = fptag;\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    asm volatile (\"frstor %0\" : \"=m\" (*fp));\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef",
        "target": 0,
        "func": "static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    /* Should never happen.\n\n       We only end up here when an existing TB is too long.  */\n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    /* execute the generated code */\n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        /* Restore PC.  This may happen if async event occurs before\n\n           the TB starts executing.  */\n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "41cbc23c5ca37a8b841915d7d252a02106d58b1e",
        "target": 0,
        "func": "static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr / 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "8c6afa6ab158467d1938cc92022135bc7a872006",
        "target": 0,
        "func": "static void handle_2misc_fcmp_zero(DisasContext *s, int opcode,\n\n                                   bool is_scalar, bool is_u, bool is_q,\n\n                                   int size, int rn, int rd)\n\n{\n\n    bool is_double = (size == 3);\n\n    TCGv_ptr fpst = get_fpstatus_ptr();\n\n\n\n    if (is_double) {\n\n        TCGv_i64 tcg_op = tcg_temp_new_i64();\n\n        TCGv_i64 tcg_zero = tcg_const_i64(0);\n\n        TCGv_i64 tcg_res = tcg_temp_new_i64();\n\n        NeonGenTwoDoubleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fallthrough */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f64;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f64;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f64;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        for (pass = 0; pass < (is_scalar ? 1 : 2); pass++) {\n\n            read_vec_element(s, tcg_op, rn, pass, MO_64);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            write_vec_element(s, tcg_res, rd, pass, MO_64);\n\n        }\n\n        if (is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n\n\n        tcg_temp_free_i64(tcg_res);\n\n        tcg_temp_free_i64(tcg_zero);\n\n        tcg_temp_free_i64(tcg_op);\n\n    } else {\n\n        TCGv_i32 tcg_op = tcg_temp_new_i32();\n\n        TCGv_i32 tcg_zero = tcg_const_i32(0);\n\n        TCGv_i32 tcg_res = tcg_temp_new_i32();\n\n        NeonGenTwoSingleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass, maxpasses;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f32;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f32;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f32;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        if (is_scalar) {\n\n            maxpasses = 1;\n\n        } else {\n\n            maxpasses = is_q ? 4 : 2;\n\n        }\n\n\n\n        for (pass = 0; pass < maxpasses; pass++) {\n\n            read_vec_element_i32(s, tcg_op, rn, pass, MO_32);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            if (is_scalar) {\n\n                write_fp_sreg(s, rd, tcg_res);\n\n            } else {\n\n                write_vec_element_i32(s, tcg_res, rd, pass, MO_32);\n\n            }\n\n        }\n\n        tcg_temp_free_i32(tcg_res);\n\n        tcg_temp_free_i32(tcg_zero);\n\n        tcg_temp_free_i32(tcg_op);\n\n        if (!is_q && !is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n    }\n\n\n\n    tcg_temp_free_ptr(fpst);\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f",
        "target": 1,
        "func": "static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n"
    },
    {
        "project": "FFmpeg",
        "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb",
        "target": 1,
        "func": "void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n"
    },
    {
        "project": "qemu",
        "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189",
        "target": 1,
        "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}"
    }
]